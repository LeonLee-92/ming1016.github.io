<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS, 戴铭, CG, 手绘, iPad, Procreate, 小说" />





  <link rel="alternate" href="/atom.xml" title="星光社 - 戴铭的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/uploads/logo.png?v=5.1.1" />






<meta name="description" content="不积跬步，无以至千里；不积小流，无以成江海">
<meta property="og:type" content="website">
<meta property="og:title" content="星光社 - 戴铭的博客">
<meta property="og:url" content="http://ming1016.github.io/page/2/index.html">
<meta property="og:site_name" content="星光社 - 戴铭的博客">
<meta property="og:description" content="不积跬步，无以至千里；不积小流，无以成江海">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="星光社 - 戴铭的博客">
<meta name="twitter:description" content="不积跬步，无以至千里；不积小流，无以成江海">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ming1016.github.io/page/2/"/>





  <title>星光社 - 戴铭的博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">星光社 - 戴铭的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ming1016.github.io/2016/05/23/try-to-decouple-with-demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="戴铭">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/251980?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星光社 - 戴铭的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/23/try-to-decouple-with-demo/" itemprop="url">竭尽全力的去解耦的一次实践，封装一个TableView和一些功能组合的控件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-23T21:24:25+08:00">
                2016-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>可以先看看这个Demo：<a href="https://github.com/ming1016/DecoupleDemo" target="_blank" rel="external">https://github.com/ming1016/DecoupleDemo</a>。从这个Demo里可以看到Controller和View还有Store的头文件里没有任何Delegate，Block回调，只有初始化和更新ViewModel的方法。所有这些控件，请求，ViewController和视图之间的联系都是通过ViewModel来进行的，而viewModel也不进行任何逻辑处理，只是简单的起到描述和默认值设置的作用。ViewController也被减轻的小得不能再小了，只需要初始化视图和Store即可。这也是我的一次尝试，看看如何利用KVO能够做到最大限度的解耦，和最大限度的减少代码和接口。</p>
<p>可以先看看以前代码最臃肿的地方在使用了新的思路后会变成怎么样，首先是ViewController<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [<span class="keyword">self</span> addKVO];</div><div class="line">    [<span class="keyword">self</span> buildConstraints];</div><div class="line">    <span class="keyword">self</span>.tbStore = [[TestTableStore alloc] initWithViewModel:<span class="keyword">self</span>.tbView.viewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到里面仅仅做了添加KVO，布局控件和初始化Store的工作。</p>
<p>封装的TableView作为一个通用控件是不会去设置管理不同的Cell的，可以看看不用Delegate和Block是如何处理的。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="keyword">self</span>.viewModel.tableViewIdentifier = smTableViewIdentifier;</div><div class="line">    <span class="keyword">self</span>.viewModel.tableView = tableView;</div><div class="line">    <span class="keyword">self</span>.viewModel.cellIndexPath = indexPath;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.viewModel.cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我觉得这样应该很简化了。当触发到UITableView这个配置Cell的回调时，通过对ViewModel的键值的监听就能够在任何地方对Cell进行配置了，而不用通过繁琐的Delegate和Block来层层回调了。</p>
<p>除了这里外，其它地方也用同样的方法进行了处理，比如说对新出现消息提示点击使其消失只需要设置ViewModel里的isHideHintView的值的处理，还有对请求不同状态显示不同引导页，只要是以前需要通过接口和回调的全部干掉，用ViewModel去控制，下面可以看看我写的ViewModel中，我将KVO分成了View Side和Data Side，前者主要是响应视图方面的逻辑变化，后者Data Side是响应不同的动作来产生对数据不同的处理，其它就都是些关于样式和数据配置相关的了。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="comment">//           KVO View Side</span></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isHideGuideView;             <span class="comment">//是否显示guide view</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isHideHintView;              <span class="comment">//是否显示hint view</span></div><div class="line"><span class="comment">//下拉刷新上拉加载更多</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SMTableRequestStatus requestStatus; <span class="comment">//刷新状态</span></div><div class="line"><span class="comment">//TableView Delegate</span></div><div class="line"><span class="comment">//通用</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITableView</span> *tableView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *tableViewIdentifier;</div><div class="line"><span class="comment">//Cell</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *cellIndexPath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITableViewCell</span> *cell;</div><div class="line"><span class="comment">//CellHeight</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *cellHeightIndexPath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;</div><div class="line"></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="comment">//          KVO Data Side</span></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SMTableRefreshingStatus dataSourceRefreshingStatus; <span class="comment">//请求状态</span></div></pre></td></tr></table></figure></p>
<p>纵观整个项目，头文件都很干净，唯一有方法需要参数的也就是ViewModel。这种完全面向对象思路的编程方式在需求经常变更的情况下优势就会慢慢显露出来，对吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ming1016.github.io/2016/04/04/tenth-middle-school/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="戴铭">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/251980?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星光社 - 戴铭的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/04/tenth-middle-school/" itemprop="url">十中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-04T16:08:08+08:00">
                2016-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/小说/" itemprop="url" rel="index">
                    <span itemprop="name">小说</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一话"><a href="#第一话" class="headerlink" title="第一话"></a>第一话</h1><p>决赛进入了加时赛，凌召一记凌空射门，球入网，十中获得联赛冠军。凌召站在获奖台时当着所有人的面对着喇叭说，“丁晓炎，谢谢你的加油，让我有一直努力的毅力，因为我是好喜欢，好喜欢你”。这时他看到台下丁晓炎正被另一个男生搂着，他们带着冷冷的笑看着自己。就在这时凌召从梦中惊醒过来。</p>
<p>是因为要小学同学的聚会的原因吧，聚会前一天会梦到丁晓炎。二十年以来第一次聚会，聚会还没有结束凌召就匆匆离席了，他为什么会早走呢？他的同学们都不知道，原来他听说丁晓炎同学成了一个作家，而这天她却没有来，于是凌召直奔图书大厦找她写的书去了。</p>
<p>来到图书大厦，他检索到丁晓炎写的几本书，其中有一本是她的短篇集，封面是个黄色的表，凌召还记得这个表是他小学时送给她的那个。打开目录他发现有篇名叫《凌召的表》，这不是自己的名字么，文字将他的回忆一页一页的翻了起来。</p>
<p>那时，凌召还在十中读初中，他的小学的同学们几乎都对口了另一所中学，一中。</p>
<p>“你小学是哪个班的？”凌召的同桌秦珊问道。</p>
<p>“我以前不是你们学校的，我小学同学都去一中了。”凌召回答。</p>
<p>“那你觉得现在我们班上哪些女生漂亮，这样吧，来个排名从五到一，你说说看。”</p>
<p>凌召看了看秦珊，她，瓜子脸，肤色较黑，虽然不是自己喜欢的类型，但是他知道秦珊是希望自己说她漂亮的。</p>
<p>“恩，第五嘛，我觉得是古文蔚，我唯一在十中的小学女同学，第四是于佳吧，看起来蛮文静的，第三是周冰…”</p>
<p>秦珊带着焦虑的眼神看着凌召，虽然她觉得自己好看，但是也自知算不上班花级别，担心自己凌召说完五人也不会提自己。</p>
<p>“第二，让我好好想想，好难分高下。恩，就蒋美龄吧。”凌召说着看到秦珊渴望又带着焦虑的眼神，心中窃喜。</p>
<p>“不是吧，我觉得蒋美龄是班上最好看的。”</p>
<p>“不要急嘛，当当当，当当当。第一就是秦珊。”</p>
<p>秦珊噗的一声，随手推了凌召一下，黑黑的脸上泛起一丝红晕，看来是满足了，还有点不好意思，开心却又假装生气的说：“去去，是因为我问的你，你才把我排第一吧。”话虽这么说，心里却等着凌召否认。</p>
<p>凌召摇了摇头，其实他本来就对这个班上的女同学不熟悉，提到的这些人也是平时男生常常讨论的人，当然里面没有秦珊，但是凌召不希望秦珊失望。他也不是很关心这个班上的女孩子，因为他喜欢的女孩不在这个学校里。</p>
<p>“你想听听我给男生排名是什么样的吗？”</p>
<p>凌召点了点头。</p>
<p>“我觉得你马马虎虎，也算是帅，排第五吧。”</p>
<p>这时，班主任带着一位同学走近教室。</p>
<p>“同学们，我介绍一位同学，他名叫李文龙，转校到我们十中，他特长是足球，以前小学曾代表学校比赛得过奖。希望他以后也能够带领十中校队获得好成绩，来，大家一起鼓掌欢迎他。”</p>
<p>李文龙挎着单肩书包，在掌声中穿过，旁边不断有人低声窃语，感叹着好帅。</p>
<p>“你进不了前五了。你看他这双大眼睛，高高鼻梁，还有这360度无死角的脸型，迷死人了，秒杀你们，踢足球的男孩就是帅气，第一，第二，第三，第四，第五都是他了。”秦珊对凌召说，眼睛里泛出无数的心心。</p>
<p>自从凌召担任了小组长后，就一直不顺利，这不，收个作业还被同组同学找茬。</p>
<p>“韩霍，交作业了，就差你了。”凌召拿着那堆收好的作业来到韩霍的座位旁。</p>
<p>“没写。”韩霍坐在桌上，一只手搭在翘在桌上的腿，一只手依着桌角，瞟了一眼凌召后就跟李文龙接着聊天。韩霍是个典型的外面玩的那种孩子，常常到其它学校去抢钱，到街机厅抢币，坐在最后，成天和他的哥们一起。李文龙来后也总是跟他们在一起。所谓好兔不吃窝边草，只要惹他们，也不怎么欺负班上同学。</p>
<p>“没写我给你一本，你可以抄完再交。”凌召从收的作业本里抽出一本递给韩霍。</p>
<p>韩霍一把打掉凌召手中的作业本，说：“老子不想写，也懒得抄，怎么着。滚一边去！”</p>
<p>凌召心想着以前有次作业忘记做了，当时那叫一个着急啊，这时有位同学将自己作业递给自己说给他抄，这是要担着被老师发现的危险的，还好凌召机智的将几个题答案故意写错避过一劫，但心里却是非常的感激这位同学的，然而韩霍不但不感谢自己，还这样对自己，只觉得委屈生气，一脸怒气看着韩霍。</p>
<p>啪的一声，韩霍一个大巴掌打了过来。凌召被打得后退了一步，手捂着脸，韩霍手浮着还未收回，说：“看什么看。”</p>
<p>凌召哪里受得了这气，抬起脚朝韩霍踢去。韩霍毕竟打的架多，侧个身闪过，同时一手抓住凌召的脚，用力一拉，凌召一屁股倒在地上，头撞到一旁桌脚上。接着韩霍一脚踢向凌召腰部，旁边的韩霍的那帮人准备过来一起动手。</p>
<p>这时韩霍的肩膀被轻轻拍了一下。“哥们，不想抄，我来帮你抄。来来，但是，抄完别忘记给我买包烟。”李文龙在背后笑着看着韩霍。韩霍看是李文龙，于是跟旁边打算过来帮手的人使了个眼色让他们不要过来。凌召捂着腰站起来正要冲过去时被李文龙一手搂住肩膀拉着转了个身，小声地说：“别跟他一般见识，他是什么层次的人你又不是不知道。”</p>
<p>凌召侧脸抬头看着李文龙俊朗的脸上那双有着长长睫毛有神的大眼睛正自信的看着自己，心中的怒气也就消散了。李文龙看了看凌召的脸，怒容已散，说了句：“对吧。”</p>
<p>“要不你加入足球部，跟我一起玩玩足球怎么样，听说你喜欢弹钢琴，看你这弱身板，不练练体力怎么能够弹得带劲。”李文龙对凌召提出邀请。</p>
<p>“真是隔行如隔山，弹钢琴才不是你想的那样呢，不过踢足球，挺不错的，我答应你。”凌召想起秦珊说踢足球的男孩有魅力，然后又看了看李文龙，还真以为踢上足球就能够像李文龙那样，真是笑死人了。不过凌召有些纳闷的是李文龙怎么知道自己喜欢弹钢琴，班上应该还没有人知道这事呢。</p>
<p>自从在他加入足球部后，情况确实有了些变化，但一定不是凌召想的那样。</p>
<p>训练时，凌召被秦珊称为班级第一美的蒋美龄拿着一封信来到凌召跟前低着头递给了他。凌召奇怪的接过信，问了句：“这时什么？”</p>
<p>“情书。”说着脸开始红了。</p>
<p>凌召仔细打量起了，蒋美龄果然是个美人胚子，白白嫩嫩的皮肤，标致的五官，确实看起来比班上其他女生要好看些。但凌召还惦记着小学那个喜欢的女孩，不好意思又很果断的回绝道：“那个，要不我们做朋友吧。”</p>
<p>蒋美龄脸色一下子就变了，一脸的害羞荡然无存，大声说：“这个不是给你的，是让你帮我给李文龙的，你好好看看上面的字吧。臭美”说完就走了。凌召仔细看了看信封上的字，一脸尴尬。拿着情书回到训练球场，想着自己是不是也该给自己喜欢的那个女孩丁晓炎也写封情书表达下自己的思念。这个时候，他觉得附近好像有双眼睛一直看着自己，余光中感觉像是丁晓炎，但扭头看去却都是还是那些李文龙的粉丝女们，细想下丁晓炎现在在一中了，怎么会出现在十中。觉得自己要不就是太想她了，要不就是天气太热训练过头中暑了。他还没有回过神，砰的一下，一球打在了脸上。</p>
<p>“干嘛呢，快练球”李文龙厉声叫道。凌召很奇怪一向遇事冷静的李文龙今儿怎么突然发起火来。看李文龙的表情也是奇怪，李文龙发现凌召愣着看自己，勉强的故装轻松却无法按耐着生气。</p>
<p>“不要这样生气嘛，你看看这是什么，班花给你的情书耶！”凌召走向李文龙。李文龙接过情书都没有打开就揉成一团扔到一边。</p>
<p>“凌召，把注意力放到训练上，你没有足球的基础，这段时间我看你练得不错，已经给校队教练提名让你入校队了，应该问题不大。不过以你现在的实力还只能够作替补，加把油，十中十来年都没拿过奖呢，争取这次联赛时能够上场，给咱们十中拿个大奖杯回来。”</p>
<p>“能进校队了，真的！替补也行啊！”凌召开心的不行。</p>
<p>“恩，好好干。”李文龙拍了拍凌召的肩膀就继续自己的训练了。</p>
<p>慢慢接近联赛，凌召在李文龙的指导下进行了异常艰苦的训练。</p>
<p>进入淘汰赛，李文龙把一班的队员集合在一起，对大家说：“你们三个和我都是一班的，下场比赛，纪崇飞还是踢边锋，韩霍后卫，你要注意我教你的那些小动作，关键时候一定要用，我们队守门员水平偏下，后卫非常关键。我来担任前锋，落后的分就交给我补回来，凌召这次你还是在场外学习，这次对手很强劲，他们的主力小学也跟我对过手，这场比赛将会是场异常艰苦的作战，大家都记住了吧！”</p>
<p>李文龙伸出手掌，四人将手叠在一起。“这次也要赢！有信心吗？”李文龙大声叫道。</p>
<p>“有！”四人齐声喊道。</p>
<p>四人散开时，韩霍故意撞了下凌召，凌召想着李文龙说的大人不记小人过，也就没有和韩霍计较，哪知韩霍来了句：“听见没，多学着点。”说完神气的走在了凌召前面，凌召想着就来气，打到淘汰赛之前一直坐冷板凳，一直憋着，这次和一中比赛，主场还在一中，他喜欢的丁晓炎一定会来看这场比赛，如果被她发现自己一直坐冷板凳多没有面子，现在还被韩霍这么一嘲笑，准备反嘴道你个连作业都不会写的货有什么资格说我，但是转眼看旁边的李文龙对自己使了个眼色，这气也就忍了下来。上次凌召就问过李文龙怎么把韩霍这货给弄进校队，李文龙说校队欢迎所有球踢得好的，同时他提醒凌召不要和韩霍起冲突，不然教练会把他们都赶出校队。</p>
<p>比赛那天，凌召特意跑到观众席上找以前的小学同学。凌召环顾了一圈都没发现丁晓炎，反而是其他以前小学的同学们围了过来问他在十中的情况。</p>
<p>回到球场边板凳上，没有见到喜爱的人一脸无精打采。比赛过程也是乏味的很，淘汰赛阶段双方都会非常小心的进攻，而加强防守，而且两支球队教练都采用了防守反击策略，导致在没有进球的情况下，比赛看着让人犯困。</p>
<p>到了临近结束前，双方为了避免进入疲劳的加时赛都开始转守为攻，急于夺分的一中前锋一脚铲伤了十中的右后卫，这时十中教练将凌召换上场。凌召一脸兴奋，想着最后关键时刻李文龙一定会力挽狂澜，如果这次能胜了一中一定会在一中的校刊上留下一笔，说不定丁晓炎也能够看到呢。拍了下场受伤后卫的手，凌召一路开心的小跑到场上。一站到位，凌召就发现李文龙正一脸焦虑的看着自己，一旁还有韩霍那种不屑异常轻视，仿佛等着自己出丑的目光。放眼朝观众席看去，所有目光都集中到了自己身上，还伴随着一片主场特有的阵阵嘘声。这让本就毫无赛场经验的凌召开始紧张起来了，李文龙还没来得及给他鼓气，对手的进攻就来了。</p>
<p>一中前锋也看出了凌召是个十足的新手，就带着球冲向凌召防守的这边。一个简单的虚晃就过了凌召。凌召怎可罢休，紧紧的贴身在对手身边把他往边路挤。对手想往里过时，他就侧个身背挡着裁判视线手伸出去拽对手衣裤。李文龙教他的小动作他也算是活学活用了。临近球门却没有机会，一中这位前锋只得后脚跟一磕将球传给右侧前来接应的队友。</p>
<p>一心担心着凌召的李文龙也不顾自己体力，急忙回防，发现对手传球的意识，大呼一声：“断球！”</p>
<p>凌召下意识侧身伏下左脚一伸将球给断了下来。</p>
<p>抢下球的凌召瞬间就被对方两名球员给贴身夹住了。这下凌召给慌了，看着前面路线被堵死，他只得转身寻找接球人，这时韩霍给他示意了下，凌召急忙大脚将球踢了过去。</p>
<p>嗖的一声，球进来！但是是自家球门。原来韩霍示意凌召传他球后，故意装作不知情的跑开了，这样球直接进入自家球门死角。凌召呆呆的站在那里，这次真是会上一中校刊头条了，如此的耻辱，让他有种想钻进地下去的冲动。</p>
<p>离结束还有不到两分钟，一中又有了一次进攻的机会，凌召还茫然的站在那里。又一球入网。自此，十中已无缘奖杯。凌召感觉自己也没脸呆在十中校队了。</p>
<p>赛后在更衣室，队友一个个叹着气离开，韩霍捂着嘴冷笑着看了凌召一眼，很满足的离开了。这时更衣室就只剩下李文龙和凌召了。</p>
<p>“别灰心！”李文龙坐到凌召身边。</p>
<p>“是韩霍，是他…”本来就强忍着委屈的凌召听到李文龙的安慰，忍不住想说出委屈，看着眼泪都快要流出来的凌召，李文龙一把将他搂住，说：“别说了，我知道是韩霍故意漏球的。我都看到了。本来呢，对你上场我也是反对的，主要就是担心你和韩霍的配合，当然还有你的上场经验。教练让你上次，我刚才想通了，这场比赛教练他估计是觉得没有胜算了，为了将来球队着想才让你上场积累下大赛经验。一中毕竟也是名校，也是最近这几届的冠军队。教练他也看出了你的潜力，争取明年你能够有大的进步让我们扳倒一中吧。”</p>
<p>看李文龙严肃而自信的看着自己，凌召咽下一口水，连连点头。</p>
<h1 id="第二话"><a href="#第二话" class="headerlink" title="第二话"></a>第二话</h1><p>虽然自己上了十中的耻辱柱，但校园的生活还是要继续嘛。这是个阳光极好的一天，难得的万里无云，同学们嬉笑着到音乐教室上课，你也知道音乐课正是大家放松的时候，没有枯燥的公式，单调的英文字母，难读还要背的文言文，让人发困与自己无关的那些古代牛人，难以下笔，下笔又画得无法欣赏的画，有的只是动听的节奏，美妙的音符。</p>
<p>不过今儿这节课音乐老师却问哪位同学们上来表演。“哪位同学愿意自告奋勇上台给大家弹上一曲？”老师问道。这一问弄得大家都默默低下头，一阵沉寂，以往那种轻松的气氛变得紧张起来，大家都担心着老师会点到自己。</p>
<p>“我来吧！”以为女同学站了起来，走到钢琴前。老师鼓起掌以示鼓励，同时摆了下头示意大家来一起鼓掌。这位女同学坐上钢琴椅，微微卷起衣袖，坐正了身子，十指缓慢的放在琴键上方。</p>
<p>等着大家掌声结束，琴声随即响起，同学们都感叹这位同学的专业。凌召小时候也学了六年多的钢琴，此刻也自叹不如。</p>
<p>“以前都没注意过这女孩，你知道她叫什么名字吗？”凌召问身边的叶正。</p>
<p>“于佳啊，我不是跟你说过，这班上也就她我看得上眼了，又漂亮又有气质。你都没放心上啊，真不知道你成天都想啥呢。”叶正说。叶正是凌召在十中最要好的朋友，也是小学跟他一起到十中那极少的同学中的一个。叶正也凌召的爱好也差不多，都喜欢音乐，而且他一直在学，直到现在还请着老师教呢。</p>
<p>叶正这一问凌召在想啥和于佳美妙的琴声一下子把凌召的思绪带回到了他怀念的小学时光里，让他想起了小学时和丁晓炎同桌的时光，还有那次课上不知道是幻觉还是真实的画面。把凌召上次比赛的烦恼羞辱一点点的破碎掉，转成无比的愉悦，随着琴声娴熟的转向高潮，凌召兴奋的也站了起来，走向台上。</p>
<p>于佳抬眼看着凌召，只见凌召寻着一旁的吉它，将它抱起，跟着于佳的节奏弹了起来。于佳微笑着继续弹着，时不时的瞟眼看凌召。凌召却也是十分享受着这段曲子竟也是陶醉起来。叶正也注意到于佳的眼神，忍不住也走向他们，坐在架子鼓上随着他们的节奏敲打起来，这画面可把音乐老师乐坏了。</p>
<p>下课后老师讲他们三人留下，希望他们都能够加入音乐部。</p>
<p>“我可能不行”凌召为难的说。</p>
<p>于佳看了看凌召，说凌召不加入她也不想加入了。叶正看这情况，想着难得有机会和于佳一起，于是说：“凌召是担心参加两个部时间顾不上吧。”凌召点了点头。</p>
<p>“没事，这不，联赛也结束了，好好放松下，下个赛季开始再退出也不迟嘛。”叶正眼光闪烁着一股自以为聪明劲儿满怀着期待的看着凌召。凌召思量了下，回想了刚才弹琴时的感觉，今儿才发现原来音乐不光能够表演炫技，还能够勾起对丁晓炎的思念和回忆。再看看自己好朋友叶正那双渴望的眼神，于是答应了加入音乐部。</p>
<p>叶正握手收腰耶的一声，于佳也露出了笑容。就这样这三个人开始了他们的校园音乐生活。在音乐部里他们形影不离，音乐部没有活动时他们就一起去街机厅玩游戏，一起去台球厅打台球，在江滩上一起弹吉它。</p>
<p>说到梦想谁没有呢，特别是在凌召他们这样的年龄。三人坐在江滩沙子上，刚弹完凌召写的一个曲子，三人相互望了一下，表示了下对自己和队友的肯定，随后三人一起望着夜空。</p>
<p>“听说对着星星许愿会灵验哦。”叶正说。</p>
<p>“笨蛋，是流星啦！”于佳说：“星星天天都能看到，哪会那么容易让你实现。”</p>
<p>“也是啊。”叶正摸着头，怪不好意思。</p>
<p>于佳看了看凌召，凌召静静坐在那里看着星星发呆。于佳接着对叶正说：“你学学人家凌召，别没话找话说。”</p>
<p>凌召笑了笑，看着于佳和叶正说：“难得叶正有这兴致，要不，我们一起对着这条江河许个愿吧，让它能够带着我们的愿望流向浩瀚大海，征服我们的未来。”</p>
<p>于佳听凌召这么一说，抿嘴直点头，然后用手轻轻的拽了两下叶正的袖子，示意他不要说傻话。</p>
<p>“对，对，来吧，一，二，三，一起许愿吧。”叶正傻傻的点着头望了望于佳又望了望凌召。三人闭眼低头双手紧握开始许愿。凌召此刻正迫不及待的想对大江说他希望自己长大能够成为一个有名的音乐人，大街小巷都能听到他创作的音乐，还有，他希望能够和丁晓炎在一起。</p>
<p>“我许完了，凌召你的愿望是什么？”于佳许完愿望急忙的问凌召。</p>
<p>“不是说许的愿望说出来就不灵了吗？”凌召回道。</p>
<p>“那是对流星许愿才有这规矩。这流向浩瀚大海的心愿才没有那么小气呢！”于佳咧着嘴笑着说。</p>
<p>“那你先说。”凌召说。</p>
<p>于佳瘪着嘴说：“说就说，我呀！希望以后能够像现在一样和你凌召一起玩音乐，组乐队，做出最棒的音乐。”</p>
<p>“喂，还有我。”叶正急忙补充道：“是我们三个人的乐队，我的愿望也是这个。凌召，你的呢？”</p>
<p>“恩，我的嘛。”凌召犹豫了会，接着说：“其实，也是这样的，好期待以后的我们呢。”凌召竖起大拇指，说道：“给未来的我们和现在的我们赞一个。”</p>
<p>于佳和叶正也竖起大拇指，三人拇指并在一起，月光洒在他们脸上，让他们在黑暗的夜里也光芒起来。</p>
<p>加入音乐部后凌召练足球的时间也少了不少，而且有一点让凌召很不爽的是自他加入音乐部后，音乐部里那些女同学们总是从他那里打探李文龙的事情，比如说李文龙喜欢什么类型女孩子，喜欢什么颜色，星座啊，什么时候会到球场练球什么的。看来不是说只要踢球的男孩就会受欢迎，还需要球技高人长的帅才行啊，凌召不断的感叹到，这个看脸的时代。这不，情人节到了，凌召打开在音乐部的存包柜，发现里面堆满了信，随便拿出几封都是要转交给李文龙的。凌召想着这不用打开也知道里面写的都是些肉麻的话。</p>
<p>来到足球部，凌召从书包中掏出一打信用力往更衣室正在换衣服的李文龙身旁桌上一砸。</p>
<p>“好开心吧，这批来自音乐部的情书够你看一阵了吧。”凌召说。</p>
<p>“你有打火机吗？”李文龙问。</p>
<p>“我又不抽烟，干嘛？”凌召反问。</p>
<p>“帮我烧了呗。”李文龙看起来一副淡定自若对这事习以为常的态度说道。</p>
<p>“多可惜啊！你看看这一封封爱意满满的信，谁不知道音乐部都是美女啊，就没你喜欢的？”凌召左手拿一封右手拿一封，不断摇着头以示可惜。</p>
<p>“美女？你是指那个天天跟你一起的于佳么？”李文龙坏笑着说。</p>
<p>“哦！对哦，让我找找，看看美女会用什么深情意浓的文字来写情书。”凌召顺着李文龙的玩笑一边说着，一边在那堆信中找署名是于佳的信。李文龙换好衣服坐在凳子上，歪着脑袋以一种不屑的神情帮着凌召找。</p>
<p>“这里！”李文龙翻到了，笑着大声说。裁开看着信时不时看了看凌召，看完后对凌召说：“这个是给你的。”</p>
<p>凌召接过信，心里有种说不出的感觉。</p>
<p>“看来你们修成正果了。不简单，美女的情书哦。”李文龙看起来是那么幸福，好像是自己修成正果那般的甜蜜笑着对凌召说。</p>
<p>凌召拿着信回到家。坐在自己的书桌前，慢慢读着信。首先是不敢相信自己也能够收到情书，同时也担心是于佳在跟自己开玩笑。认真看完信里的每个字，他能够感觉到于佳对自己的真情实意。</p>
<p>凌召一头倒在床上，双手举着那封情书，信结尾说如果凌召对她也有意明天放学后在江滩那见面。</p>
<p>次日，课间，叶正把凌召拉到走廊一角。</p>
<p>“这个，能帮我把这封信交给于佳吗？”叶正拽着凌召的袖子，神神秘秘的将一封信塞到凌召手中。</p>
<p>“情书？怎么不直接给她？”凌召问。</p>
<p>“我看她蛮听你的，你给我多说几句好话呗。靠你了。”叶正再次用那满怀期待的眼神望着凌召。凌召其实早就发现叶正的小心思了，点了点头，将信装到了口袋中。</p>
<p>放学后，叶正背着书包经过凌召轻轻撞了下凌召，给他使了个眼色提醒他不要忘记给于佳送情书。</p>
<p>凌召低着头小步慢走来到江滩。远处看到于佳正坐在沙堆高处，双手托着面额面对着江水。凌召走上沙堆来到于佳身边，于佳转头看见凌召，开心的双手将他抱住。</p>
<p>时间就像停止了一样，于佳紧紧的抱着凌召，嘴角凑到他耳边。</p>
<p>“我们就像这样一直在一起吧。”于佳慢慢闭上眼睛，享受着属于自己的这一刻的满足。</p>
<p>凌召轻轻拿开于佳的手，说：“对不起。”</p>
<p>“对不起？你不是来了吗？”于佳吃惊的看着凌召。</p>
<p>凌召扭开书包扣，取出叶正那封信给了于佳，说道：“我是来给叶正送这封信的。叶正挺棒的，琴弹的比我好，又很喜欢你，你应该能感觉到吧。我们还是最佳拍档对吧。我们许的愿…”</p>
<p>“我就问你，你喜欢我吗？”于佳没等凌召说完认真的看着他说。</p>
<p>“我…”凌召不忍回答。停顿许久，于佳一直目不转睛的看着他。</p>
<p>“不用回答了，你走吧。”于佳转过头背对着凌召说。低下头，双肩有些颤抖，带着些许嘶哑声说：“你不是说过许的愿望说出来就不灵了么，看来是真的。”</p>
<p>回到家中，凌召将自己房间的门锁住，背靠内门，心里埋怨自己，他也没想到于佳会那样将自己抱住，那一刻他心也酥了，有种也想将她抱住的冲动。但那时他眼前出现了丁晓炎的幻觉。凌召来到书桌旁的钢琴边，掀开琴布，琴盖打开，坐下，翻到他和于佳叶正一起创作的曲子那页，弹了起来。此刻他的心情是极好的，谁不喜欢被人爱呢，但也带着些愧疚。随着曲子的进行，又将凌召带回了小学时光，好一个多愁善感之人，他是更享受音乐带他进入另一个世界的感觉。晚上，凌召不断想着丁晓炎，到了很晚才入睡，睡梦中，他进到他家旁边那家书店，忽然发现了丁晓炎正从书店里出来，她没有发现自己，他们擦肩而过。</p>
<p>梦有时真的很奇怪，日有所思，夜有所梦是没错，但夜有所梦，日有所见竟也会发生，而当这事出现时会让你有充满希望和那种命中注定的那种幸福感。</p>
<p>凌召来到音乐部发现叶正已退出了，看来于佳已经拒绝他了。于佳还没退出音乐部，但也没有再像以前对凌召热情。音乐部训练结束，凌召走出门，发现韩霍正在门口，回头发现于佳正笑着走向韩霍。</p>
<p>韩霍和于佳小学就是同学，只是为什么会是韩霍，凌召心里很难受，这个他最讨厌的人。他急步走了一段，回头看了看，于佳正牵着韩霍的手看着自己，缓缓的将头靠向韩霍。</p>
<p>于佳跟谁和自己又有什么关系呢，凌召不断跟自己讲着。想着于佳刚刚看自己的眼神，心里感觉那一定是她想气自己才这么做的吧，想必应该是这样吧。凌召心里七上八下的，久久无法平复，其实想想也不能怨人家于佳，是自己先伤了对方的心，当时她心里也一定很难过。</p>
<p>想着想着，凌召一脚已踏进家附近那家书店，昨晚梦中画面忽的浮现在面前，他也不知怎么就来到这，可能是本能的期待着梦中那画面能够出现，所谓的梦想成真也不过如此。但却是真的成了真。凌召选择了一本刚出的七龙珠，贝吉塔时隔一年后来到地球本。到柜台时发现身边正站着那个日里梦里都想着的丁晓炎。</p>
<p>可能是两人很久没见了，多了好些生疏。丁晓炎也发现了凌召，说道：“凌召，你也来买书了。”</p>
<p>凌召正准备说丁晓炎的名字，忽然发现这个他心中默念过千遍万遍的名字，此刻竟无法说出口，急忙中简单了回了句：“是的。”说完低下头，脸上开始泛起红。这是他们上初中以来第一次碰面，而且这次偶遇的画面和昨晚梦中的画面是如此的相似。</p>
<p>丁晓炎看凌召一句简单的回答就一直低着头，也没有再说些什么，其实这时的凌召的心里已翻江倒海，正为这个梦有所见欢喜不已。凌召拿起书时胳膊一不小心靠到丁晓炎的胳膊，她没有本能的挪开。此刻，他心跳急剧加速，脸红烫到了鼻头。脚开始发软了，只得用右手使劲撑着柜台面。</p>
<p>“我结完帐了，先走一步。再见。”丁晓炎看着还低着头的凌召说。</p>
<p>凌召挥了挥手，没好意思抬头让丁晓炎瞧见自己烤熟的脸蛋。这时多么不容易的一次能够看看自己朝思暮想的丁晓炎的机会，当凌召想到这点时，将头抬起，发现丁晓炎早已走远。</p>
<p>有时缘分就是这么奇妙，虽有祸不单行一说，但也有福不单行发生。凌召又再次见到了丁晓炎。凌召走到教学楼总会经过一片绿植园，穿过后走几步就能够到了。在他刚走出那片绿植时惊讶发现李文龙正在和丁晓炎聊着什么，丁晓炎发现凌召后就急匆匆的走了，连跟李文龙道别和跟自己打招呼都没有。凌召正纳闷她怎么会认识李文龙，发现李文龙直站在那发呆，看起来悲伤极了。</p>
<p>“李文龙，你怎么认识丁晓炎？她来十中干什么？”凌召走到李文龙身边将手搭在他肩上问道。</p>
<p>李文龙将凌召的手从自己肩上拿下，转过身背对着凌召慢慢走向教学楼。</p>
<p>后来凌召也没有再问李文龙这个事情，李文龙也没有跟凌召提过丁晓炎的事。</p>
<h1 id="第三话"><a href="#第三话" class="headerlink" title="第三话"></a>第三话</h1><p>随着第二次市足球联赛的逼近，凌召将更多时间花到了足球部上。李文龙为了让凌召能够发挥出最大潜力，每天都陪他练球到很晚。当然再晚也会有李文龙的女粉在场边守候。</p>
<p>“你看，秦珊啊，蒋美龄啊这些美女们每天都这么辛苦的陪着我，怪不好意思的。”凌召说完用手捂着脸假装一副怪不好意思的样子。</p>
<p>“哧！”李文龙刚喝到嘴里的那口水差点喷了出来。“又不是陪你，你有什么不好意思的。好好练球，别成天想这些乱七八糟的，你没有经验，实战又少，自己摸索时间等不起，这段时间我陪你练习，是不是感觉进步了很多。”</p>
<p>“那是，李文龙亲自带那还会不成。”凌召双手叉腰神气的说。</p>
<p>“少来，今天时间差不多了，走了。”李文龙用力拍了下凌召的背。</p>
<p>出球场，换好衣服，走出场馆。走在通过十中大门的树荫大道上，李文龙挎着书包，一手扶着自行车，一手托着球把玩着，凌召双手推着自行车，女粉大队们也陆陆续续的骑着车走了。天已黑，路边的灯亮了起来。凌召看了看神情自若的李文龙。</p>
<p>“那个…”凌召打算试着问下丁晓炎的事情。</p>
<p>李文龙似乎已察觉到似的，将球放进车前框子里，左脚一蹬右脚一抬骑上自行车对凌召说：“时间不早了，我们都快点回家休息吧，明天继续练。十中必胜！”说完握拳做出加油的动作，凌召也做了个同样的动作，看着李文龙骑走。</p>
<p>快到家门时发现一个高大的身影出现在面前。</p>
<p>“凌召，好久不见了。”黑影显然认识自己。</p>
<p>凌召透过昏暗的灯光看去。</p>
<p>“陈天丸？”凌召激动的叫道。陈天丸是凌召小学时非常要好的朋友，凌召经常去他家玩游戏机，什么魂斗罗，马里奥，松鼠大战，绿色兵团的。凌召仔细打量了下，说：“一年多，个子长了这么多，样子也凶悍了不少，差点认不出了。”</p>
<p>“走，我们玩去。介绍几个朋友你认识下，以后外面有人欺负，就报我们的名字，保证没人敢动你。”陈天丸大拇指往外一翘。凌召急着将自行车停在楼下，跟着陈天丸。</p>
<p>“陈天丸，你现在是外面玩的了，你在一中几班呢？还有哪些小学同学分在你们班？”凌召急着问了一堆。</p>
<p>“哈哈，凌召，还惦记着丁晓炎呢，这么含蓄干嘛！直接问我不就得了。还挺巧，丁晓炎现在跟我一个班，情书不好意思送就让我代你给她。”</p>
<p>凌召脸刷的一下就红了，没想到自个小心思这么容易就被看穿了，但心里却是十分的欢喜，想着终于有了一个能够将他和丁晓炎连在一起的人了。</p>
<p>来到街机厅，陈天丸将凌召介绍给他的两个朋友，江曰日和程三石。程三石瞧了瞧凌召，对陈天丸说：“你兄弟看起来这么斯文秀气，三好学生吧，哈哈。”说着左右望了望江曰日和陈天丸，哈哈大笑起来。</p>
<p>“别小看他，人家是十中足球校队的，来，凌召，把那个小家伙的游戏币给抢了。别让程三石小瞧了。”陈天丸将手搭在凌召肩上指着一个刚买完币的小孩对凌召说。</p>
<p>凌召这会儿还在为那事兴奋着呢，他伸手将陈天丸的手扶下，接着走到老板那买了一个游戏币，程三石和江曰日双目相望捂着嘴咯咯笑了起来。凌召拿着那枚币走到里面对那小孩说：“把我们的币交换下怎么样？”说着讲手掌张开，小孩看了看凌召手中那个币，又看了看凌召，凌召正凶横的俯视着他，身后还有三个黄色头发的大个子盯着自己，吓得赶紧将手中那堆币给力凌召，叫上自己的伙伴跑出街机厅，刚出门就回头大叫：“你们给我等着，有本事就别走。”</p>
<p>“凌召，真看不出来，你刚才那样还真像那么回事。”陈天丸松了口气说道。</p>
<p>江曰日给程三石使了个眼色。接着他们来到一个录像厅附近的一家台球室，一路上边说边笑那个小屁孩跑了还不忘放个屁。</p>
<p>“来一局，看今天我怎么灭你。”程三石抽出一个长杆擦着防滑粉对江曰日说道。</p>
<p>凌召自进入台球室就发现了于佳和韩霍还有韩霍小跟班们在里侧球桌那。整个台球室充满了烟味，于佳也拿着烟在那儿抽。凌召气冲冲的看着于佳，于佳也看着他。</p>
<p>陈天丸看到此状问：“那伙人认识你？”</p>
<p>凌召没心思答，走到于佳前面将她手中的烟一把夺了过来，往地上一扔，用脚踩灭。气呼呼的说：“你知不知道这样会影响你的嗓子吗？你以后还想不想唱歌了。这段时间看你都不怎么去音乐部，你成天都在干嘛？”</p>
<p>于佳将口中那口烟吐到凌召的脸上，说：“干你什么事，好心先生，你不也没怎么去吗。”</p>
<p>凌召正要解释，韩霍走了过来，一把揪住凌召衣领，凶狠狠的看着他，将他往外一推，力气真够大，凌召背撞到柱子上，韩霍跨步冲上去，于佳用手抓住韩霍的衣服，摇头一副心疼的样子，韩霍不顾于佳，将她手一甩，冲到凌召面前就是一拳，说道：“今儿没有李文龙，看我怎么好好教训你。”</p>
<p>接着有是一拳，凌召不是对手，捂着头，韩霍就用膝盖磕凌召头。</p>
<p>砰的一声，韩霍摸了摸头，手上全是血，对面程三石拿着球杆，另一只手做出一个漏空的动作。</p>
<p>“哟，刚才球去哪了，是不是撞到那条狗了，咦，怎么没听到狗叫呢。”程三石一本正经的说着。</p>
<p>“操，敢打老子。”韩霍怒气满面。</p>
<p>“喔，是这条，我还以为是条哑巴狗呢。”程三石左右看看江曰日和陈天丸，捂嘴笑着说。</p>
<p>韩霍气得血流的更急了，他捡起地上击中他的那个球要扔回去。趁他弯下腰时，程三石他们三人就冲到韩霍旁边拿着球杆往他身上打。韩霍那群人冲了过来帮忙。</p>
<p>不一会，韩霍和那伙人就扛不住了，跑到台球室门口，韩霍指着程三石说：“臭小子，有种，敢告诉我你在哪个学校，叫什么名字吗？”</p>
<p>“这有什么，想找我还不容易，记住我叫程三石就行，到哪都能找到我。”程三石舔了舔溅到嘴边的血说道。</p>
<p>“三石？小黄毛？”韩霍这个外面玩的当然知道了，这片地方的老大就是大黄毛，他弟弟就是人称小黄毛的程三石。</p>
<p>“难怪，小黄毛果然能打。”说完就准备走。</p>
<p>“喂，你的名字呢？哪个学校的？真不懂礼貌。”程三石说。</p>
<p>韩霍呆了一下，赶紧拉着小弟们跑了。</p>
<p>“切，一群不懂事的小屁孩。”程三石说着拉起地上的凌召。</p>
<p>“他是怕你再找他。”凌召捂着疼痛的肚子说。</p>
<p>“我知道，你跟他们很认识？一个班的吧，以后他要是再找你麻烦，直接找我，看我怎么教训这群兔崽子。”</p>
<p>由于李文龙的特训，凌召进步飞快，现在已成为首发。足球联赛开始后，十中已经连下几城。</p>
<p>训练时，陈天丸找到凌召。</p>
<p>“怎么了？”凌召看陈天丸慌慌张张的。</p>
<p>“你们足球队那个李文龙又跟程三石杠上了，说是要弄死他。”</p>
<p>“李文龙怎么跟你们一中的人扯上关系了。”凌召好奇的问道。</p>
<p>“怎么，看你跟他挺熟的，难道他没跟你提过他以前是一中的吗？李文龙年以前跟我们一个班，有次程三石正在教训一个不听话的同学时，李文龙过来管这闲事，动起手来，结果两个人都被学校开除了，转到十中，再后来的事你就知道了。”陈天丸说。</p>
<p>还真是李文龙的风格，凌召想起收作业和韩霍起冲突李文龙过来解围的那次。</p>
<p>陈天丸接着说：“最近不知怎么的李文龙跟丁晓炎好上了，经常跑到我们一中找丁晓炎，有次程三石来找我，正好碰到了李文龙和丁晓炎在一起，我跟程三石说过你小学时就挺喜欢丁晓炎，结果他看到这幕，新仇旧恨一气上来，跟李文龙干了起来。李文龙天天练球这身手也比以前强多了，结果把程三石打得很惨，今儿他准备过来好好教训下李文龙。”</p>
<p>凌召听到李文龙和丁晓炎好上了这事着实吃了一惊。想起那次在十中碰到他们在一起聊天，又想到他们时常在一中碰面的画面，心里升起一阵妒忌，可能太在意丁晓炎了，对李文龙有种特别的反感，有种想冲回球场跟他干一场的冲动。</p>
<p>凌召低头沉思了会说：“你让程三石他们等会，我会把训练时间拖的晚点，那时没人后，你们想怎么弄他就怎么弄他。”</p>
<p>回到球场，凌召拼命的往球门射球，心中那股妒气难消。到了很晚天都黑了，其他队员和粉丝们都离开球场，李文龙发现凌召一点走的意思都没有。问道：“凌召，今天怎么这么主动训练，平时这么晚你都吵着要回的。”</p>
<p>凌召看着李文龙，忽然浮现出丁晓炎依偎在李文龙身上笑着看自己的画面。</p>
<p>“压力太大，想多练练。”凌召心里发虚，不敢抬头看李文龙。</p>
<p>“没事，放松些，还有我呢。”李文龙笑着说，用脚挑起球到空中，凌空一脚强力旋转球，擦着球门左边侧栏应声入网。</p>
<p>这球好棒，凌召心里不断感叹道，只觉得自己和李文龙比起来还差得好远。以前只有崇拜，现在却有多了种要比较带来的自卑感。</p>
<p>“我去小卖部买点喝的，等会回来再跟你请教这球怎么练。”</p>
<p>凌召说完慢慢走出球馆大门，刚走出门口，程三石早已等在那，带着一群人，其中有个个子高高块头较大黄头发的人，凌召想那一定是程三石的哥哥大黄毛。他们从凌召身边走过，凌召站在原地不动，余光看见程三石对着他竖起大拇指，大黄毛从衣服里掏出一把大砍刀。刀在月光下一闪，霎那间凌召想到血腥的画面，脑袋一下子清醒过来，想起李文龙一直也没有做错什么事，他又不知道自己喜欢丁晓炎，而且他比自己优秀那么多，丁晓炎喜欢他也很正常啊，只要丁晓炎开心，自己还有什么好气的呢。李文龙心又那么好，帮过自己，还这么用心教自己，鼓励自己。 先前陈天丸说程三石要弄死李文龙，现在看这状况是真有可能了，即使没弄死也得残废吧。先到这里，凌召转身准备冲进球场，转而一想，程三石那么多人，自己单枪匹马冲进去不但救不了李文龙，自己也得打个半死，于是急忙跑到学校门口传达室让他们叫警察过来。</p>
<p>警察赶到时，李文龙已满身是血，看到警察终于坚持不住晕倒在地。</p>
<p>次日放学，凌召来到李文龙病床边，在床头放下自己用省出来的零花钱买的水果，坐在床边的椅子上看着睡着的李文龙。虽然受了重伤，脸上也是青一块紫一块的，依然无法盖住他的俊气。凌召眼角一股酸意，眼泪完全没法控制住流了一脸，他用力的抽搐着，眼泪越流越多，模糊了整个视线。模糊的眼睛看见一只手伸了过来，凌召本能的将眼闭上，这只手将眼边泪水擦干。凌召睁开眼，看见李文龙已醒，笑着看着自己，手上正流着自己的眼泪。</p>
<p>李文龙对凌召说：“你哭什么，都是些皮肉伤，过几天就好了。”</p>
<p>李文龙看凌召又开始哭了，接着说：“还哭，我听护士说昨晚你一直床边哭，一夜了，上学才走。昨晚是你叫的警察吧？”</p>
<p>凌召点了点头。</p>
<p>“这我就要怪你了，完全没必要嘛，在多等一会，我就能将他们都放倒。还好那会你出去了，不然要拖我后腿了。”李文龙假装着生气的说道。</p>
<p>李文龙看凌召一直不说话，头躺了下来，看着天花板叹了口气说：“你这是干什么来的，又不和我说话。下午学校来人通知我被退学了，看来我又要转学了，不知道这次还有没有学校愿意再要我了，你也不说点开心的话逗我开心开心。”</p>
<p>“怎么会这样，那以后我们的足球怎么办，没有你，十中怎么踢？”凌召听到这着急的说。</p>
<p>“我也不想这样，不过也没有办法，以后十中就靠你了，你要相信自己，你现在缺的就是自信了。等我到了其它学校，我们还是有机会在一个赛场上踢球的，我期待着下个赛季的到来。你可不能因为我不在而放弃训练啊！”</p>
<p>凌召含着泪不断点着头，心里充满了对李文龙的愧疚。在凌召准备回去走到病房门口时，李文龙语气严肃的叫住了凌召。</p>
<p>“这一年你要好好练球，下次赛场上你要用全力和我比，如果你输了，我们就再也不是好兄弟了。同意？”</p>
<p>凌召没有转身，背对着李文龙点了下头就离开了，其实这也是凌召所期待的，对！与其对李文龙羡慕嫉妒恨，不如堂堂正正在赛场上去赢来的光荣。</p>
<p>十中缺少了李文龙犹如猛龙少了龙头一般不堪一击，很快就被淘汰了。凌召也开始了准备下一届联赛的训练，有了和李文龙的约定，即使李文龙不在身边监督他也比以往更加刻苦了。</p>
<p>临近圣诞，也是同学们之间相互赠送圣诞卡片的时候。凌召没有丝毫放松自己的训练，走出球场，回家路上经过那家书店，发现从小就和丁晓炎总在一起的姚婷正站在书店门口。</p>
<p>“这不是姚婷吗？在等人吗？”凌召走上前问道。</p>
<p>“凌召！”姚婷发现凌召站在身旁自己要抬着头看，她用手从自己头上横划着比划了下，说：“长这么高了，小学时都看出来呢，看着好像也帅了好多。我是在等丁晓炎。”</p>
<p>凌召一听到丁晓炎的名字，心开始扑动一阵急跳，他往书店看去，看见丁晓炎还在里面找书。</p>
<p>“你们常到这里买书吗？”凌召问道。</p>
<p>“也不是，偶尔吧，我都是跟丁晓炎来的。这么久没见你，你怎么都不来一中找我们这些老同学玩呢，把我们都忘了吧！”姚婷撅着嘴说。</p>
<p>“怎么会，天天都想你们呢。这不圣诞节快到了，等我给你们这些老同学寄贺卡啊。”凌召说。</p>
<p>“姚婷，我买好了。”丁晓炎走出书店对姚婷说。</p>
<p>凌召转头看见丁晓炎，脸忽然又热起来，他只好又低下头。</p>
<p>“丁晓炎，你看，凌召这两年变化挺大的吧，是不是比以前帅多了？”姚婷笑着对丁晓炎说。</p>
<p>“我看还是跟以前一样啊。”丁晓炎看起来没有姚婷那样激动，很平淡的看着姚婷。</p>
<p>对嘛，凌召想着就算自己再怎么变也没法跟李文龙比，想必在丁晓炎心里只有李文龙，其他人她定是瞧不上。越想，凌召越难受，一个人的不开心往往都是来自比较吧。</p>
<p> 回到家，凌召对着镜子，想着丁晓炎的淡淡的表情和她的话，还有镜子前浮现的李文龙帅气而阳光的笑容，心中只觉得自卑到了极致。</p>
<p>凌召从柜子中翻出小学时自己的照片，对着镜中的自己看了又看，虽然没有质的变化，但五官却是更正了，脸颊更加消瘦，轮廓更清晰了，回想姚婷的话，觉得跟以前的自己比就好了。想到这。他回到自己的书桌前，从抽屉里拿出一堆准备好的贺卡。将笔蘸了蘸墨水，他第一个想写给的人当然就是丁晓炎了。</p>
<p>他写道：“丁晓炎：不知道你是否会回想起小学时我们同桌的快乐时光，自从我被调到后面座位，就没有一刻不想你，想和你再在一起，我知道你现在喜欢的是李文龙，他也是我的好兄弟，是个很棒的男孩，我的目标，我真的为你感到高兴。圣诞到了，祝你在新的一年能够同样开开心心的！”</p>
<p>写完所有人的贺卡，凌召来到陈天丸家，托他将这些贺卡送给以前小学同学们。第二天，陈天丸将贺卡一一送给同学们时发现少了几张，估计是书包没拉紧路上弄丢了，于是他将缺的那几个贺卡自己补上，随便写了几句祝福话。在丢失的这几张卡片里包括了丁晓炎那张。就这样凌召对丁晓炎的这份表白和祝福在丁晓炎的世界里错失了。</p>
<p>丁晓炎给凌召回了一张贺卡。</p>
<p>贺卡中这样写着：“凌召：谢谢你的卡片，圣诞快乐，彩虹桥的另一端十分精彩，但需要努力才能够踏过去，祝愿你新的一年球技大增，获得冠军，我会为你加油的！”凌召看着丁晓炎对自己的这份鼓励，心中充满了力量，将卡片好好收起，双手握拳，心里默念着这次一定要得冠军。</p>
<h1 id="第四话"><a href="#第四话" class="headerlink" title="第四话"></a>第四话</h1><p>足球毕竟是团体运动，这次联赛也是凌召初中生活最后一次了，十中没有李文龙进入淘汰赛都非常困难，可凌召也顾不了这么多了，他现在只有全力提高自己的体力和球技，他把训练时间延得更长了，休息时就看意甲，研究战术和队友们的话题也是十句九句不离足球。</p>
<p>到了赛季，十中开局虽然胜了两局，但是都非常的吃力。第三场面对的对手是上届第四名的四十七中，因为接受了被十中开除的天才足球少年李文龙，这次他们的目标是冠军。</p>
<p>比赛前，十中更衣室，凌召将大家聚到一起说：“大家心里肯定都明白，这场比赛我们想赢几乎不可能，但我这几天仔细的看了他们的球员资料和比赛录像，具体情况我先不说，大家只要按我的计划来，还是有机会能够胜的。”</p>
<p>队友们都用好奇而怀疑的目光看着凌召，只有教练点了点头说：“凌召，这次我是真没招了，如果你有那么一丁点把握就去试试，我支持你。”</p>
<p>“那好，这次按541进行防守，上半场我不上场，只守不攻。下半场采用防守反击，我会全力将比分扳回来。”</p>
<p>队员们和教练都惊诧的看着凌召，多么冒险的一招棋啊。但凌召却表现得异常冷静而自信。</p>
<p>“好，大家就按凌召的办法来，加油，十中必胜！”教练大声给队员们鼓气。</p>
<p>比赛一开始，四十七中的攻击就在李文龙的带领下如狂风暴雨般倾盆而下，虽说是全场防守，但在这样有组织又激烈的撞击下也没能守得住。上半场以0比7大比分落后，这样的比分，无论是观众还是在十中队员甚至是对凌召有信心的教练看来都是没有什么扳回的机会了。韩霍气冲冲来到凌召面前大声吼道：“看你干的好事，十中的脸都让你丢尽了。”</p>
<p>哪知凌召却轻松的回答道：“丢脸的是你吧，我又没在场上。”</p>
<p>韩霍咬着牙，眼睛直瞪着凌召说：“好小子，有你的，乘机报复我是吧，等会下半场看你怎么收拾这局面。”说完转身做了个操的手势。</p>
<p>“喂，韩霍，有本事跟我比比吗？”凌召说。</p>
<p>“比什么？”</p>
<p>“比下半场是你丢球少还是我进球多，怎么样。”凌召笑着说。</p>
<p>“比就比，输了，就等着被我揍吧。”韩霍用手指着凌召说。</p>
<p>“好，我输了，随你怎么打，我绝不还手。”</p>
<p>下半场，四十七中为了保存实力，换下了两名主力，李文龙继续在场上。开球时，凌召望着李文龙。</p>
<p>“终于等到这一刻了，看来你是宝都压到下半场了，让我们好好比比吧。”李文龙笑着对凌召说。</p>
<p>“恩，可不要放水啊，不然我们就不是好兄弟了。”凌召说。</p>
<p>“还当然。”</p>
<p>哨声响起，凌召犀利的带着球一连突破中场来到后场，后场队员一脚铲了过来，凌召将球挑起，跳过对手，一脚站地，另一脚凌空一个快速的大弯弧线球冲向四十七中大门左侧，球擦着球门侧栏应声入网。这一球一气呵成漂亮极了。李文龙也惊住了，这不是他最擅长的那招么，竟被凌召运用的这样娴熟。</p>
<p>接下来，李文龙进攻的机会越来越少，凌召控球时长越来越长，满场的跑，李文龙上半场踢得太疯，体力没法跟上凌召了。一旦李文龙接住球，凌召还会过来协助围堵，断下球就回传队友，自个拼命往前跑，接到长传就疯狂的攻击。在这样疯狂的战术下，居然扳回了比分，打成了8比8平，进入加时。</p>
<p>加时赛时，四十七中已没有了换人名额，而十中将体力充沛的三名队员换上场，这时四十七中被一口气追上这么多比分心理上的压力是数倍于十中的。原来这一切也都在凌召的预料之中。早在比赛前，凌召就仔细研究过四十七中，发现他们今年厉害的后卫都退役了，新生的没有补上，联赛以来一直以攻代守，所以他才想到不在上半场和他们硬拼，将赌注都压在了下半场。看来这战略是没错了，在加时赛时凌召依旧保持了下半场那股冲劲将四十七中打回了老家。</p>
<p>比赛结束后，李文龙走了过来，伸出手，凌召抓住他的手，李文龙红着双眼说：“你赢了，我不如你。”</p>
<p>凌召用力一拽将李文龙抱住，凌召对李文龙的感觉真是酸甜苦辣咸五味俱全。这一时竟无话可以说出来。对于李文龙与无巨细的教足球他感激不尽，对于丁晓炎的事情他醋意满满，对于退学的事情他追悔莫及。</p>
<p>这场与李文龙的对战立刻传遍各个中学，校刊上到处都是凌召球场上的照片和采访的照片。赛中凌召战术的安排，下半场精妙绝伦进攻表现让人印象深刻。</p>
<p>训练时，教练领着几位新同学来到大家中间，对大家说：“同学们，这三位今天要加入我们十中的校队，他们都是非常优秀的球员，这次我们有希望能够那个冠军回来了。”</p>
<p>其中一位长发飘飘走到凌召跟前说：“凌召，上场比赛够精彩的，多么又想象力的比赛啊！其他两位都是跟着我来的，都是经验丰富的好手。对了，我叫王亦，待会我就办入学手续，到你班上，以后多多指教，让我来帮你圆个冠军梦吧。”</p>
<p>王亦是个爱热闹的人，他组织班上同学到他家里开派对。他家在江边有座独楼。这次派对王亦发现凌召总是一副闷闷不乐的表情，在房顶烧烤时，王亦发现凌召已经回去了。他向身边的秦珊打听原因。</p>
<p>“你刚来不知道，凌召以前跟于佳好过一阵，现在于佳跟凌召死对头韩霍在一起，你说你把他们邀到一块，凌召不尴尬才怪。”秦珊说。</p>
<p>“喔，喔，这样，我算明白了，这好办，我再办个派对。”王亦笑着说。</p>
<p>他果然说到做到，打听到跟凌召关系好的同学后。没几天他又办了个，这次，他只请了一些跟凌召玩的好的到江滩边烧烤。他特意请了于佳而没请韩霍。一箱烧烤吃的差不多时，王亦给大伙使了个眼色，说：“走，走，大家帮我再搬下吃的来。”凌召和于佳准备起身时，王亦对他说：“你们就在这里等好了，让我们去搬就好了。”</p>
<p>一转眼，江滩就只剩凌召和于佳了。与刚才的喧嚣相比，此刻的安静有点让人窒息的感觉。远处江面传来一阵船鸣声，于佳站了起来。望着坐在地上一脸无所适从的凌召说道：“王亦是故意的，找这个机会让我单独和你在一起。”</p>
<p>“为什么这么说？”凌召抬头望着双手叉在背后一只脚抬起做出不稳姿态的于佳说。</p>
<p>“他找过我，跟我说，要我不要跟韩霍在一起，让我和你好。”</p>
<p>“什么？他怎么…”凌召惊慌的站起来。</p>
<p>“他一定是错以为你喜欢我，所以想帮你，但其实是你不要我。”于佳转过身望着远方那支鸣着笛缓缓开过来的船。凌召又低下头，于佳转头看着凌召，接着说：“我现在还喜欢你，但你不要担心，我只要把你放在心里就好。”于佳将右手放到胸口，眼眶开始湿润起来。</p>
<p>凌召望着于佳欲言又止。</p>
<p>“王亦说如果我跟你好的话，可以捧红我。”于佳说。</p>
<p>“王亦？他有这本事。”凌召奇怪的问。</p>
<p>“你不知道吧，他父亲是王朝集团董事长，王朝娱乐就是他们旗下的，那个SGirls组合就是王亦班上的，他给一手捧红的。”</p>
<p>“难怪他家房子这么大呢，但是我…”凌召为难的说不下去了。</p>
<p>“没事，你不用愧疚，我已经告诉王亦我们的事情了，他说只要以后不跟韩霍在一起就行，免得让你看着心里难受。我答应了，反正我跟韩霍一起也是因为你，一点不可惜，我会好好把握这次机会…”于佳一副强作开心的笑着说。还有一句她没有说出口：“等我成为万人迷时，我想那时你可能会喜欢我的。”</p>
<p>“我是真心祝你能够成功的，你的愿望马上就要实现了。”凌召从地上捡起一听可乐，哧的一声打开，举杯说道。</p>
<p>“可惜我的愿望不是这个啊。”于佳眼睛直直的看着凌召，好像有种支撑不住想要倒在他怀里的感觉。凌召是知道于佳想法的，双眼无法承受这种过浓的情意，有种无法呼吸的感觉。</p>
<p>凌召一口气将手中可乐喝完。将易拉罐捏扁用力抛向江面。呼出一口气，接着对于佳说：“我最近写了一个新曲子，要不要听听？”</p>
<p>于佳点了点头，凌召从书包中掏出一个口风琴吹了起来。</p>
<p>于佳坐在地上，头侧贴着交叉置于双膝的双手上，目不转睛的望着吹着口风琴的凌召，细细的欣赏他的曲子。</p>
<p>吹完曲子，凌召自信的笑着说：“怎么样，等你成为明星后，让我做你的御用作曲人没问题吧。”</p>
<p>于佳没有回答他，从他手中拿过口风琴，没有擦，直接放到嘴上吹了起来。吹的曲子就是许愿那次他们一起弹的那首。每次想凌召时于佳就会弹这首曲子，于佳娴熟的吹着这首曲子，因为她早已弹过了无数遍。双手握着凌召的口风琴，贴着琴口，仿佛感觉自己已抱着凌召，吻着他的唇。她知道这只是幻觉，泪水已忍不住流过面颊滴在了口风琴上。</p>
<p>王亦继承了他父亲那种聪明和气质，不光成绩名列年纪第一，对待同学也十分平易近人，一点架子都没有。对于凌召来说，在接下来比赛中，王亦无疑起到了巨大的作用，使得十中能够顺利进入到淘汰赛。</p>
<p>随着联赛到了淘汰阶段，凌召他们年纪也开始面临初三的毕业。学校为了保证升学率，专门开设了晚间提高班，将那些各个班级成绩一般但有希望能够进一步提高的同学集中到一个班上学习。凌召成绩一般所以也在这群人中，这样他就还需要多花些时间在这个提高班上。</p>
<p>放学后，凌召跟王亦分组进行了一场训练赛，吸引力很多的同学围观。很多非球迷都是因为想看王朝董事公子王亦而慕名而来的。王亦球场上一头长发飘飘，非常帅气，球技也不亚于李文龙，和他一块来的两名同学也是他精挑细选的，所以这次十中能够进入淘汰赛，王亦亦是功不可没。打完训练赛，凌召已是大汗淋漓，接着他还要赶着去参加提高补习。</p>
<p>凌召来到提高补习教室，坐了下来，身上的热气还没有散，他从书包里拿出本子不住的扇着。</p>
<p>“跑着来的吧。”凌召旁边一位女孩子问道。</p>
<p>“刚才踢球了，好热！”凌召一边扇着，一边转过头看那女孩。那女孩白白净净的，五官清秀端正，大大的眼睛正有神的瞧着额头发稍汗湿的凌召。</p>
<p>“我叫田晓宁，是你提高班的同桌。”田晓宁说。</p>
<p>“我叫凌召，看我这身汗，我先去冲下。”凌召用手提了提衣领口。</p>
<p>冲完，凌召感觉舒畅极了。课上，田晓宁问凌召：“你在班上排名第几？”</p>
<p>“三十多吧。”</p>
<p>“我也是，那你打算考哪个高中？”</p>
<p>“还是十中吧。”</p>
<p>“我打算上一中，不过可能考不上。”田晓宁看起来也没有怎么担心的样子说。</p>
<p>凌召听到一中就想起了丁晓炎来，想着她是不是也能考上一中高中呢，转而一想是不是自己也应该好好学习了，也争取考上一中高中呢，这样就能够常常见到她了。</p>
<p>“我也想考一中。”凌召说：“但是现在水平估计难，离中考也没有多长时间了，不知道还来不来得及。”</p>
<p>“所以才让我们来提高班嘛，努力努力还是有希望的。”田晓宁蛮自信的说着。</p>
<p>在课上，田晓宁埋着头在本子上涂着画，凌召觉得很诧异，刚不是说要上一中么，上课还这么不认真。</p>
<p>“田晓宁，不是想考一中吗，怎么不好好听课，在画什么呢？”凌召问田晓宁，凑过去看她在画什么。</p>
<p>田晓宁急忙趴在本子上，有些不好意思地说：“没画什么，我是要上一中，考不上也能上的。”</p>
<p>“是么，你家有关系么。”</p>
<p>“恩，我爸有办法。凌召，你高中毕业后有打算考哪个大学吗？”</p>
<p>“这个，还从没想过呢，先把中考搞定再说吧。你有打算考哪个大学吗？”</p>
<p>这时老师发现他们俩一直在讲话，就点田晓宁站起来回答问题，田晓宁站起来时一着急把那个本子弄到地上，凌召帮着将那本子捡起，已经站着的田晓宁焦急而尴尬的看着凌召捡起本子后惊讶的看着本子的表情。</p>
<p>田晓宁回答完问题，满脸通红的从正在仔细欣赏本子上画的凌召手中将本子拿了回来。</p>
<p>“真像，你很早就知道我了呢，前面都是我踢足球玩乐器的画，最后一张肖像画是刚才画的吧，跟照片一样样的，好厉害好专业。”凌召兴奋的说。</p>
<p>田晓宁合上本子低着头半天都没有啃声。</p>
<p>快下课时，田晓宁对凌召说：“下次提高课你带几张你的照片送给我好吗，我现在还画的不好，有照片毕业后还能够有个纪念。”</p>
<p>“好啊，没问题。”凌召站起来收拾书包打算走。</p>
<p>“还有，你问我大学想去哪，我是打算直接去美国读，我有亲戚在那。”田晓宁说。</p>
<p>“美国，这么好，我就没有办法了，我没有一个亲戚在国外。”凌召羡慕极了。</p>
<p>“我去了后就可以给你担保啊，这样你也能够过来了啊。”田晓宁一副感觉一切都是轻而易举似的表情说。</p>
<p>凌召看着田晓宁期待的眼神看着自己，他知道这只是随口说出的一句话，但心里却是十分开心着呢。</p>
<p>回家路上，他一路哼着小曲。</p>
<p>随着淘汰赛的进行，一切都看起来很顺利。摆在十中面前的最后一堵墙是连续获得数届冠军的一中。</p>
<p>广播体操结束后，凌召和王亦边走边聊着应对一中的战术，在上楼梯时，一个女孩大叫了一声凌召的名字，凌召和王亦朝上看去，原来是田晓宁，凌召也回了句：“田晓宁。”挥挥手跟她打了个招呼。</p>
<p>王亦凑到凌召耳边说：“怎么认识这么漂亮的女孩，回头介绍给我。”</p>
<p>凌召看了看王亦色迷迷的眼神，忽地想起叶正找他递给于佳情书的事情，结果是两边不讨好，叶正这个朋友也没得做了。于是凌召对王亦说：“我也不认识啊，就是一粉丝，想泡自己追去。”说完就快速朝前走去。</p>
<p>王亦赶紧追了去，拉下凌召的衣袖说：“喂！别那么小气，不像介绍就算了，也用不着这样嘛，名字都记住了还说不认识，不用担心，兄弟我不跟你抢，漂亮妹子多的是，有你这么好的哥们可不容易咯。”</p>
<p>凌召笑着用力朝王亦胸口推了一把，假装生气的说：“去，谁担心了，不要太自信了，好好准备下场比赛，我想赢，我最在乎的人也希望我能赢，现在只剩最后这一场了。”</p>
<p>王亦看着凌召一脸认真的表情，哈哈大笑说：“最在乎的人，哈哈，是刚才那个漂亮女孩吗？”接着假装一本正经拍了拍凌召的肩膀说：“这不，here I am，我来十中就是来助你一臂之力的，我来这就是因为你，你不知道吗，你不知道你那场和李文龙的比赛又多精彩，彻底的吸引了我。”</p>
<p>“少胡扯，谁不知道是你老爸在这边有个项目才把你带过来的，这些甜言蜜语的话跟姑娘说去。我看你最近练球越来越不刻苦了，一点都不像李文龙。”凌召非常认真的表情说道。</p>
<p>“像李文龙那样干嘛，还不是被你击败了。”王亦一脸不服的说。</p>
<p>“他只是在足球上，准确来说是那一场比赛输给了我，其它地方，我比不过。算了，总之一句，已经到了这一步，绝对不能输，ok？”</p>
<p>看着凌召真的认真起来，王亦在一旁不停地点着头。</p>
<h1 id="第五话"><a href="#第五话" class="headerlink" title="第五话"></a>第五话</h1><p>命运往往都不那么会顺着人意，对凌召是，对丁晓炎也是。</p>
<p>画面终于定在了凌召期待的决赛，这次主场是在一中，上半场王亦和凌召娴熟的配合通过防守反击在快结束时压哨率先取得一分。凌召开心的小跑到场边，看见田晓宁已经准备好毛巾和水正等着他，他接过水，田晓宁满脸笑容深情的望着凌召，凌召想着凭借这一分优势，下半场就能够很容易掌握主动权，胜算将非常大。他打算在胜利后在台上大声说出对丁晓炎鼓励的感激。拿着水正要喝时，忽地感觉有个眼神在另一边看着自己，他放下水杯，往那边看去，那个身影忽地消失在人群中，那身型和发型像极了丁晓炎。</p>
<p>这一定是自己想丁晓炎想得太多了产生的幻觉吧。凌召将水往脸上泼了去，想让自己清醒下。</p>
<p>下半场，十中在最后时刻因为韩霍的冲动红牌下场而陷入被动，最终没能够挡住一中猛烈的攻势。这样凌召因为败落而失去找丁晓炎的勇气。那以后凌召就再也没有见过丁晓炎了。</p>
<p>即使这么多年过去，小学同学聚会上她也没有出现。凌召翻着那篇丁晓炎的文章，文章是这样写的：“</p>
<p>那年，我四年级，转学到一所小学，周围都那么陌生，和我同桌的以为男孩成为了我在这儿的第一个朋友。他叫凌召，我们很谈得来。他送给我一只黄色的电子表，这是我收到的第一个男生的礼物。</p>
<p>快乐的时光总是短暂的，在凌召被调到后面做的那天，放学后，我站在他必经路边的一颗树旁等他。在他经过时我问他不跟我坐是不是不开心，他看起来有些伤心，看也没看我一眼就走了。</p>
<p>自那以后，我常常看见凌召和他的同桌们吵架。一次学校庆典上，凌召来了场钢琴独奏，随着琴声飘荡在我耳边，我发现我已经喜欢上了他。他送给我的那只黄色表我放在抽屉一打开就能够看见的地方，这样我每次打开抽屉就能够回想和他同桌的时光。小女孩的心思就是这样的简单，单纯着，虽然也知道自己对凌召来说只是一个普通的同桌过的人而已，但却也能够勇敢的不顾一切的去享受着这份纯纯的单恋。</p>
<p>我们那个年代没有手机，小学临近毕业那会，同学们都会让自己在乎的人在自己的本子上留下家庭住址联系方式，因为毕业后大家可能会分开去其它的学校。当我把本子给凌召时，他的那些朋友们都这跟着起哄，弄得凌召不好意思的脸都红了，为了让他不尴尬，我让他的那些朋友也都在本子上写了。</p>
<p>上课后，我一直在想为什么就我去找凌召时他的朋友们会起哄，其他女同学去时他们也没什么反应啊，想着想着趴在桌上回头抄凌召坐的方向看去，发现他也正在看着我，我有点惊慌，心跳加速，但视线一直没有离开他，他也没有离开我。我有点不相信，回过神，发现他已经趴在桌上睡着了。</p>
<p>上了初中，我们分在了不同的学校，但因为一个人，让我能再了解到凌召在十中的所有事。这个人算得上是万人迷吧，班上的女生都被他迷得神魂颠倒的，可不知怎么的他就是喜欢我，我都没怎么跟他说过话耶，就是这样，可能一种感觉能让你毫无缘由的喜欢上一个人。这个男孩叫李文龙，在他跟我表白后，我说我已经有喜欢的人了，李文龙看起来有点不服气非要问出那个人是谁。</p>
<p>后来他跟班上一位同学打架劝退后转到了十中凌召的班，虽然转校了，但是因为凌召，他也能够有足够的话题来找我说了，对于我来说我也能够知道更多凌召的事情了。听说凌召加入了足球部，我想这样我就能够在放学后去他们学校看他练球了。</p>
<p>但那次当我在球场边栅栏看时发现一个非常漂亮的女生正在将一封信递给凌召。看着那女孩子不好意思的样子，我想那一定是情书吧。这时发现球场上另一边李文龙正带着一种伤心的眼神看着我。一会凌召也朝我这边看来，我赶紧躲到一旁树后。</p>
<p>后来听说我们一中要跟一中比赛，我想凌召应该也会来参赛，于是我申请了球赛自愿者在场边捡球。这样就能够近距离看见凌召了。开赛前，我在场边做准备，发现凌召跑到观众席和以前小学同学们打着招呼，我有点后悔应该呆在观众席了。比赛时，凌召全神贯注的注视着球场，直到最后他才被换上场，没想到我捡到他唯一的一个球竟是他的乌龙球。那时我离他是那么近，但他双眼已无神，看起来难过极了。</p>
<p>我一直担心着他后来的状况，一直盼着李文龙来找我。但这次李文龙带来的消息是凌召跟班上一个玩音乐的女孩子好上了，我知道凌召是很喜欢音乐的，想着他们一起聊着他们喜爱的音乐幸福的画面，有种难于形容的妒忌涌上心头。</p>
<p>李文龙跟我说不信可以第二天放学后去江滩看看，因为那女孩子给凌召的情书里是约着去那相见的。等我到江滩时看见那女孩正抱着凌召，我心里真的好难受，原本还抱着的一丝侥幸变得绝望。</p>
<p>这样的心情我想会持续很久吧，晚上我无法入睡，枕头全被泪水浸湿。</p>
<p>放学后我好像被一中磁场带动了凌召家旁边的书店。因为这家书店离我家比较远，我很少来。我漫不经心的翻着书架上的书，但脑海里却满是那女孩抱着凌召的画面，想到当时的情景，凌召看起来并不是很开心，他当时没有抱着那女孩。会不会只是那女孩单方面的喜欢呢，想到这里我已拿到新出的伯爵千金来到收银台。有种磁场理论就是对一个事渴望意念足够强就会产生巨大的磁场将那事吸引到身边。这时一个高大的身影出现在我身边。我抬头发现正是我日夜思恋的凌召，他好像没发现我，我跟他打了个招呼，他只是简单的回了句，然后就一直低着头。因为我们已经好久没这样一起过，我不知道他现在对我是怎样的感觉，于是也没有再说什么，在这样的气氛下，凌召不小心的碰到我的手臂，我用余光看见他害羞的脸好红，我胳膊能够感觉到他的颤动，虽然我们没怎么说话，但此时我能感觉他还是小学那会的他，那是种熟悉而难忘的感觉，我好希望能够这样多待会儿，可是凌召好像有些紧张，让我觉得他对我和对其他女生还是不一样的。结完帐，我看凌召好像还没有回过神。</p>
<p>我没法不去想和凌召的这次偶遇，接下来的一天，我没法忍住，在中午先去了十中，希望能够再看看他。来到他的教学楼下，碰到了李文龙，他开始是惊喜的表情，后来可能想到我是来看凌召的才恢复了淡定的神情。他应该也没想到我会这么喜欢凌召，李文龙说给凌召写情书的女孩后来没有跟凌召在一起，看来我的感觉是对的。接着李文龙说他愿意帮我去问问凌召喜欢谁。说可能那个人有可能是我。</p>
<p>听到这，我忽地红起脸来，心中窃喜，口中却连连说不可能。但我又害怕如果那个人不是我，我可能会更加难受。因为太在意所以会害怕，我让李文龙不要问，即使问了也不要跟我说。李文龙不傻，很快看出了我的小心思，他知道我对结果是既期待又惧怕，但是这种事情如果不挑明怎么会有结果呢，我们都知道凌召不是那种主动的人，于是李文龙想了个办法。他说现在凌召球是越踢越好了，如果十中能够获得冠军，他就帮我问，如果凌召喜欢的人是我，他会祝福我们，如果不是，李文龙希望我能够接受他。我没有答应如果那个人不是我就接受李文龙这个条件，心里觉得有些对不起李文龙，我不希望李文龙成为备胎，那样对他不公平，我是真的把他当成很好的朋友，但也只能到这一步。李文龙神情有些恍惚，我想定是我的回答伤了他骄傲的心。</p>
<p>这时，我看见李文龙身后出现了凌召的身影，他不会听到了我和李文龙的对话吧。我一时不知该如何面对，于是匆匆的走开了。</p>
<p>接下来，我就一直期待着足球足球赛的进行和李文龙定期到一中来跟我描述和称赞凌召如何聪明。每每听到凌召的事情我都会很开心，李文龙说他喜欢看到我笑的样子，他也知道是因为他说了很多凌召的事使我能够感到愉悦。所以每次他都只说凌召的事情，其它的事情包括他自己的事情他都是只字不提。</p>
<p>人生总是会出现很多无法预料的事情，上次因为打架而跟李文龙一起退学的程三石和他又在一中碰到了，他们又打了起来。这次打架后，李文龙就一直没有再到一中来。</p>
<p>这样我再无法知道凌召的消息，就算是守株待兔吧，我还是想像上次那样能够在那书店偶遇凌召。这次我要主动问他的近况，我暗暗的下着决心。</p>
<p>我和他还是有缘分的吧，一次我在书店里面挑书，跟我一起来的小学时就跟我要好的姚婷好像在书店门口和什么人说着话。我走出书店，发现是凌召，他还是跟上次一样，一见到我就低着头，姚婷说凌召比以前帅了，但我觉得他一直都很帅啊。</p>
<p>姚婷后来说凌召要给老同学们写贺卡，想着十中这最后一届足球联赛没有了李文龙，夺冠可能无法实现了，我也没法知道凌召心里那个她是不是我，想着每次碰见凌召那害羞的画面，我越发想确认了。于是我给凌召回卡里表达希望他能够夺冠的心情，我想如果凌召心中的那个她是我的话，他一定会全力以赴去夺冠的吧。我想当他获得冠军那天，我会鼓起勇气向他表白，就算没有夺冠，我也会，我不想错过我最喜欢的人。</p>
<p>接着的事情远比想象的好，从十中战胜李文龙带领的四十七中开始，校刊里不断出现凌召的身影，富家子弟王亦的加入让十中如虎添翼，战无不胜，一直冲到决赛和我们一中开始了最后的角逐。</p>
<p>决赛那天，空中飘满了气球彩条，赛前十中的王亦请来他们公司的当红明星过来表演助阵，从演出名单我能看到那位给凌召写情书的于佳的名字，现场我能看到于佳一边唱着歌跳舞，一边看着场边正在做准备运动的凌召，那种不一样的眼神，想想自己从小就很喜欢跳舞，也希望自己能够像于佳那样在观众面前表演展现自己。</p>
<p>比赛开始后，十中打得很不错，虽然我不懂足球，但从射门次数控球时间看来，明显能够感觉十中占据了优势，果不其然在中场结束前凌召一脚凌空射门将球打入。看着凌召兴奋的在场上奔跑着，我也忍不住欢呼起来。当然我能够感觉到边上同学看着我的异样眼神。我兴奋的拿着早已准备好的毛巾和水朝十中场地那边走去。</p>
<p>当我接近时，凌召正开心的带着一副帅气自信的笑容朝场边一位看起来秀美很有气质的女孩走去，那女孩微笑着用手中的毛巾擦着凌召额头的汗水，凌召的表情看起来幸福极了，他笑着从那女孩手中接过水，这时，我已感到脚有些发软，我急忙转过身朝人群中走去。此时，我觉得自己好傻，我这么一个平凡的女孩还天真的以为凌召会喜欢自己，想着他一直都在不断的努力着，琴弹的那么好，能够让和他一样优秀的于佳对他恋恋不忘，还通过自己的努力把自己不擅长的足球都踢得这么好，能够交上这么一个气质与美丽兼备的女朋友。</p>
<p>觉得天天想着的凌召离自己越来越远，有种以后就再也无法见到凌召的感觉，我坐在观众席上，用捧着的头发将头埋在里面不停的流着眼泪，比赛的结果对我来说已不重要。</p>
<p>那以后，我再也没有见过凌召，但对他的这段思念去一直住在我心里。”</p>
<p>看完这篇文章，凌召已按耐不住了，他已管不了那么多了，他一定要去见丁晓炎，不管她现在如何，也不管她是否还和以前一样喜欢自己。</p>
<p>通过出版社，凌召找到了丁晓炎的家。</p>
<p>打开门的是一个十来岁的男孩，凌召突然觉得自己是不是有些冒失。这么多年了，自己虽然没有结婚，但同龄人大多都该有这么大的孩子了。</p>
<p>“你是凌召叔叔吧。”那小孩问道。</p>
<p>凌召从发呆中回过神来。用惊讶的眼神看着那小孩。那男孩没等凌召回答继续说道：“来找我妈妈丁晓炎吧，她已经去世了，就在不久前。”</p>
<p>男孩看着凌召的眼睛，已经红了一片。</p>
<p>“我是丁晓炎的养子，我翻她的日记本知道了你。”男孩说完牵着凌召来到丁晓炎的房间，房间里书柜上堆满了书，书桌上还留着她未完成的作品草稿，相比结局丁晓炎一定会写得很圆满吧。凌召这么想着，眼前浮现出丁晓炎坐在书桌前写着小说的身影。他伸出手，那身影化成粉末飘散开去，在阳光的照耀下散发着亮光。</p>
<p>男孩拿出一个日记本递给凌召，刚翻开，他已控制不住满脸泪水如泉水不住从下颚流下来。那日记本里贴满了丁晓炎从校刊里剪下的凌召的照片，这么多年她一直精心的保存着。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ming1016.github.io/2016/01/13/how-to-use-gcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="戴铭">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/251980?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星光社 - 戴铭的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/13/how-to-use-gcd/" itemprop="url">细说 GCD（Grand Central Dispatch）如何用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-13T17:20:08+08:00">
                2016-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 <a href="https://github.com/ming1016/GCDDemo" target="_blank" rel="external">https://github.com/ming1016/GCDDemo</a> 对着文章试着来调demo体会更深哦，细细嚼消化好:)</p>
<h1 id="GCD（Grand-Central-Dispatch）-介绍"><a href="#GCD（Grand-Central-Dispatch）-介绍" class="headerlink" title="GCD（Grand Central Dispatch） 介绍"></a>GCD（Grand Central Dispatch） 介绍</h1><p>GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址<a href="http://libdispatch.macosforge.org" target="_blank" rel="external">http://libdispatch.macosforge.org</a>。GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。</p>
<h2 id="GCD概要"><a href="#GCD概要" class="headerlink" title="GCD概要"></a>GCD概要</h2><ul>
<li>和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。</li>
<li>公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O）</li>
<li>可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。</li>
<li>操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在主线程执行了</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>系统标准两个队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//全局队列，一个并行的队列</span></div><div class="line">dispatch_get_global_queue</div><div class="line"><span class="comment">//主队列，主线程中的唯一队列，一个串行队列</span></div><div class="line">dispatch_get_main_queue</div></pre></td></tr></table></figure>
<ul>
<li>自定义队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//串行队列</span></div><div class="line">dispatch_queue_create(<span class="string">"com.starming.serialqueue"</span>, DISPATCH_QUEUE_SERIAL)</div><div class="line"><span class="comment">//并行队列</span></div><div class="line">dispatch_queue_create(<span class="string">"com.starming.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT)</div></pre></td></tr></table></figure>
<ul>
<li>同步异步线程创建</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步线程</span></div><div class="line"><span class="built_in">dispatch_sync</span>(..., ^(block))</div><div class="line"><span class="comment">//异步线程</span></div><div class="line"><span class="built_in">dispatch_async</span>(..., ^(block))</div></pre></td></tr></table></figure>
<h1 id="队列（dispatch-queue）"><a href="#队列（dispatch-queue）" class="headerlink" title="队列（dispatch queue）"></a>队列（dispatch queue）</h1><ul>
<li>Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。</li>
<li>Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。</li>
<li>Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dipatch_queue_t queue;</div><div class="line">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<ul>
<li>user create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<ul>
<li>自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dipatch_queue_attr_make_with_qos_class</span></div><div class="line">dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class="number">-1</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.qosqueue"</span>, attr);</div><div class="line"></div><div class="line"><span class="comment">//dispatch_set_target_queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.settargetqueue"</span>,<span class="literal">NULL</span>); <span class="comment">//需要设置优先级的queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>); <span class="comment">//参考优先级</span></div><div class="line">dispatch_set_target_queue(queue, referQueue); <span class="comment">//设置queue和referQueue的优先级一样</span></div></pre></td></tr></table></figure>
<ul>
<li>dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_queue_t</span> firstQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.firstqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_queue_t</span> secondQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.secondqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_set_target_queue(firstQueue, serialQueue);</div><div class="line">dispatch_set_target_queue(secondQueue, serialQueue);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(firstQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.</span>f];</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(secondQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(secondQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h2><p>队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init;</div><div class="line">&#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">          <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.isolation.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</div><div class="line">          <span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</div><div class="line"></div><div class="line">          label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.work.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</div><div class="line">          <span class="keyword">self</span>.workQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<p>示例：后台加载显示图片<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">     dispatch_async(dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INITIATED</span>.value), <span class="number">0</span>)) &#123; <span class="comment">// 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成，</span></div><div class="line">          <span class="keyword">let</span> overlayImage = <span class="keyword">self</span>.faceOverlayImageFromImage(<span class="keyword">self</span>.image)</div><div class="line">          dispatch_async(dispatch_get_main_queue()) &#123; <span class="comment">// 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。</span></div><div class="line">               <span class="keyword">self</span>.fadeInNewImage(overlayImage) <span class="comment">// 更新UI</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>何时使用何种队列类型</p>
<ul>
<li>主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。</li>
<li>并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。</li>
<li>自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。</li>
</ul>
<p>可以使用下面的方法简化QoS等级参数的写法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="type">GlobalMainQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_main_queue()</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUserInteractiveQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INTERACTIVE</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUserInitiatedQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INITIATED</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUtilityQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_UTILITY</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalBackgroundQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_BACKGROUND</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用起来就是这样，易读而且容易看出在使用哪个队列</span></div><div class="line">dispatch_async(<span class="type">GlobalUserInitiatedQueue</span>) &#123;</div><div class="line">     <span class="keyword">let</span> overlayImage = <span class="keyword">self</span>.faceOverlayImageFromImage(<span class="keyword">self</span>.image)</div><div class="line">     dispatch_async(<span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">self</span>.fadeInNewImage(overlayImage)</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-once用法"><a href="#dispatch-once用法" class="headerlink" title="dispatch_once用法"></a>dispatch_once用法</h2><p>dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIColor</span> *)boringColor;</div><div class="line">&#123;</div><div class="line">     <span class="keyword">static</span> <span class="built_in">UIColor</span> *color;</div><div class="line">     <span class="comment">//只运行一次</span></div><div class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">          color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.380</span>f green:<span class="number">0.376</span>f blue:<span class="number">0.376</span>f alpha:<span class="number">1.000</span>f];</div><div class="line">     &#125;);</div><div class="line">     <span class="keyword">return</span> color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h2><p>设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)processImage:(<span class="built_in">UIImage</span> *)image completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> success))handler;</div><div class="line">&#123;</div><div class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.isolationQueue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">          <span class="comment">// do actual processing here</span></div><div class="line">          <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.resultQueue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">               handler(<span class="literal">YES</span>);</div><div class="line">          &#125;);</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码框架</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">     <span class="comment">// 耗时的操作</span></div><div class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">          <span class="comment">// 更新界面</span></div><div class="line">     &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//下载图片的示例</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">     <span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg"</span>];</div><div class="line">     <span class="built_in">NSData</span> * data = [[<span class="built_in">NSData</span> alloc]initWithContentsOfURL:url];</div><div class="line">     <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc]initWithData:data];</div><div class="line">     <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">               <span class="keyword">self</span>.imageView.image = image;</div><div class="line">          &#125;);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-after延后执行"><a href="#dispatch-after延后执行" class="headerlink" title="dispatch_after延后执行"></a>dispatch_after延后执行</h2><p>dispatch_after只是延时提交block，不是延时立刻执行。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)foo</div><div class="line">&#123;</div><div class="line">     <span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</div><div class="line">     dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">     dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">          [<span class="keyword">self</span> bar];</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showOrHideNavPrompt</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">let</span> delayInSeconds = <span class="number">1.0</span></div><div class="line">     <span class="keyword">let</span> popTime = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>,</div><div class="line">          <span class="type">Int64</span>(delayInSeconds * <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>))) <span class="comment">// 在这里声明推迟的时间</span></div><div class="line">     dispatch_after(popTime, <span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 等待delayInSeconds将闭包异步到主队列</span></div><div class="line">          <span class="keyword">let</span> <span class="built_in">count</span> = <span class="type">PhotoManager</span>.sharedManager.photos.<span class="built_in">count</span></div><div class="line">          <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">               <span class="keyword">self</span>.navigationItem.prompt = <span class="literal">nil</span></div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">self</span>.navigationItem.prompt = <span class="string">"Add photos with faces to Googlyify them!"</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子中的dispatch time的参数，可以先看看函数原型<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );</div></pre></td></tr></table></figure></p>
<p>第一个参数为DISPATCH_TIME_NOW表示当前。第二个参数的delta表示纳秒，一秒对应的纳秒为1000000000，系统提供了一些宏来简化<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒</span></div><div class="line"><span class="meta">#define USEC_PER_SEC 1000000ull    //每秒有多少毫秒</span></div><div class="line"><span class="meta">#define NSEC_PER_USEC 1000ull      //每毫秒有多少纳秒</span></div></pre></td></tr></table></figure></p>
<p>这样如果要表示一秒就可以这样写<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_time(DISPATCH_TIME_NOW, <span class="number">1000</span> * USEC_PER_SEC);</div><div class="line">dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * <span class="built_in">NSEC_PER_USEC</span>);</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁"><a href="#dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁" class="headerlink" title="dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁"></a>dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁</h2><p>Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建队列</span></div><div class="line"><span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="comment">//改变setter</span></div><div class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSUInteger</span>)count forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">     key = [key <span class="keyword">copy</span>];</div><div class="line">     <span class="comment">//确保所有barrier都是async异步的</span></div><div class="line">     dispatch_barrier_async(<span class="keyword">self</span>.isolationQueue, ^()&#123;</div><div class="line">          <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">               [<span class="keyword">self</span>.counts removeObjectForKey:key];</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">self</span>.counts[key] = @(count);</div><div class="line">          &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dispatchBarrierAsyncDemo &#123;</div><div class="line">    <span class="comment">//防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> dataQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.dataqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 1"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//等待前面的都完成，在执行barrier后面的</span></div><div class="line">    dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"write data 1"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 3"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 4"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swift示例<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> concurrentPhotoQueue = dispatch_queue_create(</div><div class="line"><span class="string">"com.raywenderlich.GooglyPuff.photoQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(photo: Photo)</span></span> &#123;</div><div class="line">     dispatch_barrier_async(concurrentPhotoQueue) &#123; <span class="comment">// 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。</span></div><div class="line">          <span class="keyword">self</span>._photos.append(photo) <span class="comment">// barrier能够保障不会和其他任务同时进行。</span></div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。</span></div><div class="line">               <span class="keyword">self</span>.postContentAddedNotification()</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。</span></div><div class="line"><span class="keyword">var</span> photos: [<span class="type">Photo</span>] &#123;</div><div class="line">     <span class="keyword">var</span> photosCopy: [<span class="type">Photo</span>]!</div><div class="line">     dispatch_sync(concurrentPhotoQueue) &#123; <span class="comment">// 同步调度到concurrentPhotoQueue队列执行读操作</span></div><div class="line">          photosCopy = <span class="keyword">self</span>._photos <span class="comment">// 保存</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> photosCopy</div><div class="line">&#125;</div><div class="line"><span class="comment">//这样读写问题都解决了。</span></div></pre></td></tr></table></figure></p>
<p>都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。</p>
<h2 id="dispatch-apply进行快速迭代"><a href="#dispatch-apply进行快速迭代" class="headerlink" title="dispatch_apply进行快速迭代"></a>dispatch_apply进行快速迭代</h2><p>类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (size_t y = <span class="number">0</span>; y &lt; height; ++y) &#123;</div><div class="line">     <span class="keyword">for</span> (size_t x = <span class="number">0</span>; x &lt; width; ++x) &#123;</div><div class="line">          <span class="comment">// Do something with x and y here</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//因为可以并行执行，所以使用dispatch_apply可以运行的更快</span></div><div class="line">- (<span class="keyword">void</span>)dispatchApplyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_apply(<span class="number">10</span>, concurrentQueue, ^(size_t i) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>,i);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The end"</span>); <span class="comment">//这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispatch_apply能避免线程爆炸，因为GCD会管理并发<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealWiththreadWithMaybeExplode:(<span class="built_in">BOOL</span>)explode &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="keyword">if</span> (explode) &#123;</div><div class="line">        <span class="comment">//有问题的情况，可能会死锁</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span> ; i++) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"wrong %d"</span>,i);</div><div class="line">                <span class="comment">//do something hard</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//会优化很多，能够利用GCD管理</span></div><div class="line">        dispatch_apply(<span class="number">999</span>, concurrentQueue, ^(size_t i)&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"correct %zu"</span>,i);</div><div class="line">            <span class="comment">//do something hard</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</div><div class="line">     <span class="keyword">let</span> addresses = [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line"></div><div class="line">     dispatch_apply(<span class="type">UInt</span>(addresses.<span class="built_in">count</span>), <span class="type">GlobalUserInitiatedQueue</span>) &#123;</div><div class="line">          i <span class="keyword">in</span></div><div class="line">          <span class="keyword">let</span> index = <span class="type">Int</span>(i)</div><div class="line">          <span class="keyword">let</span> address = addresses[index]</div><div class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">               image, error <span class="keyword">in</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                    storedError = error</div><div class="line">               &#125;</div><div class="line">               dispatch_group_leave(downloadGroup)</div><div class="line">          &#125;</div><div class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Block组合Dispatch-groups"><a href="#Block组合Dispatch-groups" class="headerlink" title="Block组合Dispatch_groups"></a>Block组合Dispatch_groups</h2><p>dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。</p>
<p>当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。</p>
<p>第一种使用dispatch_group_wait的swift的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     dispatch_async(<span class="type">GlobalUserInitiatedQueue</span>) &#123; <span class="comment">// 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞</span></div><div class="line">          <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">          <span class="keyword">var</span> downloadGroup = dispatch_group_create() <span class="comment">// 创建一个dispatch group</span></div><div class="line"></div><div class="line">          <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">               <span class="type">SuccessKidURLString</span>,</div><div class="line">               <span class="type">LotsOfFacesURLString</span>]</div><div class="line">          &#123;</div><div class="line">               <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">               dispatch_group_enter(downloadGroup) <span class="comment">// dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。</span></div><div class="line">               <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">                    image, error <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                         storedError = error</div><div class="line">                    &#125;</div><div class="line">                    dispatch_group_leave(downloadGroup) <span class="comment">// 保持和dispatch_group_enter配对。通知任务已经完成</span></div><div class="line">               &#125;</div><div class="line">               <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          dispatch_group_wait(downloadGroup, <span class="type">DISPATCH_TIME_FOREVER</span>) <span class="comment">// dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。</span></div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123; <span class="comment">// 执行闭包内容</span></div><div class="line">                    completion(error: storedError)</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>oc例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchGroupWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="comment">//在group中添加队列的block</span></div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"go on"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种使用dispatch_group_notify的swift的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="comment">// 不用加dispatch_async，因为没有阻塞主进程</span></div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</div><div class="line"></div><div class="line">     <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">               image, error <span class="keyword">in</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                    storedError = error</div><div class="line">               &#125;</div><div class="line">               dispatch_group_leave(downloadGroup)</div><div class="line">          &#125;</div><div class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。</span></div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>oc例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dispatch_group_notify</span></div><div class="line">- (<span class="keyword">void</span>)dispatchGroupNotifyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"can continue"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//dispatch_group_wait</span></div><div class="line">- (<span class="keyword">void</span>)dispatchGroupWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="comment">//在group中添加队列的block</span></div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"can continue"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如何对现有API使用dispatch_group_t<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。</span></div><div class="line">- (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</div><div class="line">          [<span class="keyword">self</span> performBlock:block];</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          dispatch_group_enter(group);</div><div class="line">          [<span class="keyword">self</span> performBlock:^()&#123;</div><div class="line">               block();</div><div class="line">               dispatch_group_leave(group);</div><div class="line">          &#125;];</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//NSURLConnection也可以这样做</span></div><div class="line">+ (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group</div><div class="line">     sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">     queue:(<span class="built_in">NSOperationQueue</span> *)queue</div><div class="line">     completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</div><div class="line">          [<span class="keyword">self</span> sendAsynchronousRequest:request</div><div class="line">               queue:queue</div><div class="line">               completionHandler:handler];</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          dispatch_group_enter(group);</div><div class="line">          [<span class="keyword">self</span> sendAsynchronousRequest:request</div><div class="line">                    queue:queue</div><div class="line">                    completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error)&#123;</div><div class="line">               handler(response, data, error);</div><div class="line">               dispatch_group_leave(group);</div><div class="line">          &#125;];</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意事项</p>
<ul>
<li>dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。</li>
<li>dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。</li>
<li>dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的</li>
</ul>
<h2 id="Dispatch-Block"><a href="#Dispatch-Block" class="headerlink" title="Dispatch Block"></a>Dispatch Block</h2><p>队列执行任务都是block的方式，</p>
<ul>
<li>创建block</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)createDispatchBlock &#123;</div><div class="line">    <span class="comment">//normal way</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_block_t block = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run block"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, block);</div><div class="line"></div><div class="line">    <span class="comment">//QOS way</span></div><div class="line">    dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(<span class="number">0</span>, QOS_CLASS_USER_INITIATED, <span class="number">-1</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run qos block"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, qosBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_wait：可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t block = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"star"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, block);</div><div class="line">    <span class="comment">//设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成</span></div><div class="line">    dispatch_block_wait(block, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ok, now can go on"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_notify：可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的block</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockNotifyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, firstBlock);</div><div class="line">    dispatch_block_t secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"second block run"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//first block执行完才在serial queue中执行second block</span></div><div class="line">    dispatch_block_notify(firstBlock, serialQueue, secondBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_cancel：iOS8后GCD支持对dispatch block的取消</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockCancelDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block end"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_block_t secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"second block run"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, firstBlock);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, secondBlock);</div><div class="line">    <span class="comment">//取消secondBlock</span></div><div class="line">    dispatch_block_cancel(secondBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用dispatch-block-object（调度块）在任务执行前进行取消"><a href="#使用dispatch-block-object（调度块）在任务执行前进行取消" class="headerlink" title="使用dispatch block object（调度块）在任务执行前进行取消"></a>使用dispatch block object（调度块）在任务执行前进行取消</h2><p>dispatch block object可以为队列中的对象设置<br>示例，下载图片中途进行取消<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">let</span> downloadGroup = dispatch_group_create()</div><div class="line">     <span class="keyword">var</span> addresses = [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line">     addresses += addresses + addresses <span class="comment">// 扩展address数组，复制3份</span></div><div class="line">     <span class="keyword">var</span> blocks: [dispatch_block_t] = [] <span class="comment">// 一个保存block的数组</span></div><div class="line"></div><div class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; addresses.<span class="built_in">count</span> &#123;</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> block = dispatch_block_create(<span class="type">DISPATCH_BLOCK_INHERIT_QOS_CLASS</span>) &#123; <span class="comment">// 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS</span></div><div class="line">               <span class="keyword">let</span> index = <span class="type">Int</span>(i)</div><div class="line">               <span class="keyword">let</span> address = addresses[index]</div><div class="line">               <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">               <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">                    image, error <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                         storedError = error</div><div class="line">                    &#125;</div><div class="line">                    dispatch_group_leave(downloadGroup)</div><div class="line">               &#125;</div><div class="line">               <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">          &#125;</div><div class="line">          blocks.append(block)</div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>, block) <span class="comment">// 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">for</span> block <span class="keyword">in</span> blocks[<span class="number">3</span> ..&lt; blocks.<span class="built_in">count</span>] &#123;</div><div class="line">          <span class="keyword">let</span> cancel = arc4random_uniform(<span class="number">2</span>) <span class="comment">// 随机返回一个整数，会返回0或1</span></div><div class="line">          <span class="keyword">if</span> cancel == <span class="number">1</span> &#123;</div><div class="line">               dispatch_block_cancel(block) <span class="comment">// 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。</span></div><div class="line">               dispatch_group_leave(downloadGroup) <span class="comment">// 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-IO-文件操作"><a href="#Dispatch-IO-文件操作" class="headerlink" title="Dispatch IO 文件操作"></a>Dispatch IO 文件操作</h2><p>dispatch io读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文件这样会比单线程要快很多。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 0-99 bytes*/</span>&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 100-199 bytes*/</span>&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 200-299 bytes*/</span>&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li>dispatch_io_create：创建dispatch io</li>
<li>dispatch_io_set_low_water：指定切割文件大小</li>
<li>dispatch_io_read：读取切割的文件然后合并。</li>
</ul>
<p>苹果系统日志API里用到了这个技术，可以在这里查看：<a href="https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c" target="_blank" rel="external">https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">pipe_q = dispatch_queue_create(<span class="string">"PipeQ"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//创建</span></div><div class="line">pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(<span class="keyword">int</span> err)&#123;</div><div class="line">    close(fd);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">*out_fd = fdpair[<span class="number">1</span>];</div><div class="line"><span class="comment">//设置切割大小</span></div><div class="line">dispatch_io_set_low_water(pipe_channel, SIZE_MAX);</div><div class="line"></div><div class="line">dispatch_io_read(pipe_channel, <span class="number">0</span>, SIZE_MAX, pipe_q, ^(<span class="keyword">bool</span> done, dispatch_data_t pipedata, <span class="keyword">int</span> err)&#123;</div><div class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        size_t len = dispatch_data_get_size(pipedata);</div><div class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//对每次切块数据的处理</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *bytes = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">char</span> *encoded;</div><div class="line">            uint32_t eval;</div><div class="line"></div><div class="line">            dispatch_data_t md = dispatch_data_create_map(pipedata, (<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;bytes, &amp;len);</div><div class="line">            encoded = asl_core_encode_buffer(bytes, len);</div><div class="line">            asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded);</div><div class="line">            free(encoded);</div><div class="line">            eval = _asl_evaluate_send(<span class="literal">NULL</span>, (aslmsg)aux, <span class="number">-1</span>);</div><div class="line">            _asl_send_message(<span class="literal">NULL</span>, eval, aux, <span class="literal">NULL</span>);</div><div class="line">            asl_msg_release(aux);</div><div class="line">            dispatch_release(md);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (done)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//semaphore +1使得不需要再等待继续执行下去。</span></div><div class="line">        dispatch_semaphore_signal(sem);</div><div class="line">        dispatch_release(pipe_channel);</div><div class="line">        dispatch_release(pipe_q);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Source-用GCD监视进程"><a href="#Dispatch-Source-用GCD监视进程" class="headerlink" title="Dispatch Source 用GCD监视进程"></a>Dispatch Source 用GCD监视进程</h2><p>Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:left">数据增加</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:left">数据OR</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:left">Mach端口发送</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:left">Mach端口接收</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</td>
<td style="text-align:left">内存情况</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:left">进程事件</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:left">读数据</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:left">信号</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:left">定时器</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:left">文件系统变化</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:left">文件写入</td>
</tr>
</tbody>
</table>
<p>方法</p>
<ul>
<li>dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。</li>
<li>dispatch_source_set_event_handler：设置事件处理handler</li>
<li>dispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。</li>
<li>dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSRunningApplication</span> *mail = [<span class="built_in">NSRunningApplication</span> runningApplicationsWithBundleIdentifier:<span class="string">@"com.apple.mail"</span>];</div><div class="line"><span class="keyword">if</span> (mail == <span class="literal">nil</span>) &#123;</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pid_t <span class="keyword">const</span> pid = mail.processIdentifier;</div><div class="line"><span class="keyword">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^()&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Mail quit."</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//在事件源传到你的事件处理前需要调用dispatch_resume()这个方法</span></div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure>
<p>监视文件夹内文件变化<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *directoryURL; <span class="comment">// assume this is set to a directory</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);</div><div class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">     <span class="keyword">char</span> buffer[<span class="number">80</span>];</div><div class="line">     strerror_r(errno, buffer, <span class="keyword">sizeof</span>(buffer));</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Unable to open \"%@\": %s (%d)"</span>, [directoryURL path], buffer, errno);</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,</div><div class="line">DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> data = dispatch_source_get_data(source);</div><div class="line">     <span class="keyword">if</span> (data &amp; DISPATCH_VNODE_WRITE) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"The directory changed."</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (data &amp; DISPATCH_VNODE_DELETE) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"The directory has been deleted."</span>);</div><div class="line">     &#125;</div><div class="line">&#125;);</div><div class="line">dispatch_source_set_cancel_handler(source, ^()&#123;</div><div class="line">     close(fd);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">self</span>.source = source;</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div><div class="line"><span class="comment">//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听</span></div></pre></td></tr></table></figure></p>
<p>NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,<span class="number">0</span>, <span class="number">0</span>, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Time flies."</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_time_t start</div><div class="line">dispatch_source_set_timer(source, DISPATCH_TIME_NOW, <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>,<span class="number">100</span>ull * <span class="built_in">NSEC_PER_MSEC</span>);</div><div class="line"><span class="keyword">self</span>.source = source;</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Semaphore和的介绍"><a href="#Dispatch-Semaphore和的介绍" class="headerlink" title="Dispatch Semaphore和的介绍"></a>Dispatch Semaphore和的介绍</h2><p>另外一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dispatch semaphore</span></div><div class="line">- (<span class="keyword">void</span>)dispatchSemaphoreDemo &#123;</div><div class="line">    <span class="comment">//创建semaphore</span></div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"semaphore +1"</span>);</div><div class="line">        dispatch_semaphore_signal(semaphore); <span class="comment">//+1 semaphore</span></div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"continue"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>这里简单介绍下iOS中常用的各种锁和他们的性能。</p>
<ul>
<li>NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。</li>
<li>NSDistributedLock：分布锁，基于文件方式的锁机制，可以跨进程访问。</li>
<li>NSConditionLock：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。</li>
<li>OSSpinLock：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用pthread_mutex较好。</li>
<li>pthread_mutex_t：同步锁基于C语言，底层api性能高，使用方法和其它的类似。</li>
<li>@synchronized：更加简单。</li>
</ul>
<h2 id="dispatch-suspend和dispatch-resume挂起和恢复队列"><a href="#dispatch-suspend和dispatch-resume挂起和恢复队列" class="headerlink" title="dispatch_suspend和dispatch_resume挂起和恢复队列"></a>dispatch_suspend和dispatch_resume挂起和恢复队列</h2><p>dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。</p>
<h2 id="dispatch-set-context和dispatch-get-context"><a href="#dispatch-set-context和dispatch-get-context" class="headerlink" title="dispatch_set_context和dispatch_get_context"></a>dispatch_set_context和dispatch_get_context</h2><h2 id="GCD深入操作"><a href="#GCD深入操作" class="headerlink" title="GCD深入操作"></a>GCD深入操作</h2><ul>
<li>缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域</li>
<li>I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close</li>
<li>测试：使用dispatch_benchmark小工具</li>
<li>原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。</li>
</ul>
<h2 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h2><p>当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)deadLockCase1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="comment">//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="comment">//3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase3 &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        <span class="comment">//串行队列里面同步一个串行队列就会死锁</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase4 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        <span class="comment">//将同步的串行队列放到另外一个线程就能够解决</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase5 &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">        <span class="comment">//回到主线程发现死循环后面就没法执行了</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    <span class="comment">//死循环</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="GCD实际使用"><a href="#GCD实际使用" class="headerlink" title="GCD实际使用"></a>GCD实际使用</h1><h2 id="FMDB如何使用dispatch-queue-set-specific和dispatch-get-specific来防止死锁"><a href="#FMDB如何使用dispatch-queue-set-specific和dispatch-get-specific来防止死锁" class="headerlink" title="FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁"></a>FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁</h2><p>作用类似objc_setAssociatedObject跟objc_getAssociatedObject<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;</div><div class="line"><span class="comment">//创建串行队列，所有数据库的操作都在这个队列里</span></div><div class="line">_queue = dispatch_queue_create([[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"fmdb.%@"</span>, <span class="keyword">self</span>] UTF8String], <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//标记队列</span></div><div class="line">dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">//检查是否是同一个队列来避免死锁的方法</span></div><div class="line">- (<span class="keyword">void</span>)inDatabase:(<span class="keyword">void</span> (^)(FMDatabase *db))block &#123;</div><div class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge <span class="keyword">id</span>)dispatch_get_specific(kDispatchQueueSpecificKey);</div><div class="line">    assert(currentSyncQueue != <span class="keyword">self</span> &amp;&amp; <span class="string">"inDatabase: was called reentrantly on the same queue, which would lead to a deadlock"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="iOS系统版本新特性"><a href="#iOS系统版本新特性" class="headerlink" title="iOS系统版本新特性"></a>iOS系统版本新特性</h1><h2 id="iOS8"><a href="#iOS8" class="headerlink" title="iOS8"></a>iOS8</h2><p>iOS8新加了一个功能叫Quality of Service(QoS)，里面提供了一下几个更容易理解的枚举名来使用user interactive，user initiated，utility和background。下面的表做了对比</p>
<table>
<thead>
<tr>
<th style="text-align:left">Global queue</th>
<th style="text-align:left">Corresponding QoS class</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Main thread</td>
<td style="text-align:left">NSQualityOfServiceUserInteractive</td>
<td style="text-align:left">UI相关，交互等</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_HIGH</td>
<td style="text-align:left">NSQualityOfServiceUserInitiated</td>
<td style="text-align:left">用户发起需要马上得到结果进行后续任务</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_DEFAULT</td>
<td style="text-align:left">NSQualityOfServiceDefault</td>
<td style="text-align:left">默认的不应该使用这个设置任务</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_LOW</td>
<td style="text-align:left">NSQualityOfServiceUtility</td>
<td style="text-align:left">花费时间稍多比如下载，需要几秒或几分钟的</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>
<td style="text-align:left">NSQualityOfServiceBackground</td>
<td style="text-align:left">不可见在后台的操作可能需要好几分钟甚至几小时的</td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h2><ul>
<li>Building Responsive and Efficient Apps with GCD：<a href="https://developer.apple.com/videos/play/wwdc2015-718/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-718/</a></li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li>官方文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="external">https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="戴铭">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/251980?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星光社 - 戴铭的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/03/deeply-analyse-autolayout/" itemprop="url">深入剖析Auto Layout，分析iOS各版本新增特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-03T21:17:54+08:00">
                2015-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先前写到的一篇Masonry心得文章里已经提到了很多AutoLayout相关的知识，这篇我会更加详细的对其知识要点进行分析和整理。</p>
<h1 id="来历"><a href="#来历" class="headerlink" title="来历"></a>来历</h1><p>一般大家都会认为Auto Layout这个东西是苹果自己搞出来的，其实不然，早在1997年Alan Borning, Kim Marriott, Peter Stuckey等人就发布了《Solving Linear Arithmetic Constraints for User Interface Applications》论文（论文地址：<a href="http://constraints.cs.washington.edu/solvers/uist97.html" target="_blank" rel="external">http://constraints.cs.washington.edu/solvers/uist97.html</a>）提出了在解决布局问题的Cassowary constraint-solving算法实现，并且将代码发布在他们搭建的Cassowary网站上<a href="http://constraints.cs.washington.edu/cassowary/" target="_blank" rel="external">http://constraints.cs.washington.edu/cassowary/</a>。后来更多开发者用各种语言来写Cassowary，比如说pybee用python写的<a href="https://github.com/pybee/cassowary" target="_blank" rel="external">https://github.com/pybee/cassowary</a>。自从它发布以来JavaScript，.NET，JAVA，Smalltall和C++都有相应的库。2011年苹果将这个算法运用到了自家的布局引擎中，美其名曰Auto Layout。</p>
<h2 id="Cassowary"><a href="#Cassowary" class="headerlink" title="Cassowary"></a>Cassowary</h2><p>Cassowary是个解析工具包，能够有效解析线性等式系统和线性不等式系统，用户的界面中总是会出现不等关系和相等关系，Cassowary开发了一种规则系统可以通过约束来描述视图间关系。约束就是规则，能够表示出一个视图相对于另一个视图的位置。</p>
<h1 id="Auto-Layout的生命周期"><a href="#Auto-Layout的生命周期" class="headerlink" title="Auto Layout的生命周期"></a>Auto Layout的生命周期</h1><p>进入下面主题前可以先介绍下加入Auto Layout的生命周期。在得到自己的layout之前Layout Engine会将Views，约束，Priorities（优先级），instrinsicContentSize（主要是UILabel,UIImageView等）通过计算转换成最终的效果。在Layout Engine里会有约束变化到Deferred Layout Pass再到应用Run Loop再回到约束变化这样的循环机制。</p>
<h2 id="约束变化"><a href="#约束变化" class="headerlink" title="约束变化"></a>约束变化</h2><p>触发约束变化包括</p>
<ul>
<li>Activating或Deactivating</li>
<li>设置constant或priority</li>
<li>添加和删除视图</li>
</ul>
<p>这个Engine遇到约束变化会重新计算layout，获取新值后会call它的superview.setNeedsLayout()</p>
<h2 id="Deferred-Layout-Pass"><a href="#Deferred-Layout-Pass" class="headerlink" title="Deferred Layout Pass"></a>Deferred Layout Pass</h2><p>在这个时候主要是做些容错处理，更新约束有些没有确定或者缺失布局声明的视图会在这里处理。接着从上而下调用layoutSubviews()来确定视图各个子视图的位置，这个过程实际上就是将subview的frame从layout engine里拷贝出来。这里要注意重写layoutSubviews()或者执行类似layoutIfNeeded这样可能会立刻唤起layoutSubviews()的方法，如果要这样做需要注意手动处理的这个地方自己的子视图布局的树状关系是否合理。</p>
<h2 id="生命周期中需要注意的事项"><a href="#生命周期中需要注意的事项" class="headerlink" title="生命周期中需要注意的事项"></a>生命周期中需要注意的事项</h2><ul>
<li>不要期望frame会立刻变化。</li>
<li>在重写layoutSubviews()时需要非常小心。</li>
</ul>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>Auto Layout你的视图层级里所有视图通过放置在它们里面的约束来动态计算的它们的大小和位置。一般控件需要四个约束决定位置大小，如果定义了intrinsicContentSize的比如UILabel只需要两个约束即可。</p>
<h2 id="约束方程式"><a href="#约束方程式" class="headerlink" title="约束方程式"></a>约束方程式</h2><p>view1.attribute1 = mutiplier * view2.attribute2 + constant</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redButton.left = <span class="number">1.0</span> * yellowLabel.right + <span class="number">10.0</span> <span class="comment">//红色按钮的左侧距离黄色label有10个point</span></div></pre></td></tr></table></figure>
<h2 id="使用API添加约束"><a href="#使用API添加约束" class="headerlink" title="使用API添加约束"></a>使用API添加约束</h2><p>使用NSLayoutConstraint类（最低支持iOS6）添加约束。NSLayoutConstraint官方参考：<a href="https://developer.apple.com/library/prerelease/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/index.html" target="_blank" rel="external">https://developer.apple.com/library/prerelease/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/index.html</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSLayoutContraint</span> constraintWithItem:view1</div><div class="line">                                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                               relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                    toItem:view2</div><div class="line">                                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                multiplier:<span class="number">1.0</span></div><div class="line">                                                 constant:<span class="number">-5</span>]</div></pre></td></tr></table></figure></p>
<p>把约束用约束中两个view的共同父视图或者两视图中层次高视图的- (void)addConstraint:(NSLayoutConstraint *)constraint方法将约束添加进去。</p>
<h2 id="使用VFL语言添加约束"><a href="#使用VFL语言添加约束" class="headerlink" title="使用VFL语言添加约束"></a>使用VFL语言添加约束</h2><p>先举个简单的例子并排两个view添加约束<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[NSLayoutConstraint constraintWithVisualFormat:@“[view1]-[view2]"</div><div class="line">                                                                  options:0</div><div class="line">                                                                  metrics:nil</div><div class="line">                                                                     views:viewsDictionary;</div></pre></td></tr></table></figure></p>
<p>viewDictionary可以通过NSDictionaryOfVariableBindings方法得到</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">viewsDictionary = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1,view2);</div></pre></td></tr></table></figure>
<h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>可以给这个位掩码传入NSLayoutFormatAlignAllTop使它们顶部对齐，这个值的默认值是NSLayoutFormatDirectionLeadingToTrailing从左到右。可以使用NSLayoutFormatAlignAllTop | NSLayoutFormatAlignAllBottom 表示两个视图的顶部和底部约束相同。</p>
<h3 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h3><p>这个参数作用是替换VFL语句中对应的值<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> viewFrame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1, view2);</div><div class="line"><span class="built_in">NSDictionary</span> *metrics = @&#123;<span class="string">@"left"</span>: @(<span class="built_in">CGRectGetMinX</span>(viewFrame)),</div><div class="line">                                           <span class="string">@"top"</span>: @(<span class="built_in">CGRectGetMinY</span>(viewFrame)),</div><div class="line">                                        <span class="string">@"width"</span>: @(<span class="built_in">CGRectGetWidth</span>(viewFrame)),</div><div class="line">                                       <span class="string">@"height"</span>: @(<span class="built_in">CGRectGetHeight</span>(viewFrame))&#125;;</div><div class="line">[view1 addConstraints:[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-left-[view(&gt;=width)]"</span> options:<span class="number">0</span> metrics:metrics views:views]];</div></pre></td></tr></table></figure></p>
<p>使用NSDictionaryOfVariableBindings(…)快速创建<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *left = @<span class="number">50</span>;</div><div class="line"><span class="built_in">NSNumber</span> *top = @<span class="number">50</span>;</div><div class="line"><span class="built_in">NSNumber</span> *width = @<span class="number">100</span>;</div><div class="line"><span class="built_in">NSNumber</span> *height = @<span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1, view2);</div><div class="line"><span class="built_in">NSDictionary</span> *metrics = <span class="built_in">NSDictionaryOfVariableBindings</span>(left, top, width, height);</div><div class="line"></div><div class="line">[view1 addConstraints:[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-left-[view(&gt;=width)]"</span> options:<span class="number">0</span> metrics:metrics views:views]];</div></pre></td></tr></table></figure></p>
<h3 id="VFL几个基本例子"><a href="#VFL几个基本例子" class="headerlink" title="VFL几个基本例子"></a>VFL几个基本例子</h3><ul>
<li>[view1(50)]-10-[view2(100)] 表示view1宽50，view2宽100，间隔10</li>
<li>[view1(&gt;=50@750)] 表示view1宽度大于50，约束条件优先级为750（优先级越大优先执行该约束，最大1000）</li>
<li>V:[view1][view2(==view1)] 表示按照竖直排，上面是view1下面是一个和它一样大的view2</li>
<li>H:|-[view1]-[view2]-[view3(&gt;=20)]-| 表示按照水平排列，|表示父视图，各个视图之间按照默认宽度来排列</li>
</ul>
<h2 id="VFL介绍"><a href="#VFL介绍" class="headerlink" title="VFL介绍"></a>VFL介绍</h2><p>无论使用哪种方法创建约束都是NSLayoutConstraint类的成员，每个约束都会在一个Objective-C对象中存储y = mx + b规则，然后通过Auto Layout引擎来表达该规则，VFL也不例外。VFL由一个描述布局的文字字符串组成，文本会指出间隔，不等量和优先级。官方对其的介绍：Visual Format Language <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html</a></p>
<h2 id="VFL的语法"><a href="#VFL的语法" class="headerlink" title="VFL的语法"></a>VFL的语法</h2><ul>
<li>标准间隔：[button]-[textField]</li>
<li>宽约束：[button(&gt;=50)]</li>
<li>与父视图的关系：|-50-[purpleBox]-50-|</li>
<li>垂直布局：V:[topField]-10-[bottomField]</li>
<li>Flush Views：[maroonView][buleView]</li>
<li>权重：[button(100@20)]</li>
<li>等宽：[button(==button2)]</li>
<li>Multiple Predicates：[flexibleButton(&gt;=70,&lt;=100)]</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>创建这种字符串时需要注意一下几点：</p>
<ul>
<li>H:和V:每次都使用一个。</li>
<li>视图变量名出现在方括号中，例如[view]。</li>
<li>字符串中顺序是按照从顶到底，从左到右</li>
<li>视图间隔以数字常量出现，例如-10-。</li>
<li>|表示父视图</li>
</ul>
<h1 id="使用Auto-Layout时需要注意的点"><a href="#使用Auto-Layout时需要注意的点" class="headerlink" title="使用Auto Layout时需要注意的点"></a>使用Auto Layout时需要注意的点</h1><ul>
<li>注意禁用Autoresizing Masks。对于每个需要使用Auto Layout的视图需要调用setTranslatesAutoresizingMaskIntoConstraints:NO</li>
<li>VFL语句里不能包含空格和&gt;，&lt;这样的约束</li>
<li>布局原理是由外向里布局，最先屏幕尺寸，再一层一层往里决定各个元素大小。</li>
<li>删除视图时直接使用removeConstraint和removeConstraints时需要注意这样删除是没法删除视图不支持的约束导致view中还包含着那个约束（使用第三方库时需要特别注意下）。解决这个的办法就是添加约束时用一个局部变量保存下，删除时进行比较删掉和先前那个，还有个办法就是设置标记，constraint.identifier = @“What you want to call”。</li>
</ul>
<h1 id="布局约束规则"><a href="#布局约束规则" class="headerlink" title="布局约束规则"></a>布局约束规则</h1><p>表达布局约束的规则可以使用一些简单的数学术语，如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图位置</td>
<td style="text-align:left">NSLayoutAttributeLeft, NSLayoutAttributeRight, NSLayoutAttributeTop, NSLayoutAttributeBottom</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图前面后面</td>
<td style="text-align:left">NSLayoutAttributeLeading, NSLayoutAttributeTrailing</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图的宽度和高度</td>
<td style="text-align:left">NSLayoutAttributeWidth, NSLayoutAttributeHeight</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图中心</td>
<td style="text-align:left">NSLayoutAttributeCenterX, NSLayoutAttributeCenterY</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图的基线，在视图底部上方放置文字的地方</td>
<td style="text-align:left">NSLayoutAttributeBaseline</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">占位符，在与另一个约束的关系中没有用到某个属性时可以使用占位符</td>
<td style="text-align:left">NSLayoutAttributeNotAnAttribute</td>
</tr>
<tr>
<td style="text-align:left">关系</td>
<td style="text-align:left">允许将属性通过等式和不等式相互关联</td>
<td style="text-align:left">NSLayoutRelationLessThanOrEqual, NSLayoutRelationEqual, NSLayoutRelationGreaterThanOrEqual</td>
</tr>
<tr>
<td style="text-align:left">数学运算</td>
<td style="text-align:left">每个约束的乘数和相加性常数</td>
<td style="text-align:left">CGFloat值</td>
</tr>
</tbody>
</table>
<h1 id="约束层级"><a href="#约束层级" class="headerlink" title="约束层级"></a>约束层级</h1><p>约束引用两视图时，这两个视图需要属于同一个视图层次结构，对于引用两个视图的约束只有两个情况是允许的。第一种是一个视图是另一个视图的父视图，第二个情况是两个视图在一个窗口下有一个非nil的共同父视图。</p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>哪个约束优先级高会先满足其约束，系统内置优先级枚举值UILayoutPriority<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="built_in">UILayoutPriorityRequired</span> = <span class="number">1000</span>, <span class="comment">//默认的优先级，意味着默认约束一旦冲突就会crash</span></div><div class="line">    <span class="built_in">UILayoutPriorityDefaultHigh</span> = <span class="number">750</span>,</div><div class="line">    <span class="built_in">UILayoutPriorityDefaultLow</span> = <span class="number">250</span>,</div><div class="line">    <span class="built_in">UILayoutPriorityFittingSizeLevel</span> = <span class="number">50</span>,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> <span class="built_in">UILayoutPriority</span>;</div></pre></td></tr></table></figure></p>
<h1 id="IntrinsicContentSize-Compression-Resistance-Priority-Hugging-Priority"><a href="#IntrinsicContentSize-Compression-Resistance-Priority-Hugging-Priority" class="headerlink" title="IntrinsicContentSize / Compression Resistance Priority / Hugging Priority"></a>IntrinsicContentSize / Compression Resistance Priority / Hugging Priority</h1><p>具有instrinsic content size的控件，比如UILabel，UIButton，选择控件，进度条和分段等等，可以自己计算自己的大小，比如label设置text和font后大小是可以计算得到的。这时可以通过设置Hugging priority让这些控件不要大于某个设定的值,默认优先级为250。设置Content Compression Resistance就是让控件不要小于某个设定的值，默认优先级为750。加这些值可以当作是加了个额外的约束值来约束宽。</p>
<h1 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h1><p>updateConstraints -&gt; layoutSubViews -&gt; drawRect</p>
<h2 id="viewDidLayoutSubviews，-layoutSubviews"><a href="#viewDidLayoutSubviews，-layoutSubviews" class="headerlink" title="viewDidLayoutSubviews，-layoutSubviews"></a>viewDidLayoutSubviews，-layoutSubviews</h2><p>使用Auto Layout的view会在viewDidLayoutSubviews或－layoutSubview调用super转换成具有正确显示的frame值。</p>
<h2 id="View的改变会调用哪些方法"><a href="#View的改变会调用哪些方法" class="headerlink" title="View的改变会调用哪些方法"></a>View的改变会调用哪些方法</h2><ul>
<li>改变frame.origin不会掉用layoutSubviews</li>
<li>改变frame.size会使 superVIew的layoutSubviews调用</li>
<li>改变bounds.origin和bounds.size都会调用superView和自己view的layoutSubviews方法</li>
</ul>
<h1 id="Auto-Layout的Debug"><a href="#Auto-Layout的Debug" class="headerlink" title="Auto Layout的Debug"></a>Auto Layout的Debug</h1><p>Auto Layout以下几种情况会出错</p>
<ul>
<li>Unsatisfiable Layouts：约束冲突，同一时刻约束没法同时满足。系统发现时会先检测那些冲突的约束，然后会一直拆掉冲突的约束再检查布局直到找到合适的布局，最后日志会将冲突的约束和拆掉的约束打印在控制台上。</li>
<li>Ambiguous Layouts：约束有缺失，比如说位置或者大小没有全指定到。还有种情况就是两个冲突的约束的权重是一样的就会崩。</li>
<li>Logical Errors：布局中的逻辑错误。</li>
<li>不含视图项的约束不合法，每个约束至少需要引用一个视图，不然会崩。在删除视图时一定要注意。<h2 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h2></li>
<li>po [[UIWindow keyWindow] _autolayoutTrace]<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>参考官方文档：<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html</a></li>
</ul>
<h1 id="容易出问题的Bug-Case"><a href="#容易出问题的Bug-Case" class="headerlink" title="容易出问题的Bug Case"></a>容易出问题的Bug Case</h1><ul>
<li>无共同父视图的视图之间相互添加约束会有问题。</li>
<li>调用了setNeedsLayout后不能通过frame改变视图和控件</li>
<li>为了让在设置了setTranslatesAutoresizingMaskIntoConstraints:NO视图里更改的frame立刻生效而执行了没有标记立刻刷新的layoutIfNeeded的方式是不可取的。</li>
</ul>
<h1 id="实践中碰到的非必现低配置机器崩溃bug分析"><a href="#实践中碰到的非必现低配置机器崩溃bug分析" class="headerlink" title="实践中碰到的非必现低配置机器崩溃bug分析"></a>实践中碰到的非必现低配置机器崩溃bug分析</h1><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>一个视图缺少高宽约束，在设置完了约束后执行layoutIfNeeded，然后设置宽高，这种情况在低配机器上可能会出现崩问题。原因在于layoutIfNeeded需要有标记才会立刻调用layoutSubview得到宽高，不然是不会马上调用的。页面第一次显示是会自动标记上需要刷新这个标记的，所以第一次看显示都是看不出问题的，但页面再次调用layoutIfNeeded时是不会立刻执行layoutSubview的（但之前加上setNeedsLayout就会立刻执行），这时改变的宽高值会在上文生命周期中提到的Auto Layout Cycle中的Engine里的Deferred Layout Pass里执行layoutSubview，手动设置的layoutIfNeeded也会执行一遍layoutSubview，但是这个如果发生在Deferred Layout Pass之后就会出现崩的问题，因为当视图设置为setTranslatesAutoresizingMaskIntoConstraints:NO时会严格按照约束-&gt;Engine-&gt;显示这种流程，如在Deferred Layout Pass之前设置好是没有问题的，之后强制执行LayoutSubview会产生一个权重和先前一样的约束在类似动画block里更新布局让Engine执行导致Ambiguous Layouts这种权重相同冲突崩溃的情况发生。</p>
<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p>将多个有相互约束关系视图removeFromSuperView后更新布局在低配机器上出现崩的问题。这个原因主要是根据不含视图项的约束不合法这个原则来的，同时会抛出野指针的错误。在内存吃紧机器上，当应用占内存较多系统会抓住任何可以释放heap区内存的机会视图被移除后会立刻被清空，这时约束如果还没有被释就满足不含视图项的约束会崩的情况了。</p>
<h1 id="推荐Auto-Layout第三方库"><a href="#推荐Auto-Layout第三方库" class="headerlink" title="推荐Auto Layout第三方库"></a>推荐Auto Layout第三方库</h1><h2 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h2><p>Github地址：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">https://github.com/SnapKit/Masonry</a></p>
<h2 id="Cartography"><a href="#Cartography" class="headerlink" title="Cartography"></a>Cartography</h2><p>Github地址：<a href="https://github.com/robb/Cartography" target="_blank" rel="external">https://github.com/robb/Cartography</a></p>
<h1 id="Masonry-1"><a href="#Masonry-1" class="headerlink" title="Masonry"></a>Masonry</h1><p>可以参看我上篇文章《AutoLayout框架Masonry使用心得》:<a href="http://www.starming.com/index.php?v=index&amp;view=81" target="_blank" rel="external">http://www.starming.com/index.php?v=index&amp;view=81</a></p>
<h1 id="各版本iOS中AutoLayout的区别"><a href="#各版本iOS中AutoLayout的区别" class="headerlink" title="各版本iOS中AutoLayout的区别"></a>各版本iOS中AutoLayout的区别</h1><p>完整记录可以到官方网站进行核对和查找：What’s New in iOS <a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html</a></p>
<h2 id="iOS6"><a href="#iOS6" class="headerlink" title="iOS6"></a>iOS6</h2><p>苹果在这个版本引入Auto Layout，具备了所有核心功能。</p>
<h2 id="iOS7"><a href="#iOS7" class="headerlink" title="iOS7"></a>iOS7</h2><ul>
<li>NavigationBar,TabBar和ToolBar的translucent属性默认为YES，当前ViewController的高度是整个屏幕的高度，为了确保不被这些Bar覆盖可以在布局中使用topLayoutGuide和bottomLayoutGuide属性。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:[topLayoutGuide]-[view1]"</span> options:<span class="number">0</span> metrics:<span class="literal">nil</span> views:view2];</div></pre></td></tr></table></figure>
<h2 id="iOS8"><a href="#iOS8" class="headerlink" title="iOS8"></a>iOS8</h2><ul>
<li>Self Sizing Cells <a href="http://www.appcoda.com/self-sizing-cells/" target="_blank" rel="external">http://www.appcoda.com/self-sizing-cells/</a></li>
<li>UIViewController新增两个方法，用来处理UITraitEnvironment协议，UIKit里有UIScreen，UIViewController，UIView和UIPresentationController支持这个协议，当视图traitCollection改变时UIViewController时可以捕获到这个消息进行处理的。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setOverrideTraitCollection:(<span class="built_in">UITraitCollection</span> *)collection forChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="built_in">UITraitCollection</span> *)overrideTraitCollectionForChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure>
<ul>
<li>Size Class的出现UIViewController提供了一组新协议来支持UIContentContainer</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)systemLayoutFittingSizeDidChangeForChildContentContainer:(<span class="keyword">id</span> )container <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="built_in">CGSize</span>)sizeForChildContentContainer:(<span class="keyword">id</span> )container withParentContainerSize:(<span class="built_in">CGSize</span>)parentSize <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)willTransitionToTraitCollection:(<span class="built_in">UITraitCollection</span> *)newCollection withTransitionCoordinator:(<span class="keyword">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure>
<ul>
<li>UIView的Margin新增了3个API，NSLayoutMargins可以定义view之间的距离，这个只对Auto Layout有效，并且默认值为{8,8,8,8}。NSLayoutAttribute的枚举值也有相应的更新</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UIView的3个Margin相关API</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIEdgeInsets</span> layoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> preservesSuperviewLayoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)layoutMarginsDidChange <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">//NSLayoutAttribute的枚举值更新</span></div><div class="line"><span class="built_in">NSLayoutAttributeLeftMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeRightMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeTopMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeBottomMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeLeadingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeTrailingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeCenterXWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeCenterYWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div></pre></td></tr></table></figure>
<h2 id="iOS9"><a href="#iOS9" class="headerlink" title="iOS9"></a>iOS9</h2><h3 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h3><p>苹果一直希望能够让更多的人来用Auto Layout，除了弄出一个VFL现在又弄出一个不需要约束的方法，使用Stack view使大家使用Auto Layout时不用触碰到约束，官方口号是“Start with Stack View, use constraints as needed”。 更多细节可以查看官方介绍：UIKit Framework Reference  UIStackView Class Reference<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html</a></p>
<p>Stack Views ：<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html</a></p>
<p>Stack View提供了更加简便的自动布局方法比如Alignment的Fill，Leading，Center，Trailing。Distribution的Fill，Fill Equally，Fill Proportionally，Equal Spacing。</p>
<p>如果希望在iOS9之前的系统也能够使用Stack view可以用sunnyxx的FDStackView<a href="https://github.com/forkingdog/FDStackView" target="_blank" rel="external">https://github.com/forkingdog/FDStackView</a>，利用运行时替换元素的方法来支持iOS6+系统。</p>
<h3 id="NSLayoutAnchorAPI"><a href="#NSLayoutAnchorAPI" class="headerlink" title="NSLayoutAnchorAPI"></a>NSLayoutAnchorAPI</h3><p>新增这个API能够让约束的声明更加清晰，还能够通过静态类型检查确保约束的正常工作。具体可以查看官方文档<a href="https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLayoutConstraint</span> *constraint = [view1.leadingAnchor constraintEqualToAnchor:view2.topAnchor];</div></pre></td></tr></table></figure></p>
<h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul>
<li>Auto Layout Guide <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/index.html</a></li>
<li>UIScrollView And Autolayout <a href="https://developer.apple.com/library/ios/technotes/tn2154/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/technotes/tn2154/_index.html</a></li>
<li>IB中使用Auto Layout：Auto Layout Help <a href="https://developer.apple.com/library/ios/recipes/xcode_help-IB_auto_layout/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/recipes/xcode_help-IB_auto_layout/_index.html</a></li>
<li>What’s New in iOS <a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html</a></li>
</ul>
<h2 id="WWDC视频"><a href="#WWDC视频" class="headerlink" title="WWDC视频"></a>WWDC视频</h2><ul>
<li>WWDC 2012: Introduction to Auto Layout for iOS and OS X <a href="https://developer.apple.com/videos/wwdc/2012/?id=202" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=202</a></li>
<li>WWDC 2012: Introducing Collection Views <a href="https://developer.apple.com/videos/play/wwdc2012-205/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2012-205/</a></li>
<li>WWDC 2012: Advanced Collection Views and Building Custom Layouts <a href="https://developer.apple.com/videos/play/wwdc2012-219" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2012-219</a></li>
<li>WWDC 2012: Best Practices for Mastering Auto Layout <a href="https://developer.apple.com/videos/wwdc/2012/?id=228" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=228</a></li>
<li>WWDC 2012: Auto Layout by Example <a href="https://developer.apple.com/videos/wwdc/2012/?id=232" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=232</a></li>
<li>WWDC 2013: Interface Builder Core Concepts <a href="https://developer.apple.com/videos/play/wwdc2013-405" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2013-405</a></li>
<li>WWDC 2013: Taking Control of Auto Layout in Xcode 5 <a href="https://developer.apple.com/videos/wwdc/2013/?id=406" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2013/?id=406</a></li>
<li>WWDC 2015: Mysteries of Auto Layout, Part 1 内容包含了Auto Layout更高封装stack view的介绍 <a href="https://developer.apple.com/videos/play/wwdc2015-218/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-218/</a></li>
<li>WWDC 2015: Mysteries of Auto Layout, Part 2 包含Auto Layout生命周期和调试Auto Layout的一些方法介绍<a href="https://developer.apple.com/videos/play/wwdc2015-219/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-219/</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ming1016.github.io/2015/04/01/objc-runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="戴铭">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/251980?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星光社 - 戴铭的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/01/objc-runtime/" itemprop="url">Objc Runtime 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-01T20:24:27+08:00">
                2015-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。Runtime是C和汇编编写的，这里<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="external">http://www.opensource.apple.com/source/objc4/</a>可以下到苹果维护的开源代码，GNU也有一个开源的runtime版本，他们都努力的保持一致。<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">苹果官方的Runtime编程指南</a></p>
<h2 id="Runtime函数"><a href="#Runtime函数" class="headerlink" title="Runtime函数"></a>Runtime函数</h2><p>Runtime系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/usr/include/objc目录下可以看到头文件，可以用其中一些函数通过C语言实现objectivec中一样的功能。苹果官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html</a> 里有详细的Runtime函数文档。</p>
<h1 id="Class和Object基础数据结构"><a href="#Class和Object基础数据结构" class="headerlink" title="Class和Object基础数据结构"></a>Class和Object基础数据结构</h1><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>objc/runtime.h中objc_class结构体的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">Class isa OBJC_ISA_AVAILABILITY; <span class="comment">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">Class super_class OBJC2_UNAVAILABLE; <span class="comment">// 父类</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></div><div class="line"><span class="keyword">long</span> version OBJC2_UNAVAILABLE; <span class="comment">// 类的版本信息，默认为0</span></div><div class="line"><span class="keyword">long</span> info OBJC2_UNAVAILABLE; <span class="comment">// 类信息，供运行期使用的一些位标识</span></div><div class="line"><span class="keyword">long</span> instance_size OBJC2_UNAVAILABLE; <span class="comment">// 该类的实例变量大小</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 该类的成员变量链表</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法定义的链表</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 协议链表</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>objc_ivar_list和objc_method_list的定义<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//objc_ivar_list结构体存储objc_ivar数组列表</span></div><div class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</div><div class="line">     <span class="keyword">int</span> ivar_count OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">     <span class="keyword">int</span> space OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">     <span class="comment">/* variable length structure */</span></div><div class="line">     <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>] OBJC2_UNAVAILABLE;</div><div class="line">&#125; OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line"><span class="comment">//objc_method_list结构体存储着objc_method的数组列表</span></div><div class="line"><span class="keyword">struct</span> objc_method_list &#123;</div><div class="line">     <span class="keyword">struct</span> objc_method_list *obsolete OBJC2_UNAVAILABLE;</div><div class="line">     <span class="keyword">int</span> method_count OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">     <span class="keyword">int</span> space OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">     <span class="comment">/* variable length structure */</span></div><div class="line">     <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>] OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="objc-object与id"><a href="#objc-object与id" class="headerlink" title="objc_object与id"></a>objc_object与id</h2><p>objc_object是一个类的实例结构体，objc/objc.h中objc_object是一个类的实例结构体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></div><div class="line">Class isa OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></div></pre></td></tr></table></figure></p>
<p>向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。</p>
<h2 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h2><p>objc_class结构体中的cache字段用于缓存调用过的method。cache指针指向objc_cache结构体，这个结构体的定义如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> &#123;</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span> OBJC2_UNAVAILABLE; <span class="comment">//指定分配缓存bucket的总数。runtime使用这个字段确定线性查找数组的索引位置</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> occupied OBJC2_UNAVAILABLE; <span class="comment">//实际占用缓存bucket总数</span></div><div class="line">Method buckets[<span class="number">1</span>] OBJC2_UNAVAILABLE; <span class="comment">//指向Method数据结构指针的数组，这个数组的总数不能超过mask+1，但是指针是可能为空的，这就表示缓存bucket没有被占用，数组会随着时间增长。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="Meta-Class"><a href="#Meta-Class" class="headerlink" title="Meta Class"></a>Meta Class</h2><p>meta class是一个类对象的类，当向对象发消息，runtime会在这个对象所属类方法列表中查找发送消息对应的方法，但当向类发送消息时，runtime就会在这个类的meta class方法列表里查找。所有的meta class，包括Root class，Superclass，Subclass的isa都指向Root class的meta class，这样能够形成一个闭环。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> TestMetaClass(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line"></div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"This objcet is %p"</span>, <span class="keyword">self</span>);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Class is %@, super class is %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</div><div class="line"></div><div class="line">     Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">     <span class="comment">//</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Following the isa pointer %d times gives %p"</span>, i, currentClass);</div><div class="line">          <span class="comment">//通过objc_getClass获得对象isa，这样可以回溯到Root class及NSObject的meta class，可以看到最后指针指向的是0x0和NSObject的meta class类地址一样。</span></div><div class="line">          currentClass = objc_getClass((__bridge <span class="keyword">void</span> *)currentClass);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"NSObject's class is %p"</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"NSObject's meta class is %p"</span>, objc_getClass((__bridge <span class="keyword">void</span> *)[<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">void</span>)ex_registerClassPair &#123;</div><div class="line"></div><div class="line">     Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> <span class="keyword">class</span>], <span class="string">"TestClass"</span>, <span class="number">0</span>);</div><div class="line">     class_addMethod(newClass, <span class="keyword">@selector</span>(testMetaClass), (IMP)TestMetaClass, <span class="string">"v@:"</span>);</div><div class="line">     objc_registerClassPair(newClass);</div><div class="line"></div><div class="line">     <span class="keyword">id</span> instance = [[newClass alloc] initWithDomain:<span class="string">@"some domain"</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</div><div class="line">     [instance performSelector:<span class="keyword">@selector</span>(testMetaClass)];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] NSObject's class is 0xe10000</div><div class="line">2014-10-20 22:57:07.354 mountain[1303:41490] NSObject's meta class is 0x0</div></pre></td></tr></table></figure></p>
<p>举个例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          <span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isKindOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isMemberOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%d %d %d %d"</span>, res1, res2, res3, res4);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">45</span>:<span class="number">08.474</span> Test[<span class="number">9412</span>:<span class="number">721945</span>] <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>先看看isKindOfClass和isMemberOfClass在Object.mm中的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isKindOf:aClass</div><div class="line">&#123;</div><div class="line">     Class cls;</div><div class="line">     <span class="keyword">for</span> (cls = isa; cls; cls = cls-&gt;superclass)</div><div class="line">          <span class="keyword">if</span> (cls == (Class)aClass)</div><div class="line">               <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">     <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)isMemberOf:aClass</div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> isa == (Class)aClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>res1中，可以从isKindOfClass看出NSObject class的isa第一次会指向NSObject的Meta Class，接着Super class时会NSObject的Meta Class根据前面讲的闭环可以知道是会指到NSObject class，这样res1的bool值就是真了。</p>
<p>res2的话因为是isMemberOf就只有一次，那么是NSObject的Meta Class和NSObject class不同返回的bool值就是false了。</p>
<p>res3第一次是Sark Meta Class，第二次super class 后就是NSObject Meta Class了，返回也是false</p>
<p>res4是Sark Meta Class，所以返回也是false</p>
<h1 id="类与对象操作函数"><a href="#类与对象操作函数" class="headerlink" title="类与对象操作函数"></a>类与对象操作函数</h1><p>runtime有很多的函数可以操作类和对象。类相关的是class为前缀，对象相关操作是objc或object_为前缀。</p>
<h2 id="类相关操作函数"><a href="#类相关操作函数" class="headerlink" title="类相关操作函数"></a>类相关操作函数</h2><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</div></pre></td></tr></table></figure>
<h3 id="super-class和meta-class"><a href="#super-class和meta-class" class="headerlink" title="super_class和meta-class"></a>super_class和meta-class</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类的父类</span></div><div class="line">Class class_getSuperclass ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 判断给定的Class是否是一个meta class</span></div><div class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</div></pre></td></tr></table></figure>
<h3 id="instance-size"><a href="#instance-size" class="headerlink" title="instance_size"></a>instance_size</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取实例大小</span></div><div class="line">size_t class_getInstanceSize ( Class cls );</div></pre></td></tr></table></figure>
<h3 id="成员变量-ivars-及属性"><a href="#成员变量-ivars-及属性" class="headerlink" title="成员变量(ivars)及属性"></a>成员变量(ivars)及属性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//成员变量操作函数</span></div><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types ); <span class="comment">//这个只能够向在runtime时创建的类添加成员变量</span></div><div class="line"></div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount ); <span class="comment">//必须使用free()来释放这个数组</span></div><div class="line"></div><div class="line"><span class="comment">//属性操作函数</span></div><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"></div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<h3 id="methodLists"><a href="#methodLists" class="headerlink" title="methodLists"></a>methodLists</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加方法</span></div><div class="line"><span class="built_in">BOOL</span> class_addMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types ); <span class="comment">//和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation</span></div><div class="line"></div><div class="line"><span class="comment">// 获取实例方法</span></div><div class="line">Method class_getInstanceMethod ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 获取类方法</span></div><div class="line">Method class_getClassMethod ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 获取所有方法的数组</span></div><div class="line">Method * class_copyMethodList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 替代方法的实现</span></div><div class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"></div><div class="line"><span class="comment">// 返回方法的具体实现</span></div><div class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</div><div class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 类实例是否响应指定的selector</span></div><div class="line"><span class="built_in">BOOL</span> class_respondsToSelector ( Class cls, SEL sel );</div></pre></td></tr></table></figure>
<h3 id="objc-protocol-list"><a href="#objc-protocol-list" class="headerlink" title="objc_protocol_list"></a>objc_protocol_list</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加协议</span></div><div class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</div><div class="line"></div><div class="line"><span class="comment">// 返回类是否实现指定的协议</span></div><div class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</div><div class="line"></div><div class="line"><span class="comment">// 返回类实现的协议列表</span></div><div class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取版本号</span></div><div class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 设置版本号</span></div><div class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</div></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>通过实例来消化下上面的那些函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// MyClass.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</div><div class="line">- (<span class="keyword">void</span>)method1;</div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line">+ (<span class="keyword">void</span>)classMethod1;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// MyClass.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</div><div class="line"><span class="built_in">NSInteger</span> _instance1;</div><div class="line"><span class="built_in">NSString</span> * _instance2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> integer;</div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"call method method1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"arg1 : %ld, arg2 : %@"</span>, arg1, arg2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// main.h</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"MySubClass.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          MyClass *myClass = [[MyClass alloc] init];</div><div class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">          Class cls = myClass.class;</div><div class="line">          <span class="comment">// 类名</span></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));    </div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 父类</span></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"super class name: %s"</span>, class_getName(class_getSuperclass(cls)));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 是否是元类</span></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ a meta-class"</span>, (class_isMetaClass(cls) ? <span class="string">@""</span> : <span class="string">@"not"</span>));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          Class meta_class = objc_getMetaClass(class_getName(cls));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%s's meta-class is %s"</span>, class_getName(cls), class_getName(meta_class));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 变量实例大小</span></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"instance size: %zu"</span>, class_getInstanceSize(cls));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 成员变量</span></div><div class="line">          Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">               Ivar ivar = ivars[i];</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"instance variable's name: %s at index: %d"</span>, ivar_getName(ivar), i);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          free(ivars);</div><div class="line"></div><div class="line">          Ivar string = class_getInstanceVariable(cls, <span class="string">"_string"</span>);</div><div class="line">          <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"instace variable %s"</span>, ivar_getName(string));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 属性操作</span></div><div class="line">          objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">               objc_property_t property = properties[i];</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"property's name: %s"</span>, property_getName(property));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          free(properties);</div><div class="line"></div><div class="line">          objc_property_t array = class_getProperty(cls, <span class="string">"array"</span>);</div><div class="line">          <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"property %s"</span>, property_getName(array));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 方法操作</span></div><div class="line">          Method *methods = class_copyMethodList(cls, &amp;outCount);</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">               Method method = methods[i];</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"method's signature: %s"</span>, method_getName(method));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          free(methods);</div><div class="line"></div><div class="line">          Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">          <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"method %s"</span>, method_getName(method1));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</div><div class="line">          <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"class method : %s"</span>, method_getName(classMethod));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"MyClass is%@ responsd to selector: method3WithArg1:arg2:"</span>, class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:)) ? <span class="string">@""</span> : <span class="string">@" not"</span>);</div><div class="line"></div><div class="line">          IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">          imp();</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 协议</span></div><div class="line">          Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</div><div class="line">          Protocol * protocol;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">               protocol = protocols[i];</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"protocol name: %s"</span>, protocol_getName(protocol));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"MyClass is%@ responsed to protocol %s"</span>, class_conformsToProtocol(cls, protocol) ? <span class="string">@""</span> : <span class="string">@" not"</span>, protocol_getName(protocol));</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">2014-10-22 19:41:37.452 RuntimeTest[3189:156810] class name: MyClass</div><div class="line">2014-10-22 19:41:37.453 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] super class name: NSObject</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass is not a meta-class</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass's meta-class is MyClass</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 48</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance1 at index: 0</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance2 at index: 1</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _array at index: 2</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _string at index: 3</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable's name: _integer at index: 4</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instace variable _string</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: array</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: string</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property's name: integer</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method1</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method2</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method3WithArg1:arg2:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: integer</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setInteger:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: array</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: string</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setString:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setArray:</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method's signature: .cxx_destruct</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method method1</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] class method : classMethod1</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] MyClass is responsd to selector: method3WithArg1:arg2:</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] call method method1</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCopying</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCoding</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] MyClass is responsed to protocol NSCoding</div><div class="line">2014-10-22 19:41:37.468 RuntimeTest[3189:156810] ======================================</div></pre></td></tr></table></figure></p>
<h2 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h2><h3 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个新类和元类</span></div><div class="line">Class objc_allocateClassPair ( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes ); <span class="comment">//如果创建的是root class，则superclass为Nil。extraBytes通常为0</span></div><div class="line"></div><div class="line"><span class="comment">// 销毁一个类及其相关联的类</span></div><div class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls ); <span class="comment">//在运行中还存在或存在子类实例，就不能够调用这个。</span></div><div class="line"></div><div class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></div><div class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls ); <span class="comment">//创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。</span></div></pre></td></tr></table></figure>
<p>使用实例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>);</div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_addIvar(cls, <span class="string">"_ivar1"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">"i"</span>);</div><div class="line"></div><div class="line">objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</div><div class="line">objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</div><div class="line">objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</div><div class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class="line"></div><div class="line">class_addProperty(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>);</div><div class="line">objc_registerClassPair(cls);</div><div class="line"></div><div class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></div></pre></td></tr></table></figure></p>
<h3 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建类实例</span></div><div class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes ); <span class="comment">//会在heap里给类分配内存。这个方法和+alloc方法类似。</span></div><div class="line"></div><div class="line"><span class="comment">// 在指定位置创建类实例</span></div><div class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes ); </div><div class="line"></div><div class="line"><span class="comment">// 销毁类实例</span></div><div class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj ); <span class="comment">//不会释放移除任何相关引用</span></div></pre></td></tr></table></figure>
<p>测试下效果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//可以看出class_createInstance和alloc的不同</span></div><div class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line"><span class="keyword">id</span> str1 = [theObject init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</div><div class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</div></pre></td></tr></table></figure></p>
<h2 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h2><p>这些函数是针对创建的实例对象的一系列操作函数。</p>
<h3 id="整个对象操作的函数"><a href="#整个对象操作的函数" class="headerlink" title="整个对象操作的函数"></a>整个对象操作的函数</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回指定对象的一份拷贝</span></div><div class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</div><div class="line"><span class="comment">// 释放指定对象占用的内存</span></div><div class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure>
<p>应用场景<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//把a转换成占用更多空间的子类b</span></div><div class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</div><div class="line">object_setClass(newB, MyClass.class);</div><div class="line">object_dispose(a);</div></pre></td></tr></table></figure></p>
<h3 id="对象实例变量进行操作的函数"><a href="#对象实例变量进行操作的函数" class="headerlink" title="对象实例变量进行操作的函数"></a>对象实例变量进行操作的函数</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 修改类实例的实例变量的值</span></div><div class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</div><div class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></div><div class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象中实例变量的值</span></div><div class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</div><div class="line"><span class="comment">// 设置对象中实例变量的值</span></div><div class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</div></pre></td></tr></table></figure>
<h3 id="对对象类操作"><a href="#对对象类操作" class="headerlink" title="对对象类操作"></a>对对象类操作</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回给定对象的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象的类</span></div><div class="line">Class object_getClass ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 设置对象的类</span></div><div class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</div></pre></td></tr></table></figure>
<h2 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取已注册的类定义的列表</span></div><div class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</div><div class="line"></div><div class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></div><div class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的类定义</span></div><div class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的元类</span></div><div class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure>
<p>演示如何使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> numClasses;</div><div class="line">Class * classes = <span class="literal">NULL</span>;</div><div class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</div><div class="line">     classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</div><div class="line">     numClasses = objc_getClassList(classes, numClasses);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"number of classes: %d"</span>, numClasses);</div><div class="line"></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</div><div class="line">          Class cls = classes[i];</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));</div><div class="line">     &#125;</div><div class="line">     free(classes);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] number of classes: <span class="number">1282</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: DDTokenRegexp</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _PFRoutines</div><div class="line">......还有大量输出</div></pre></td></tr></table></figure></p>
<h1 id="成员变量与属性"><a href="#成员变量与属性" class="headerlink" title="成员变量与属性"></a>成员变量与属性</h1><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p>实例变量类型，指向objc_ivar结构体的指针，ivar指针地址是根据class结构体的地址加上基地址偏移字节得到的。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line"><span class="keyword">char</span> *ivar_name OBJC2_UNAVAILABLE; <span class="comment">// 变量名</span></div><div class="line"><span class="keyword">char</span> *ivar_type OBJC2_UNAVAILABLE; <span class="comment">// 变量类型</span></div><div class="line"><span class="keyword">int</span> ivar_offset OBJC2_UNAVAILABLE; <span class="comment">// 基地址偏移字节</span></div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line"><span class="keyword">int</span> space OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h3><p>属性类型，指向objc_property结构体<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</div></pre></td></tr></table></figure></p>
<p>通过class_copyPropertyList和protocol_copyPropertyList方法获取类和协议的属性<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div></pre></td></tr></table></figure></p>
<p>示例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">     <span class="keyword">float</span> alone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@property</span> <span class="keyword">float</span> alone;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//获取属性列表</span></div><div class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</div><div class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</div><div class="line"></div><div class="line"><span class="comment">//查找属性名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property)</div><div class="line"></div><div class="line"><span class="comment">//通过给出的名称来在类和协议中获取属性的引用</span></div><div class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">objc_property_t protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</div><div class="line"></div><div class="line"><span class="comment">//发掘属性名称和@encode类型字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</div><div class="line"></div><div class="line"><span class="comment">//从一个类中获取它的属性</span></div><div class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</div><div class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">     objc_property_t property = properties[i];</div><div class="line">     fprintf(stdout, <span class="string">"%s %s\n"</span>, property_getName(property), property_getAttributes(property));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="objc-property-attribute-t"><a href="#objc-property-attribute-t" class="headerlink" title="objc_property_attribute_t"></a>objc_property_attribute_t</h3><p>也是结构体，定义属性的attribute<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 特性名</span></div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *value; <span class="comment">// 特性值</span></div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面代码会编译出错，Runtime Crash还是正常输出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></div><div class="line">- (<span class="keyword">void</span>)speak</div><div class="line">&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"my name is %@"</span>, <span class="keyword">self</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">          <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</div><div class="line">          <span class="keyword">void</span> *obj = &amp;cls;</div><div class="line">          [(__bridge <span class="keyword">id</span>)obj speak];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          [[Test alloc] init];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//结果正常输出</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-07</span> <span class="number">14</span>:<span class="number">08</span>:<span class="number">25.698</span> Test[<span class="number">1097</span>:<span class="number">57255</span>] my name is</div></pre></td></tr></table></figure></p>
<p>obj为指向Sark Class的指针，相当于Sark的实例对象但是还是不一样，根据objc_msgSend流程，obj指针能够在方法列表中找到speak方法，所以运行正常。</p>
<p>为了得到self.name能够输出的原因，可以加入调试代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)speak</div><div class="line">&#123;</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfIvars = <span class="number">0</span>;</div><div class="line">     Ivar *ivars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;numberOfIvars);</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">const</span> Ivar *p = ivars; p &lt; ivars+numberOfIvars; p++) &#123;</div><div class="line">          Ivar <span class="keyword">const</span> ivar = *p;</div><div class="line">          ptrdiff_t offset = ivar_getOffset(ivar);</div><div class="line">          <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Sark ivar name = %s, offset = %td"</span>, name, offset);</div><div class="line">     &#125;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"my name is %p"</span>, &amp;_name);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"my name is %@"</span>, *(&amp;_name));</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Test instance = %@"</span>, <span class="keyword">self</span>);</div><div class="line">          <span class="keyword">void</span> *self2 = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Test instance pointer = %p"</span>, &amp;self2);</div><div class="line">          <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Class instance address = %p"</span>, cls);</div><div class="line">          <span class="keyword">void</span> *obj = &amp;cls;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Void *obj = %@"</span>, obj);</div><div class="line">          [(__bridge <span class="keyword">id</span>)obj speak];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.464</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Test instance = <span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.464</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Test instance pointer = <span class="number">0x7fff5fbff7c8</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Class instance address = <span class="number">0x1000023c8</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Void *obj = <span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Sark ivar name = _name, offset = <span class="number">8</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] my name is <span class="number">0x7fff5fbff7c8</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] my name is</div></pre></td></tr></table></figure></p>
<p>Sark中Propertyname会被转换成ivar到类的结构里，runtime会计算ivar的地址偏移来找ivar的最终地址，根据输出可以看出Sark class的指针地址加上ivar的偏移量正好跟Test对象指针地址。</p>
<h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>关联对象是在运行时添加的类似成员。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将一个对象连接到其它对象</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> myKey;</div><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</div><div class="line"><span class="comment">//获取一个新的关联的对象</span></div><div class="line"><span class="keyword">id</span> anObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;myKey);</div><div class="line"><span class="comment">//使用objc_removeAssociatedObjects函数移除一个关联对象</span></div></pre></td></tr></table></figure></p>
<p>实例演示关联对象使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//动态的将一个Tap手势操作连接到任何UIView中。</span></div><div class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block</div><div class="line">&#123;</div><div class="line">     <span class="built_in">UITapGestureRecognizer</span> *gesture = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey);</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!gesture)</div><div class="line">     &#123;</div><div class="line">          gesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(__handleActionForTapGesture:)];</div><div class="line">          [<span class="keyword">self</span> addGestureRecognizer:gesture];</div><div class="line">          <span class="comment">//将创建的手势对象和block作为关联对象</span></div><div class="line">          objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//手势识别对象的target和action</span></div><div class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(<span class="built_in">UITapGestureRecognizer</span> *)gesture</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (gesture.state == <span class="built_in">UIGestureRecognizerStateRecognized</span>)</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">void</span>(^action)(<span class="keyword">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (action)</div><div class="line">          &#123;</div><div class="line">               action();</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="成员变量和属性的操作方法"><a href="#成员变量和属性的操作方法" class="headerlink" title="成员变量和属性的操作方法"></a>成员变量和属性的操作方法</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取成员变量名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量类型编码</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量的偏移量</span></div><div class="line">ptrdiff_t ivar_getOffset ( Ivar v );</div></pre></td></tr></table></figure>
<h3 id="Associated-Objects"><a href="#Associated-Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置关联对象</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</div><div class="line"><span class="comment">// 获取关联对象</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</div><div class="line"><span class="comment">// 移除关联对象</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</div><div class="line"></div><div class="line"><span class="comment">//上面方法以键值对的形式动态的向对象添加，获取或者删除关联值。其中关联政策是一组枚举常量。这些常量对应着引用关联值机制，也就是Objc内存管理的引用计数机制。</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">     OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</div><div class="line">     OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</div><div class="line">     OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</div><div class="line">     OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</div><div class="line">     OBJC_ASSOCIATION_COPY = <span class="number">01403</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取属性名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性特性描述字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性中指定的特性</span></div><div class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</div><div class="line"><span class="comment">// 获取属性的特性列表</span></div><div class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>两个接口同样数据不同的字段名处理<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span>: <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * status;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//返回字典数据有不同的字段名，一般是写两个方法，但是如果灵活用runtime只用写一个方法</span></div><div class="line">@&#123;<span class="string">@"name1"</span>: <span class="string">"张三"</span>, <span class="string">@"status1"</span>: <span class="string">@"start"</span>&#125;</div><div class="line">@&#123;<span class="string">@"name2"</span>: <span class="string">"张三"</span>, <span class="string">@"status2"</span>: <span class="string">@"end"</span>&#125;</div><div class="line"><span class="comment">//定义一个映射字典（全局）</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *map = <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">map = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line"></div><div class="line">map[<span class="string">@"name1"</span>] = <span class="string">@"name"</span>;</div><div class="line">map[<span class="string">@"status1"</span>] = <span class="string">@"status"</span>;</div><div class="line">map[<span class="string">@"name2"</span>] = <span class="string">@"name"</span>;</div><div class="line">map[<span class="string">@"status2"</span>] = <span class="string">@"status"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//不同字段映射到MyObject相同属性上</span></div><div class="line">- (<span class="keyword">void</span>)setDataWithDic:(<span class="built_in">NSDictionary</span> *)dic</div><div class="line">&#123;</div><div class="line">     [dic enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line"></div><div class="line">          <span class="built_in">NSString</span> *propertyKey = [<span class="keyword">self</span> propertyForKey:key];</div><div class="line">          <span class="keyword">if</span> (propertyKey)</div><div class="line">          &#123;</div><div class="line">               objc_property_t property = class_getProperty([<span class="keyword">self</span> <span class="keyword">class</span>], [propertyKey UTF8String]);</div><div class="line"></div><div class="line">               <span class="comment">// <span class="doctag">TODO:</span> 针对特殊数据类型做处理</span></div><div class="line">               <span class="built_in">NSString</span> *attributeString = [<span class="built_in">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">               ...</div><div class="line">               [<span class="keyword">self</span> setValue:obj forKey:propertyKey];</div><div class="line">          &#125;</div><div class="line">     &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Method和消息"><a href="#Method和消息" class="headerlink" title="Method和消息"></a>Method和消息</h1><h2 id="Method和消息的基础数据类型"><a href="#Method和消息的基础数据类型" class="headerlink" title="Method和消息的基础数据类型"></a>Method和消息的基础数据类型</h2><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>选择器表示一个方法的selector的指针，可以理解为Method中的ID类型<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div><div class="line"><span class="comment">//objc_selector编译时会根据每个方法名字参数序列生成唯一标识</span></div><div class="line">SEL sel1 = <span class="keyword">@selector</span>(method1);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"sel : %p"</span>, sel1);</div><div class="line">输出</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-30</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52734</span>:<span class="number">466626</span>] sel : <span class="number">0x100002d72</span></div></pre></td></tr></table></figure></p>
<p>获取SEL的三个方法：</p>
<ul>
<li>sel_registerName函数</li>
<li>objectivec编译器提供的@selector()</li>
<li>NSSelectorFromString()方法</li>
</ul>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>是函数指针，指向方法的首地址，通过SEL快速得到对应IMP，这时可以跳过Runtime消息传递机制直接执行函数，比直接向对象发消息高效。定义如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...)</div></pre></td></tr></table></figure></p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>用于表示类定义中的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">     SEL method_name OBJC2_UNAVAILABLE; <span class="comment">// 方法名</span></div><div class="line">     <span class="keyword">char</span> *method_types OBJC2_UNAVAILABLE; <span class="comment">//是个char指针，存储着方法的参数类型和返回值类型</span></div><div class="line">     IMP method_imp OBJC2_UNAVAILABLE; <span class="comment">// 方法实现，函数指针</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Method相关操作函数"><a href="#Method相关操作函数" class="headerlink" title="Method相关操作函数"></a>Method相关操作函数</h2><h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快</span></div><div class="line"><span class="keyword">id</span> method_invoke ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></div><div class="line"><span class="keyword">void</span> method_invoke_stret ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 获取方法名，希望获得方法明的C字符串，使用sel_getName(method_getName(method))</span></div><div class="line">SEL method_getName ( Method m );</div><div class="line"><span class="comment">// 返回方法的实现</span></div><div class="line">IMP method_getImplementation ( Method m );</div><div class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding ( Method m );</div><div class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyReturnType ( Method m );</div><div class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index );</div><div class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getReturnType ( Method m, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回方法的参数的个数</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments ( Method m );</div><div class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * method_getDescription ( Method m );</div><div class="line"><span class="comment">// 设置方法的实现</span></div><div class="line">IMP method_setImplementation ( Method m, IMP imp );</div><div class="line"><span class="comment">// 交换两个方法的实现</span></div><div class="line"><span class="keyword">void</span> method_exchangeImplementations ( Method m1, Method m2 );</div></pre></td></tr></table></figure>
<h3 id="Method的SEL"><a href="#Method的SEL" class="headerlink" title="Method的SEL"></a>Method的SEL</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sel_getName ( SEL sel );</div><div class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></div><div class="line">SEL sel_registerName ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法</span></div><div class="line">SEL sel_getUid ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"><span class="comment">// 比较两个选择器</span></div><div class="line"><span class="built_in">BOOL</span> sel_isEqual ( SEL lhs, SEL rhs );</div></pre></td></tr></table></figure>
<h2 id="Method调用流程"><a href="#Method调用流程" class="headerlink" title="Method调用流程"></a>Method调用流程</h2><p>消息函数，Objc中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个函数将消息接收者和方法名作为基础参数。消息发送给一个对象时，objc_msgSend通过对象的isa指针获得类的结构体，先在Cache里找，找到就执行，没找到就在分发列表里查找方法的selector，没找到就通过objc_msgSend结构体中指向父类的指针找到父类，然后在父类分发列表找，直到root class（NSObject）。</span></div><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure></p>
<p>编译器会根据情况在objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，或objc_msgSendSuper_stret四个方法中选一个调用。如果是传递给超类就会调用带super的函数，如果返回是数据结构而不是一个值就会调用带stret的函数。在i386平台返回类型为浮点消息会调用objc_msgSend_fpret函数。</p>
<p>举个例子，NSStringFromClass([self class])和NSStringFromClass([super class])输出都是self的类名。原因如下</p>
<p>调用[self class]的时候先调用objc_msgSend，发现self没有class这个方法，然后用objc_msgSendSuper就去父类找，还是没有，继续用objc_msgSendSuper到NSObject里找，结果找到了，查找NSObject中class方法的runtime源码会发现它会返回self，所以[self class]会返回self本身。同理[super class]相对前者就是少了objc_msgSend这一步，最后也会找到NSObject根类里的class方法，自然结果也是返回了self。</p>
<h3 id="Method中的接收消息对象参数和方法选择器参数"><a href="#Method中的接收消息对象参数和方法选择器参数" class="headerlink" title="Method中的接收消息对象参数和方法选择器参数"></a>Method中的接收消息对象参数和方法选择器参数</h3><p>在Method中使用self关键字来引用实例本身，self的内容即接收消息的对象是在Method运行时被传入的同时还有方法选择器。</p>
<h3 id="获取Method地址"><a href="#获取Method地址" class="headerlink" title="获取Method地址"></a>获取Method地址</h3><p>使用NSObject提供的methodForSelector:方法可以获得Method的指针，通过指针调用实现代码。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target</div><div class="line">     methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</div><div class="line">     <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure></p>
<h2 id="Method转发"><a href="#Method转发" class="headerlink" title="Method转发"></a>Method转发</h2><p>如果使用[object message]调用方法，object无法响应message时就会报错。用performSelector…调用就要等到运行时才确定是否能接受，不能才崩溃。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先调用respondsToSelector:来判断一下</span></div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</div><div class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Method转发机制分为三步：</p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</div><div class="line">     <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method1"</span>]) &#123;</div><div class="line">          class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">"@:"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以动态的提供一个方法的实现。例如可以用@dynamic关键字在类的实现文件中写个属性<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个表明会为这个属性动态提供set get方法，就是编译器是不会默认生成setPropertyName:和propertyName方法，需要动态提供。可以通过重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法和类方法实现。最后用class_addMethod完成添加特定方法实现的操作</span></div><div class="line"><span class="keyword">@dynamic</span> propertyName;</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">     <span class="comment">// implementation ....</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</div><div class="line">          <span class="comment">//v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</span></div><div class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</div><div class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="重定向接收者"><a href="#重定向接收者" class="headerlink" title="重定向接收者"></a>重定向接收者</h3><p>如果无法处理消息会继续调用下面的方法，同时在这里Runtime系统实际上是给了一个替换消息接收者的机会，但是替换的对象千万不要是self，那样会进入死循环。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))&#123;</div><div class="line">          <span class="keyword">return</span> alternateObject;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这个方法通常在对象内部，如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethodHelper</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethodHelper</span></span></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethod</span> () </span>&#123;</div><div class="line">     SUTRuntimeMethodHelper *_helper;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethod</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)object &#123;</div><div class="line">     <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">          _helper = [[SUTRuntimeMethodHelper alloc] init];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method2)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</div><div class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</div><div class="line"></div><div class="line">     <span class="comment">// 将消息转发给_helper来处理</span></div><div class="line">     <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method2"</span>]) &#123;</div><div class="line">          <span class="keyword">return</span> _helper;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="最后进行转发"><a href="#最后进行转发" class="headerlink" title="最后进行转发"></a>最后进行转发</h3><p>如果以上两种都没法处理未知消息就需要完整消息转发了。调用如下方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的selector，target和参数都封装在anInvocation中。forwardInvocation:像未知消息分发中心，将未知消息转发给其它对象。注意的是forwardInvocation:方法只有在消息接收对象无法正常响应消息时才被调用。</span></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div><div class="line"><span class="comment">//必须重写这个方法，消息转发使用这个方法获得的信息创建NSInvocation对象。</span></div><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>
<p>范例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">     <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!signature) &#123;</div><div class="line">          <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class="line">               signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</div><div class="line">     <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">          [anInvocation invokeWithTarget:_helper];</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h3><p>转发和继承相似，一个Object把消息转发出去就好像它继承了另一个Object的方法一样。</p>
<h3 id="Message消息的参考文章"><a href="#Message消息的参考文章" class="headerlink" title="Message消息的参考文章"></a>Message消息的参考文章</h3><ul>
<li>Message forwarding <a href="https://mikeash.com/pyblog/friday-qa-2009-03-27-objectivec-message-forwarding.html" target="_blank" rel="external">https://mikeash.com/pyblog/friday-qa-2009-03-27-objectivec-message-forwarding.html</a></li>
<li>objectivec messaging <a href="https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objectivec-messaging.html" target="_blank" rel="external">https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objectivec-messaging.html</a></li>
<li>The faster objc_msgSend <a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html" target="_blank" rel="external">http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html</a></li>
</ul>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p>是改变一个selector实际实现的技术，可以在运行时修改selector对应的函数来修改Method的实现。前面的消息转发很强大，但是需要能够修改对应类的源码，但是对于有些类无法修改其源码时又要更改其方法实现时可以使用Method Swizzling，通过重新映射方法来达到目的，但是跟消息转发比起来调试会困难。</p>
<h3 id="使用method-swizzling需要注意的问题"><a href="#使用method-swizzling需要注意的问题" class="headerlink" title="使用method swizzling需要注意的问题"></a>使用method swizzling需要注意的问题</h3><ul>
<li>Swizzling应该总在+load中执行：objectivec在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载</li>
<li>Swizzling应该总是在dispatch_once中执行：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。</li>
<li>Selector，Method和Implementation：这几个之间关系可以这样理解，一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个Method，其中key是一个特定的名称，及SEL，与其对应的实现是IMP即指向底层C函数的指针。</li>
</ul>
<p>举例说明如何使用Method Swizzling对一个类中注入一些我们的新的操作。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">          Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">          <span class="comment">// When swizzling a class method, use the following:</span></div><div class="line">          <span class="comment">// Class class = object_getClass((id)self);</span></div><div class="line">          </div><div class="line">          <span class="comment">//通过method swizzling修改了UIViewController的@selector(viewWillAppear:)的指针使其指向了自定义的xxx_viewWillAppear</span></div><div class="line">          SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</div><div class="line">          SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</div><div class="line"></div><div class="line">          Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">          Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</div><div class="line"></div><div class="line">          <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</div><div class="line">               originalSelector,</div><div class="line">               method_getImplementation(swizzledMethod),</div><div class="line">               method_getTypeEncoding(swizzledMethod));</div><div class="line">          </div><div class="line">          <span class="comment">//如果类中不存在要替换的方法，就先用class_addMethod和class_replaceMethod函数添加和替换两个方法实现。但如果已经有了要替换的方法，就调用method_exchangeImplementations函数交换两个方法的Implementation。</span></div><div class="line">          <span class="keyword">if</span> (didAddMethod) &#123;</div><div class="line">               class_replaceMethod(<span class="keyword">class</span>,</div><div class="line">                    swizzledSelector,</div><div class="line">                    method_getImplementation(originalMethod),</div><div class="line">               method_getTypeEncoding(originalMethod));</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">          &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Method Swizzling</span></div><div class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">     [<span class="keyword">self</span> xxx_viewWillAppear:animated];</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>method_exchangeImplementations做的事情和如下代码是一样的<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IMP imp1 = method_getImplementation(m1);</div><div class="line">IMP imp2 = method_getImplementation(m2);</div><div class="line">method_setImplementation(m1, imp2);</div><div class="line">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p>
<p>另一种Method Swizzling的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)replacementReceiveMessage:(<span class="keyword">const</span> <span class="keyword">struct</span> BInstantMessage *)arg1 &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"arg1 is %@"</span>, arg1);</div><div class="line">     [<span class="keyword">self</span> replacementReceiveMessage:arg1];</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">     SEL originalSelector = <span class="keyword">@selector</span>(ReceiveMessage:);</div><div class="line">     SEL overrideSelector = <span class="keyword">@selector</span>(replacementReceiveMessage:);</div><div class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</div><div class="line">     Method overrideMethod = class_getInstanceMethod(<span class="keyword">self</span>, overrideSelector);</div><div class="line">     <span class="keyword">if</span> (class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) &#123;</div><div class="line">          class_replaceMethod(<span class="keyword">self</span>, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          method_exchangeImplementations(originalMethod, overrideMethod);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有几个关于Method Swizzling的资源可以参考</p>
<ul>
<li>How do I implement method swizzling? <a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="external">http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling</a></li>
<li>Method Swizzling <a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">http://nshipster.com/method-swizzling/</a></li>
<li>What are the Dangers of Method Swizzling in Objective C? <a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objectivec" target="_blank" rel="external">http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objectivec</a></li>
<li>JRSwizzle <a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="external">https://github.com/rentzsch/jrswizzle</a></li>
</ul>
<h1 id="Protocol和Category"><a href="#Protocol和Category" class="headerlink" title="Protocol和Category"></a>Protocol和Category</h1><h2 id="基础数据类型-1"><a href="#基础数据类型-1" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>指向分类的结构体的指针<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_category &#123;</div><div class="line">     <span class="keyword">char</span> *category_name OBJC2_UNAVAILABLE; <span class="comment">// 分类名</span></div><div class="line">     <span class="keyword">char</span> *class_name OBJC2_UNAVAILABLE; <span class="comment">// 分类所属的类名</span></div><div class="line">     <span class="keyword">struct</span> objc_method_list *instance_methods OBJC2_UNAVAILABLE; <span class="comment">// 实例方法列表</span></div><div class="line">     <span class="keyword">struct</span> objc_method_list *class_methods OBJC2_UNAVAILABLE; <span class="comment">// 类方法列表，Meta Class方法列表的子集</span></div><div class="line">     <span class="keyword">struct</span> objc_protocol_list *protocols OBJC2_UNAVAILABLE; <span class="comment">// 分类所实现的协议列表</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Category里面的方法加载过程，objc源码中找到objc-os.mm，函数_objc_init就是runtime的加载入口由libSystem调用，开始初始化，之后objc-runtime-new.mm里的map_images会加载map到内存，_read_images开始初始化这个map，这时会load所有Class，Protocol和Category，NSObject的+load方法就是这个时候调用的。下面是加载代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Discover categories.</span></div><div class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</div><div class="line">     category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</div><div class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">          category_t *cat = catlist[i];</div><div class="line">          Class cls = remapClass(cat-&gt;cls);</div><div class="line">          <span class="keyword">if</span> (!cls) &#123;</div><div class="line">               <span class="comment">// Category's target class is missing (probably weak-linked).</span></div><div class="line">               <span class="comment">// Disavow any knowledge of this category.</span></div><div class="line">               catlist[i] = <span class="literal">nil</span>;</div><div class="line">               <span class="keyword">if</span> (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></div><div class="line">                         <span class="string">"missing weak-linked target class"</span>,</div><div class="line">                         cat-&gt;name, cat);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// Process this category.</span></div><div class="line">          <span class="comment">// First, register the category with its target class.</span></div><div class="line">          <span class="comment">// Then, rebuild the class's method lists (etc) if</span></div><div class="line">          <span class="comment">// the class is realized.</span></div><div class="line">          <span class="built_in">BOOL</span> classExists = <span class="literal">NO</span>;</div><div class="line">          <span class="keyword">if</span> (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties)</div><div class="line">          &#123;</div><div class="line">               addUnattachedCategoryForClass(cat, cls, hi);</div><div class="line">               <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls);</div><div class="line">                    classExists = <span class="literal">YES</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>,</div><div class="line">                         cls-&gt;nameForLogging(), cat-&gt;name,</div><div class="line">                         classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (cat-&gt;classMethods || cat-&gt;protocols <span class="comment">/* || cat-&gt;classProperties */</span>)</div><div class="line">          &#123;</div><div class="line">               addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</div><div class="line">               <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls-&gt;ISA());</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>,</div><div class="line">                         cls-&gt;nameForLogging(), cat-&gt;name);</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用remethodizeClass方法，在其实现里调用attachCategoryMethods</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">attachCategoryMethods(Class cls, category_list *cats, <span class="keyword">bool</span> flushCaches)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</div><div class="line">     <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line">     <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class="line">     method_list_t **mlists = (method_list_t **)</div><div class="line">          _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</div><div class="line">     <span class="comment">// Count backwards through cats to get newest categories first</span></div><div class="line">     <span class="keyword">int</span> mcount = <span class="number">0</span>;</div><div class="line">     <span class="keyword">int</span> i = cats-&gt;count;</div><div class="line">     <span class="built_in">BOOL</span> fromBundle = <span class="literal">NO</span>;</div><div class="line">     <span class="keyword">while</span> (i--) &#123;</div><div class="line">          method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</div><div class="line">          <span class="keyword">if</span> (mlist) &#123;</div><div class="line">               mlists[mcount++] = mlist;</div><div class="line">               fromBundle |= cats-&gt;list[i].fromBundle;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">     attachMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle, flushCaches);</div><div class="line">     _free_internal(mlists);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例，下面的代码会编译错误，Runtime Crash还是会正常输出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></div><div class="line">+ (<span class="keyword">void</span>)foo;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></div><div class="line">- (<span class="keyword">void</span>)foo</div><div class="line">&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"IMP: -[NSObject(Sark) foo]"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          [<span class="built_in">NSObject</span> foo];</div><div class="line">          [[<span class="built_in">NSObject</span> new] foo];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果，正常输出结果如下</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-06</span> <span class="number">13</span>:<span class="number">11</span>:<span class="number">46.694</span> Test[<span class="number">14872</span>:<span class="number">1110786</span>] IMP: -[<span class="built_in">NSObject</span>(Sark) foo]</div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-06</span> <span class="number">13</span>:<span class="number">11</span>:<span class="number">46.695</span> Test[<span class="number">14872</span>:<span class="number">1110786</span>] IMP: -[<span class="built_in">NSObject</span>(Sark) foo]</div></pre></td></tr></table></figure></p>
<p>objc runtime加载后NSObject的Sark Category被加载，头文件+(void)foo没有IMP，只会出现一个warning。被加到Class的Method list里的方法只有-(void)foo，Meta Class的方法列表里没有。</p>
<p>执行[NSObject foo]时，会在Meta Class的Method list里找，找不着就继续往super class里找，NSObject Meta Clas的super class是NSObject本身，这时在NSObject的Method list里就有foo这个方法了，能够正常输出。</p>
<p>执行[[NSObject new] foo]就简单的多了，[NSObject new]生成一个实例，实例的Method list是有foo方法的，于是正常输出。</p>
<h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>Protocol其实就是一个对象结构体<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Protocol;</div></pre></td></tr></table></figure></p>
<h2 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h2><p>Category操作函数信息都包含在objc_class中，我们可以通过objc_class的操作函数来获取分类的操作函数信息。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">@interface RuntimeCategoryClass : NSObject</div><div class="line">- (void)method1;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface RuntimeCategoryClass (Category)</div><div class="line">- (void)method2;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation RuntimeCategoryClass</div><div class="line">- (void)method1 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation RuntimeCategoryClass (Category)</div><div class="line">- (void)method2 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#pragma mark -</div><div class="line">NSLog(@"测试objc_class中的方法列表是否包含分类中的方法");</div><div class="line">unsigned int outCount = 0;</div><div class="line">Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);</div><div class="line"></div><div class="line">for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">     Method method = methodList[i];</div><div class="line"></div><div class="line">     const char *name = sel_getName(method_getName(method));</div><div class="line"></div><div class="line">     NSLog(@"RuntimeCategoryClass's method: %s", name);</div><div class="line"></div><div class="line">     if (strcmp(name, sel_getName(@selector(method2)))) &#123;</div><div class="line">          NSLog(@"分类方法method2在objc_class的方法列表中");</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//输出</div><div class="line">2014-11-08 10:36:39.213 [561:151847] 测试objc_class中的方法列表是否包含分类中的方法</div><div class="line">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method2</div><div class="line">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method1</div><div class="line">2014-11-08 10:36:39.215 [561:151847] 分类方法method2在objc_class的方法列表中</div></pre></td></tr></table></figure></p>
<p>Runtime提供了Protocol的一系列函数操作，函数包括<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回指定的协议</span></div><div class="line">Protocol * objc_getProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></div><div class="line">Protocol ** objc_copyProtocolList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 创建新的协议实例</span></div><div class="line">Protocol * objc_allocateProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 在运行时中注册新创建的协议</span></div><div class="line"><span class="keyword">void</span> objc_registerProtocol ( Protocol *proto ); <span class="comment">//创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></div><div class="line"><span class="comment">// 为协议添加方法</span></div><div class="line"><span class="keyword">void</span> protocol_addMethodDescription ( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></div><div class="line"><span class="keyword">void</span> protocol_addProtocol ( Protocol *proto, Protocol *addition );</div><div class="line"><span class="comment">// 为协议添加属性</span></div><div class="line"><span class="keyword">void</span> protocol_addProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"><span class="comment">// 返回协议名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * protocol_getName ( Protocol *p );</div><div class="line"><span class="comment">// 测试两个协议是否相等</span></div><div class="line"><span class="built_in">BOOL</span> protocol_isEqual ( Protocol *proto, Protocol *other );</div><div class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></div><div class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"><span class="comment">// 获取协议中的属性列表</span></div><div class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取协议的指定属性</span></div><div class="line">objc_property_t protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"><span class="comment">// 获取协议采用的协议</span></div><div class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></div><div class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</div></pre></td></tr></table></figure></p>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><p>runtime中一些支持block操作的函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></div><div class="line">IMP imp_implementationWithBlock ( <span class="keyword">id</span> block );</div><div class="line"></div><div class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></div><div class="line"><span class="keyword">id</span> imp_getBlock ( IMP anImp );</div><div class="line"></div><div class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></div><div class="line"><span class="built_in">BOOL</span> imp_removeBlock ( IMP anImp );</div></pre></td></tr></table></figure></p>
<p>测试代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyRuntimeBlock</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyRuntimeBlock</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">IMP imp = imp_implementationWithBlock(^(<span class="keyword">id</span> obj, <span class="built_in">NSString</span> *str) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</div><div class="line">&#125;);</div><div class="line">class_addMethod(MyRuntimeBlock.class, <span class="keyword">@selector</span>(testBlock:), imp, <span class="string">"v@:@"</span>);</div><div class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</div><div class="line">[runtime performSelector:<span class="keyword">@selector</span>(testBlock:) withObject:<span class="string">@"hello world!"</span>];</div><div class="line"></div><div class="line"><span class="comment">//结果</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-09</span> <span class="number">14</span>:<span class="number">03</span>:<span class="number">19.779</span> [<span class="number">1172</span>:<span class="number">395446</span>] hello world!</div></pre></td></tr></table></figure></p>
<h1 id="Runtime的应用"><a href="#Runtime的应用" class="headerlink" title="Runtime的应用"></a>Runtime的应用</h1><h2 id="获取系统提供的库相关信息"><a href="#获取系统提供的库相关信息" class="headerlink" title="获取系统提供的库相关信息"></a>获取系统提供的库相关信息</h2><p>主要函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取所有加载的objectivec框架和动态库的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyImageNames ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 获取指定类所在动态库</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getImageName ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyClassNamesForImage ( <span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<p>通过这些函数就能够获取某个类所有的库，以及某个库中包含哪些类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">NSLog(@"获取指定类所在动态库");</div><div class="line"></div><div class="line">NSLog(@"UIView's Framework: %s", class_getImageName(NSClassFromString(@"UIView")));</div><div class="line"></div><div class="line">NSLog(@"获取指定库或框架中所有类的类名");</div><div class="line">const char ** classes = objc_copyClassNamesForImage(class_getImageName(NSClassFromString(@"UIView")), &amp;outCount);</div><div class="line">for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">     NSLog(@"class name: %s", classes[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//结果</div><div class="line">2014-11-08 12:57:32.689 [747:184013] 获取指定类所在动态库</div><div class="line">2014-11-08 12:57:32.690 [747:184013] UIView's Framework: /System/Library/Frameworks/UIKit.framework/UIKit</div><div class="line">2014-11-08 12:57:32.690 [747:184013] 获取指定库或框架中所有类的类名</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: UIKeyboardPredictiveSettings</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: _UIPickerViewTopFrame</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: _UIOnePartImageView</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewSelectionBar</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerWheelView</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewTestParameters</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="对App的用户行为进行追踪"><a href="#对App的用户行为进行追踪" class="headerlink" title="对App的用户行为进行追踪"></a>对App的用户行为进行追踪</h2><p>就是用户点击时把事件记录下来。一般比较做法就是在viewDidAppear里记录事件，这样会让这样记录事件的代码遍布整个项目中。继承或类别也会有问题。这时利用Method Swizzling把一个方法的实现和另一个方法的实现进行替换。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先定义一个类别，添加要Swizzled的方法</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)- (<span class="title">void</span>)<span class="title">swizzled_viewDidAppear</span>:(<span class="title">BOOL</span>)<span class="title">animated</span></span></div><div class="line">&#123; <span class="comment">// call original implementation</span></div><div class="line">     [<span class="keyword">self</span> swizzled_viewDidAppear:animated]; <span class="comment">// Logging</span></div><div class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div><div class="line"><span class="comment">//接下来实现swizzle方法</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)<span class="title">void</span> <span class="title">swizzleMethod</span>(<span class="title">Class</span> <span class="title">class</span>, <span class="title">SEL</span> <span class="title">originalSelector</span>, <span class="title">SEL</span> <span class="title">swizzledSelector</span>) </span>&#123; <span class="comment">// the method might not exist in the class, but in its superclass</span></div><div class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">     Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector); <span class="comment">// class_addMethod will fail if original method already exists</span></div><div class="line">     <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); <span class="comment">// the method doesn’t exist and we just added one</span></div><div class="line">     <span class="keyword">if</span> (didAddMethod) &#123;</div><div class="line">          class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">else</span> &#123;</div><div class="line">          method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最后要确保在程序启动的时候调用swizzleMethod方法在之前的UIViewController的Logging类别里添加+load:方法，然后在+load:里把viewDidAppear替换掉</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)+ (<span class="title">void</span>)<span class="title">load</span></span></div><div class="line">&#123;</div><div class="line">     swizzleMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:), <span class="keyword">@selector</span>(swizzled_viewDidAppear:));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//更简化直接用新的IMP取代原IMP，不是替换，只需要有全局的函数指针指向原IMP即可。</span></div><div class="line"><span class="keyword">void</span> (gOriginalViewDidAppear)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);<span class="keyword">void</span> newViewDidAppear(<span class="built_in">UIViewController</span> *<span class="keyword">self</span>, SEL _cmd, <span class="built_in">BOOL</span> animated)</div><div class="line">&#123; <span class="comment">// call original implementation</span></div><div class="line">     gOriginalViewDidAppear(<span class="keyword">self</span>, _cmd, animated); <span class="comment">// Logging</span></div><div class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewDidAppear:));</div><div class="line">     gOriginalViewDidAppear = (<span class="keyword">void</span> *)method_getImplementation(originalMethod); <span class="keyword">if</span>(!class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewDidAppear:), (IMP) newViewDidAppear, method_getTypeEncoding(originalMethod))) &#123;</div><div class="line">          method_setImplementation(originalMethod, (IMP) newViewDidAppear);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过Method Swizzling可以把事件代码或Logging，Authentication，Caching等跟主要业务逻辑代码解耦。这种处理方式叫做Cross Cutting Concerns<a href="http://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="external">http://en.wikipedia.org/wiki/Cross-cutting_concern</a> 用Method Swizzling动态给指定的方法添加代码解决Cross Cutting Concerns的编程方式叫Aspect Oriented Programming <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="external">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a> 目前有些第三方库可以很方便的使用AOP，比如Aspects <a href="https://github.com/steipete/Aspects" target="_blank" rel="external">https://github.com/steipete/Aspects</a> 这里是使用Aspects的范例<a href="https://github.com/okcomp/AspectsDemo" target="_blank" rel="external">https://github.com/okcomp/AspectsDemo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/251980?v=3&s=460"
               alt="戴铭" />
          <p class="site-author-name" itemprop="name">戴铭</p>
           
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里；不积小流，无以成江海</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ming1016" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/allstarming" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/ming1016" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">戴铭</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
