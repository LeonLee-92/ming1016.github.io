<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星光社 - 戴铭的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ming1016.github.io/"/>
  <updated>2017-05-27T02:23:48.000Z</updated>
  <id>http://ming1016.github.io/</id>
  
  <author>
    <name>戴铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 Swift 编写的工程代码静态分析命令行工具 smck</title>
    <link href="http://ming1016.github.io/2017/04/01/build-static-analysis-program-smck-use-swift/"/>
    <id>http://ming1016.github.io/2017/04/01/build-static-analysis-program-smck-use-swift/</id>
    <published>2017-04-01T14:00:31.000Z</published>
    <updated>2017-05-27T02:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几周在用 swift 做一个命令行工具 smck 用来对现有 OC 工程的代码做些分析和处理。日后工程切换成 Swift 可以加上对 Swift 工程代码的支持。昨天看到喵神在微博上说他下周要直播 live coding 一个 swift 的命令行工具，传送门： <a href="http://m.quzhiboapp.com/?liveId=391&amp;fromUserId=12049#!/intro/391" target="_blank" rel="external">现场编程 - 用 Swift 创建命令行工具 fengniao-cli Part1</a> ，其实蛮期待。想想跟喵神挺有缘的，最近下了他开发的 iOS 应用 Mail Me，随时能够记录工作和准备讲座时一些灵感，smck 的一些实现还有模块的设计灵感也是通过这个应用随时记录了下来呢，所以也推荐大家使用，真心方便。还有先前 Segmentfault 邀请我这个月31号在他们的直播平台上做个讲座，传送门： <a href="https://segmentfault.com/l/1500000008514518" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM - 戴铭 - SegmentFault 讲堂</a> ，先前写过一篇文章，直播可能更利于演示和详细说明一些细节吧。看来这段时间我要跟喵神做好多类似的事情了。smck 的代码今天已经放到了 Github 上，地址：<a href="https://github.com/ming1016/smck" target="_blank" rel="external">https://github.com/ming1016/smck</a></p>
<h2 id="smck-可以做哪些事情呢？"><a href="#smck-可以做哪些事情呢？" class="headerlink" title="smck 可以做哪些事情呢？"></a>smck 可以做哪些事情呢？</h2><ul>
<li>简单的比如命名规则的检查，按照团队标准来，如所有继承 UIViewController 的命名末尾统一成 VC，继承 JSONModel 的命名末尾统一成 Model，还有特定功能基类的子类按照一定的命名规则来。</li>
<li>再比如查找所有中文字符串列出每个字符串分别使用在哪个控件上。</li>
<li>根据类是否被初始化或直接调用等规则检查来分析哪些类从来没有调用过来判断是否是没有用的类。</li>
<li>对工程质量的检查，比如 NSString，block，NSArray 的属性检查否是为 copy，还有 protocol 是否为 weak，Array 的操作是否使用具有安全操作的 Category 来做等等。<br>当然需要检查分析和处理的肯定不止这些，所以在 smck 这个程序设计成了一种非常利于添加各种检查功能模块的结构，通过简单的代码编写每个人或团队都可以方便编写添加各种 checker。</li>
</ul>
<h2 id="是怎么做到简单编写就能够添加功能呢？"><a href="#是怎么做到简单编写就能够添加功能呢？" class="headerlink" title="是怎么做到简单编写就能够添加功能呢？"></a>是怎么做到简单编写就能够添加功能呢？</h2><p>因为代码分析的过程会通过一系列已经编写好的 parser 来完成，parser 会完成 token 的分析和上下文还有工程全局分析输出所有节点的数据信息，根据这些完整的信息和已经定义好的一系列具有完整包含关系的结构体就能够进行各种各样功能的定制化了。下面是一些 parser 和功能介绍：</p>
<p><img src="https://github.com/ming1016/smck/blob/master/README/5.png?raw=true" alt="parser"></p>
<ul>
<li>ParsingMethod.swift ：会返回 Method 结构体，包含了方法名，各个参数，方法内使用过的方法，方法内定义的临时变量等信息。</li>
<li>ParsingMethodContent.swift ：会分析方法内的 token 根据语法形成数组结构进行处理。这里需要处理的东西很多，目前还在根据计划添加更多的数据输出。</li>
<li>ParsingMacro.swift ：处理宏定义，主要是输出 token 给其它 parser 来处理。</li>
<li>ParsingImport.swift ：返回 Import 结构体，包含引入的类名，包名</li>
<li>ParsingProperty.swift ：会分析定义的属性 Property 信息</li>
<li>ParsingInterface.swift ：会根据这个分析出一个文件中定义了多少各类，类的结构体 Object 里类名，父类名，类别名会在这里解析出。</li>
<li>ParsingProtocol.swift ：会将分析出的协议设置到 Object 结构体中。</li>
<li>ParsingObject.swift ： 目前主要是分析出使用过的类的信息。</li>
</ul>
<p>生成的 File 结构体里面套装各个子结构体，断点如图：<br><img src="https://github.com/ming1016/smck/blob/master/README/6.png?raw=true" alt="结构体"></p>
<h2 id="如何调试-smck？"><a href="#如何调试-smck？" class="headerlink" title="如何调试 smck？"></a>如何调试 smck？</h2><p>先填上对应的命令行参数和值，设置参数参考下图。然后运行即可。<br><img src="https://github.com/ming1016/smck/blob/master/README/2.png?raw=true" alt="命令行参数"></p>
<h2 id="导出成命令行工具"><a href="#导出成命令行工具" class="headerlink" title="导出成命令行工具"></a>导出成命令行工具</h2><p>在 Xcode 里选择 Product - Archive - Export 即可，如图：<br><img src="https://github.com/ming1016/smck/blob/master/README/3.png?raw=true" alt="导出"><br>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./smck -o /User/your_project_path</div></pre></td></tr></table></figure></p>
<p>输出如下<br><img src="https://github.com/ming1016/smck/blob/master/README/4.png?raw=true" alt="执行效果"></p>
<h2 id="如何编写自己的检查功能？"><a href="#如何编写自己的检查功能？" class="headerlink" title="如何编写自己的检查功能？"></a>如何编写自己的检查功能？</h2><p>由于工程检查规则非常多样化，所以需要编写一些 Plugin，后面我会逐渐抽出一些具有共性的放上来，目前在 Plugin 目录下我放了两个例子，在例子里可以看出来怎么通过订阅 Parser 输出的不同节点的不同数据来进行不同的检查。在控制台管理相关的 Checker 类里关联 Parser 和 Plugin 的代码由于使用了 RxSwift 也变得非常简洁明了，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doO</span><span class="params">(path:String)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> path.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="type">UnUseObjectPlugin</span>().plug(ob: <span class="type">ParsingEntire</span>.parsing(path: path))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近几周在用 swift 做一个命令行工具 smck 用来对现有 OC 工程的代码做些分析和处理。日后工程切换成 Swift 可以加上对 S
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="smck" scheme="http://ming1016.github.io/tags/smck/"/>
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 iOS 编译 Clang / LLVM</title>
    <link href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/"/>
    <id>http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/</id>
    <published>2017-03-01T13:58:09.000Z</published>
    <updated>2017-05-27T03:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入剖析-iOS-编译-Clang-LLVM"><a href="#深入剖析-iOS-编译-Clang-LLVM" class="headerlink" title="深入剖析 iOS 编译 Clang / LLVM"></a>深入剖析 iOS 编译 Clang / LLVM</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter <a href="https://twitter.com/clattner_llvm" target="_blank" rel="external">@clattner_llvm</a> ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p>
<p>Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。</p>
<p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</p>
<p>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</p>
<p>LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是  Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。</p>
<p>LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。</p>
<p>LLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</p>
<p>这里是 Clang 官方详细文档： <a href="http://clang.llvm.org/docs/" target="_blank" rel="external">Welcome to Clang’s documentation! — Clang 4.0 documentation</a></p>
<p>这篇是对 LLVM 架构的一个概述： <a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">The Architecture of Open Source Applications</a></p>
<p>将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 <a href="https://book.douban.com/subject/1436811/" target="_blank" rel="external">《linkers and loaders》</a> 这本书就知道了。</p>
<h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#define DEFINEEight 8</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">int</span> eight = DEFINEEight;</div><div class="line">        <span class="keyword">int</span> six = <span class="number">6</span>;</div><div class="line">        <span class="built_in">NSString</span>* site = [[<span class="built_in">NSString</span> alloc] initWithUTF8String:<span class="string">"starming"</span>];</div><div class="line">        <span class="keyword">int</span> rank = eight + six;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ rank %d"</span>, site, rank);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -ccc-print-phases main.m</div></pre></td></tr></table></figure></p>
<p>可以看到编译源文件需要的几个不同的阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: input, &quot;main.m&quot;, objective-c</div><div class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</div><div class="line">2: compiler, &#123;1&#125;, ir</div><div class="line">3: backend, &#123;2&#125;, assembler</div><div class="line">4: assembler, &#123;3&#125;, object</div><div class="line">5: linker, &#123;4&#125;, image</div><div class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image</div></pre></td></tr></table></figure></p>
<p>这样能够了解到过程和重要的信息。<br>查看oc的c实现可以使用如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m</div></pre></td></tr></table></figure></p>
<p>查看操作内部命令，可以使用 -### 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -### main.m -o main</div></pre></td></tr></table></figure></p>
<p>想看清clang的全部过程，可以先通过-E查看clang在预处理处理这步做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -E main.m</div></pre></td></tr></table></figure></p>
<p>执行完后可以看到文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 1 <span class="meta-string">"/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h"</span> 1 3</span></div><div class="line"><span class="meta"># 185 <span class="meta-string">"/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h"</span> 2 3</span></div><div class="line"><span class="meta"># 2 <span class="meta-string">"main.m"</span> 2</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">int</span> eight = <span class="number">8</span>;</div><div class="line">        <span class="keyword">int</span> six = <span class="number">6</span>;</div><div class="line">        <span class="built_in">NSString</span>* site = [[<span class="built_in">NSString</span> alloc] initWithUTF8String:<span class="string">"starming"</span>];</div><div class="line">        <span class="keyword">int</span> rank = eight + six;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ rank %d"</span>, site, rank);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个过程的处理包括宏的替换，头文件的导入，以及类似#if的处理。预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p>
<p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p>
<p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="external">Writing an LLVM Pass — LLVM 5 documentation</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</p>
<p>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure></p>
<p>生成汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure></p>
<p>生成目标文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure></p>
<p>生成可执行文件，这样就能够执行看到输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">clang main.o -o main</div><div class="line">执行</div><div class="line">./main</div><div class="line">输出</div><div class="line">starming rank 14</div></pre></td></tr></table></figure></p>
<p>下面是完整步骤：</p>
<ul>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ul>
<h2 id="Clang-编译-m-文件"><a href="#Clang-编译-m-文件" class="headerlink" title="Clang 编译 .m 文件"></a>Clang 编译 .m 文件</h2><p>在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。</p>
<p>具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CompileC DerivedData path/AFSecurityPolicy.o AFNetworking/AFNetworking/AFSecurityPolicy.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</div></pre></td></tr></table></figure></p>
<p>接下来对会更新工作路径，同时设置 PATH<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods</div><div class="line">    export LANG=en_US.US-ASCII</div><div class="line">    export PATH=&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&quot;</div></pre></td></tr></table></figure></p>
<p>接下来就是实际的编译命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc... -Wno-missing-field-initializers ... -DDEBUG=1 ... -isysroot iPhoneSimulator10.1.sdk -fasm-blocks ... -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o</div></pre></td></tr></table></figure></p>
<p>clang 命令参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-x 编译语言比如objective-c</div><div class="line">-arch 编译的架构，比如arm7</div><div class="line">-f 以-f开头的。</div><div class="line">-W 以-W开头的，可以通过这些定制编译警告</div><div class="line">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</div><div class="line">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</div><div class="line">-I 把编译信息写入指定的辅助文件</div><div class="line">-F 需要的Framework</div><div class="line">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</div><div class="line">-o 编译结果</div></pre></td></tr></table></figure></p>
<h2 id="构建-Target"><a href="#构建-Target" class="headerlink" title="构建 Target"></a>构建 Target</h2><p>编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Create product structure</div><div class="line">Process product packaging</div><div class="line">Run custom shell script &apos;Check Pods Manifest.lock&apos;</div><div class="line">Compile ... 各个项目中的.m文件</div><div class="line">Link /Users/... 路径</div><div class="line">Copy ... 静态文件</div><div class="line">Compile asset catalogs</div><div class="line">Compile Storyboard file ...</div><div class="line">Process info.plist</div><div class="line">Link Storyboards</div><div class="line">Run custom shell script &apos;Embed Pods Frameworks&apos;</div><div class="line">Run custom shell script &apos;Copy Pods Resources&apos;</div><div class="line">...</div><div class="line">Touch GCDFetchFeed.app</div><div class="line">Sign GCDFetchFeed.app</div></pre></td></tr></table></figure></p>
<p>从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。</p>
<h2 id="Target-在-Build-过程的控制"><a href="#Target-在-Build-过程的控制" class="headerlink" title="Target 在 Build 过程的控制"></a>Target 在 Build 过程的控制</h2><p>在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。</p>
<h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。</p>
<p>在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。</p>
<p>build phase 还会把静态资源拷贝到 bundle 里。</p>
<p>可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。</p>
<h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>在 build 的过程中各个阶段的选项的设置。</p>
<h3 id="pbxproj工程文件"><a href="#pbxproj工程文件" class="headerlink" title="pbxproj工程文件"></a>pbxproj工程文件</h3><p>build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rootObject = 3EE311301C4E1F0800103FA3 /* Project object */;</div></pre></td></tr></table></figure></p>
<p>然后根据这个 ID 找到 main 工程的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Begin PBXProject section */</div><div class="line">		3EE311301C4E1F0800103FA3 /* Project object */ = &#123;</div><div class="line">			isa = PBXProject;</div><div class="line">			...</div><div class="line">/* End PBXProject section */</div></pre></td></tr></table></figure></p>
<p>在 targets 里会指向各个 taget 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">targets = (</div><div class="line">	3EE311371C4E1F0800103FA3 /* GCDFetchFeed */,</div><div class="line">	3EE311501C4E1F0800103FA3 /* GCDFetchFeedTests */,</div><div class="line">	3EE3115B1C4E1F0800103FA3 /* GCDFetchFeedUITests */,</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">3EE311371C4E1F0800103FA3 /* GCDFetchFeed */ = &#123;</div><div class="line">	isa = PBXNativeTarget;</div><div class="line">	buildConfigurationList = 3EE311651C4E1F0800103FA3 /* configuration list for PBXNativeTarget &quot;GCDFetchFeed&quot; </div><div class="line">	buildPhases = (</div><div class="line">		9527AA01F4AAE11E18397E0C /* Check Pods st.lock */,</div><div class="line">		3EE311341C4E1F0800103FA3 /* Sources */,</div><div class="line">		3EE311351C4E1F0800103FA3 /* Frameworks */,</div><div class="line">		3EE311361C4E1F0800103FA3 /* Resources */,</div><div class="line">		C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks </div><div class="line">		DD33A716222617FAB49F1472 /* Copy Pods Resources </div><div class="line">	);</div><div class="line">	buildRules = (</div><div class="line">	);</div><div class="line">	dependencies = (</div><div class="line">	);</div><div class="line">	name = GCDFetchFeed;</div><div class="line">	productName = GCDFetchFeed;</div><div class="line">	productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */;</div><div class="line">	productType = &quot;com.apple.product-type.application&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。</p>
<p>接下来详细的看看 Clang 所做的事情吧。</p>
<h2 id="Clang-Static-Analyzer静态代码分析"><a href="#Clang-Static-Analyzer静态代码分析" class="headerlink" title="Clang Static Analyzer静态代码分析"></a>Clang Static Analyzer静态代码分析</h2><p>可以在 <a href="https://code.woboq.org/llvm/clang/" target="_blank" rel="external">llvm/clang/ Source Tree - Woboq Code Browser</a> 上查看 Clang 的代码。</p>
<p>Youtube上一个教程：<a href="https://www.youtube.com/watch?time_continue=280&amp;v=VqCkCDFLSsc" target="_blank" rel="external">The Clang AST - a Tutorial - YouTube</a></p>
<p>静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 <a href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def" target="_blank" rel="external">TokensKind.def</a> 里有 Clang 定义的所有 Token。通过下面的命令可以输出所有 token 和所在文件具体位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -E -Xclang -dump-tokens main.m</div><div class="line">``` </div><div class="line">结果如下</div></pre></td></tr></table></figure></p>
<p>annot_module_include ‘#import &lt;Fo’        Loc=<main.m:2:1><br>int ‘int’     [StartOfLine]    Loc=<main.m:5:1><br>identifier ‘main’     [LeadingSpace]    Loc=<main.m:5:5><br>l_paren ‘(‘        Loc=<main.m:5:9><br>r_paren ‘)’        Loc=<main.m:5:10><br>l_brace ‘{‘     [LeadingSpace]    Loc=<main.m:5:12><br>at ‘@’     [StartOfLine] [LeadingSpace]    Loc=<main.m:6:5><br>identifier ‘autoreleasepool’        Loc=<main.m:6:6><br>l_brace ‘{‘     [LeadingSpace]    Loc=<main.m:6:22><br>identifier ‘NSString’     [StartOfLine] [LeadingSpace]    Loc=<main.m:7:9><br>star ‘*’     [LeadingSpace]    Loc=<main.m:7:18><br>identifier ‘a’        Loc=<main.m:7:19><br>equal ‘=’     [LeadingSpace]    Loc=<main.m:7:21><br>at ‘@’     [LeadingSpace]    Loc=<main.m:7:23><br>string_literal ‘“aaa”‘        Loc=<main.m:7:24><br>semi ‘;’        Loc=<main.m:7:29><br>identifier ‘NSLog’     [StartOfLine] [LeadingSpace]    Loc=<main.m:8:9><br>l_paren ‘(‘        Loc=<main.m:8:14><br>at ‘@’        Loc=<main.m:8:15><br>string_literal ‘“hi %@”‘        Loc=<main.m:8:16><br>comma ‘,’        Loc=<main.m:8:23><br>identifier ‘a’        Loc=<main.m:8:24><br>r_paren ‘)’        Loc=<main.m:8:25><br>semi ‘;’        Loc=<main.m:8:26><br>r_brace ‘}’     [StartOfLine] [LeadingSpace]    Loc=<main.m:9:5><br>return ‘return’     [StartOfLine] [LeadingSpace]    Loc=<main.m:10:5><br>numeric_constant ‘0’     [LeadingSpace]    Loc=<main.m:10:12><br>semi ‘;’        Loc=<main.m:10:13><br>r_brace ‘}’     [StartOfLine]    Loc=<main.m:11:1><br>eof ‘’        Loc=<main.m:11:2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=&lt;main.m:11:1&gt; 这个样的具体位置。</div><div class="line"></div><div class="line">接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。打印语法树的命令</div></pre></td></tr></table></figure></main.m:11:2></main.m:11:1></main.m:10:13></main.m:10:12></main.m:10:5></main.m:9:5></main.m:8:26></main.m:8:25></main.m:8:24></main.m:8:23></main.m:8:16></main.m:8:15></main.m:8:14></main.m:8:9></main.m:7:29></main.m:7:24></main.m:7:23></main.m:7:21></main.m:7:19></main.m:7:18></main.m:7:9></main.m:6:22></main.m:6:6></main.m:6:5></main.m:5:12></main.m:5:10></main.m:5:9></main.m:5:5></main.m:5:1></main.m:2:1></p>
<p>clang -fmodules -fsyntax-only -Xclang -ast-dump main.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出结果</div></pre></td></tr></table></figure></p>
<p>TranslationUnitDecl 0x7fa80f018ad0 &lt;<invalid sloc="">&gt; <invalid sloc=""><br>|-TypedefDecl 0x7fa80f018fc8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit <strong>int128_t ‘</strong>int128’<br>| <code>-BuiltinType 0x7fa80f018d20 &#39;__int128&#39;
|-TypedefDecl 0x7fa80f019028 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t &#39;unsigned __int128&#39;
|</code>-BuiltinType 0x7fa80f018d40 ‘unsigned <strong>int128’<br>|-TypedefDecl 0x7fa80f0190b8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit SEL ‘SEL <em>‘<br>| `-PointerType 0x7fa80f019080 ‘SEL </em>‘<br>|   <code>-BuiltinType 0x7fa80f018f30 &#39;SEL&#39;
|-TypedefDecl 0x7fa80f019198 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit id &#39;id&#39;
|</code>-ObjCObjectPointerType 0x7fa80f019140 ‘id’ imported<br>|   <code>-ObjCObjectType 0x7fa80f019110 &#39;id&#39; imported
|-TypedefDecl 0x7fa80f019278 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit Class &#39;Class&#39;
|</code>-ObjCObjectPointerType 0x7fa80f019220 ‘Class’<br>|   `-ObjCObjectType 0x7fa80f0191f0 ‘Class’<br>|-ObjCInterfaceDecl 0x7fa80f0192c8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit Protocol<br>|-TypedefDecl 0x7fa80f019618 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit </invalid></invalid></invalid></invalid></invalid></invalid></strong>NSConstantString ‘struct <strong>NSConstantString_tag’<br>| `-RecordType 0x7fa80f019430 ‘struct </strong>NSConstantString_tag’<br>|   <code>-Record 0x7fa80f019390 &#39;__NSConstantString_tag&#39;
|-TypedefDecl 0x7fa80f0196a8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list &#39;char *&#39;
|</code>-PointerType 0x7fa80f019670 ‘char <em>‘<br>|   <code>-BuiltinType 0x7fa80f018b60 &#39;char&#39;
|-TypedefDecl 0x7fa80f047978 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list &#39;struct __va_list_tag [1]&#39;
|</code>-ConstantArrayType 0x7fa80f047920 ‘struct <strong>va_list_tag [1]’ 1<br>|   `-RecordType 0x7fa80f0197a0 ‘struct </strong>va_list_tag’<br>|     <code>-Record 0x7fa80f0196f8 &#39;__va_list_tag&#39;
|-ImportDecl 0x7fa80f0486b0 &lt;main.m:2:1&gt; col:1 implicit Foundation
|-FunctionDecl 0x7fa80f048738 &lt;line:5:1, line:11:1&gt; line:5:5 main &#39;int ()&#39;
|</code>-CompoundStmt 0x7fa80f393998 <col:12, line:11:1=""><br>|   |-ObjCAutoreleasePoolStmt 0x7fa80f393950 <line:6:5, line:9:5=""><br>|   | <code>-CompoundStmt 0x7fa80f393928 &lt;line:6:22, line:9:5&gt;
|   |   |-DeclStmt 0x7fa80f3a3b38 &lt;line:7:9, col:29&gt;
|   |   |</code>-VarDecl 0x7fa80f3a3580 <col:9, col:24=""> col:19 used a ‘NSString </col:9,></line:6:5,></col:12,></em>‘ cinit<br>|   |   |   <code>-ObjCStringLiteral 0x7fa80f3a3648 &lt;col:23, col:24&gt; &#39;NSString *&#39;
|   |   |</code>-StringLiteral 0x7fa80f3a3618 <col:24> ‘char [4]’ lvalue “aaa”<br>|   |   <code>-CallExpr 0x7fa80f3938c0 &lt;line:8:9, col:25&gt; &#39;void&#39;
|   |     |-ImplicitCastExpr 0x7fa80f3938a8 &lt;col:9&gt; &#39;void (*)(id, ...)&#39; &lt;FunctionToPointerDecay&gt;
|   |     |</code>-DeclRefExpr 0x7fa80f3a3b50 <col:9> ‘void (id, …)’ Function 0x7fa80f3a3670 ‘NSLog’ ‘void (id, …)’<br>|   |     |-ImplicitCastExpr 0x7fa80f3938f8 <col:15, col:16=""> ‘id’:’id’ <bitcast><br>|   |     | <code>-ObjCStringLiteral 0x7fa80f393800 &lt;col:15, col:16&gt; &#39;NSString *&#39;
|   |     |</code>-StringLiteral 0x7fa80f3a3bb8 <col:16> ‘char [6]’ lvalue “hi %@”<br>|   |     <code>-ImplicitCastExpr 0x7fa80f393910 &lt;col:24&gt; &#39;NSString *&#39; &lt;LValueToRValue&gt;
|   |</code>-DeclRefExpr 0x7fa80f393820 <col:24> ‘NSString <em>‘ lvalue Var 0x7fa80f3a3580 ‘a’ ‘NSString </em>‘<br>|   <code>-ReturnStmt 0x7fa80f393980 &lt;line:10:5, col:12&gt;
|</code>-IntegerLiteral 0x7fa80f393960 <col:12> ‘int’ 0<br>`-<undeserialized declarations=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。</div><div class="line"></div><div class="line">clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。</div><div class="line"></div><div class="line">可以通过 clang --analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib / StaticAnalyzer / Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker</div></pre></td></tr></table></figure></undeserialized></col:12></col:24></col:16></bitcast></col:15,></col:9></col:24></invalid></invalid></invalid></invalid></p>
<p>debug.ConfigDumper              Dump config table<br>debug.DumpCFG                   Display Control-Flow Graphs<br>debug.DumpCallGraph             Display Call Graph<br>debug.DumpCalls                 Print calls as they are traversed by the engine<br>debug.DumpDominators            Print the dominance tree for a given CFG<br>debug.DumpLiveVars              Print results of live variable analysis<br>debug.DumpTraversal             Print branch conditions as they are traversed by the engine<br>debug.ExprInspection            Check the analyzer’s understanding of expressions<br>debug.Stats                     Emit warnings with analyzer statistics<br>debug.TaintTest                 Mark tainted symbols as such.<br>debug.ViewCFG                   View Control-Flow Graphs using GraphViz<br>debug.ViewCallGraph             View Call Graph using GraphViz<br>debug.ViewExplodedGraph         View Exploded Graphs using GraphViz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。</div><div class="line"></div><div class="line">clang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。</div><div class="line"></div><div class="line">编译的概念（词法-&gt;语法-&gt;语义-&gt;IR-&gt;优化-&gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。</div><div class="line"></div><div class="line">clang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。</div><div class="line"></div><div class="line">整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf 在clang里的具体实现代码可以查看这两个文件 [MemRegion.h](https://code.woboq.org/llvm/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h.html)和 [RegionStore.cpp](https://code.woboq.org/llvm/clang/lib/StaticAnalyzer/Core/RegionStore.cpp.html) 。</div><div class="line"></div><div class="line">下面举个简单例子看看 clang static  analyzer 是如何对源码进行模拟的。</div><div class="line">```c</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int a;</div><div class="line">	int b = 10;</div><div class="line">	a = b;</div><div class="line">	return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的 AST 以及 CFG<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#----------------AST-------------------</div><div class="line"># clang -cc1 -ast-dump</div><div class="line">TranslationUnitDecl 0xc75b450 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</div><div class="line">|-TypedefDecl 0xc75b740 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list &apos;char *&apos;</div><div class="line">`-FunctionDecl 0xc75b7b0 &lt;test.cpp:1:1, line:7:1&gt; line:1:5 main &apos;int (void)&apos;</div><div class="line">  `-CompoundStmt 0xc75b978 &lt;line:2:1, line:7:1&gt;</div><div class="line">    |-DeclStmt 0xc75b870 &lt;line:3:2, col:7&gt;</div><div class="line">    | `-VarDecl 0xc75b840 &lt;col:2, col:6&gt; col:6 used a &apos;int&apos;</div><div class="line">    |-DeclStmt 0xc75b8d8 &lt;line:4:2, col:12&gt;</div><div class="line">    | `-VarDecl 0xc75b890 &lt;col:2, col:10&gt; col:6 used b &apos;int&apos; cinit</div><div class="line">    |   `-IntegerLiteral 0xc75b8c0 &lt;col:10&gt; &apos;int&apos; 10</div><div class="line"></div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; a = b &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">    |-BinaryOperator 0xc75b928 &lt;line:5:2, col:6&gt; &apos;int&apos; lvalue &apos;=&apos;</div><div class="line">    | |-DeclRefExpr 0xc75b8e8 &lt;col:2&gt; &apos;int&apos; lvalue Var 0xc75b840 &apos;a&apos; &apos;int&apos;</div><div class="line">    | `-ImplicitCastExpr 0xc75b918 &lt;col:6&gt; &apos;int&apos; &lt;LValueToRValue&gt;</div><div class="line">    |   `-DeclRefExpr 0xc75b900 &lt;col:6&gt; &apos;int&apos; lvalue Var 0xc75b890 &apos;b&apos; &apos;int&apos;</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line"></div><div class="line">    `-ReturnStmt 0xc75b968 &lt;line:6:2, col:9&gt;</div><div class="line">      `-ImplicitCastExpr 0xc75b958 &lt;col:9&gt; &apos;int&apos; &lt;LValueToRValue&gt;</div><div class="line">        `-DeclRefExpr 0xc75b940 &lt;col:9&gt; &apos;int&apos; lvalue Var 0xc75b840 &apos;a&apos; &apos;int&apos;</div><div class="line">#----------------CFG-------------------</div><div class="line"># clang -cc1 -analyze -analyzer-checker=debug.DumpCFG</div><div class="line">int main()</div><div class="line"> [B2 (ENTRY)]</div><div class="line">   Succs (1): B1</div><div class="line"></div><div class="line"> [B1]</div><div class="line">   1: int a;</div><div class="line">   2: 10</div><div class="line">   3: int b = 10;</div><div class="line">   4: b</div><div class="line">   5: [B1.4] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">   6: a</div><div class="line">   7: [B1.6] = [B1.5]</div><div class="line">   8: a</div><div class="line">   9: [B1.8] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">  10: return [B1.9];</div><div class="line">   Preds (1): B2</div><div class="line">   Succs (1): B0</div><div class="line"></div><div class="line"> [B0 (EXIT)]</div><div class="line">   Preds (1): B1</div></pre></td></tr></table></figure></p>
<p>CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。</p>
<p>在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。</p>
<p>官方 AST 相关文档</p>
<ul>
<li><a href="http://clang.llvm.org/docs/Tooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/Tooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="external">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></li>
<li><a href="http://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="external">http://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibTooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibTooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibASTMatchers.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibASTMatchers.html</a></li>
</ul>
<h2 id="CodeGen-生成-IR-代码"><a href="#CodeGen-生成-IR-代码" class="headerlink" title="CodeGen 生成 IR 代码"></a>CodeGen 生成 IR 代码</h2><p>将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。</p>
<p>这个过程中还会跟 runtime 桥接。</p>
<ul>
<li>各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。</li>
<li>Non-Fragile ABI 合成 OBJC<em>IVAR</em>$_ 偏移值常量。</li>
<li>ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。</li>
<li>strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。</li>
<li>@synthesize 的处理。</li>
<li>生成 block_layout 数据结构</li>
<li><strong>block 和 </strong>weak</li>
<li>_block_invoke</li>
<li>ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。</li>
</ul>
<h2 id="Clang-Attributes"><a href="#Clang-Attributes" class="headerlink" title="Clang Attributes"></a>Clang Attributes</h2><p>以 <strong>attribute</strong>(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法：</p>
<h3 id="attribute-format-NSString-F-A-格式化字符串"><a href="#attribute-format-NSString-F-A-格式化字符串" class="headerlink" title="attribute((format(NSString, F, A))) 格式化字符串"></a><strong>attribute</strong>((format(<strong>NSString</strong>, F, A))) 格式化字符串</h3><p>可以查看 NSLog 的用法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_EXPORT <span class="keyword">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...) <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="built_in">NS_NO_TAIL_CALL</span>;</div><div class="line"></div><div class="line"><span class="comment">// Marks APIs which format strings by taking a format string and optional varargs as arguments</span></div><div class="line"><span class="meta">#if !defined(NS_FORMAT_FUNCTION)</span></div><div class="line">    <span class="meta">#if (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED)</span></div><div class="line">	<span class="meta">#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</span></div><div class="line">    <span class="meta">#else</span></div><div class="line">	<span class="meta">#define NS_FORMAT_FUNCTION(F,A)</span></div><div class="line">    <span class="meta">#endif</span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure></p>
<h3 id="attribute-deprecated-s-版本弃用提示"><a href="#attribute-deprecated-s-版本弃用提示" class="headerlink" title="attribute((deprecated(s))) 版本弃用提示"></a><strong>attribute</strong>((deprecated(s))) 版本弃用提示</h3><p>在编译过程中能够提示开发者该方法或者属性已经被弃用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)preMethod:( <span class="built_in">NSString</span> *)string __attribute__((deprecated(<span class="string">"preMethod已经被弃用，请使用newMethod"</span>)));</div><div class="line">- (<span class="keyword">void</span>)deprecatedMethod DEPRECATED_ATTRIBUTE; <span class="comment">//也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏</span></div></pre></td></tr></table></figure></p>
<h3 id="attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-””-VA-ARGS-指明使用版本范围"><a href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-””-VA-ARGS-指明使用版本范围" class="headerlink" title="attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=”” VA_ARGS))) 指明使用版本范围"></a><strong>attribute</strong>((availability(os,introduced=m,deprecated=n, obsoleted=o,message=”” <strong>VA_ARGS</strong>))) 指明使用版本范围</h3><p>os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)method __attribute__((availability(ios,introduced=<span class="number">3</span>_0,deprecated=<span class="number">6</span>_0,obsoleted=<span class="number">7</span>_0,message=<span class="string">"iOS3到iOS7版本可用，iOS7不能用"</span>)));</div></pre></td></tr></table></figure></p>
<h3 id="attribute-unavailable-…-方法不可用提示"><a href="#attribute-unavailable-…-方法不可用提示" class="headerlink" title="attribute((unavailable(…))) 方法不可用提示"></a><strong>attribute</strong>((unavailable(…))) 方法不可用提示</h3><p>这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。</p>
<h3 id="attribute-unused"><a href="#attribute-unused" class="headerlink" title="attribute((unused))"></a><strong>attribute</strong>((unused))</h3><p>没有被使用也不报警告</p>
<h3 id="attribute-warn-unused-result"><a href="#attribute-warn-unused-result" class="headerlink" title="attribute((warn_unused_result))"></a><strong>attribute</strong>((<strong>warn_unused_result</strong>))</h3><p>不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。</p>
<h3 id="attribute-availability-swift-unavailable-message-msg"><a href="#attribute-availability-swift-unavailable-message-msg" class="headerlink" title="attribute((availability(swift, unavailable, message=_msg)))"></a><strong>attribute</strong>((<strong>availability</strong>(swift, unavailable, message=_msg)))</h3><p>OC 的方法不能在 Swift 中使用。</p>
<h3 id="attribute-cleanup-…-作用域结束时自动执行一个指定方法"><a href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法" class="headerlink" title="attribute((cleanup(…))) 作用域结束时自动执行一个指定方法"></a><strong>attribute</strong>((cleanup(…))) 作用域结束时自动执行一个指定方法</h3><p>作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。</p>
<p>Reactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define onExit \</span></div><div class="line">    rac_keywordify \</div><div class="line">    __<span class="keyword">strong</span> rac_cleanupBlock_t metamacro_concat(rac_exitBlock_, __LINE__) __attribute__((cleanup(rac_executeCleanupBlock), unused)) = ^</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> rac_executeCleanupBlock (__<span class="keyword">strong</span> rac_cleanupBlock_t *block) &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (property != <span class="literal">NULL</span>) &#123;</div><div class="line">		rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property);</div><div class="line">		<span class="keyword">if</span> (attributes != <span class="literal">NULL</span>) &#123;</div><div class="line">			@onExit &#123;</div><div class="line">				free(attributes);</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			<span class="built_in">BOOL</span> isObject = attributes-&gt;objectClass != <span class="literal">nil</span> || strstr(attributes-&gt;type, <span class="keyword">@encode</span>(<span class="keyword">id</span>)) == attributes-&gt;type;</div><div class="line">			<span class="built_in">BOOL</span> isProtocol = attributes-&gt;objectClass == <span class="built_in">NSClassFromString</span>(<span class="string">@"Protocol"</span>);</div><div class="line">			<span class="built_in">BOOL</span> isBlock = strcmp(attributes-&gt;type, <span class="keyword">@encode</span>(<span class="keyword">void</span>(^)())) == <span class="number">0</span>;</div><div class="line">			<span class="built_in">BOOL</span> isWeak = attributes-&gt;<span class="keyword">weak</span>;</div><div class="line"></div><div class="line">			shouldAddDeallocObserver = isObject &amp;&amp; isWeak &amp;&amp; !isBlock &amp;&amp; !isProtocol;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。</p>
<h3 id="attribute-overloadable-方法重载"><a href="#attribute-overloadable-方法重载" class="headerlink" title="attribute((overloadable)) 方法重载"></a><strong>attribute</strong>((overloadable)) 方法重载</h3><p>能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">__attribute__((overloadable)) <span class="keyword">void</span> printArgument(<span class="keyword">int</span> number)&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Add Int %i"</span>, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) <span class="keyword">void</span> printArgument(<span class="built_in">NSString</span> *number)&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Add NSString %@"</span>, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) <span class="keyword">void</span> printArgument(<span class="built_in">NSNumber</span> *number)&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Add NSNumber %@"</span>, number);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="attribute-objc-designated-initializer-指定内部实现的初始化方法"><a href="#attribute-objc-designated-initializer-指定内部实现的初始化方法" class="headerlink" title="attribute((objc_designated_initializer)) 指定内部实现的初始化方法"></a><strong>attribute</strong>((objc_designated_initializer)) 指定内部实现的初始化方法</h3><ul>
<li>如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。</li>
<li>如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。</li>
</ul>
<h3 id="attribute-objc-subclassing-restricted-指定不能有子类"><a href="#attribute-objc-subclassing-restricted-指定不能有子类" class="headerlink" title="attribute((objc_subclassing_restricted)) 指定不能有子类"></a><strong>attribute</strong>((objc_subclassing_restricted)) 指定不能有子类</h3><p>相当于 Java 里的 final 关键字，如果有子类继承就会出错。</p>
<h3 id="attribute-objc-requires-super-子类继承必须调用-super"><a href="#attribute-objc-requires-super-子类继承必须调用-super" class="headerlink" title="attribute((objc_requires_super)) 子类继承必须调用 super"></a><strong>attribute</strong>((objc_requires_super)) 子类继承必须调用 super</h3><p>声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。</p>
<h3 id="attribute-const-重复调用相同数值参数优化返回"><a href="#attribute-const-重复调用相同数值参数优化返回" class="headerlink" title="attribute((const)) 重复调用相同数值参数优化返回"></a><strong>attribute</strong>((const)) 重复调用相同数值参数优化返回</h3><p>用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。</p>
<h3 id="attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><a href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY" class="headerlink" title="attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))"></a><strong>attribute</strong>((constructor(PRIORITY))) 和 <strong>attribute</strong>((destructor(PRIORITY)))</h3><p>PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。</p>
<p>通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。</p>
<h2 id="Clang-警告处理"><a href="#Clang-警告处理" class="headerlink" title="Clang 警告处理"></a>Clang 警告处理</h2><p>先看看这个<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">        sizeLabel = [<span class="keyword">self</span> sizeWithFont:font constrainedToSize:size lineBreakMode:<span class="built_in">NSLineBreakByWordWrapping</span>];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div></pre></td></tr></table></figure></p>
<p>如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p>
<h2 id="使用-libclang-来进行语法分析"><a href="#使用-libclang-来进行语法分析" class="headerlink" title="使用 libclang 来进行语法分析"></a>使用 libclang 来进行语法分析</h2><p>使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。</p>
<p>使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js / ruby binding，还有 Objective-C的开源库 <a href="https://github.com/macmade/ClangKit" target="_blank" rel="external">GitHub - macmade/ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented.</a> 。</p>
<p>写个 python 脚本来调用 clang<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pip install clang</div><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># vim: set fileencoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> clang.cindex</div><div class="line"><span class="keyword">import</span> asciitree</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node_children</span><span class="params">(node)</span>:</span></div><div class="line">    <span class="keyword">return</span> (c <span class="keyword">for</span> c <span class="keyword">in</span> node.get_children() <span class="keyword">if</span> c.location.file == sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_node</span><span class="params">(node)</span>:</span></div><div class="line">    text = node.spelling <span class="keyword">or</span> node.displayname</div><div class="line">    kind = str(node.kind)[str(node.kind).index(<span class="string">'.'</span>)+<span class="number">1</span>:]</div><div class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125; &#123;&#125;'</span>.format(kind, text)</div><div class="line"></div><div class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</div><div class="line">    print(<span class="string">"Usage: dump_ast.py [header file name]"</span>)</div><div class="line">    sys.exit()</div><div class="line"></div><div class="line">clang.cindex.Config.set_library_file(<span class="string">'/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib'</span>)</div><div class="line">index = clang.cindex.Index.create()</div><div class="line">translation_unit = index.parse(sys.argv[<span class="number">1</span>], [<span class="string">'-x'</span>, <span class="string">'objective-c'</span>])</div><div class="line"></div><div class="line"><span class="keyword">print</span> asciitree.draw_tree(translation_unit.cursor,</div><div class="line">                          <span class="keyword">lambda</span> n: list(n.get_children()),</div><div class="line">                          <span class="keyword">lambda</span> n: <span class="string">"%s (%s)"</span> % (n.spelling <span class="keyword">or</span> n.displayname, str(n.kind).split(<span class="string">"."</span>)[<span class="number">1</span>]))</div></pre></td></tr></table></figure></p>
<p>基于语法树的分析还可以针对字符串做加密。</p>
<h2 id="LibTooling-对语法树完全的控制"><a href="#LibTooling-对语法树完全的控制" class="headerlink" title="LibTooling 对语法树完全的控制"></a>LibTooling 对语法树完全的控制</h2><p>因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。</p>
<ul>
<li>可以改变 clang 生成代码的方式。</li>
<li>增加更强的类型检查。</li>
<li>按照自己的定义进行代码的检查分析。</li>
<li>对源码做任意类型分析，甚至重写程序。</li>
<li>给 clang 添加一些自定义的分析，创建自己的重构器。</li>
<li>基于现有代码做出大量的修改。</li>
<li>基于工程生成相关图形或文档。</li>
<li>检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者  Swift 。</li>
</ul>
<p>官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： <a href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="external">Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation</a></p>
<p>按照说明编译完成后进入 LLVM 的目录 ~/llvm/tools/clang/tools/ 在这了可以创建自己的 clang 工具。这里有个范例： <a href="https://github.com/objcio/issue-6-compiler-tool" target="_blank" rel="external">GitHub - objcio/issue-6-compiler-tool: Example code for a standalone clang/llvm tool.</a> 可以直接 make 成一个二进制文件。</p>
<p>下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Observer</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)observerWithTarget:(<span class="keyword">id</span>)target action:(SEL)selector;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">VisitObjCMessageExpr</span><span class="params">(ObjCMessageExpr *E)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) &#123;</div><div class="line">    QualType ReceiverType = E-&gt;getClassReceiver();</div><div class="line">    Selector Sel = E-&gt;getSelector();</div><div class="line">    <span class="built_in">string</span> TypeName = ReceiverType.getAsString();</div><div class="line">    <span class="built_in">string</span> SelName = Sel.getAsString();</div><div class="line">    <span class="keyword">if</span> (TypeName == <span class="string">"Observer"</span> &amp;&amp; SelName == <span class="string">"observerWithTarget:action:"</span>) &#123;</div><div class="line">      Expr *Receiver = E-&gt;getArg(<span class="number">0</span>)-&gt;IgnoreParenCasts();</div><div class="line">      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(<span class="number">1</span>)-&gt;IgnoreParenCasts());</div><div class="line">      Selector Sel = SelExpr-&gt;getSelector();</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">const</span> ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) &#123;</div><div class="line">        ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl();</div><div class="line">        <span class="keyword">if</span> (! decl-&gt;lookupInstanceMethod(Sel)) &#123;</div><div class="line">          errs() &lt;&lt; <span class="string">"Warning: class "</span> &lt;&lt; TypeName &lt;&lt; <span class="string">" does not implement selector "</span> &lt;&lt; Sel.getAsString() &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">          SourceLocation Loc = E-&gt;getExprLoc();</div><div class="line">          PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc);</div><div class="line">          errs() &lt;&lt; <span class="string">"in "</span> &lt;&lt; PLoc.getFilename() &lt;&lt; <span class="string">" &lt;"</span> &lt;&lt; PLoc.getLine() &lt;&lt; <span class="string">":"</span> &lt;&lt; PLoc.getColumn() &lt;&lt; <span class="string">"&gt;\n"</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ClangPlugin"><a href="#ClangPlugin" class="headerlink" title="ClangPlugin"></a>ClangPlugin</h2><p>通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm/tools/clang/tools</p>
<p>动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库  <a href="https://lmsgsendnilself.github.io/blog/2017/02/28/clangtojszi-yuan/" target="_blank" rel="external">clangtojs资源 - Lmsgsendnilself</a> ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： <a href="http://slides.com/sunnyxx/calling-conventions-in-cocoa#/" target="_blank" rel="external">Calling Conventions in Cocoa by sunnyxx</a> bang 也有篇文章： <a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="external">如何动态调用 C 函数 «  bang’s blog</a>  。</p>
<p>这三个方案作者都分别写了文章详细说明其实现方案。</p>
<ul>
<li><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">JSPatch实现原理详解 «  bang’s blog</a></li>
<li><a href="http://mp.weixin.qq.com/s/qRW_akbU3TSd0SxpF3iQmQ" target="_blank" rel="external">DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航</a></li>
<li><a href="http://www.jianshu.com/p/6c756ce76758" target="_blank" rel="external">OCS——史上最疯狂的iOS动态化方案 - 简书</a></li>
</ul>
<p>滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 <a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651112856&amp;idx=1&amp;sn=b2c74c62a10b4c9a4e7538d1ad7eb739" target="_blank" rel="external">《基于clang插件的一种iOS包大小瘦身方案》</a></p>
<p>那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。</p>
<ul>
<li>收集一些如何使用 clang 库的例子：<a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li>在 Xcode 中添加 clang 静态分析自定义 checks： <a href="http://clang-analyzer.llvm.org/xcode.html" target="_blank" rel="external">Running the analyzer within Xcode</a></li>
<li>将 LLVM C 的 API 用 swift 来包装： <a href="https://github.com/harlanhaskins/LLVMSwift" target="_blank" rel="external">GitHub - harlanhaskins/LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1</a></li>
</ul>
<h2 id="Swift-编译流"><a href="#Swift-编译流" class="headerlink" title="Swift 编译流"></a>Swift 编译流</h2><p>Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C/OC 进行交互。</p>
<p>下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"hi!"</span>)</div></pre></td></tr></table></figure></p>
<p>生成程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc toy.swift</div><div class="line">./toy</div></pre></td></tr></table></figure></p>
<p>生成检查 AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -dump-ast toy.swift</div></pre></td></tr></table></figure></p>
<p>可以还原之前函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-silgen toy.swift | xcrun swift-demangle</div></pre></td></tr></table></figure></p>
<p>llvm ir 和汇编的生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-ir toy.swift</div><div class="line">swiftc -emit-assembly toy.swift</div></pre></td></tr></table></figure></p>
<p>生成可执行的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk macosx swiftc toy.swift -o toy</div></pre></td></tr></table></figure></p>
<h2 id="编译后生成的二进制内容-Link-Map-File"><a href="#编译后生成的二进制内容-Link-Map-File" class="headerlink" title="编译后生成的二进制内容 Link Map File"></a>编译后生成的二进制内容 Link Map File</h2><p>在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容</p>
<h3 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h3><p>这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。</p>
<h3 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h3><p>这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 <strong>TEXT 代码段和 </strong>DATA 数据段两种。</p>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>Symbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。</p>
<h2 id="每次编译后生成的-dSYM-文件"><a href="#每次编译后生成的-dSYM-文件" class="headerlink" title="每次编译后生成的 dSYM 文件"></a>每次编译后生成的 dSYM 文件</h2><p>在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。</p>
<p>可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。</p>
<p>还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</div><div class="line">symbolicatecrash appName.crash appName.app &gt; appName.log</div></pre></td></tr></table></figure></p>
<h2 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h2><p>记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。</p>
<p>Mach-O 文件包含三个区域</p>
<ul>
<li>Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等</li>
<li>Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。</li>
<li>Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。</li>
</ul>
<h3 id="Mach-O-文件的解析"><a href="#Mach-O-文件的解析" class="headerlink" title="Mach-O 文件的解析"></a>Mach-O 文件的解析</h3><p>再通过一个例子来分析下：<br>这次用 xcrun 来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -v</div></pre></td></tr></table></figure></p>
<p>先创建一个test.c的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch test.c</div></pre></td></tr></table></figure></p>
<p>编辑里面的内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vi test.c</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hi there!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行，没有起名默认为 a.out<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang test.c</div><div class="line">./a.out</div></pre></td></tr></table></figure></p>
<p>a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -S -o - test.c | open -f</div></pre></td></tr></table></figure></p>
<p>输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.section	__TEXT,__text,regular,pure_instructions</div><div class="line">.macosx_version_min 10, 12</div><div class="line">.globl	_main</div><div class="line">.align	4, 0x90</div></pre></td></tr></table></figure></p>
<p>.section 指令指定接下来执行哪一个段。</p>
<p>.globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。</p>
<p>.align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。</p>
<p>看看接下来的 main 函数头部部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_main:                                  ## @main</div><div class="line">	.cfi_startproc</div><div class="line">## BB#0:</div><div class="line">	pushq	%rbp</div><div class="line">Ltmp0:</div><div class="line">	.cfi_def_cfa_offset 16</div><div class="line">Ltmp1:</div><div class="line">	.cfi_offset %rbp, -16</div><div class="line">	movq	%rsp, %rbp</div><div class="line">Ltmp2:</div><div class="line">	.cfi_def_cfa_register %rbp</div><div class="line">	subq	$32, %rsp</div></pre></td></tr></table></figure></p>
<p>_main 是函数开始的地址，二进制文件会有这个位置的引用。</p>
<p>.cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in / out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。</p>
<p>pushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。</p>
<p>.cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。</p>
<p>movq %rsp, %rbp 把局部变量放到栈上。</p>
<p>subq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。</p>
<p>再看看 printf()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">leaq	L_.str(%rip), %rax</div><div class="line">movl	$0, -4(%rbp)</div><div class="line">movl	%edi, -8(%rbp)</div><div class="line">movq	%rsi, -16(%rbp)</div><div class="line">movq	%rax, %rdi</div><div class="line">movb	$0, %al</div><div class="line">callq	_printf</div></pre></td></tr></table></figure></p>
<p>leap 会将 L<em>.str 这个指针加载到 rax 寄存器里。可以看看 L</em>.str 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div></pre></td></tr></table></figure></p>
<p>这个就是我们代码文件里定义的那个字符串。</p>
<p>这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。</p>
<p>当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。</p>
<p>printf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。</p>
<p>接下来看看返回和函数的结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xorl	%ecx, %ecx</div><div class="line">movl	%eax, -20(%rbp)         ## 4-byte Spill</div><div class="line">movl	%ecx, %eax</div><div class="line">addq	$32, %rsp</div><div class="line">popq	%rbp</div><div class="line">retq</div><div class="line">.cfi_endproc</div></pre></td></tr></table></figure></p>
<p>xorl    %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。</p>
<p>函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。</p>
<p>接下来是字符串输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	.section	__TEXT,__cstring,cstring_literals</div><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div><div class="line"></div><div class="line">.subsections_via_symbols</div></pre></td></tr></table></figure></p>
<p>同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。</p>
<p>接下来通过 size 工具来看看 a.out 里的 section。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun size -x -l -m a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</div><div class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</div><div class="line">	Section __text: 0x34 (addr 0x100000f50 offset 3920)</div><div class="line">	Section __stubs: 0x6 (addr 0x100000f84 offset 3972)</div><div class="line">	Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980)</div><div class="line">	Section __cstring: 0xa (addr 0x100000fa6 offset 4006)</div><div class="line">	Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016)</div><div class="line">	total 0xa6</div><div class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</div><div class="line">	Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</div><div class="line">	Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</div><div class="line">	total 0x18</div><div class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</div><div class="line">total 0x100003000</div></pre></td></tr></table></figure>
<p>可以看出有四个 segment 和多个section。</p>
<p>在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。</p>
<p>__PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。</p>
<p>__TEXT segment 包含被执行的代码以只读和可执行的方式映射。</p>
<ul>
<li>__text section 包含编译后的机器码。</li>
<li><strong>stubs 和 </strong>stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。</li>
<li>__cstring 可执行文件中的字符串。</li>
<li>__const 不可变的常量。</li>
</ul>
<p>__DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。</p>
<ul>
<li>__nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 </li>
<li>__la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。</li>
<li>__const 需要重定向的常量，例如 char * const c = “foo”; c指针指向可变的数据。</li>
<li>__bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。</li>
<li>__common 包含外部全局变量。例如在函数外定义 int i;</li>
<li>__dyld 是section占位符，用于动态链接器。</li>
</ul>
<p>更多 section 类型介绍可以查看苹果文档： <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html" target="_blank" rel="external">OS X Assembler Reference</a></p>
<p>接下来用 otool 查看下 section 里的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -s __TEXT __text a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">Contents of (__TEXT,__text) section</div><div class="line">0000000100000f50	55 48 89 e5 48 83 ec 20 48 8d 05 47 00 00 00 c7 </div><div class="line">0000000100000f60	45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 </div><div class="line">0000000100000f70	b0 00 e8 0d 00 00 00 31 c9 89 45 ec 89 c8 48 83 </div><div class="line">0000000100000f80	c4 20 5d c3</div></pre></td></tr></table></figure>
<p>这个返回的内容很难读，加个 - v  就可以查看反汇编代码了， -s <strong>TEXT </strong>text 有个缩写 -t<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -v -t a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">(__TEXT,__text) section</div><div class="line">_main:</div><div class="line">0000000100000f50	pushq	%rbp</div><div class="line">0000000100000f51	movq	%rsp, %rbp</div><div class="line">0000000100000f54	subq	$0x20, %rsp</div><div class="line">0000000100000f58	leaq	0x47(%rip), %rax</div><div class="line">0000000100000f5f	movl	$0x0, -0x4(%rbp)</div><div class="line">0000000100000f66	movl	%edi, -0x8(%rbp)</div><div class="line">0000000100000f69	movq	%rsi, -0x10(%rbp)</div><div class="line">0000000100000f6d	movq	%rax, %rdi</div><div class="line">0000000100000f70	movb	$0x0, %al</div><div class="line">0000000100000f72	callq	0x100000f84</div><div class="line">0000000100000f77	xorl	%ecx, %ecx</div><div class="line">0000000100000f79	movl	%eax, -0x14(%rbp)</div><div class="line">0000000100000f7c	movl	%ecx, %eax</div><div class="line">0000000100000f7e	addq	$0x20, %rsp</div><div class="line">0000000100000f82	popq	%rbp</div><div class="line">0000000100000f83	retq</div></pre></td></tr></table></figure>
<p>看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。</p>
<p>现在来看看可执行文件。</p>
<p>通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -h a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Mach header</div><div class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</div><div class="line">MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    15       1200   NOUNDEFS DYLDLINK TWOLEVEL PIE</div></pre></td></tr></table></figure>
<p>mach_header 结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>      magic;</div><div class="line">  <span class="keyword">cpu_type_t</span>    cputype;</div><div class="line">  <span class="keyword">cpu_subtype_t</span> cpusubtype;</div><div class="line">  <span class="keyword">uint32_t</span>      filetype;</div><div class="line">  <span class="keyword">uint32_t</span>      ncmds;</div><div class="line">  <span class="keyword">uint32_t</span>      sizeofcmds;</div><div class="line">  <span class="keyword">uint32_t</span>      flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -l a.out | open -f</div></pre></td></tr></table></figure></p>
<p>加载命令结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>  cmd;</div><div class="line">  <span class="keyword">uint32_t</span>  cmdsize;</div><div class="line">  <span class="keyword">char</span>      segname[<span class="number">16</span>];</div><div class="line">  <span class="keyword">uint32_t</span>  vmaddr;</div><div class="line">  <span class="keyword">uint32_t</span>  vmsize;</div><div class="line">  <span class="keyword">uint32_t</span>  fileoff;</div><div class="line">  <span class="keyword">uint32_t</span>  filesize;</div><div class="line">  <span class="keyword">vm_prot_t</span> maxprot;</div><div class="line">  <span class="keyword">vm_prot_t</span> initprot;</div><div class="line">  <span class="keyword">uint32_t</span>  nsects;</div><div class="line">  <span class="keyword">uint32_t</span>  flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。</p>
<p>在加载命令里还是看看 <strong>TEXT </strong>text 的section的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Section</div><div class="line">  sectname __text</div><div class="line">   segname __TEXT</div><div class="line">      addr 0x0000000100000f50</div><div class="line">      size 0x0000000000000034</div><div class="line">    offset 3920</div><div class="line">     align 2^4 (16)</div><div class="line">    reloff 0</div><div class="line">    nreloc 0</div><div class="line">      type S_REGULAR</div><div class="line">attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS</div><div class="line"> reserved1 0</div><div class="line"> reserved2 0</div></pre></td></tr></table></figure></p>
<p>addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。</p>
<p>单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。<br>Foo.h<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)say;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>Foo.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"Foo.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)say</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hi there again!\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>SayHi.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"Foo.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</div><div class="line">&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        Foo *foo = [[Foo alloc] init];</div><div class="line">        [foo say];</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先编译多个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang -c Foo.m</div><div class="line">xcrun clang -c SayHi.m</div></pre></td></tr></table></figure></p>
<p>再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang SayHi.o Foo.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</div></pre></td></tr></table></figure></p>
<h3 id="逆向-Mach-O-文件"><a href="#逆向-Mach-O-文件" class="headerlink" title="逆向 Mach-O 文件"></a>逆向 Mach-O 文件</h3><p>需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。</p>
<p>Mobilesubstrate 提供了三个模块来方便开发。</p>
<ul>
<li>MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。</li>
<li>MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook  放在这里就可以了。</li>
<li>Safe mode：类似安全模式，会禁用的改动。</li>
</ul>
<p>先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。</p>
<p>当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。</p>
<ul>
<li>这里有个实例，讲解如何通过逆向实现微信抢红包的插件： <a href="http://dev.qq.com/topic/5791da152168f2690e72daa4" target="_blank" rel="external">【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB</a></li>
<li>入门文章可以看看这篇： <a href="https://github.com/zhengmin1989/MyArticles/tree/master/iOS%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C" target="_blank" rel="external">MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub</a></li>
<li>玩出新花样： <a href="http://blog.imjun.net/2016/10/08/%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%9A%E6%8A%8A%E7%AC%AC%E4%B8%89%E6%96%B9-iOS-%E5%BA%94%E7%94%A8%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/" target="_blank" rel="external">黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog</a>，作者另一篇文章： <a href="http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog</a></li>
</ul>
<h2 id="dyld动态链接"><a href="#dyld动态链接" class="headerlink" title="dyld动态链接"></a>dyld动态链接</h2><p>生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。</p>
<p>用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。</p>
<p>符号表会规定它们的符号，使用 nm 工具看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm SayHi.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _OBJC_CLASS_$_Foo</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush</div><div class="line">                 (undefined) external _objc_msgSend</div><div class="line">0000000000000000 (__TEXT,__text) external _main</div></pre></td></tr></table></figure>
<ul>
<li>_OBJC<em>CLASS</em>$_Foo 表示 Foo 的 OC 符号。</li>
<li>(undefined) external 表示未实现非私有，如果是私有就是 non-external。</li>
<li>external _main 表示 main() 函数，处理 0 地址，将要到 <strong>TEXT,</strong>text section </li>
</ul>
<p>再看看 Foo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm Foo.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject</div><div class="line">                 (undefined) external ___CFConstantStringClassReference</div><div class="line">                 (undefined) external __objc_empty_cache</div><div class="line">0000000000000000 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo</div><div class="line">00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo</div><div class="line">00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo</div><div class="line">0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>因为 undefined 符号表示该文件类未实现的，所以在目标文件和  Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。</p>
<p>链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog (from Foundation)</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</div><div class="line">                 (undefined) external __objc_empty_cache (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</div><div class="line">                 (undefined) external _objc_msgSend (from libobjc)</div><div class="line">                 (undefined) external dyld_stub_binder (from libSystem)</div><div class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</div><div class="line">0000000100000e90 (__TEXT,__text) external _main</div><div class="line">0000000100000f10 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。</p>
<p>通过 otool 可以找到所需库在哪<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -L a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">	/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0)</div><div class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)</div><div class="line">	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0)</div><div class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</div></pre></td></tr></table></figure>
<p>libSystem 里有很多我们熟悉的lib</p>
<ul>
<li>libdispatch：GCD</li>
<li>libsystem_c：C语言库</li>
<li>libsystem_blocks：Block</li>
<li>libcommonCrypto：加密，比如md5</li>
</ul>
<p>dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。</p>
<p>打印什么库被加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(export DYLD_PRINT_LIBRARIES=; ./a.out )</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dyld: loaded: /Users/didi/Downloads/./a.out</div><div class="line">dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</div><div class="line">dyld: loaded: /usr/lib/libSystem.B.dylib</div><div class="line">dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation</div><div class="line">...</div></pre></td></tr></table></figure>
<p>数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。</p>
<p>动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external">Dynamic Linking On OS X</a></p>
<p>dyld 做了些什么事</p>
<ul>
<li>kernel 做启动程序初始准备，开始由dyld负责。</li>
<li>基于非常简单的原始栈为 kernel 设置进程来启动自身。</li>
<li>使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。</li>
<li>立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。</li>
<li>为可执行文件运行静态初始化。</li>
<li>设置参数到可执行文件的 main 函数并调用它。</li>
<li>在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 runtime 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime  会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 Class，按照继承层级依次调用  +load 方法。</li>
<li>在 mian 函数返回后运行 static terminator。</li>
<li>在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。</li>
</ul>
<p>查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="external">RetVal/objc-runtime: objc runtime 706</a> 来进行断点查看调用的 runtime 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  +[someclass load]</div><div class="line">1  call_class_loads()</div><div class="line">2  ::call_load_methods</div><div class="line">3  ::load_images(const char *path __unused, const struct mach_header *mh)</div><div class="line">4  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</div><div class="line">11 _dyld_start</div></pre></td></tr></table></figure>
<p>在  load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。</p>
<p>prepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。</p>
<p>最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。</p>
<p>如果想了解 Cocoa 的 Fundation 库可以通过 <a href="https://github.com/AaronYi/gnustep-base" target="_blank" rel="external">GNUStep</a> 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。</p>
<p>dyld 是开源的： <a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">GitHub - opensource-apple/dyld</a></p>
<p>还可以看看苹果的 WWDC 视频 <a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="external">WWDC 2016 Session 406</a> 里讲解对启动进行优化。</p>
<p>这篇文章也不错： <a href="https://www.codeproject.com/articles/187181/dynamic-linking-of-imported-functions-in-mach-o" target="_blank" rel="external">Dynamic Linking of Imported Functions in Mach-O - CodeProject</a></p>
<h2 id="附：安装编译-LLVM"><a href="#附：安装编译-LLVM" class="headerlink" title="附：安装编译 LLVM"></a>附：安装编译 LLVM</h2><h3 id="多种获取方式"><a href="#多种获取方式" class="headerlink" title="多种获取方式"></a>多种获取方式</h3><ul>
<li>官网：<a href="http://releases.llvm.org/download.html" target="_blank" rel="external">http://releases.llvm.org/download.html</a></li>
<li><p>svn</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#先下载 LLVM</div><div class="line">svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</div><div class="line"></div><div class="line">#在 LLVM 的 tools 目录下下载 Clang</div><div class="line">cd llvm/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</div><div class="line"></div><div class="line">#在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabi</div><div class="line">cd ../projects</div><div class="line">svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi</div><div class="line"></div><div class="line">#在 Clang 的 tools 下安装 extra 工具</div><div class="line">cd ../tools/clang/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</div></pre></td></tr></table></figure>
</li>
<li><p>git</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git clone http://llvm.org/git/llvm.git</div><div class="line">cd llvm/tools</div><div class="line">git clone http://llvm.org/git/clang.git</div><div class="line">cd ../projects</div><div class="line">git clone http://llvm.org/git/compiler-rt.git</div><div class="line">cd ../tools/clang/tools</div><div class="line">git clone http://llvm.org/git/clang-tools-extra.git</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">brew install gcc</div><div class="line">brew install cmake</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake /path/to/llvm/source</div><div class="line">cmake --build .</div><div class="line"></div><div class="line">#如果希望是 xcodeproject 方式 build 可以使用 -GXcode</div><div class="line">mkdir xcodeBuild</div><div class="line">cd xcodeBuild</div><div class="line">cmake cmake -GXcode /path/to/llvm/source</div></pre></td></tr></table></figure>
<p>接下来可以看看 LLVM 的官方教程如何实现一个自己的编程语Kaleidoscope。 <a href="http://llvm.org/docs/tutorial/index.html" target="_blank" rel="external">LLVM Tutorial: Table of Contents — LLVM 5 documentation</a></p>
<p>这里有个使用swift的实现的系列教程<br><a href="https://harlanhaskins.com/2017/01/08/building-a-compiler-with-swift-in-llvm-part-1-introduction-and-the-lexer.html" target="_blank" rel="external">Building a Compiler in Swift with LLVM</a></p>
<h2 id="附：Swift-编译"><a href="#附：Swift-编译" class="headerlink" title="附：Swift 编译"></a>附：Swift 编译</h2><p>官网： <a href="https://github.com/apple/swift" target="_blank" rel="external">GitHub - apple/swift: The Swift Programming Language</a><br>swift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： <a href="https://swift.org/contributing/#contributing-code" target="_blank" rel="external">Swift.org - Contributing</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录</div><div class="line">brew install cmake ninja</div><div class="line">mkdir swiftsource</div><div class="line">cd swiftsource</div><div class="line"></div><div class="line">#clone 下 swift 源码</div><div class="line">git clone https://github.com/apple/swift.git</div><div class="line"></div><div class="line">#checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个</div><div class="line">./swift/utils/update-checkout --clone</div><div class="line"></div><div class="line">#查看文件夹</div><div class="line">du -h -d 1</div><div class="line"></div><div class="line">#build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#更新</div><div class="line">./swift/utils/update-checkout</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#切到指定tag和分支</div><div class="line">#tag</div><div class="line">./swift/utils/update-checkout --tag swift-3.0-RELEASE</div><div class="line">#特定分支</div><div class="line">./swift/utils/update-checkout --scheme swift-3.0-branch</div></pre></td></tr></table></figure>
<p>swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： <a href="https://swift.org/source-code/" target="_blank" rel="external">Swift.org - Source Code</a></p>
<h2 id="附：其它编译工具"><a href="#附：其它编译工具" class="headerlink" title="附：其它编译工具"></a>附：其它编译工具</h2><h3 id="js写的C-解释器JSCPP"><a href="#js写的C-解释器JSCPP" class="headerlink" title="js写的C++解释器JSCPP"></a>js写的C++解释器JSCPP</h3><p>适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：<a href="https://github.com/felixhao28/JSCPP" target="_blank" rel="external">GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript</a></p>
<h2 id="附：资料网址"><a href="#附：资料网址" class="headerlink" title="附：资料网址"></a>附：资料网址</h2><ul>
<li><a href="http://llvm.org" target="_blank" rel="external">http://llvm.org</a></li>
<li><a href="http://clang.llvm.org/" target="_blank" rel="external">http://clang.llvm.org/</a></li>
<li><a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">http://www.aosabook.org/en/llvm.html</a></li>
<li><a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li><a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks" target="_blank" rel="external">Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入剖析-iOS-编译-Clang-LLVM&quot;&gt;&lt;a href=&quot;#深入剖析-iOS-编译-Clang-LLVM&quot; class=&quot;headerlink&quot; title=&quot;深入剖析 iOS 编译 Clang / LLVM&quot;&gt;&lt;/a&gt;深入剖析 iOS 编译 Clang 
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="LLVM" scheme="http://ming1016.github.io/tags/LLVM/"/>
    
      <category term="Clang" scheme="http://ming1016.github.io/tags/Clang/"/>
    
  </entry>
  
  <entry>
    <title>iOS预加载Web页面方案</title>
    <link href="http://ming1016.github.io/2016/11/22/how-to-preload-web-in-ios/"/>
    <id>http://ming1016.github.io/2016/11/22/how-to-preload-web-in-ios/</id>
    <published>2016-11-22T13:55:35.000Z</published>
    <updated>2017-05-27T06:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以先下载Demo看看效果，Github地址：&lt; <a href="https://github.com/ming1016/STMURLCache" target="_blank" rel="external">GitHub - ming1016/STMURLCache: iOS预加载Web页面方案</a> &gt;<br>可以预加载多个网址，然后在离线状态去显示那几个网址，看看是不是都完全缓存下来了。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在需要开启预加载的地方创建<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.sCache = [STMURLCache create:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.whiteListsHost(whiteLists).whiteUserAgent(<span class="string">@"starming"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>这里是所有可设置项目，默认设置可以查看 model 的 get 方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) memoryCapacity;   <span class="comment">//内存容量</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) diskCapacity;     <span class="comment">//本地存储容量</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) cacheTime;        <span class="comment">//缓存时间</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) subDirectory;     <span class="comment">//子目录</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">BOOL</span>)) isDownloadMode;         <span class="comment">//是否启动下载模式</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSArray</span> *)) whiteListsHost;    <span class="comment">//域名白名单</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) whiteUserAgent;   <span class="comment">//WebView的user-agent白名单</span></div><div class="line"></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) addHostWhiteList;        <span class="comment">//添加一个域名白名单</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) addRequestUrlWhiteList;  <span class="comment">//添加请求白名单</span></div><div class="line"></div><div class="line"><span class="comment">//NSURLProtocol相关设置</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">BOOL</span>)) isUsingURLProtocol; <span class="comment">//是否使用NSURLProtocol，默认使用NSURLCache</span></div></pre></td></tr></table></figure></p>
<p>也可以随时更新这些设置项<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.sCache update:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.isDownloadMode(<span class="literal">YES</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>预加载名单可以按照整个 web 页面请求进行预加载<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.sCache preLoadByWebViewWithUrls:@[<span class="string">@"http://www.v2ex.com"</span>,<span class="string">@"http://www.github.com"</span>];</div></pre></td></tr></table></figure></p>
<p>如果需要按照单个资源列表进行预加载可以使用 <em>preLoadByRequestWithUrls</em> 这个方法。</p>
<h2 id="白名单设置"><a href="#白名单设置" class="headerlink" title="白名单设置"></a>白名单设置</h2><p>对于只希望缓存特定域名或者地址的可以通过白名单进行设置，可以在创建时进行设置或者更新时设置。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *whiteListStr = <span class="string">@"www.starming.com|www.github.com|www.v2ex.com|www.baidu.com"</span>;</div><div class="line"><span class="built_in">NSMutableArray</span> *whiteLists = [<span class="built_in">NSMutableArray</span> arrayWithArray:[whiteListStr componentsSeparatedByString:<span class="string">@"|"</span>]];</div><div class="line"><span class="keyword">self</span>.sCache = [STMURLCache create:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.whiteListsHost(whiteLists).whiteUserAgent(<span class="string">@"starming"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>这里的 <em>whiteUserAgent</em> 的设置会设置 webview 的 UserAgent，这样能够让webview以外的网络请求被过滤掉。</p>
<h2 id="基本加载缓存实现原理"><a href="#基本加载缓存实现原理" class="headerlink" title="基本加载缓存实现原理"></a>基本加载缓存实现原理</h2><p>创建 <em>STMURLCache</em> 后设置 <em>NSURLCache</em> 的 <em>URLCache</em> ，在 <em>cachedResponseForRequest</em> 方法中获取 <em>NSURLRequest</em> 判断白名单，检验是否有与之对应的 Cache ，有就使用本地数据返回 <em>NSCachedURLResponse</em> ，没有就通过网络获取数据数据缓存。 <em>STMURLCache</em> 对象释放时将 <em>NSURLCache</em> 设置为不缓存，表示这次预加载完成不需要再缓存。当缓存空间超出设置大小会将其清空。</p>
<p>使用 <em>NSURLProtocol</em> 这种原理基本类似。</p>
<h2 id="白名单实现原理"><a href="#白名单实现原理" class="headerlink" title="白名单实现原理"></a>白名单实现原理</h2><p>创建域名列表设置项 <em>whiteListsHost</em> 和 <em>userAgent</em> 设置项，在创建和更新时对其进行设置。在网络请求开始通过设置项进行过滤。具体实现如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对于域名白名单的过滤</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.whiteListsHost.count &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">id</span> isExist = [<span class="keyword">self</span>.mk.cModel.whiteListsHost objectForKey:[<span class="keyword">self</span> hostFromRequest:request]];</div><div class="line">    <span class="keyword">if</span> (!isExist) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//User-Agent来过滤</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.whiteUserAgent.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">NSString</span> *uAgent = [request.allHTTPHeaderFields objectForKey:<span class="string">@"User-Agent"</span>];</div><div class="line">    <span class="keyword">if</span> (uAgent) &#123;</div><div class="line">        <span class="keyword">if</span> (![uAgent hasSuffix:<span class="keyword">self</span>.mk.cModel.whiteUserAgent]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="具体缓存实现"><a href="#具体缓存实现" class="headerlink" title="具体缓存实现"></a>具体缓存实现</h2><p>缓存的实现有两种，一种是 <em>NSURLCache</em> 另一种是 <em>NSURLProtocol</em> ， <em>STMURLCache</em> 同时支持了这两种，通过 <em>STMURLCacheModel</em> 里的 <em>isUsingURLProtocol</em> 设置项来选择使用哪个。</p>
<h3 id="NSURLCache的实现"><a href="#NSURLCache的实现" class="headerlink" title="NSURLCache的实现"></a>NSURLCache的实现</h3><p>没有缓存的 request 会对其进行请求将获取数据按照hash地址存两份于本地，一份是数据，一份记录时间和类型，时间记录可以用于判断失效时间。对于判断是否有缓存可以根据请求地址对应的文件进行判断。具体实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSCachedURLResponse</span> *)localCacheResponeWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    __block <span class="built_in">NSCachedURLResponse</span> *cachedResponse = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span> filePathFromRequest:request isInfo:<span class="literal">NO</span>];</div><div class="line">    <span class="built_in">NSString</span> *otherInfoPath = [<span class="keyword">self</span> filePathFromRequest:request isInfo:<span class="literal">YES</span>];</div><div class="line">    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</div><div class="line">    <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="keyword">if</span> ([fm fileExistsAtPath:filePath]) &#123;</div><div class="line">        <span class="comment">//有缓存文件的情况</span></div><div class="line">        <span class="built_in">BOOL</span> expire = <span class="literal">false</span>;</div><div class="line">        <span class="built_in">NSDictionary</span> *otherInfo = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:otherInfoPath];</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cacheTime &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSInteger</span> createTime = [[otherInfo objectForKey:<span class="string">@"time"</span>] integerValue];</div><div class="line">            <span class="keyword">if</span> (createTime + <span class="keyword">self</span>.cacheTime &lt; [date timeIntervalSince1970]) &#123;</div><div class="line">                expire = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (expire == <span class="literal">false</span>) &#123;</div><div class="line">            <span class="comment">//从缓存里读取数据</span></div><div class="line">            <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</div><div class="line">            <span class="built_in">NSURLResponse</span> *response = [[<span class="built_in">NSURLResponse</span> alloc] initWithURL:request.URL MIMEType:[otherInfo objectForKey:<span class="string">@"MIMEType"</span>] expectedContentLength:data.length textEncodingName:[otherInfo objectForKey:<span class="string">@"textEncodingName"</span>]];</div><div class="line">            <span class="built_in">NSCachedURLResponse</span> *cachedResponse = [[<span class="built_in">NSCachedURLResponse</span> alloc] initWithResponse:response data:data];</div><div class="line">            <span class="keyword">return</span> cachedResponse;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//cache失效了</span></div><div class="line">            [fm removeItemAtPath:filePath error:<span class="literal">nil</span>];      <span class="comment">//清除缓存data</span></div><div class="line">            [fm removeItemAtPath:otherInfoPath error:<span class="literal">nil</span>]; <span class="comment">//清除缓存其它信息</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//从网络读取</span></div><div class="line">        <span class="keyword">self</span>.isSavedOnDisk = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">id</span> isExist = [<span class="keyword">self</span>.responseDic objectForKey:request.URL.absoluteString];</div><div class="line">        <span class="keyword">if</span> (isExist == <span class="literal">nil</span>) &#123;</div><div class="line">            [<span class="keyword">self</span>.responseDic setValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">TRUE</span>] forKey:request.URL.absoluteString];</div><div class="line">            <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</div><div class="line">            <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">                <span class="keyword">if</span> (error) &#123;</div><div class="line">                    cachedResponse = <span class="literal">nil</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">NSDictionary</span> *dic = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%f"</span>,[date timeIntervalSince1970]],<span class="string">@"time"</span>,response.MIMEType,<span class="string">@"MIMEType"</span>,response.textEncodingName,<span class="string">@"textEncodingName"</span>, <span class="literal">nil</span>];</div><div class="line">                    <span class="built_in">BOOL</span> resultO = [dic writeToFile:otherInfoPath atomically:<span class="literal">YES</span>];</div><div class="line">                    <span class="built_in">BOOL</span> result = [data writeToFile:filePath atomically:<span class="literal">YES</span>];</div><div class="line">                    <span class="keyword">if</span> (resultO == <span class="literal">NO</span> || result == <span class="literal">NO</span>) &#123;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    &#125;</div><div class="line">                    cachedResponse = [[<span class="built_in">NSCachedURLResponse</span> alloc] initWithResponse:response data:data];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            [task resume];</div><div class="line">            <span class="keyword">return</span> cachedResponse;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="NSURLProtocol的实现"><a href="#NSURLProtocol的实现" class="headerlink" title="NSURLProtocol的实现"></a>NSURLProtocol的实现</h3><p>在设置配置项和更新配置项时需要创建一个 <em>STMURLCacheModel</em> 的单例来进行设置和更新配置项给 NSURLProtocol 的实现来使用。通过 isUsingURLProtocol 设置项区分， NSURLProtocol 是通过registerClass方式将protocol实现的进行注册。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (STMURLCache *)configWithMk &#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.mk.cModel.isSavedOnDisk = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.isUsingURLProtocol) &#123;</div><div class="line">        STMURLCacheModel *sModel = [STMURLCacheModel shareInstance];</div><div class="line">        sModel.cacheTime = <span class="keyword">self</span>.mk.cModel.cacheTime;</div><div class="line">        sModel.diskCapacity = <span class="keyword">self</span>.mk.cModel.diskCapacity;</div><div class="line">        sModel.diskPath = <span class="keyword">self</span>.mk.cModel.diskPath;</div><div class="line">        sModel.cacheFolder = <span class="keyword">self</span>.mk.cModel.cacheFolder;</div><div class="line">        sModel.subDirectory = <span class="keyword">self</span>.mk.cModel.subDirectory;</div><div class="line">        sModel.whiteUserAgent = <span class="keyword">self</span>.mk.cModel.whiteUserAgent;</div><div class="line">        sModel.whiteListsHost = <span class="keyword">self</span>.mk.cModel.whiteListsHost;</div><div class="line">        [<span class="built_in">NSURLProtocol</span> registerClass:[STMURLProtocol <span class="keyword">class</span>]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="built_in">NSURLCache</span> setSharedURLCache:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关闭时两者也是不同的，通过设置项进行区分<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.isUsingURLProtocol) &#123;</div><div class="line">        [<span class="built_in">NSURLProtocol</span> unregisterClass:[STMURLProtocol <span class="keyword">class</span>]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSURLCache</span> *c = [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">0</span> diskCapacity:<span class="number">0</span> diskPath:<span class="literal">nil</span>];</div><div class="line">        [<span class="built_in">NSURLCache</span> setSharedURLCache:c];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.mk.cModel checkCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>白名单处理还有读取缓存和前者都类似，但是在缓存Data时 <em>NSURLCached</em> 的方案里是通过发起一次新的请求来获取数据，而 <em>NSURLProtocol</em> 在 <em>NSURLConnection</em> 的 Delegate 里可以获取到，少了一次网络的请求，这里需要注意的是在 - (void) connection:(NSURLConnection <em>)connection didReceiveData:(NSData </em>)data 每次从这个回调里获取的数据不是完整的，要在 - (void) connectionDidFinishLoading:(NSURLConnection *)connection 这个会调里将分段数据拼接成完整的数据保存下来。具体完整的代码实现可以看 STMURLProtocol 里的代码实现。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过 <em>map</em> 网络请求可以缓存请求，也可以 <em>mock</em> 接口请求进行测试。</p>
<p>完整代码：&lt; <a href="https://github.com/ming1016/STMURLCache" target="_blank" rel="external">GitHub - ming1016/STMURLCache: iOS预加载Web页面方案</a> &gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以先下载Demo看看效果，Github地址：&amp;lt; &lt;a href=&quot;https://github.com/ming1016/STMURLCache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub - ming1016/STMURLCach
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="UIWebView" scheme="http://ming1016.github.io/tags/UIWebView/"/>
    
      <category term="NSURLProtocol" scheme="http://ming1016.github.io/tags/NSURLProtocol/"/>
    
  </entry>
  
  <entry>
    <title>使用Swift3开发了个macOS的程序可以检测出objc项目中无用方法，然后一键全部清理</title>
    <link href="http://ming1016.github.io/2016/11/17/use-swift3-build-macos-program-to-clear-unuse-method/"/>
    <id>http://ming1016.github.io/2016/11/17/use-swift3-build-macos-program-to-clear-unuse-method/</id>
    <published>2016-11-17T13:51:58.000Z</published>
    <updated>2017-05-27T06:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>当项目越来越大，引入第三方库越来越多，上架的APP体积也会越来越大，对于用户来说体验必定是不好的。在清理资源，编译选项优化，清理无用类等完成后，能够做而且效果会比较明显的就只有清理无用函数了。现有一种方案是根据Linkmap文件取到objc的所有类方法和实例方法。再用工具逆向可执行文件里引用到的方法名，求个差集列出无用方法。这个方案有些比较麻烦的地方，因为检索出的无用方法没法确定能够直接删除，还需要挨个检索人工判断是否可以删除，这样每次要清理时都需要这样人工排查一遍是非常耗时耗力的。</p>
<p>这样就只有模拟编译过程对代码进行深入分析才能够找出确定能够删除的方法。具体效果可以先试试看，程序代码在：<a href="https://github.com/ming1016/SMCheckProject" target="_blank" rel="external">https://github.com/ming1016/SMCheckProject</a> 选择工程目录后程序就开始检索无用方法然后将其注释掉。</p>
<h2 id="设置结构体-😚"><a href="#设置结构体-😚" class="headerlink" title="设置结构体 😚"></a>设置结构体 😚</h2><p>首先确定结构，类似先把 <em>OC</em> 文件根据语法画出整体结构。先看看 <em>OC Runtime</em> 里是如何设计的结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span>  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*类*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span>  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">long</span> version;</div><div class="line">    <span class="keyword">long</span> info;</div><div class="line">    <span class="keyword">long</span> instance_size;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*成员变量列表*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> ivar_count               </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                    </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> <span class="title">ivar_list</span>[1]</span></div><div class="line">&#125;      </div><div class="line"></div><div class="line">/*成员变量结构体*/</div><div class="line"><span class="title">struct</span> <span class="title">objc_ivar</span> &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name</div><div class="line">    <span class="keyword">char</span> *ivar_type</div><div class="line">    <span class="keyword">int</span> ivar_offset</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space      </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;    </div><div class="line"></div><div class="line"><span class="comment">/*方法列表*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> &#123;</span>  </div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">obsolete</span>;</span></div><div class="line">    <span class="keyword">int</span> method_count;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*方法结构体*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> &#123;</span>  </div><div class="line">    SEL method_name;</div><div class="line">    <span class="keyword">char</span> *method_types;    <span class="comment">/* a string representing argument/return types */</span></div><div class="line">    IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>一个 class 只有少量函数会被调用，为了减少较大的遍历所以创建一个 <em>objc_cache</em> ，在找到一个方法后将 <em>method_name</em> 作为 key，将 <em>method_imp</em> 做值，再次发起时就可以直接在 cache 里找。</p>
<p>使用 swift 创建类似的结构体，做些修改<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">//文件</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="type">FileType</span>.<span class="type">FileH</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> content = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> methods = [<span class="type">Method</span>]() <span class="comment">//所有方法</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> imports = [<span class="type">Import</span>]() <span class="comment">//引入类</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//引入</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Import</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> fileName = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对象</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> superObject = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> properties = [<span class="type">Property</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> methods = [<span class="type">Method</span>]()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//成员变量</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Property</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> classMethodTf = <span class="literal">false</span> <span class="comment">//+ or -</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnType = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnTypePointTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnTypeBlockTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> params = [<span class="type">MethodParam</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> usedMethod = [<span class="type">Method</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> filePath = <span class="string">""</span> <span class="comment">//定义方法的文件路径，方便修改文件使用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> pnameId = <span class="string">""</span>  <span class="comment">//唯一标识，便于快速比较</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParam</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> typePointTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> iName = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">//todo:更多类型</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="number">0</span> <span class="comment">//0是值类型 1是指针</span></div><div class="line">&#125;</div><div class="line">```swift</div><div class="line"></div><div class="line">## 开始语法解析 😈</div><div class="line">首先遍历目录下所有的文件。</div><div class="line">```swift</div><div class="line"><span class="keyword">let</span> fileFolderPath = <span class="keyword">self</span>.selectFolder()</div><div class="line"><span class="keyword">let</span> fileFolderStringPath = fileFolderPath.replacingOccurrences(of: <span class="string">"file://"</span>, with: <span class="string">""</span>)</div><div class="line"><span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span>;</div><div class="line"><span class="comment">//深度遍历</span></div><div class="line"><span class="keyword">let</span> enumeratorAtPath = fileManager.enumerator(atPath: fileFolderStringPath)</div><div class="line"><span class="comment">//过滤文件后缀</span></div><div class="line"><span class="keyword">let</span> filterPath = <span class="type">NSArray</span>(array: (enumeratorAtPath?.allObjects)!).pathsMatchingExtensions([<span class="string">"h"</span>,<span class="string">"m"</span>])</div></pre></td></tr></table></figure></p>
<p>然后将注释排除在分析之外，这样做能够有效避免无用的解析。</p>
<p>分析是否需要按照行来切割，在 <em>@interface</em> ， <em>@end</em> 和 <em>@ implementation</em> ， <em>@end</em> 里面不需要换行，按照;符号，外部需要按行来。所以两种切割都需要。</p>
<p>先定义语法标识符<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sb</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> add = <span class="string">"+"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> minus = <span class="string">"-"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> rBktL = <span class="string">"("</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> rBktR = <span class="string">")"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> asterisk = <span class="string">"*"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> colon = <span class="string">":"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> semicolon = <span class="string">";"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> divide = <span class="string">"/"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> agBktL = <span class="string">"&lt;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> agBktR = <span class="string">"&gt;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> quotM = <span class="string">"\""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> pSign = <span class="string">"#"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> braceL = <span class="string">"&#123;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> braceR = <span class="string">"&#125;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> bktL = <span class="string">"["</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> bktR = <span class="string">"]"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> qM = <span class="string">"?"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> upArrow = <span class="string">"^"</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> inteface = <span class="string">"@interface"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> implementation = <span class="string">"@implementation"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> end = <span class="string">"@end"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> selector = <span class="string">"@selector"</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> space = <span class="string">" "</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> newLine = <span class="string">"\n"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就要开始根据标记符号来进行切割分组了，使用 <em>Scanner</em> ，具体方式如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据代码文件解析出一个根据标记符切分的数组</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createOCTokens</span>(<span class="title">conent</span>:<span class="title">String</span>) -&gt; [<span class="title">String</span>] </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = conent</div><div class="line"></div><div class="line">    str = <span class="keyword">self</span>.dislodgeAnnotaion(content: str)</div><div class="line"></div><div class="line">    <span class="comment">//开始扫描切割</span></div><div class="line">    <span class="keyword">let</span> scanner = <span class="type">Scanner</span>(string: str)</div><div class="line">    <span class="keyword">var</span> tokens = [<span class="type">String</span>]()</div><div class="line">    <span class="comment">//Todo:待处理符号,.</span></div><div class="line">    <span class="keyword">let</span> operaters = [<span class="type">Sb</span>.add,<span class="type">Sb</span>.minus,<span class="type">Sb</span>.rBktL,<span class="type">Sb</span>.rBktR,<span class="type">Sb</span>.asterisk,<span class="type">Sb</span>.colon,<span class="type">Sb</span>.semicolon,<span class="type">Sb</span>.divide,<span class="type">Sb</span>.agBktL,<span class="type">Sb</span>.agBktR,<span class="type">Sb</span>.quotM,<span class="type">Sb</span>.pSign,<span class="type">Sb</span>.braceL,<span class="type">Sb</span>.braceR,<span class="type">Sb</span>.bktL,<span class="type">Sb</span>.bktR,<span class="type">Sb</span>.qM]</div><div class="line">    <span class="keyword">var</span> operatersString = <span class="string">""</span></div><div class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> operaters &#123;</div><div class="line">        operatersString = operatersString.appending(op)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> <span class="keyword">set</span> = <span class="type">CharacterSet</span>()</div><div class="line">    <span class="keyword">set</span>.insert(charactersIn: operatersString)</div><div class="line">    <span class="keyword">set</span>.formUnion(<span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> !scanner.isAtEnd &#123;</div><div class="line">        <span class="keyword">for</span> operater <span class="keyword">in</span> operaters &#123;</div><div class="line">            <span class="keyword">if</span> (scanner.scanString(operater, into: <span class="literal">nil</span>)) &#123;</div><div class="line">                tokens.append(operater)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> result:<span class="type">NSString</span>?</div><div class="line">        result = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span> scanner.scanUpToCharacters(from: <span class="keyword">set</span>, into: &amp;result) &#123;</div><div class="line">            tokens.append(result <span class="keyword">as</span>! <span class="type">String</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    tokens = tokens.<span class="built_in">filter</span> &#123;</div><div class="line">        $<span class="number">0</span> != <span class="type">Sb</span>.space</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tokens;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行解析的方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据代码文件解析出一个根据行切分的数组</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createOCLines</span>(<span class="title">content</span>:<span class="title">String</span>) -&gt; [<span class="title">String</span>] </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = content</div><div class="line">    str = <span class="keyword">self</span>.dislodgeAnnotaion(content: str)</div><div class="line">    <span class="keyword">let</span> strArr = str.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">    <span class="keyword">return</span> strArr</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="根据结构将定义的方法取出-🤖"><a href="#根据结构将定义的方法取出-🤖" class="headerlink" title="根据结构将定义的方法取出 🤖"></a>根据结构将定义的方法取出 🤖</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithMemoryCapacity:(<span class="built_in">NSUInteger</span>)memoryCapacity diskCapacity:(<span class="built_in">NSUInteger</span>)diskCapacity diskPath:(<span class="built_in">NSString</span> *)path cacheTime:(<span class="built_in">NSInteger</span>)cacheTime subDirectory:(<span class="built_in">NSString</span>*)subDirectory;</div></pre></td></tr></table></figure>
<p>这里按照语法规则顺序取出即可，将方法名，返回类型，参数名，参数类型记录。这里需要注意 <em>Block</em> 类型的参数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (STMPartMaker *(^)(STMPartColorType))colorTypeIs;</div></pre></td></tr></table></figure></p>
<p>这种类型中还带有括号的语法的解析，这里用到的方法是对括号进行计数，左括号加一右括号减一的方式取得完整方法。</p>
<p>获得这些数据后就可以开始检索定义的方法了。我写了一个类专门用来获得所有定义的方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">parsingWithArray</span>(<span class="title">arr</span>:<span class="title">Array</span>&lt;<span class="title">String</span>&gt;) -&gt; <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> mtd = <span class="type">Method</span>()</div><div class="line">    <span class="keyword">var</span> returnTypeTf = <span class="literal">false</span> <span class="comment">//是否取得返回类型</span></div><div class="line">    <span class="keyword">var</span> parsingTf = <span class="literal">false</span> <span class="comment">//解析中</span></div><div class="line">    <span class="keyword">var</span> bracketCount = <span class="number">0</span> <span class="comment">//括弧计数</span></div><div class="line">    <span class="keyword">var</span> step = <span class="number">0</span> <span class="comment">//1获取参数名，2获取参数类型，3获取iName</span></div><div class="line">    <span class="keyword">var</span> types = [<span class="type">String</span>]()</div><div class="line">    <span class="keyword">var</span> methodParam = <span class="type">MethodParam</span>()</div><div class="line">    <span class="comment">//print("\(arr)")</span></div><div class="line">    <span class="keyword">for</span> <span class="keyword">var</span> tk <span class="keyword">in</span> arr &#123;</div><div class="line">        tk = tk.replacingOccurrences(of: <span class="type">Sb</span>.newLine, with: <span class="string">""</span>)</div><div class="line">        <span class="keyword">if</span> (tk == <span class="type">Sb</span>.semicolon || tk == <span class="type">Sb</span>.braceL) &amp;&amp; step != <span class="number">1</span> &#123;</div><div class="line">            <span class="keyword">var</span> shouldAdd = <span class="literal">false</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> mtd.params.<span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</div><div class="line">                <span class="comment">//处理这种- (void)initWithC:(type)m m2:(type2)i, ... NS_REQUIRES_NIL_TERMINATION;入参为多参数情况</span></div><div class="line">                <span class="keyword">if</span> methodParam.type.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">                    shouldAdd = <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                shouldAdd = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> shouldAdd &#123;</div><div class="line">                mtd.params.append(methodParam)</div><div class="line">                mtd.pnameId = mtd.pnameId.appending(<span class="string">"<span class="subst">\(methodParam.name)</span>:"</span>)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktL &#123;</div><div class="line">            bracketCount += <span class="number">1</span></div><div class="line">            parsingTf = <span class="literal">true</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktR &#123;</div><div class="line">            bracketCount -= <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> bracketCount == <span class="number">0</span> &#123;</div><div class="line">                <span class="keyword">var</span> typeString = <span class="string">""</span></div><div class="line">                <span class="keyword">for</span> typeTk <span class="keyword">in</span> types &#123;</div><div class="line">                    typeString = typeString.appending(typeTk)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> !returnTypeTf &#123;</div><div class="line">                    <span class="comment">//完成获取返回</span></div><div class="line">                    mtd.returnType = typeString</div><div class="line">                    step = <span class="number">1</span></div><div class="line">                    returnTypeTf = <span class="literal">true</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> step == <span class="number">2</span> &#123;</div><div class="line">                        methodParam.type = typeString</div><div class="line">                        step = <span class="number">3</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//括弧结束后的重置工作</span></div><div class="line">                parsingTf = <span class="literal">false</span></div><div class="line">                types = []</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> parsingTf &#123;</div><div class="line">            types.append(tk)</div><div class="line">            <span class="comment">//todo:返回block类型会使用.设置值的方式，目前获取用过方法方式没有.这种的解析，暂时作为</span></div><div class="line">            <span class="keyword">if</span> tk == <span class="type">Sb</span>.upArrow &#123;</div><div class="line">                mtd.returnTypeBlockTf = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">            step = <span class="number">2</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> step == <span class="number">1</span> &#123;</div><div class="line">            <span class="keyword">if</span> tk == <span class="string">"initWithCoordinate"</span> &#123;</div><div class="line">                <span class="comment">//</span></div><div class="line">            &#125;</div><div class="line">            methodParam.name = tk</div><div class="line">            step = <span class="number">0</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> step == <span class="number">3</span> &#123;</div><div class="line">            methodParam.iName = tk</div><div class="line">            step = <span class="number">1</span></div><div class="line">            mtd.params.append(methodParam)</div><div class="line">            mtd.pnameId = mtd.pnameId.appending(<span class="string">"<span class="subst">\(methodParam.name)</span>:"</span>)</div><div class="line">            methodParam = <span class="type">MethodParam</span>()</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk != <span class="type">Sb</span>.minus &amp;&amp; tk != <span class="type">Sb</span>.add &#123;</div><div class="line">            methodParam.name = tk</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;<span class="comment">//遍历</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> mtd</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法大概的思路就是根据标记符设置不同的状态，然后将获取的信息放入定义的结构中。</p>
<h2 id="使用过的方法的解析-😱"><a href="#使用过的方法的解析-😱" class="headerlink" title="使用过的方法的解析 😱"></a>使用过的方法的解析 😱</h2><p>进行使用过的方法解析前需要处理的事情</p>
<ul>
<li>@“…” 里面的数据，因为这里面是允许我们定义的标识符出现的。</li>
<li>递归出文件中 import 所有的类，根据对类的使用可以清除无用的 import</li>
<li>继承链的获取。</li>
<li>解析获取实例化了的成员变量列表。在解析时需要依赖列表里的成员变量名和变量的类进行方法的完整获取。</li>
</ul>
<p>简单的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[view update:status animation:<span class="literal">YES</span>];</div></pre></td></tr></table></figure></p>
<p>从左到右按照 : 符号获取</p>
<p>方法嵌套调用，下面这种情况如何解析出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[[[[[SMNetManager shareInstance] fetchAllFeedWithModelArray:<span class="keyword">self</span>.feeds] map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSUInteger</span> index = [value integerValue];</div><div class="line">    <span class="keyword">self</span>.feeds[index] = [SMNetManager shareInstance].feeds[index];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.feeds[index];</div><div class="line">&#125;] doCompleted:^&#123;</div><div class="line">    <span class="comment">//抓完所有的feeds</span></div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"fetch complete"</span>);</div><div class="line">    <span class="comment">//完成置为默认状态</span></div><div class="line">    <span class="keyword">self</span>.tbHeaderLabel.text = <span class="string">@""</span>;</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>;</div><div class="line">    [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">NO</span>;</div><div class="line">    <span class="comment">//下拉刷新关闭</span></div><div class="line">    [<span class="keyword">self</span>.tableView.mj_header endRefreshing];</div><div class="line">    <span class="comment">//更新列表</span></div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    <span class="comment">//检查是否需要增加源</span></div><div class="line">    <span class="keyword">if</span> ([SMFeedStore defaultFeeds].count &gt; <span class="keyword">self</span>.feeds.count) &#123;</div><div class="line">        <span class="keyword">self</span>.feeds = [SMFeedStore defaultFeeds];</div><div class="line">        [<span class="keyword">self</span> fetchAllFeeds];</div><div class="line">    &#125;</div><div class="line">&#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(SMFeedModel *feedModel) &#123;</div><div class="line">    <span class="comment">//抓完一个</span></div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.tbHeaderView;</div><div class="line">    <span class="comment">//显示抓取状态</span></div><div class="line">    <span class="keyword">self</span>.fetchingCount += <span class="number">1</span>;</div><div class="line">    <span class="keyword">self</span>.tbHeaderLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"正在获取%@...(%lu/%lu)"</span>,feedModel.title,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.fetchingCount,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.feeds.count];</div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>一开始会想到使用递归，以前我做 <em>STMAssembleView</em> 时就是使用的递归，这样时间复杂度就会是 O(nlogn) ，这次我换了个思路，将复杂度降低到了 n ，思路大概是 创建一个字典，键值就是深度，从左到右深度的增加根据 <em>[</em> 符号，减少根据 <em>]</em> 符号，值会在 <em>[</em> 时创建一个 <em>Method</em> 结构体，根据]来完成结构体，将其添加到 <em>methods</em> 数组中 。</p>
<p>具体实现如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">parsing</span>(<span class="title">contentArr</span>:<span class="title">Array</span>&lt;<span class="title">String</span>&gt;, <span class="title">inMethod</span>:<span class="title">Method</span>) -&gt; <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> mtdIn = inMethod</div><div class="line">    <span class="comment">//处理用过的方法</span></div><div class="line">    <span class="comment">//todo:还要过滤@""这种情况</span></div><div class="line">    <span class="keyword">var</span> psBrcStep = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> uMtdDic = [<span class="type">Int</span>:<span class="type">Method</span>]()</div><div class="line">    <span class="keyword">var</span> preTk = <span class="string">""</span></div><div class="line">    <span class="comment">//处理?:这种条件判断简写方式</span></div><div class="line">    <span class="keyword">var</span> psCdtTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> psCdtStep = <span class="number">0</span></div><div class="line">    <span class="comment">//判断selector</span></div><div class="line">    <span class="keyword">var</span> psSelectorTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> preSelectorTk = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> selectorMtd = <span class="type">Method</span>()</div><div class="line">    <span class="keyword">var</span> selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line"></div><div class="line">    uMtdDic[psBrcStep] = <span class="type">Method</span>() <span class="comment">//初始时就实例化一个method，避免在define里定义只定义]符号</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="keyword">var</span> tk <span class="keyword">in</span> contentArr &#123;</div><div class="line">        <span class="comment">//selector处理</span></div><div class="line">        <span class="keyword">if</span> psSelectorTf &#123;</div><div class="line">            <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">                selectorMtdPar.name = preSelectorTk</div><div class="line">                selectorMtd.params.append(selectorMtdPar)</div><div class="line">                selectorMtd.pnameId += <span class="string">"<span class="subst">\(selectorMtdPar.name)</span>:"</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktR &#123;</div><div class="line">                mtdIn.usedMethod.append(selectorMtd)</div><div class="line">                psSelectorTf = <span class="literal">false</span></div><div class="line">                selectorMtd = <span class="type">Method</span>()</div><div class="line">                selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                preSelectorTk = tk</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> tk == <span class="type">Sb</span>.selector &#123;</div><div class="line">            psSelectorTf = <span class="literal">true</span></div><div class="line">            selectorMtd = <span class="type">Method</span>()</div><div class="line">            selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//通常处理</span></div><div class="line">        <span class="keyword">if</span> tk == <span class="type">Sb</span>.bktL &#123;</div><div class="line">            <span class="keyword">if</span> psCdtTf &#123;</div><div class="line">                psCdtStep += <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">            psBrcStep += <span class="number">1</span></div><div class="line">            uMtdDic[psBrcStep] = <span class="type">Method</span>()</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.bktR &#123;</div><div class="line">            <span class="keyword">if</span> psCdtTf &#123;</div><div class="line">                psCdtStep -= <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (uMtdDic[psBrcStep]?.params.<span class="built_in">count</span>)! &gt; <span class="number">0</span> &#123;</div><div class="line">                mtdIn.usedMethod.append(uMtdDic[psBrcStep]!)</div><div class="line">            &#125;</div><div class="line">            psBrcStep -= <span class="number">1</span></div><div class="line">            <span class="comment">//[]不配对的容错处理</span></div><div class="line">            <span class="keyword">if</span> psBrcStep &lt; <span class="number">0</span> &#123;</div><div class="line">                psBrcStep = <span class="number">0</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">            <span class="comment">//条件简写情况处理</span></div><div class="line">            <span class="keyword">if</span> psCdtTf &amp;&amp; psCdtStep == <span class="number">0</span> &#123;</div><div class="line">                psCdtTf = <span class="literal">false</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//dictionary情况处理@"key":@"value"</span></div><div class="line">            <span class="keyword">if</span> preTk == <span class="type">Sb</span>.quotM || preTk == <span class="string">"respondsToSelector"</span> &#123;</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> prm = <span class="type">MethodParam</span>()</div><div class="line">            prm.name = preTk</div><div class="line">            <span class="keyword">if</span> prm.name != <span class="string">""</span> &#123;</div><div class="line">                uMtdDic[psBrcStep]?.params.append(prm)</div><div class="line">                uMtdDic[psBrcStep]?.pnameId = (uMtdDic[psBrcStep]?.pnameId.appending(<span class="string">"<span class="subst">\(prm.name)</span>:"</span>))!</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.qM &#123;</div><div class="line">            psCdtTf = <span class="literal">true</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tk = tk.replacingOccurrences(of: <span class="type">Sb</span>.newLine, with: <span class="string">""</span>)</div><div class="line">            preTk = tk</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> mtdIn</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在设置 <em>Method</em> 结构体时将参数名拼接起来成为 <em>Method</em> 的识别符用于后面处理时的快速比对。</p>
<p>解析使用过的方法时有几个问题需要注意下<br>1.在方法内使用的方法，会有 <em>respondsToSelector</em> ， <em>@selector</em> 还有条件简写语法的情况需要单独处理下。<br>2.在 <em>#define</em> 里定义使用了方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define CLASS_VALUE(x)    [NSValue valueWithNonretainedObject:(x)]</span></div></pre></td></tr></table></figure></p>
<h2 id="找出无用方法-😄"><a href="#找出无用方法-😄" class="headerlink" title="找出无用方法 😄"></a>找出无用方法 😄</h2><p>获取到所有使用方法后进行去重，和定义方法进行匹对求出差集，即全部未使用的方法。</p>
<h2 id="去除无用方法-😎"><a href="#去除无用方法-😎" class="headerlink" title="去除无用方法 😎"></a>去除无用方法 😎</h2><p>比对后获得无用方法后就要开始注释掉他们了。遍历未使用的方法，根据先前 <em>Method</em> 结构体中定义了方法所在文件路径，根据文件集结构和File的结构体，可以避免 IO ，直接获取方法对应的文件内容和路径。<br>对文件内容进行行切割，逐行检测方法名和参数，匹对时开始对行加上注释， h 文件已;符号为结束， m 文件会对大括号进行计数，逐行注释。实现的方法具体如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除指定的一组方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">delete</span>(<span class="title">methods</span>:[<span class="title">Method</span>]) </span>&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"无用方法"</span>)</div><div class="line">    <span class="keyword">for</span> aMethod <span class="keyword">in</span> methods &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(File.desDefineMethodParams(paramArr: aMethod.params)</span>)"</span>)</div><div class="line"></div><div class="line">        <span class="comment">//开始删除</span></div><div class="line">        <span class="comment">//continue</span></div><div class="line">        <span class="keyword">var</span> hContent = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mContent = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mFilePath = aMethod.filePath</div><div class="line">        <span class="keyword">if</span> aMethod.filePath.hasSuffix(<span class="string">".h"</span>) &#123;</div><div class="line">            hContent = <span class="keyword">try</span>! <span class="type">String</span>(contentsOf: <span class="type">URL</span>(string:aMethod.filePath)!, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">            <span class="comment">//todo:因为先处理了h文件的情况</span></div><div class="line">            mFilePath = aMethod.filePath.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"h"</span>)) <span class="comment">//去除头尾字符集</span></div><div class="line">            mFilePath = mFilePath.appending(<span class="string">"m"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> mFilePath.hasSuffix(<span class="string">".m"</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                mContent = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: <span class="type">URL</span>(string:mFilePath)!, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">            &#125; <span class="keyword">catch</span> &#123;</div><div class="line">                mContent = <span class="string">""</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> hContentArr = hContent.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">        <span class="keyword">let</span> mContentArr = mContent.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">        <span class="comment">//print(mContentArr)</span></div><div class="line">        <span class="comment">//----------------h文件------------------</span></div><div class="line">        <span class="keyword">var</span> psHMtdTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">var</span> hMtds = [<span class="type">String</span>]()</div><div class="line">        <span class="keyword">var</span> hMtdStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> hMtdAnnoStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> hContentCleaned = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> hOneLine <span class="keyword">in</span> hContentArr &#123;</div><div class="line">            <span class="keyword">var</span> line = hOneLine.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasPrefix(<span class="type">Sb</span>.minus) || line.hasPrefix(<span class="type">Sb</span>.add) &#123;</div><div class="line">                psHMtdTf = <span class="literal">true</span></div><div class="line">                hMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                hMtdStr = hMtdStr.appending(hOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                hMtdAnnoStr += <span class="string">"//-----由SMCheckProject工具删除-----\n//"</span></div><div class="line">                hMtdAnnoStr += hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                line = <span class="keyword">self</span>.dislodgeAnnotaionInOneLine(content: line)</div><div class="line">                line = line.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> psHMtdTf &#123;</div><div class="line">                hMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                hMtdStr = hMtdStr.appending(hOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                hMtdAnnoStr += <span class="string">"//"</span> + hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                line = <span class="keyword">self</span>.dislodgeAnnotaionInOneLine(content: line)</div><div class="line">                line = line.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                hContentCleaned += hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasSuffix(<span class="type">Sb</span>.semicolon) &amp;&amp; psHMtdTf&#123;</div><div class="line">                psHMtdTf = <span class="literal">false</span></div><div class="line"></div><div class="line">                <span class="keyword">let</span> methodPnameId = <span class="type">ParsingMethod</span>.parsingWithArray(arr: hMtds).pnameId</div><div class="line">                <span class="keyword">if</span> aMethod.pnameId == methodPnameId &#123;</div><div class="line">                    hContentCleaned += hMtdAnnoStr</div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    hContentCleaned += hMtdStr</div><div class="line">                &#125;</div><div class="line">                hMtdAnnoStr = <span class="string">""</span></div><div class="line">                hMtdStr = <span class="string">""</span></div><div class="line">                hMtds = []</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//删除无用函数</span></div><div class="line">        <span class="keyword">try</span>! hContentCleaned.write(to: <span class="type">URL</span>(string:aMethod.filePath)!, atomically: <span class="literal">false</span>, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line"></div><div class="line">        <span class="comment">//----------------m文件----------------</span></div><div class="line">        <span class="keyword">var</span> mDeletingTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">var</span> mBraceCount = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> mContentCleaned = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtdStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtdAnnoStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtds = [<span class="type">String</span>]()</div><div class="line">        <span class="keyword">var</span> psMMtdTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">for</span> mOneLine <span class="keyword">in</span> mContentArr &#123;</div><div class="line">            <span class="keyword">let</span> line = mOneLine.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> mDeletingTf &#123;</div><div class="line">                <span class="keyword">let</span> lTokens = <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                mMtdAnnoStr += <span class="string">"//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                <span class="keyword">for</span> tk <span class="keyword">in</span> lTokens &#123;</div><div class="line">                    <span class="keyword">if</span> tk == <span class="type">Sb</span>.braceL &#123;</div><div class="line">                        mBraceCount += <span class="number">1</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> tk == <span class="type">Sb</span>.braceR &#123;</div><div class="line">                        mBraceCount -= <span class="number">1</span></div><div class="line">                        <span class="keyword">if</span> mBraceCount == <span class="number">0</span> &#123;</div><div class="line">                            mContentCleaned = mContentCleaned.appending(mMtdAnnoStr)</div><div class="line">                            mMtdAnnoStr = <span class="string">""</span></div><div class="line">                            mDeletingTf = <span class="literal">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasPrefix(<span class="type">Sb</span>.minus) || line.hasPrefix(<span class="type">Sb</span>.add) &#123;</div><div class="line">                psMMtdTf = <span class="literal">true</span></div><div class="line">                mMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                mMtdStr = mMtdStr.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                mMtdAnnoStr += <span class="string">"//-----由SMCheckProject工具删除-----\n//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> psMMtdTf &#123;</div><div class="line">                mMtdStr = mMtdStr.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                mMtdAnnoStr += <span class="string">"//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                mMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mContentCleaned = mContentCleaned.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasSuffix(<span class="type">Sb</span>.braceL) &amp;&amp; psMMtdTf &#123;</div><div class="line">                psMMtdTf = <span class="literal">false</span></div><div class="line">                <span class="keyword">let</span> methodPnameId = <span class="type">ParsingMethod</span>.parsingWithArray(arr: mMtds).pnameId</div><div class="line">                <span class="keyword">if</span> aMethod.pnameId == methodPnameId &#123;</div><div class="line">                    mDeletingTf = <span class="literal">true</span></div><div class="line">                    mBraceCount += <span class="number">1</span></div><div class="line">                    mContentCleaned = mContentCleaned.appending(mMtdAnnoStr)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    mContentCleaned = mContentCleaned.appending(mMtdStr)</div><div class="line">                &#125;</div><div class="line">                mMtdStr = <span class="string">""</span></div><div class="line">                mMtdAnnoStr = <span class="string">""</span></div><div class="line">                mMtds = []</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="comment">//m文件</span></div><div class="line"></div><div class="line">        <span class="comment">//删除无用函数</span></div><div class="line">        <span class="keyword">if</span> mContent.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">try</span>! mContentCleaned.write(to: <span class="type">URL</span>(string:mFilePath)!, atomically: <span class="literal">false</span>, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整代码在：<a href="https://github.com/ming1016/SMCheckProject" target="_blank" rel="external">https://github.com/ming1016/SMCheckProject</a> 这里。</p>
<h2 id="后记-🦁"><a href="#后记-🦁" class="headerlink" title="后记 🦁"></a>后记 🦁</h2><p>有了这样的结构数据就可以模拟更多人工检测的方式来检测项目。</p>
<p>通过获取的方法结合获取类里面定义的局部变量和全局变量，在解析过程中模拟引用的计数来分析循环引用等等类似这样的检测。<br>通过获取的类的完整结构还能够将其转成JavaScriptCore能解析的js语法文件等等。</p>
<h2 id="对于APP瘦身的一些想法-👽"><a href="#对于APP瘦身的一些想法-👽" class="headerlink" title="对于APP瘦身的一些想法 👽"></a>对于APP瘦身的一些想法 👽</h2><p>瘦身应该从平时开发时就需要注意。除了功能和组件上的复用外还需要对堆栈逻辑进行封装以达到代码压缩的效果。</p>
<p>比如使用ReactiveCocoa和RxSwift这样的函数响应式编程库提供的方法和编程模式进行</p>
<p>对于UI的视图逻辑可以使用一套统一逻辑压缩代码使用DSL来简化写法等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当项目越来越大，引入第三方库越来越多，上架的APP体积也会越来越大，对于用户来说体验必定是不好的。在清理资源，编译选项优化，清理无用类等完成后，能够做而且效果会比较明显的就只有清理无用函数了。现有一种方案是根据Linkmap文件取到objc的所有类方法和实例方法。再用工具逆
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="macOS" scheme="http://ming1016.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>使用ReactiveCocoa开发RSS阅读器</title>
    <link href="http://ming1016.github.io/2016/09/02/develop-rss-reader/"/>
    <id>http://ming1016.github.io/2016/09/02/develop-rss-reader/</id>
    <published>2016-09-02T13:47:59.000Z</published>
    <updated>2017-05-27T04:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前已经完成的功能有对RSS的解析和Atom解析，RSS内容本地数据库存储和读取，抓取中状态进度展示，标记阅读状态，标记全部已读等。这些功能里我对一些异步操作产生的数据采用了ReactiveCocoa来对数据流向进行了控制，下面我来说下如何运用RAC来进行的开发。</p>
<h1 id="初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新"><a href="#初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新" class="headerlink" title="初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新"></a>初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新</h1><p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot1.png?raw=true" alt="截图"></p>
<p>这里会用到RAC这个宏可以方便的来进行键值和信号的绑定，RACObserve这个宏方便的进行键值变化的监听处理。具体实现代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line"><span class="comment">//首页列表数据赋值，过滤无效数据</span></div><div class="line">RAC(<span class="keyword">self</span>, feeds) = [[[SMDB shareInstance] selectAllFeeds] filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSMutableArray</span> *feedsArray) &#123;</div><div class="line">    <span class="keyword">if</span> (feedsArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">//监听列表数据变化进行列表更新</span></div><div class="line">[RACObserve(<span class="keyword">self</span>, feeds) subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">//本地读取首页订阅源数据</span></div><div class="line">- (RACSignal *)selectAllFeeds &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        FMDatabase *db = [FMDatabase databaseWithPath:<span class="keyword">self</span>.feedDBPath];</div><div class="line">        <span class="keyword">if</span> ([db open]) &#123;</div><div class="line">            FMResultSet *rs = [db executeQuery:<span class="string">@"select * from feeds"</span>];</div><div class="line">            <span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line">            <span class="built_in">NSMutableArray</span> *feedsArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">                SMFeedModel *feedModel = [[SMFeedModel alloc] init];</div><div class="line">                feedModel.fid = [rs intForColumn:<span class="string">@"fid"</span>];</div><div class="line">                feedModel.title = [rs stringForColumn:<span class="string">@"title"</span>];</div><div class="line">                feedModel.link = [rs stringForColumn:<span class="string">@"link"</span>];</div><div class="line">                feedModel.des = [rs stringForColumn:<span class="string">@"des"</span>];</div><div class="line">                feedModel.copyright = [rs stringForColumn:<span class="string">@"copyright"</span>];</div><div class="line">                feedModel.generator = [rs stringForColumn:<span class="string">@"generator"</span>];</div><div class="line">                feedModel.imageUrl = [rs stringForColumn:<span class="string">@"imageurl"</span>];</div><div class="line">                feedModel.feedUrl = [rs stringForColumn:<span class="string">@"feedurl"</span>];</div><div class="line">                feedModel.unReadCount = [rs intForColumn:<span class="string">@"unread"</span>];</div><div class="line">                [feedsArray addObject:feedModel];</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            [subscriber sendNext:feedsArray];</div><div class="line">            [subscriber sendCompleted];</div><div class="line">            [db close];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示"><a href="#通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示" class="headerlink" title="通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示"></a>通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示</h1><p>这里的异步操作比较多，而且为了尽快取得数据采用的是并行队列，需要准确的获取到每个源完成的状态，包括解析的完成，本地存储完成，全部获取完成等数据完成情况。具体使用RAC方式的代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取所有feeds以及完成处理</span></div><div class="line">- (<span class="keyword">void</span>)fetchAllFeeds &#123;</div><div class="line">    [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.tbHeaderView;</div><div class="line">    <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>; <span class="comment">//统计抓取数量</span></div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    [[[[[[SMNetManager shareInstance] fetchAllFeedWithModelArray:<span class="keyword">self</span>.feeds] map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="built_in">NSUInteger</span> index = [value integerValue];</div><div class="line">        <span class="keyword">self</span>.feeds[index] = [SMNetManager shareInstance].feeds[index];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.feeds[index];</div><div class="line">    &#125;] doCompleted:^&#123;</div><div class="line">        <span class="comment">//抓完所有的feeds</span></div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fetch complete"</span>);</div><div class="line">        <span class="comment">//完成置为默认状态</span></div><div class="line">        <span class="keyword">self</span>.tbHeaderLabel.text = <span class="string">@""</span>;</div><div class="line">        <span class="keyword">self</span>.tableView.tableHeaderView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">        <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>;</div><div class="line">        [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">NO</span>;</div><div class="line">    &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(SMFeedModel *feedModel) &#123;</div><div class="line">        <span class="comment">//抓完一个</span></div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="comment">//显示抓取状态</span></div><div class="line">        <span class="keyword">self</span>.fetchingCount += <span class="number">1</span>;</div><div class="line">        <span class="keyword">self</span>.tbHeaderLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"正在获取%@...(%lu/%lu)"</span>,feedModel.title,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.fetchingCount,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.feeds.count];</div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"><span class="comment">//网络获取以及解析本地存储</span></div><div class="line">- (RACSignal *)fetchAllFeedWithModelArray:(<span class="built_in">NSMutableArray</span> *)modelArray &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="comment">//创建并行队列</span></div><div class="line">        <span class="built_in">dispatch_queue_t</span> fetchFeedQueue = dispatch_queue_create(<span class="string">"com.starming.fetchfeed.fetchfeed"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">        dispatch_group_t group = dispatch_group_create();</div><div class="line">        <span class="keyword">self</span>.feeds = modelArray;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; modelArray.count; i++) &#123;</div><div class="line">            dispatch_group_enter(group);</div><div class="line">            SMFeedModel *feedModel = modelArray[i];</div><div class="line">            <span class="built_in">dispatch_async</span>(fetchFeedQueue, ^&#123;</div><div class="line">                [<span class="keyword">self</span> GET:feedModel.feedUrl parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">                    <span class="comment">//解析feed</span></div><div class="line">                    <span class="keyword">self</span>.feeds[i] = [<span class="keyword">self</span>.feedStore updateFeedModelWithData:responseObject preModel:feedModel];</div><div class="line">                    <span class="comment">//入库存储</span></div><div class="line">                    SMDB *db = [[SMDB alloc] init];</div><div class="line">                    [[db insertWithFeedModel:<span class="keyword">self</span>.feeds[i]] subscribeNext:^(<span class="built_in">NSNumber</span> *x) &#123;</div><div class="line">                        SMFeedModel *model = (SMFeedModel *)<span class="keyword">self</span>.feeds[i];</div><div class="line">                        model.fid = [x integerValue];</div><div class="line">                        <span class="comment">//插入本地数据库成功后开始sendNext</span></div><div class="line">                        [subscriber sendNext:@(i)];</div><div class="line">                        <span class="comment">//通知单个完成</span></div><div class="line">                        dispatch_group_leave(group);</div><div class="line">                    &#125;];</div><div class="line"></div><div class="line">                &#125; failure:^(<span class="built_in">NSURLSessionTask</span> *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                    dispatch_group_leave(group);</div><div class="line">                &#125;];</div><div class="line"></div><div class="line">            &#125;);<span class="comment">//end dispatch async</span></div><div class="line"></div><div class="line">        &#125;<span class="comment">//end for</span></div><div class="line">        <span class="comment">//全完成后执行事件</span></div><div class="line">        dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">            [subscriber sendCompleted];</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="读取RSS列表，异步读取，主线程更新"><a href="#读取RSS列表，异步读取，主线程更新" class="headerlink" title="读取RSS列表，异步读取，主线程更新"></a>读取RSS列表，异步读取，主线程更新</h1><p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot2.png?raw=true" alt="截图"></p>
<p>这里通过RAC能够很方便的进行主线程操作UI，非主线程操作数据这样的操作，具体实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取列表数据以及对应的操作</span></div><div class="line">- (<span class="keyword">void</span>)selectFeedItems &#123;</div><div class="line">    RACScheduler *scheduler = [RACScheduler schedulerWithPriority:RACSchedulerPriorityHigh];</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    [[[[[SMDB shareInstance] selectFeedItemsWithPage:<span class="keyword">self</span>.page fid:<span class="keyword">self</span>.feedModel.fid]</div><div class="line">       subscribeOn:scheduler]</div><div class="line">      deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">     subscribeNext:^(<span class="built_in">NSMutableArray</span> *x) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.listData.count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//进入时加载</span></div><div class="line">            [<span class="keyword">self</span>.listData addObjectsFromArray:x];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//加载更多</span></div><div class="line">            <span class="keyword">self</span>.listData = x;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//刷新</span></div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">        <span class="comment">//处理无数据的显示</span></div><div class="line">        [<span class="keyword">self</span>.tableView.mj_footer endRefreshingWithNoMoreData];</div><div class="line">    &#125; completed:^&#123;</div><div class="line">        <span class="comment">//加载完成后的处理</span></div><div class="line">        [<span class="keyword">self</span>.tableView.mj_footer endRefreshing];</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.page += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//数据库获取信号</span></div><div class="line">- (RACSignal *)selectFeedItemsWithPage:(<span class="built_in">NSUInteger</span>)page fid:(<span class="built_in">NSUInteger</span>)fid &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        FMDatabase *db = [FMDatabase databaseWithPath:<span class="keyword">self</span>.feedDBPath];</div><div class="line">        <span class="keyword">if</span> ([db open]) &#123;</div><div class="line">            <span class="comment">//分页获取</span></div><div class="line">            FMResultSet *rs = [db executeQuery:<span class="string">@"select * from feeditem where fid = ? and isread = ? order by iid desc limit ?, 20"</span>,@(fid), @(<span class="number">0</span>), @(page * <span class="number">20</span>)];</div><div class="line">            <span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line">            <span class="built_in">NSMutableArray</span> *feedItemsArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="comment">//设置返回Array里的Model</span></div><div class="line">            <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">                SMFeedItemModel *itemModel = [[SMFeedItemModel alloc] init];</div><div class="line">                itemModel.iid = [rs intForColumn:<span class="string">@"iid"</span>];</div><div class="line">                itemModel.fid = [rs intForColumn:<span class="string">@"fid"</span>];</div><div class="line">                itemModel.link = [rs stringForColumn:<span class="string">@"link"</span>];</div><div class="line">                itemModel.title = [rs stringForColumn:<span class="string">@"title"</span>];</div><div class="line">                itemModel.author = [rs stringForColumn:<span class="string">@"author"</span>];</div><div class="line">                itemModel.category = [rs stringForColumn:<span class="string">@"category"</span>];</div><div class="line">                itemModel.pubDate = [rs stringForColumn:<span class="string">@"pubDate"</span>];</div><div class="line">                itemModel.des = [rs stringForColumn:<span class="string">@"des"</span>];</div><div class="line">                itemModel.isRead = [rs intForColumn:<span class="string">@"isread"</span>];</div><div class="line">                [feedItemsArray addObject:itemModel];</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                [subscriber sendNext:feedItemsArray];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//获取出错处理</span></div><div class="line">                [subscriber sendError:<span class="literal">nil</span>];</div><div class="line">            &#125;</div><div class="line">            [subscriber sendCompleted];</div><div class="line">            [db close];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot3.png?raw=true" alt="截图"></p>
<p>完整代码可以在这里看:<a href="https://github.com/ming1016/GCDFetchFeed" target="_blank" rel="external">https://github.com/ming1016/GCDFetchFeed</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前已经完成的功能有对RSS的解析和Atom解析，RSS内容本地数据库存储和读取，抓取中状态进度展示，标记阅读状态，标记全部已读等。这些功能里我对一些异步操作产生的数据采用了ReactiveCocoa来对数据流向进行了控制，下面我来说下如何运用RAC来进行的开发。&lt;/p&gt;

    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="RSSReader" scheme="http://ming1016.github.io/tags/RSSReader/"/>
    
  </entry>
  
  <entry>
    <title>iOS函数响应式编程以及ReactiveCocoa的使用</title>
    <link href="http://ming1016.github.io/2016/08/09/how-to-use-reactivecocoa/"/>
    <id>http://ming1016.github.io/2016/08/09/how-to-use-reactivecocoa/</id>
    <published>2016-08-09T13:44:10.000Z</published>
    <updated>2017-05-27T06:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅</p>
<h1 id="声明式编程泛型Declarative-programming"><a href="#声明式编程泛型Declarative-programming" class="headerlink" title="声明式编程泛型Declarative programming"></a>声明式编程泛型Declarative programming</h1><p>函数反应式编程是声明式编程的子编程范式之一</p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>需要满足两个条件</p>
<ul>
<li>一个或者多个函数作为输入。</li>
<li>有且仅有一个函数输出。</li>
</ul>
<p>objectivec里使用block作为函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">NSNumber</span> *number, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,number);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h2 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> * mappedArray = [array rx_mapWithBlock:^<span class="keyword">id</span>(<span class="keyword">id</span> each)&#123;</div><div class="line">    <span class="keyword">return</span> @(pow([each integerValue],<span class="number">2</span>));</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="过滤filter"><a href="#过滤filter" class="headerlink" title="过滤filter"></a>过滤filter</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *filteredArray = [array rx_filterWithBlock:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> each)&#123;</div><div class="line">    <span class="keyword">return</span> ([each integerValue] % <span class="number">2</span> == <span class="number">0</span>);</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<h2 id="折叠fold"><a href="#折叠fold" class="headerlink" title="折叠fold"></a>折叠fold</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[array rx_mapWithBlock:^<span class="keyword">id</span> (<span class="keyword">id</span> each)&#123;</div><div class="line">        <span class="keyword">return</span> [each stringValue];</div><div class="line">    &#125;] rx_foldInitialValue:<span class="string">@""</span> block:^<span class="keyword">id</span> (<span class="keyword">id</span> memo , <span class="keyword">id</span> each)&#123;</div><div class="line">        <span class="keyword">return</span> [memo stringByAppendingString:each];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>用函数生成另一个函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGenerator</span><span class="params">(lastnameCondition: String)</span></span> -&gt; (<span class="type">Staff</span>) -&gt; (<span class="type">Bool</span>) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;staff <span class="keyword">in</span></div><div class="line">        <span class="keyword">return</span> staff.lastname == lastnameCondition</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> filterWang = filterGenerator(<span class="string">"Wang"</span>)</div><div class="line"><span class="keyword">let</span> filterHu = filterGenerator(<span class="string">"Hu"</span>)</div><div class="line"></div><div class="line">staffs.<span class="built_in">filter</span>(filterHu)</div></pre></td></tr></table></figure></p>
<h1 id="RAC中使用高阶函数"><a href="#RAC中使用高阶函数" class="headerlink" title="RAC中使用高阶函数"></a>RAC中使用高阶函数</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[ @<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span> ];</div><div class="line">RACSequence * stream = [array rac_sequence];</div><div class="line"><span class="comment">//RACSequence是一个RACStream的子类。</span></div><div class="line">[stream map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">    <span class="keyword">return</span> @(pow([value integerValue], <span class="number">2</span>));</div><div class="line">&#125;];</div><div class="line"><span class="comment">//RACSequence有一个方法返回数组:array</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[stream array]);</div><div class="line"></div><div class="line"><span class="comment">//避免污染变量的作用域</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[[array rac_sequence] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> @(pow([value integerValue], <span class="number">2</span>));</div><div class="line">                &#125;] array]);</div></pre></td></tr></table></figure>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[array rac_sequence] filter:^<span class="built_in">BOOL</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                        <span class="keyword">return</span> [value integerValue] % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">                    &#125;] array]);</div></pre></td></tr></table></figure>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[[array rac_sequence] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> [value stringValue];</div><div class="line">                &#125;] foldLeftWithStart:<span class="string">@""</span> reduce:^<span class="keyword">id</span> (<span class="keyword">id</span> accumulator, <span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> [accumulator stringByAppendingString:value];</div><div class="line">            &#125;]);</div></pre></td></tr></table></figure>
<h2 id="绑定键值"><a href="#绑定键值" class="headerlink" title="绑定键值"></a>绑定键值</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RACSignal * validEmailSignal = [<span class="keyword">self</span>.textField.rac_textSignal map:^<span class="keyword">id</span> (<span class="built_in">NSString</span> *value)&#123;</div><div class="line">    <span class="keyword">return</span> @([value rangeOfString:<span class="string">@"@"</span>].location != <span class="built_in">NSNotFound</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RAC(<span class="keyword">self</span>.button, enabled) = validEmailSignal;</div><div class="line"></div><div class="line">RAC(<span class="keyword">self</span>.textField, textColor) = [validEmailSignal map: ^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">    <span class="keyword">if</span>([value boolValue])&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> greenColor];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> redColor];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><img src="https://github.com/ming1016/study/blob/master/pic/CombinePipeline.png?raw=true" alt="绑定键值图示"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>比较好的一个完整的RAC实践的例子：<a href="https://github.com/ashfurrow/FunctionalReactivePixels" target="_blank" rel="external">https://github.com/ashfurrow/FunctionalReactivePixels</a></p>
<h3 id="网络请求生成对应model"><a href="#网络请求生成对应model" class="headerlink" title="网络请求生成对应model"></a>网络请求生成对应model</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">+ (RACSignal *)importPhotos&#123;</div><div class="line">    RACReplaySubject * subject = [RACReplaySubject subject];</div><div class="line">    <span class="built_in">NSURLRequest</span> * request = [<span class="keyword">self</span> popularURLRequest];</div><div class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request</div><div class="line">                                    queue:[<span class="built_in">NSOperationQueue</span> mainQueue]</div><div class="line">                        completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError)&#123;</div><div class="line">                            <span class="keyword">if</span> (data) &#123;</div><div class="line">                                <span class="keyword">id</span> results = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">                                [subject sendNext:[[[results[<span class="string">@"photos"</span>] rac_sequence] map:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *photoDictionary)&#123;</div><div class="line">                                    FRPPhotoModel * model = [FRPPhotoModel new];</div><div class="line"></div><div class="line">                                    [<span class="keyword">self</span> configurePhotoModel:model withDictionary:photoDictionary];</div><div class="line">                                    [<span class="keyword">self</span> downloadThumbnailForPhotoModel:model];</div><div class="line"></div><div class="line">                                    <span class="keyword">return</span> model;</div><div class="line">                                &#125;] array]];</div><div class="line"></div><div class="line">                                [subject sendCompleted];</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span>&#123;</div><div class="line">                                [subject sendError:connectionError];</div><div class="line">                            &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> subject;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="过滤相同大小的图片，取出他们的url，返回第一个"><a href="#过滤相同大小的图片，取出他们的url，返回第一个" class="headerlink" title="过滤相同大小的图片，取出他们的url，返回第一个"></a>过滤相同大小的图片，取出他们的url，返回第一个</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSString</span> *)urlForImageSize:(<span class="built_in">NSInteger</span>)size inDictionary:(<span class="built_in">NSArray</span> *)array&#123;</div><div class="line">    <span class="keyword">return</span> [[[[[array rac_sequence] filter:^ <span class="built_in">BOOL</span> (<span class="built_in">NSDictionary</span> * value)&#123;</div><div class="line">        <span class="keyword">return</span> [value[<span class="string">@"size"</span>] integerValue] == size;</div><div class="line">    &#125;] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">        <span class="keyword">return</span> value[<span class="string">@"url"</span>];</div><div class="line">    &#125;] array] firstObject];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径"><a href="#观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径" class="headerlink" title="观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径"></a>观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setPhotoModel:(FRPPhotoModel *)photoModel&#123;</div><div class="line">    <span class="keyword">self</span>.subscription = [[[RACObserver(photoModel, thumbnailData)</div><div class="line">        filter:^ <span class="built_in">BOOL</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">            <span class="keyword">return</span> value != <span class="literal">nil</span>;</div><div class="line">        &#125;] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithData:value];</div><div class="line">        &#125;] setKeyPath:@keypath(<span class="keyword">self</span>.imageView, image) onObject:<span class="keyword">self</span>.imageView];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="UITableViewCell复用时需要取消cell上各个组件的订阅"><a href="#UITableViewCell复用时需要取消cell上各个组件的订阅" class="headerlink" title="UITableViewCell复用时需要取消cell上各个组件的订阅"></a>UITableViewCell复用时需要取消cell上各个组件的订阅</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForReuse &#123;</div><div class="line">    [<span class="keyword">super</span> prepareForReuse];</div><div class="line">    [<span class="keyword">self</span>.subscription dispose], <span class="keyword">self</span>.subscription = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Delegate的使用"><a href="#Delegate的使用" class="headerlink" title="Delegate的使用"></a>Delegate的使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意：你必须retain这个delegate对象，否则他们将会被释放，你将会得到一个EXC_BAD_ACCESS异常。添加下列私有属性到画廊视图控制器：</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> collectionViewDelegate;</div><div class="line"></div><div class="line"><span class="comment">//同时你也需要导入RACDelegateProxy.h，因为他不是ReactiveCocoa的核心部分，不包含在ReactiveCocoa.h中。</span></div><div class="line">RACDelegateProxy *viewControllerDelegate = [[RACDelegateProxy alloc]</div><div class="line">                                    initWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">FRPFullSizePhotoViewControllerDelegate</span>)];</span></div><div class="line"></div><div class="line">[[viewControllerDelegate rac_signalForSelector:<span class="keyword">@selector</span>(userDidScroll:toPhotoAtIndex:)     fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">FRPFullSizePhotoViewControllerDelegate</span>)]</span></div><div class="line">        subscribeNext:^(RACTuple *value)&#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            [<span class="keyword">self</span>.collectionView</div><div class="line">                scrollToItemAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForItem:[value.second integerValue] inSection:<span class="number">0</span>]</div><div class="line">                atScrollPosition:<span class="built_in">UICollectionViewScrollPositionCenteredVertically</span></div><div class="line">                animated:<span class="literal">NO</span>];</div><div class="line">        &#125;];</div><div class="line"></div><div class="line"><span class="keyword">self</span>.collectionViewDelegate = [[RACDelegateProxy alloc] initWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UICollectionViewDelegate</span>)];</span></div><div class="line"></div><div class="line">[[<span class="keyword">self</span>.collectionViewDelegate rac_signalForSelector:<span class="keyword">@selector</span>(collectionView:didSelectItemAtIndexPath:)]</div><div class="line">        subscribeNext:^(RACTuple *arguments) &#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            FRPFullSizePhotoViewController *viewController = [[FRPFullSizePhotoViewController alloc] initWithPhotoModels:<span class="keyword">self</span>.photosArray currentPhotoIndex:[(<span class="built_in">NSIndexPath</span> *)arguments.second item]];</div><div class="line">            viewController.delegate = (<span class="keyword">id</span>&lt;FRPFullSizePhotoViewControllerDelegate&gt;)viewControllerDelegate;</div><div class="line"></div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:viewController animated:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">        &#125;];</div></pre></td></tr></table></figure>
<h3 id="处理异常，完成执行刷新操作，异常打印日志，执行对应方法"><a href="#处理异常，完成执行刷新操作，异常打印日志，执行对应方法" class="headerlink" title="处理异常，完成执行刷新操作，异常打印日志，执行对应方法"></a>处理异常，完成执行刷新操作，异常打印日志，执行对应方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RAC(<span class="keyword">self</span>, photosArray) = [[[[FRPPhotoImporter importPhotos]</div><div class="line">        doCompleted:^&#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            [<span class="keyword">self</span>.collectionView reloadData];</div><div class="line">        &#125;] logError] catchTo:[RACSignal empty]];</div></pre></td></tr></table></figure>
<h3 id="网络请求处理数据，获取数据返回主线程"><a href="#网络请求处理数据，获取数据返回主线程" class="headerlink" title="网络请求处理数据，获取数据返回主线程"></a>网络请求处理数据，获取数据返回主线程</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+ (RACSignal *)importPhotos &#123;</div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="keyword">self</span> popularURLRequest];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[[[[[<span class="built_in">NSURLConnection</span> rac_sendAsynchronousRequest:request]</div><div class="line">                reduceEach:^<span class="keyword">id</span>(<span class="built_in">NSURLResponse</span> *response , <span class="built_in">NSData</span> *data)&#123;</div><div class="line">                    <span class="comment">//注意：我们可以用下面的reduceEach:替代使用RACTuple的第一个map:，以便提供编译时检查。</span></div><div class="line">                    <span class="keyword">return</span> data;</div><div class="line">                &#125;]</div><div class="line">                deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">                map:^<span class="keyword">id</span> (<span class="built_in">NSData</span> *data) &#123;</div><div class="line">                    <span class="keyword">id</span> results = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</div><div class="line">                    <span class="keyword">return</span> [[[results[<span class="string">@"photo"</span>] rac_sequence]</div><div class="line">                        map:^<span class="keyword">id</span> (<span class="built_in">NSDictionary</span> *photoDictionary) &#123;</div><div class="line">                            FRPPhotoModel *model = [FRPPhotoModel new];</div><div class="line">                            [<span class="keyword">self</span> configurePhotoModel:model withDictionary:photoDictionary];</div><div class="line">                            [<span class="keyword">self</span> downloadThumbnailForPhotoModel:model];</div><div class="line">                            <span class="keyword">return</span> model;</div><div class="line">                        &#125;] array];</div><div class="line">                &#125;] publish] autoconnect];</div><div class="line">    <span class="comment">//信号链条最末端的信号操作publish. publish返回一个RACMulitcastConnection,当信号连接上时，他将订阅该接收信号。autoconnect为我们做的是：当它返回的信号被订阅，连接到 该(订阅背后的)信号（underly signal）。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="信号的信号Signal-of-signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext-块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。"><a href="#信号的信号Signal-of-signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext-块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。" class="headerlink" title="信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。"></a>信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">//x</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）"><a href="#不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）" class="headerlink" title="不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）"></a>不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)requestAccessToTwitterSignal</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 定义一个错误，如果用户拒绝访问则发送</span></div><div class="line">    <span class="built_in">NSError</span> *accessError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 创建并返回信号</span></div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 请求访问twitter</span></div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        [<span class="keyword">self</span>.accountStore requestAccessToAccountsWithType:<span class="keyword">self</span>.twitterAccountType</div><div class="line">                                                   options:<span class="literal">nil</span></div><div class="line">                                                completion:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                                                    <span class="comment">// 处理响应</span></div><div class="line">                                                    <span class="keyword">if</span> (!granted)</div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendError:accessError];</div><div class="line">                                                    &#125;</div><div class="line">                                                    <span class="keyword">else</span></div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendNext:<span class="literal">nil</span>];</div><div class="line">                                                        [subscriber sendCompleted];</div><div class="line">                                                    &#125;</div><div class="line">                                                &#125;];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//throttle可以避免连续输入造成的不必要的请求，then会忽略前一个信号的值，底层的实现是先过滤之前信号发的值，再使用concat连接then返回的信号。</span></div><div class="line">[[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line">      then:^RACSignal *&#123;</div><div class="line">          @strongify(<span class="keyword">self</span>)</div><div class="line">          <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line">      &#125;]</div><div class="line">     filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">         @strongify(<span class="keyword">self</span>)</div><div class="line">         <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line">     &#125;]</div><div class="line">    throttle:<span class="number">0.5</span>]</div><div class="line">   flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">       @strongify(<span class="keyword">self</span>)</div><div class="line">       <span class="comment">//flattenMap来将每个next事件映射到一个新的被订阅的信号</span></div><div class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line">   &#125;]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="built_in">NSDictionary</span> *jsonSearchResult) &#123;</div><div class="line">     <span class="built_in">NSArray</span> *statuses = jsonSearchResult[<span class="string">@"statuses"</span>];</div><div class="line">     <span class="built_in">NSArray</span> *tweets = [statuses linq_select:^<span class="keyword">id</span>(<span class="keyword">id</span> tweet) &#123;</div><div class="line">         <span class="keyword">return</span> [RWTweet tweetWithStatus:tweet];</div><div class="line">     &#125;];</div><div class="line">     [<span class="keyword">self</span>.resultsViewController displayTweets:tweets];</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div><div class="line"> - (RACSignal *)signalForSearchWithText:(<span class="built_in">NSString</span> *)text &#123;</div><div class="line">    <span class="comment">// 1 - define the errors</span></div><div class="line">    <span class="built_in">NSError</span> *noAccountsError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain</div><div class="line">                                                   code:RWTwitterInstantErrorNoTwitterAccounts</div><div class="line">                                               userInfo:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSError</span> *invalidResponseError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain</div><div class="line">                                                        code:RWTwitterInstantErrorInvalidResponse</div><div class="line">                                                        userInfo:<span class="literal">nil</span>];</div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span> subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        SLRequest *request = [<span class="keyword">self</span> requestforTwitterSearchWithText:text];</div><div class="line">        <span class="built_in">NSArray</span> *twitterAccounts = [<span class="keyword">self</span>.accountStore accountsWithAccountType:<span class="keyword">self</span>.twitterAccountType];         <span class="keyword">if</span> (twitterAccounts.count == <span class="number">0</span>) &#123;</div><div class="line">            [subscriber sendError:noAccountsError];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [request setAccount:[twitterAccounts lastObject]];</div><div class="line">        [request performRequestWithHandler: ^(<span class="built_in">NSData</span> *responseData,</div><div class="line">                <span class="built_in">NSHTTPURLResponse</span> *urlResponse, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">            <span class="keyword">if</span> (urlResponse.statusCode == <span class="number">200</span>) &#123;</div><div class="line">                <span class="built_in">NSDictionary</span> *timelineData = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:responseData</div><div class="line">                                                options:<span class="built_in">NSJSONReadingAllowFragments</span></div><div class="line">                                                  error:<span class="literal">nil</span>];</div><div class="line">                [subscriber sendNext:timelineData];</div><div class="line">                [subscriber sendCompleted];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [subscriber sendError:invalidResponseError];</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/ming1016/study/blob/master/pic/CompletePipeline.png?raw=true" alt="不同信号顺序链接"></p>
<h3 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-(RACSignal *)signalForLoadingImage:(<span class="built_in">NSString</span> *)imageUrl &#123;</div><div class="line"></div><div class="line">    RACScheduler *scheduler = [RACScheduler</div><div class="line">                               schedulerWithPriority:RACSchedulerPriorityBackground];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:imageUrl]];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        [subscriber sendNext:image];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;] subscribeOn:scheduler];</div><div class="line">&#125;</div><div class="line"></div><div class="line">cell.twitterAvatarView.image = <span class="literal">nil</span>;</div><div class="line">[[[<span class="keyword">self</span> signalForLoadingImage:tweet.profileImageUrl]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">  subscribeNext:^(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">   cell.twitterAvatarView.image = image;</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<h3 id="观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用"><a href="#观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用" class="headerlink" title="观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用"></a>观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[[RACSignal merge: @[RACObserve(<span class="keyword">self</span>.viewModel,  tweets),</div><div class="line">                     RACObserve(<span class="keyword">self</span>.viewModel,  allTweetsLoaded)]]</div><div class="line">    bufferWithTime: <span class="number">0</span> onScheduler: [RACScheduler mainThreadScheduler]]</div><div class="line">    subscribeNext: ^(<span class="keyword">id</span> value) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125;];</div><div class="line"><span class="comment">//bufferWithTime设置为0是为了避免同一时刻两个值被同时设置新值产生了table进行了两次reloadData</span></div></pre></td></tr></table></figure>
<h3 id="封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。"><a href="#封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。" class="headerlink" title="封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。"></a>封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[tableView rac_signalForSelector:<span class="keyword">@selector</span>(layoutSubviews)]subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    [<span class="keyword">self</span> doSomethingBeforeTableViewLayoutSubviews];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等"><a href="#使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等" class="headerlink" title="使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等"></a>使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等</h3><p>Demo的github地址：<a href="https://github.com/olegam/RACCommandExample" target="_blank" rel="external">https://github.com/olegam/RACCommandExample</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindWithViewModel &#123;</div><div class="line">  RAC(<span class="keyword">self</span>.viewModel, email) =<span class="keyword">self</span>.emailTextField.rac_textSignal;</div><div class="line">  <span class="keyword">self</span>.subscribeButton.rac_command = <span class="keyword">self</span>.viewModel.subscribeCommand;</div><div class="line">  RAC(<span class="keyword">self</span>.statusLabel, text) =RACObserve(<span class="keyword">self</span>.viewModel, statusMessage);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubscribeViewModel</span> :<span class="title">NSObject</span></span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)RACCommand *subscribeCommand;  <span class="comment">// writeto this property</span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *email;  <span class="comment">// read from this property</span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *statusMessage;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"SubscribeViewModel.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"AFHTTPRequestOperationManager+RACSupport.h"</span></span></div><div class="line"><span class="meta">#import<span class="meta-string">"NSString+EmailAdditions.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kSubscribeURL =<span class="string">@"http://reactivetest.apiary.io/subscribers"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubscribeViewModel</span> ()</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSignal*emailValidSignal;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubscribeViewModel</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">       <span class="keyword">self</span>= [<span class="keyword">super</span> init];</div><div class="line">       <span class="keyword">if</span>(<span class="keyword">self</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> mapSubscribeCommandStateToStatusMessage];</div><div class="line">       &#125;</div><div class="line">       returnself;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)mapSubscribeCommandStateToStatusMessage &#123;</div><div class="line">       RACSignal *startedMessageSource = [<span class="keyword">self</span>.subscribeCommand.executionSignals map:^<span class="keyword">id</span>(RACSignal *subscribeSignal) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Sending request..."</span>, <span class="literal">nil</span>);</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RACSignal *completedMessageSource = [<span class="keyword">self</span>.subscribeCommand.executionSignals flattenMap:^RACStream *(RACSignal *subscribeSignal) &#123;</div><div class="line">              <span class="keyword">return</span>[[[subscribeSignal materialize] filter:^<span class="built_in">BOOL</span>(RACEvent *event) &#123;</div><div class="line">                     <span class="keyword">return</span> event.eventType == RACEventTypeCompleted;</div><div class="line">              &#125;] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">                     <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Thanks"</span>, <span class="literal">nil</span>);</div><div class="line">              &#125;];</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RACSignal*failedMessageSource = [[<span class="keyword">self</span>.subscribeCommand.errors subscribeOn:[RACSchedulermainThreadScheduler]] map:^<span class="keyword">id</span>(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Error :("</span>, <span class="literal">nil</span>);</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RAC(<span class="keyword">self</span>,statusMessage) = [RACSignal merge:@[startedMessageSource, completedMessageSource, failedMessageSource]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (RACCommand *)subscribeCommand &#123;</div><div class="line">       <span class="keyword">if</span>(!_subscribeCommand) &#123;</div><div class="line">              @weakify(<span class="keyword">self</span>);</div><div class="line">              _subscribeCommand = [[RACCommand alloc] initWithEnabled:<span class="keyword">self</span>.emailValidSignal signalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line">                     @strongify(<span class="keyword">self</span>);</div><div class="line">                     <span class="keyword">return</span> [SubscribeViewModel postEmail:<span class="keyword">self</span>.email];</div><div class="line">              &#125;];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> _subscribeCommand;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (RACSignal *)postEmail:(<span class="built_in">NSString</span> *)email&#123;</div><div class="line">       AFHTTPRequestOperationManager*manager = [AFHTTPRequestOperationManager manager];</div><div class="line">       manager.requestSerializer= [AFJSONRequestSerializer new];</div><div class="line">       <span class="built_in">NSDictionary</span>*body = @&#123;<span class="string">@"email"</span>: email ?: <span class="string">@""</span>&#125;;</div><div class="line">       <span class="keyword">return</span> [[[manager rac_POST:kSubscribeURL parameters:body] logError] replayLazily];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (RACSignal *)emailValidSignal &#123;</div><div class="line">       <span class="keyword">if</span>(!_emailValidSignal) &#123;</div><div class="line">              _emailValidSignal= [RACObserve(<span class="keyword">self</span>, email) map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *email) &#123;</div><div class="line">                     <span class="keyword">return</span>@([email isValidEmail]);</div><div class="line">              &#125;];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> _emailValidSignal;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="替换Delegate，直接使用RACSubject"><a href="#替换Delegate，直接使用RACSubject" class="headerlink" title="替换Delegate，直接使用RACSubject"></a>替换Delegate，直接使用RACSubject</h3><h1 id="RAC内存管理"><a href="#RAC内存管理" class="headerlink" title="RAC内存管理"></a>RAC内存管理</h1><p>RAC会维护一个全局的信号集合，一个或多于一个订阅者就可用，所有订阅者都被移除了，信号就被释放了。</p>
<h1 id="RAC需要注意的内存问题"><a href="#RAC需要注意的内存问题" class="headerlink" title="RAC需要注意的内存问题"></a>RAC需要注意的内存问题</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123; <span class="comment">//1</span></div><div class="line">        MTModel *model = [[MTModel alloc] init]; <span class="comment">// MTModel有一个名为的title的属性</span></div><div class="line">        [subscriber sendNext:model];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.flattenMapSignal = [signal flattenMap:^RACStream *(MTModel *model) &#123; <span class="comment">//2</span></div><div class="line">        <span class="keyword">return</span> RACObserve(model, title);</div><div class="line">    &#125;];</div><div class="line">    [<span class="keyword">self</span>.flattenMapSignal subscribeNext:^(<span class="keyword">id</span> x) &#123; <span class="comment">//3</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"subscribeNext - %@"</span>, x);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的RACObserve会引起引用不释放的问题，通过RACObserve的定义来看看，里面会对self进行持有。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define RACObserve(TARGET, KEYPATH) \</span></div><div class="line">    (&#123; \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic push"</span>) \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic ignored \"-Wreceiver-is-weak\""</span>) \</div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">id</span> target_ = (TARGET); \</div><div class="line">        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:<span class="keyword">self</span>]; \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic pop"</span>) \</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p>对subject进行map这样的操作，这时就需要sendCompleted<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    RACSubject *subject = [RACSubject subject];</div><div class="line">    [subject.rac_willDeallocSignal subscribeCompleted:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"subject dealloc"</span>);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [[subject map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">        <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</div><div class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"next = %@"</span>, x);</div><div class="line">    &#125;];</div><div class="line">    [subject sendNext:@<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是为什么signal进行map操作，不sendCompleted而不会内存泄漏呢。因为调到bind的比如map、filter、merge、combineLatest、flattenMap等操作如果是RACSubject这样会持有订阅者的信号会产生内存泄漏需要sendCompleted。可以先看看bind的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * -bind: should:</div><div class="line">     *</div><div class="line">     * 1. Subscribe to the original signal of values.</div><div class="line">     * 2. Any time the original signal sends a value, transform it using the binding block.</div><div class="line">     * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they're received.</div><div class="line">     * 4. If the binding block asks the bind to terminate, complete the _original_ signal.</div><div class="line">     * 5. When _all_ signals complete, send completed to the subscriber.</div><div class="line">     *</div><div class="line">     * If any signal sends an error at any point, send that to the subscriber.</div><div class="line">     */</div><div class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        RACStreamBindBlock bindingBlock = block();</div><div class="line">        <span class="built_in">NSMutableArray</span> *signals = [<span class="built_in">NSMutableArray</span> arrayWithObject:<span class="keyword">self</span>];</div><div class="line">        <span class="comment">// 此处省略了80行代码</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>didSubscribe的开头，就创建了一个数组signals，并且持有了self，也就是源信号，也就是订阅者持有了信号，如果是Subject那么这种信号又会持有订阅者，这样就形成了循环引用。</p>
<p>下面看看sendCompleted如何修复的内存泄漏<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^completeSignal)(RACSignal *, RACDisposable *) = ^(RACSignal *signal, RACDisposable *finishedDisposable) &#123;</div><div class="line">    <span class="built_in">BOOL</span> removeDisposable = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">@synchronized</span> (signals) &#123;</div><div class="line">        [signals removeObject:signal]; <span class="comment">//1</span></div><div class="line">        <span class="keyword">if</span> (signals.count == <span class="number">0</span>) &#123;</div><div class="line">            [subscriber sendCompleted]; <span class="comment">//2</span></div><div class="line">            [compoundDisposable dispose]; <span class="comment">//3</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            removeDisposable = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (removeDisposable) [compoundDisposable removeDisposable:finishedDisposable]; <span class="comment">//4</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从signals这个数组中移除传入的signal，也就是让订阅的signal不会持有subject这种信号。</p>
<p>还有replay这样的操作，因为这个方法返回的是一个RACReplaySubject<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    [subscriber sendNext:@<span class="number">1</span>];</div><div class="line">    [subscriber sendCompleted]; <span class="comment">// 保证源信号发送完成</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *replaySignal = [signal replay]; <span class="comment">// 这里返回的其实是一个RACReplaySubject</span></div><div class="line"></div><div class="line">[[replaySignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">    <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscribeNext - %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h1 id="热信号冷信号"><a href="#热信号冷信号" class="headerlink" title="热信号冷信号"></a>热信号冷信号</h1><ul>
<li>热信号是主动的，不订阅也能够按时发送。冷信号是被动的，只有订阅才会发送。</li>
<li>热信号可以有多个订阅者。冷信号只能够一对一，有不同订阅者，消息会从新完整发送。</li>
</ul>
<h1 id="RAC的API手册"><a href="#RAC的API手册" class="headerlink" title="RAC的API手册"></a>RAC的API手册</h1><h2 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h2><h3 id="RACSiganl-信号类。"><a href="#RACSiganl-信号类。" class="headerlink" title="RACSiganl 信号类。"></a>RACSiganl 信号类。</h3><ul>
<li>RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法；</li>
<li>RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法；</li>
<li>RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；</li>
<li>RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法；</li>
<li>RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。</li>
</ul>
<h3 id="RACSubscriber-订阅者"><a href="#RACSubscriber-订阅者" class="headerlink" title="RACSubscriber 订阅者"></a>RACSubscriber 订阅者</h3><h3 id="RACDisposable-用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。"><a href="#RACDisposable-用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。" class="headerlink" title="RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。"></a>RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</h3><ul>
<li>RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来；</li>
<li>RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察；</li>
<li>RACCompoundDisposable ：它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象</li>
<li>RACScopedDisposable ：当它被 dealloc 的时候调用本身的 -dispose 方法。</li>
</ul>
<h3 id="RACSubject-信号提供者，自己可以充当信号，又能发送信号。订阅后发送"><a href="#RACSubject-信号提供者，自己可以充当信号，又能发送信号。订阅后发送" class="headerlink" title="RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送"></a>RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送</h3><ul>
<li>RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能；</li>
<li>RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值；</li>
<li>RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。可以先发送后订阅</li>
</ul>
<h3 id="RACTuple-元组类-类似NSArray-用来包装值"><a href="#RACTuple-元组类-类似NSArray-用来包装值" class="headerlink" title="RACTuple 元组类,类似NSArray,用来包装值."></a>RACTuple 元组类,类似NSArray,用来包装值.</h3><h3 id="RACSequence-RAC中的集合类"><a href="#RACSequence-RAC中的集合类" class="headerlink" title="RACSequence RAC中的集合类"></a>RACSequence RAC中的集合类</h3><h3 id="RACCommand-RAC中用于处理事件的类，可以把事件如何处理-事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。"><a href="#RACCommand-RAC中用于处理事件的类，可以把事件如何处理-事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。" class="headerlink" title="RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。"></a>RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</h3><h3 id="RACMulticastConnection-用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。"><a href="#RACMulticastConnection-用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。" class="headerlink" title="RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。"></a>RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</h3><h3 id="RACScheduler-RAC中的队列，用GCD封装的。"><a href="#RACScheduler-RAC中的队列，用GCD封装的。" class="headerlink" title="RACScheduler RAC中的队列，用GCD封装的。"></a>RACScheduler RAC中的队列，用GCD封装的。</h3><ul>
<li>RACImmediateScheduler ：立即执行调度的任务，这是唯一一个支持同步执行的调度器；</li>
<li>RACQueueScheduler ：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务；</li>
<li>RACTargetQueueScheduler ：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务；</li>
<li>RACSubscriptionScheduler ：一个只用来调度订阅的调度器。</li>
</ul>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><ul>
<li>rac_signalForSelector : 代替代理</li>
<li>rac_valuesAndChangesForKeyPath: KVO</li>
<li>rac_signalForControlEvents:监听事件</li>
<li>rac_addObserverForName 代替通知</li>
<li>rac_textSignal：监听文本框文字改变</li>
<li>rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
</ul>
<h2 id="常见宏"><a href="#常见宏" class="headerlink" title="常见宏"></a>常见宏</h2><ul>
<li>RAC(TARGET, [KEYPATH, [NIL_VALUE]])：用于给某个对象的某个属性绑定</li>
<li>RACObserve(self, name) ：监听某个对象的某个属性,返回的是信号。</li>
<li>@weakify(Obj)和@strongify(Obj)</li>
<li>RACTuplePack ：把数据包装成RACTuple（元组类）</li>
<li>RACTupleUnpack：把RACTuple（元组类）解包成对应的数据</li>
<li>RACChannelTo 用于双向绑定的一个终端</li>
</ul>
<h2 id="常用操作方法"><a href="#常用操作方法" class="headerlink" title="常用操作方法"></a>常用操作方法</h2><ul>
<li>flattenMap map 用于把源信号内容映射成新的内容。</li>
<li>concat 组合 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号</li>
<li>then 用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</li>
<li>merge 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用</li>
<li>zipWith 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。</li>
<li>combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</li>
<li>reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值</li>
<li>filter:过滤信号，使用它可以获取满足条件的信号.</li>
<li>ignore:忽略完某些值的信号.</li>
<li>distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</li>
<li>take:从开始一共取N次的信号</li>
<li>takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.</li>
<li>takeUntil:(RACSignal *):获取信号直到某个信号执行完成</li>
<li>skip:(NSUInteger):跳过几个信号,不接受。</li>
<li>switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</li>
<li>doNext: 执行Next之前，会先执行这个Block</li>
<li>doCompleted: 执行sendCompleted之前，会先执行这个Block</li>
<li>timeout：超时，可以让一个信号在一定的时间后，自动报错。</li>
<li>interval 定时：每隔一段时间发出信号</li>
<li>delay 延迟发送next。</li>
<li>retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</li>
<li>replay重放：当一个信号被多次订阅,反复播放内容</li>
<li>throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</li>
</ul>
<h2 id="UI-Category（常用汇总）"><a href="#UI-Category（常用汇总）" class="headerlink" title="UI - Category（常用汇总）"></a>UI - Category（常用汇总）</h2><h3 id="rac-prepareForReuseSignal：-需要复用时用"><a href="#rac-prepareForReuseSignal：-需要复用时用" class="headerlink" title="rac_prepareForReuseSignal： 需要复用时用"></a>rac_prepareForReuseSignal： 需要复用时用</h3><ul>
<li>相关UI: MKAnnotationView、UICollectionReusableView、UITableViewCell、UITableViewHeaderFooterView</li>
</ul>
<h3 id="rac-buttonClickedSignal：点击事件触发信号"><a href="#rac-buttonClickedSignal：点击事件触发信号" class="headerlink" title="rac_buttonClickedSignal：点击事件触发信号"></a>rac_buttonClickedSignal：点击事件触发信号</h3><ul>
<li>相关UI：UIActionSheet、UIAlertView</li>
</ul>
<h3 id="rac-command：button类、刷新类相关命令替换"><a href="#rac-command：button类、刷新类相关命令替换" class="headerlink" title="rac_command：button类、刷新类相关命令替换"></a>rac_command：button类、刷新类相关命令替换</h3><ul>
<li>相关UI：UIBarButtonItem、UIButton、UIRefreshControl</li>
</ul>
<h3 id="rac-signalForControlEvents-control-event-触发"><a href="#rac-signalForControlEvents-control-event-触发" class="headerlink" title="rac_signalForControlEvents: control event 触发"></a>rac_signalForControlEvents: control event 触发</h3><ul>
<li>相关UI：UIControl</li>
</ul>
<h3 id="rac-gestureSignal-UIGestureRecognizer-事件处理信号"><a href="#rac-gestureSignal-UIGestureRecognizer-事件处理信号" class="headerlink" title="rac_gestureSignal UIGestureRecognizer 事件处理信号"></a>rac_gestureSignal UIGestureRecognizer 事件处理信号</h3><ul>
<li>相关UI：UIGestureRecognizer</li>
</ul>
<h3 id="rac-imageSelectedSignal-选择图片的信号"><a href="#rac-imageSelectedSignal-选择图片的信号" class="headerlink" title="rac_imageSelectedSignal 选择图片的信号"></a>rac_imageSelectedSignal 选择图片的信号</h3><ul>
<li>相关UI：UIImagePickerController</li>
</ul>
<h3 id="rac-textSignal"><a href="#rac-textSignal" class="headerlink" title="rac_textSignal"></a>rac_textSignal</h3><ul>
<li>相关UI：UITextField、UITextView</li>
</ul>
<h3 id="可实现双向绑定的相关API"><a href="#可实现双向绑定的相关API" class="headerlink" title="可实现双向绑定的相关API"></a>可实现双向绑定的相关API</h3><ul>
<li>rac_channelForControlEvents: key: nilValue:</li>
<li>相关UI：UIControl类</li>
<li>rac_newDateChannelWithNilValue:</li>
<li>相关UI：UIDatePicker</li>
<li>rac_newSelectedSegmentIndexChannelWithNilValue:</li>
<li>相关UI：UISegmentedControl</li>
<li>rac_newValueChannelWithNilValue:</li>
<li>相关UI：UISlider、UIStepper</li>
<li>rac_newOnChannel</li>
<li>相关UI：UISwitch</li>
<li>rac_newTextChannel</li>
<li>相关UI：UITextField</li>
</ul>
<h2 id="Foundation-Category-（常用汇总）"><a href="#Foundation-Category-（常用汇总）" class="headerlink" title="Foundation - Category （常用汇总）"></a>Foundation - Category （常用汇总）</h2><h3 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h3><ul>
<li>rac_readContentsOfURL: options: scheduler: 比oc多出线程设置</li>
</ul>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><ul>
<li>rac_sequence</li>
<li>rac_keySequence key 集合</li>
<li>rac_valueSequence value 集合</li>
</ul>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><ul>
<li>rac_sequence 信号集合</li>
</ul>
<h3 id="NSFileHandle"><a href="#NSFileHandle" class="headerlink" title="NSFileHandle"></a>NSFileHandle</h3><ul>
<li>rac_readInBackground 后台线程读取</li>
</ul>
<h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><ul>
<li>rac_setArgument: atIndex: 设置参数</li>
<li>rac_argumentAtIndex 取某个参数</li>
<li>rac_returnValue 所关联方法的返回值</li>
</ul>
<h3 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h3><ul>
<li>rac_addObserverForName: object:注册通知</li>
</ul>
<h3 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h3><ul>
<li>rac_willDeallocSignal 对象销毁时发动的信号</li>
<li>rac_description debug用</li>
<li>rac_observeKeyPath: options: observer: block:监听某个事件</li>
<li>rac_liftSelector: withSignals: 全部信号都next在执行</li>
<li>rac_signalForSelector: 代替某个方法</li>
<li>rac_signalForSelector:(SEL)selector fromProtocol:代替代理</li>
</ul>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><ul>
<li>rac_keyPathComponents 获取一个路径所有的部分</li>
<li>rac_keyPathByDeletingLastKeyPathComponent 删除路径最后一部分</li>
<li>rac_keyPathByDeletingFirstKeyPathComponent 删除路径第一部分</li>
<li>rac_readContentsOfURL: usedEncoding: scheduler: 比之OC多线程调用</li>
<li>rac_sequence</li>
</ul>
<h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><ul>
<li>rac_sendAsynchronousRequest 发起异步请求</li>
</ul>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><ul>
<li>rac_channelTerminalForKey 用于双向绑定，此乃一</li>
</ul>
<h3 id="NSEnumerator"><a href="#NSEnumerator" class="headerlink" title="NSEnumerator"></a>NSEnumerator</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSIndexSet"><a href="#NSIndexSet" class="headerlink" title="NSIndexSet"></a>NSIndexSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSOrderedSet"><a href="#NSOrderedSet" class="headerlink" title="NSOrderedSet"></a>NSOrderedSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h1 id="RAC图片版的API手册"><a href="#RAC图片版的API手册" class="headerlink" title="RAC图片版的API手册"></a>RAC图片版的API手册</h1><h2 id="ReactiveCocoa-objectivec"><a href="#ReactiveCocoa-objectivec" class="headerlink" title="ReactiveCocoa objectivec"></a>ReactiveCocoa objectivec</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/ReactiveCocoaOC.png?raw=true" alt="ReactiveCocoaobjectivec"></p>
<h2 id="ReactiveCocoa-Swift"><a href="#ReactiveCocoa-Swift" class="headerlink" title="ReactiveCocoa Swift"></a>ReactiveCocoa Swift</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/ReactiveCocoaSwift.png?raw=true" alt="ReactiveCocoaSwift"></p>
<h2 id="RXSwift"><a href="#RXSwift" class="headerlink" title="RXSwift"></a>RXSwift</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/RXSwift.png?raw=true" alt="RXSwift"></p>
<h1 id="本文参考整理自"><a href="#本文参考整理自" class="headerlink" title="本文参考整理自"></a>本文参考整理自</h1><ul>
<li>ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2 <a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1</a></li>
<li>ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2 <a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2</a></li>
<li>iOS的函数响应型编程 <a href="https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details" target="_blank" rel="external">https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details</a></li>
<li>ReactiveCocoa Essentials: Understanding and Using RACCommand <a href="http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/" target="_blank" rel="external">http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/</a></li>
<li>iOS ReactiveCocoa 最全常用API整理（可做为手册查询）<a href="http://www.cocoachina.com/ios/20160729/17236.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20160729/17236.html</a></li>
<li>ReactiveCocoa和RXSwift速查表 <a href="http://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/" target="_blank" rel="external">http://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/</a></li>
<li>ReactiveCocoa中潜在的内存泄漏及解决方案<a href="http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅&lt;/p&gt;
&lt;h1 id=&quot;声明式编程泛型Declarative-programming&quot;&gt;&lt;a href=&quot;#声明式编程泛型Declarative-programming&quot;
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://ming1016.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>制作一个类似苹果VFL(Visual Format Language)的格式化语言来描述类似UIStackView那种布局思路，并解析生成页面</title>
    <link href="http://ming1016.github.io/2016/07/21/assembleview/"/>
    <id>http://ming1016.github.io/2016/07/21/assembleview/</id>
    <published>2016-07-21T13:38:01.000Z</published>
    <updated>2017-05-26T13:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中总是希望页面上各处的文字，颜色，字体大小甚至各个视图控件布局都能够在发版之后能够修改以弥补一些前期考虑不周，或者根据统计数据能够随时进行调整，当然是各个版本都能够统一变化。看到这样的要求后，第一反应是这样的页面只能改成H5，或者尝试使用React Native来应对这种要求。</p>
<p>既然UIStackView已经提供了一种既先进又简洁的布局思路，为何不通过制作一个类似VFL这样的DSL语言来处理布局。这样不就能够通过下发一串DSL字符串的方式来进行内容样式甚至布局的更换，不用跟版，还能使多版本统一。同时在端内直接用这样的DSL语言来写界面不光能够减少代码量易于维护，还能够很直观方便的看出整个界面布局结构。</p>
<h1 id="AssembleView（组装视图）和PartView（零件视图）"><a href="#AssembleView（组装视图）和PartView（零件视图）" class="headerlink" title="AssembleView（组装视图）和PartView（零件视图）"></a>AssembleView（组装视图）和PartView（零件视图）</h1><p>在设计格式化语言之前需要对布局做个统一思想进行管理，在看了WWDC里关于UIStackView的介绍后感觉任何复杂的布局都能够通过这样一种组合排布再组合排布的思路特别适合用格式化语言来描述。于是我想出两个视图概念。</p>
<p>一个是AssembleView组合视图，专门用于对其PartView子视图进行排列，比如说是水平排列还是垂直排列，PartView是按照居中对齐还是居左等对齐方式，各个PartView之间间隔是多少。</p>
<p>PartView决定自己视图类型，内容，无固定大小的可以设置大小，同时AssembleView可以作为PartView被加入另一个AssembleView里进行排列，这样各种设计图都可以在初期通过拆解分成不同的AssembleView和PartView进行组合套组合布局出来。</p>
<h1 id="格式化语言"><a href="#格式化语言" class="headerlink" title="格式化语言"></a>格式化语言</h1><p>接下来是如何通过格式化语言来描述AssembleView和PartView。“{}”符号里包含的是AssembleView的设置，“[]”符号里是PartView的设置，“()”里是他们的属性设置，“&lt;&gt;”可以将对象带入到设置里。下面举几个例子说明下。完整Demo放到了Github上：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">https://github.com/ming1016/STMAssembleView</a></p>
<h2 id="三个星星水平对齐居中排列"><a href="#三个星星水平对齐居中排列" class="headerlink" title="三个星星水平对齐居中排列"></a>三个星星水平对齐居中排列</h2><p>h表示水平排列horizontal，c表示居中center，“[]”PartView会根据顺序依次添加排列，imageName属性能够指定本地图片<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/center.png?raw=true" alt="三个星星水平对齐居中排列"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    hc(padding:30)</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView里套作为PartView的AssembleView的复杂情况"><a href="#AssembleView里套作为PartView的AssembleView的复杂情况" class="headerlink" title="AssembleView里套作为PartView的AssembleView的复杂情况"></a>AssembleView里套作为PartView的AssembleView的复杂情况</h2><p>color可以指定文字颜色，font指定文字大小<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/mid.png?raw=true" alt="AssembleView里套作为PartView的AssembleView的复杂情况"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    ht(padding:10)</div><div class="line">    [avatarImageView(imageName:avatar)]</div><div class="line">    [</div><div class="line">        &#123;</div><div class="line">            vl(padding:10)</div><div class="line">            [(text:戴铭,color:AAA0A3)]</div><div class="line">            [(text:Starming站长,color:E3DEE0,font:13)]</div><div class="line">            [(text:喜欢画画编程和写小说,color:E3DEE0,font:13)]</div><div class="line">        &#125;</div><div class="line">        (width:210,backColor:FAF8F9,backPaddingHorizontal:10,backPaddingVertical:10,radius:8)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="给PartView设置背景色和按钮"><a href="#给PartView设置背景色和按钮" class="headerlink" title="给PartView设置背景色和按钮"></a>给PartView设置背景色和按钮</h2><p>设置背景色使用backColor，背景距离设置的PartView的内容间距通过backPaddingHorizontal属性设置水平间距，backPaddingVertical设置垂直间距，“&lt;&gt;”符号带入的button通过button属性设置。<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/followBt.png?raw=true" alt="给PartView设置背景色和按钮"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        hc(padding:4)</div><div class="line">        [(imageName:starmingicon,width:14,height:10)]</div><div class="line">        [(text:关注,font:16,color:FFFFFF)]</div><div class="line">    &#125;</div><div class="line">    (height:36,backColor:AAA0A3,radius:8,backBorderWidth:1,backBorderColor:E3DEE0,backPaddingHorizontal:80,backPaddingVertical:10,button:&lt;clickBt&gt;)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView设置忽略约束的方法"><a href="#AssembleView设置忽略约束的方法" class="headerlink" title="AssembleView设置忽略约束的方法"></a>AssembleView设置忽略约束的方法</h2><p>水平排列时，通过ignoreAlignment属性设置忽略left约束，如果是垂直排列设置top忽略。<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/des.png?raw=true" alt="AssembleView设置忽略约束的方法"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    hc(padding:5)</div><div class="line">    [(text:STMAssembleView演示,color:E3DEE0,font:13)]</div><div class="line">    [(imageName:starmingicon,width:14,height:10,ignoreAlignment:left)]</div><div class="line">    [(text:Starming星光社,color:E3DEE0,font:13)]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="将前面的视图组合成一个AssembleView"><a href="#将前面的视图组合成一个AssembleView" class="headerlink" title="将前面的视图组合成一个AssembleView"></a>将前面的视图组合成一个AssembleView</h2><p><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/as.png?raw=true" alt="将前面的视图组合成一个AssembleView"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ASS(@&quot;&#123;</div><div class="line">    vc(padding:20)</div><div class="line">    [%@(height:90)]</div><div class="line">    [%@(height:36,backColor:AAA0A3,radius:8,backBorderWidth:1,backBorderColor:E3DEE0,backPaddingHorizontal:80,backPaddingVertical:10,button:&lt;clickBt&gt;)]</div><div class="line">    [%@(height:25)]</div><div class="line">    [%@(ignoreAlignment:top,isFill:1,height:16)]</div><div class="line">&#125;&quot;,midStr,followBtStr,centerStr,desStr)</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView的属性"><a href="#AssembleView的属性" class="headerlink" title="AssembleView的属性"></a>AssembleView的属性</h2><ul>
<li>当在“{}”里面第一个字母是v表示垂直排列vertical，是h表示水平排列horizontal</li>
<li>第二个字母是c表示所有PartView居中对齐center，l表示居左对齐left，r表示居右对齐right，t表示居上对齐top，b表示居下对齐bottom。</li>
<li>padding：默认各个PartView的间距。</li>
</ul>
<h2 id="PartView的属性"><a href="#PartView的属性" class="headerlink" title="PartView的属性"></a>PartView的属性</h2><p>如果不希望通过属性生成视图，可以通过在[后直接填入带入对象对应的key，然后再在()里设置属性。</p>
<h3 id="PartView布局相关属性"><a href="#PartView布局相关属性" class="headerlink" title="PartView布局相关属性"></a>PartView布局相关属性</h3><ul>
<li>width：UILabel和UIImage这样有固定大小的可以不用设置，会按照固定大小的来。</li>
<li>height：有固定大小的可以不用设置。</li>
<li>isFill：垂直排列时会将宽设置为父AssembleView的宽，水平排列时会将高设置为父AssembleView的高。</li>
<li>padding：设置后会忽略父AssembleView里设置的padding，达到自定义间距的效果。</li>
<li>partAlignment：可以自定义对齐方向，设置后会忽略父AssembleView里设置的对齐。值可填center，left，right，top，bottom。</li>
<li>ignoreAlignment：设置忽略的约束方向，在父AssembleView不需要由子PartView决定大小的情况下，可以通过打断某个方向约束来实现拆开排列的效果。值可填center，left，right，top，bottom。</li>
</ul>
<h3 id="PartView权重相关属性"><a href="#PartView权重相关属性" class="headerlink" title="PartView权重相关属性"></a>PartView权重相关属性</h3><ul>
<li>crp：Compression Resistance Priority的设置，根据权重由低到高值可以设置为fit，low，high，required。对应的UILayoutPriority的分别是UILayoutPriorityFittingSizeLevel，UILayoutPriorityDefaultLow，UILayoutPriorityDefaultHigh，UILayoutPriorityRequired。</li>
<li>minWidth：对应NSLayoutRelationGreaterThanOrEqual，设置一个最小的宽</li>
<li>maxWidth：对应NSLayoutRelationLessThanOrEqual，设置一个最大的宽</li>
</ul>
<h3 id="PartView视图控件相关设置"><a href="#PartView视图控件相关设置" class="headerlink" title="PartView视图控件相关设置"></a>PartView视图控件相关设置</h3><p>通过以下属性即可生成对应的UILabel，UIImageView或者UIButton等控件视图，而不用特别指出需要生成哪种控件视图</p>
<ul>
<li>text：设置文字内容</li>
<li>font：设置字体，可以带入一个UIFont，也可以直接设置一个字体大小，解析时会判断类型。</li>
<li>color：设置颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>imageName：设置本地图片，值是本地图片名称。</li>
<li>image：带入一个UIImage。</li>
<li>imageUrl：设置一个网络图片的url地址，ps:目前需要通过&lt;&gt;来带入一个字符串。</li>
</ul>
<h3 id="PartView的通用设置"><a href="#PartView的通用设置" class="headerlink" title="PartView的通用设置"></a>PartView的通用设置</h3><p>可以为PartView创建一个底部视图，并设置其样式。也可以添加一个UIButton设置UIControlStateHighlighted时的样式。</p>
<ul>
<li>backColor：设置底部视图的颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>backPaddingHorizontal：设置当前PartView视图距离底部视图top和bottom的间距。</li>
<li>backPaddingVertical：设置当前PartView视图距离底部视图left和right的间距。</li>
<li>backBorderColor：设置底部视图边框的颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>backBorderWidth：设置底部视图边框宽。</li>
<li>radius：设置底部视图的圆角半径。</li>
<li>button：带入一个button。</li>
<li>buttonHighlightColor：设置button在UIControlStateHighlighted时的颜色，默认是透明度0.05的黑色。</li>
</ul>
<h1 id="解析格式化语言"><a href="#解析格式化语言" class="headerlink" title="解析格式化语言"></a>解析格式化语言</h1><p>解析过程的第一步采用扫描scanner程序将字符串按照分析符号表将字符流序列收集到有意义的单元中。</p>
<p>第二步将这些单元逐个归类到对应的类别中。比如解析到“()”里内容时就将其归类到对应的AssembleView的属性或者PartView的属性类别中。在归类过程中会出现PartView是AssembleView，这个Assemble里面又有这样作为PartView的AssembleView这样层层套的情况，所以需要采用类似引用计数方式保证在最后一个“}”符号结束时能将整个Assemble递归进行解析。</p>
<p>第三步将各个类别集合转换成对应原生代码从而生成对应的视图布局。</p>
<p>具体实现可以查看STMAssembleView.m文件。Github地址：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">https://github.com/ming1016/STMAssembleView</a></p>
<h1 id="如何生成页面"><a href="#如何生成页面" class="headerlink" title="如何生成页面"></a>如何生成页面</h1><p>生成页面需要实现格式化语言对应的原生代码，所有PartView的属性都会存放在STMPartMaker里，包括带入的自定义视图还有用于生成视图控件的属性等。PartView属性设置完成后会在STMPartView这个类中先决定对应的视图控件，并将STMPartMaker里的属性都设置上。实现代码可以查看STMPartView.m里的- (STMPartView *)buildPartView方法。</p>
<p>接下来STMAssembleView会在buildAssembleView时进行布局，具体实现代码可以查看STMAssembleView.m里的- (STMAssembleView *)buildAssembleView方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中总是希望页面上各处的文字，颜色，字体大小甚至各个视图控件布局都能够在发版之后能够修改以弥补一些前期考虑不周，或者根据统计数据能够随时进行调整，当然是各个版本都能够统一变化。看到这样的要求后，第一反应是这样的页面只能改成H5，或者尝试使用React Native来应对
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="AssembleView" scheme="http://ming1016.github.io/tags/AssembleView/"/>
    
  </entry>
  
  <entry>
    <title>从 ReactiveCocoa 中能学到什么？不用此库也能学以致用</title>
    <link href="http://ming1016.github.io/2016/05/30/what-learn-from-reactivecocoa/"/>
    <id>http://ming1016.github.io/2016/05/30/what-learn-from-reactivecocoa/</id>
    <published>2016-05-30T13:32:02.000Z</published>
    <updated>2017-05-27T06:14:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>从知道ReactiveCocoa开始就发现对这个库有不同的声音，上次参加<t>技术沙龙时唐巧对在项目中已全面使用FRP的代码家提出为什么这种编程模型出现了这么长时间怎么像ReactiveCocoa这种完全按FRP编写的库没能够流行起来这个问题。对这个问题的回答一般都是门槛高，解决方法就是培训和通过熟悉以前的代码来快速入门。其实在我学习的过程中也发现确实会有这个问题，不过就算是有这样那样问题使得ReactiveCocoa这样的库没法大面积使用起来，也不能错失学习这种编程思想的机会。</t></p>
<p>如果不用这样的库，能不能将这种库的编程思想融入项目中，发挥出其优势呢？答案是肯定的。</p>
<p>FRP全称Function Reactive Programming，从名称就能够看出来这个模型关键就是Function Programming和Reactive Programming的结合。那么就先从函数式编程说起。说函数式编程前先聊聊链式编程，先看看一个开源Alert控件的头文件里定义的接口方法的写法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *  自定义样式的alertView</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="keyword">instancetype</span>)showAlertWithTitle:(<span class="built_in">NSString</span> *)title</div><div class="line">                           message:(<span class="built_in">NSString</span> *)message</div><div class="line">                        completion:(PXAlertViewCompletionBlock)completion</div><div class="line">                       cancelTitle:(<span class="built_in">NSString</span> *)cancelTitle</div><div class="line">                       otherTitles:(<span class="built_in">NSString</span> *)otherTitles, ... <span class="built_in">NS_REQUIRES_NIL_TERMINATION</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * @param otherTitles Must be a NSArray containing type NSString, or set to nil for no otherTitles.</div><div class="line"> */</div><div class="line">+ (<span class="keyword">instancetype</span>)showAlertWithTitle:(<span class="built_in">NSString</span> *)title</div><div class="line">                       contentView:(<span class="built_in">UIView</span> *)view</div><div class="line">                       secondTitle:(<span class="built_in">NSString</span> *)secondTitle</div><div class="line">                           message:(<span class="built_in">NSString</span> *)message</div><div class="line">                       cancelTitle:(<span class="built_in">NSString</span> *)cancelTitle</div><div class="line">                       otherTitles:(<span class="built_in">NSArray</span> *)otherTitles</div><div class="line">                          btnStyle:(<span class="built_in">BOOL</span>)btnStyle</div><div class="line">                        completion:(PXAlertViewCompletionBlock)completion;</div></pre></td></tr></table></figure>
<p>库里还有更多这样的组合，这么写是没有什么问题，无非是为了更方便组合使用而啰嗦了点，但是如果现在要添加一个AttributeString，那么所有组合接口都需要修改，每次调用接口方法如果不需要用Attribuite的地方还要去设置nil，这样会很不易于扩展。下面举个上报日志接口的例子。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMLogger</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">//初始化</span></div><div class="line">+ (SMLogger *)create;</div><div class="line"><span class="comment">//可选设置</span></div><div class="line">- (SMLogger *)object:(<span class="keyword">id</span>)obj;                        <span class="comment">//object对象记录</span></div><div class="line">- (SMLogger *)message:(<span class="built_in">NSString</span> *)msg;               <span class="comment">//描述</span></div><div class="line">- (SMLogger *)classify:(SMProjectClassify)classify;  <span class="comment">//分类</span></div><div class="line">- (SMLogger *)level:(SMLoggerLevel)level;            <span class="comment">//级别</span></div><div class="line"></div><div class="line"><span class="comment">//最后需要执行这个方法进行保存，什么都不设置也会记录文件名，函数名，行数等信息</span></div><div class="line">- (<span class="keyword">void</span>)save;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//宏</span></div><div class="line">FOUNDATION_EXPORT <span class="keyword">void</span> SMLoggerDebugFunc(DCProjectClassify classify, DCLoggerLevel level, <span class="built_in">NSString</span> *format, ...) <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">3</span>,<span class="number">4</span>);</div><div class="line"><span class="comment">//debug方式打印日志，不会上报</span></div><div class="line"><span class="meta">#define SMLoggerDebug(frmt, ...) \</span></div><div class="line"><span class="keyword">do</span> &#123; SMLoggerDebugFunc(SMProjectClassifyNormal,DCLoggerLevelDebug,frmt, <span class="meta">##__VA_ARGS__);&#125; while(0)</span></div><div class="line"><span class="comment">//简单的上报日志</span></div><div class="line"><span class="meta">#define SMLoggerSimple(frmt, ...) \</span></div><div class="line"><span class="keyword">do</span> &#123; SMLoggerDebugFunc(SMProjectClassifyNormal,SMLoggerLevelDebug,frmt, <span class="meta">##__VA_ARGS__);&#125; while(0)</span></div><div class="line"><span class="comment">//自定义classify和level的日志，可上报</span></div><div class="line"><span class="meta">#define SMLoggerCustom(classify,level,frmt, ...) \</span></div><div class="line"><span class="keyword">do</span> &#123; SMLoggerDebugFunc(classify,level,frmt, <span class="meta">##__VA_ARGS__);&#125; while(0)</span></div></pre></td></tr></table></figure>
<p>从这个头文件可以看出，对接口所需的参数不用将各种组合一一定义，只需要按照需要组合即可，而且做这个日志接口时发现后续维护过程中会增加越来越多的功能和需要更多的input数据。比如每条日志添加应用生命周期唯一编号，产品线每次切换唯一编号这样需要在特定场景需要添加的input支持。采用这种方式会更加易于扩展。写的时候会是[[[[DCLogger create] message:@”此处必改”] classify:DCProjectClassifyTradeHome] save]; 这样，对于不是特定场所较通用的场景可以使用宏来定义，内部实现还是按照前者的来实现，看起来是[DCLogger loggerWithMessage:@”此处必改”];，这样就能够同时满足常用场景和特殊场景的调用需求。</p>
<p>有了链式编程这种易于扩展方式的编程方式再来构造函数式编程，函数编程主要思路就是用有输入输出的函数作为参数将运算过程尽量写成一系列嵌套的函数调用，下面我构造一个需求来看看函数式编程的例子。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, SMStudentGender) &#123;</div><div class="line">    SMStudentGenderMale,</div><div class="line">    SMStudentGenderFemale</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">BOOL</span>(^SatisfyActionBlock)(<span class="built_in">NSUInteger</span> credit);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMStudent</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SMCreditSubject *creditSubject;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isSatisfyCredit;</div><div class="line"></div><div class="line">+ (SMStudent *)create;</div><div class="line">- (SMStudent *)name:(<span class="built_in">NSString</span> *)name;</div><div class="line">- (SMStudent *)gender:(SMStudentGender)gender;</div><div class="line">- (SMStudent *)studentNumber:(<span class="built_in">NSUInteger</span>)number;</div><div class="line"></div><div class="line"><span class="comment">//积分相关</span></div><div class="line">- (SMStudent *)sendCredit:(<span class="built_in">NSUInteger</span>(^)(<span class="built_in">NSUInteger</span> credit))updateCreditBlock;</div><div class="line">- (SMStudent *)filterIsASatisfyCredit:(SatisfyActionBlock)satisfyBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个例子中，sendCredit的block函数参数会处理当前的积分这个数据然后返回给SMStudent记录下来，filterIsASatisfyCredit的block函数参数会处理是否达到合格的积分判断返回是或否的BOOL值给SMStudent记录下来。实现代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//present</span></div><div class="line"><span class="keyword">self</span>.student = [[[[[SMStudent create]</div><div class="line">                   name:<span class="string">@"ming"</span>]</div><div class="line">                  gender:SMStudentGenderMale]</div><div class="line">                 studentNumber:<span class="number">345</span>]</div><div class="line">                filterIsASatisfyCredit:^<span class="built_in">BOOL</span>(<span class="built_in">NSUInteger</span> credit)&#123;</div><div class="line">                    <span class="keyword">if</span> (credit &gt;= <span class="number">70</span>) &#123;</div><div class="line">                        <span class="keyword">self</span>.isSatisfyLabel.text = <span class="string">@"合格"</span>;</div><div class="line">                        <span class="keyword">self</span>.isSatisfyLabel.textColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">                        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">self</span>.isSatisfyLabel.text = <span class="string">@"不合格"</span>;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;];</div><div class="line"></div><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[<span class="keyword">self</span>.testButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.student sendCredit:^<span class="built_in">NSUInteger</span>(<span class="built_in">NSUInteger</span> credit) &#123;</div><div class="line">        credit += <span class="number">5</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current credit %lu"</span>,credit);</div><div class="line">        [<span class="keyword">self</span>.student.creditSubject sendNext:credit];</div><div class="line">        <span class="keyword">return</span> credit;</div><div class="line">    &#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.student.creditSubject subscribeNext:^(<span class="built_in">NSUInteger</span> credit) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅的credit处理积分%lu"</span>,credit);</div><div class="line">    <span class="keyword">self</span>.currentCreditLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%lu"</span>,credit];</div><div class="line">    <span class="keyword">if</span> (credit &lt; <span class="number">30</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.currentCreditLabel.textColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(credit &lt; <span class="number">70</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.currentCreditLabel.textColor = [<span class="built_in">UIColor</span> purpleColor];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.currentCreditLabel.textColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.student.creditSubject subscribeNext:^(<span class="built_in">NSUInteger</span> credit) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅的credit处理积分%lu"</span>,credit);</div><div class="line">    <span class="keyword">if</span> (!(credit &gt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">self</span>.currentCreditLabel.text = <span class="string">@"0"</span>;</div><div class="line">        <span class="keyword">self</span>.isSatisfyLabel.text = <span class="string">@"未设置"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>每次按钮点击都会增加5个积分，达到70个积分就算合格了。上面的例子里可以看到一个对每次积分变化有不同的观察者处理的操作代码，这里并没有使用ReactiveCocoa里的信号，而是自己实现了一个特定的积分的类似信号的对象，方法名也用的是一样的。实现这个对象也是用的函数式编程方式。下面我的具体的实现代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMCreditSubject</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SubscribeNextActionBlock)(<span class="built_in">NSUInteger</span> credit);</div><div class="line"></div><div class="line">+ (SMCreditSubject *)create;</div><div class="line"></div><div class="line">- (SMCreditSubject *)sendNext:(<span class="built_in">NSUInteger</span>)credit;</div><div class="line">- (SMCreditSubject *)subscribeNext:(SubscribeNextActionBlock)block;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMCreditSubject</span>()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> credit;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SubscribeNextActionBlock subscribeNextBlock;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *blockArray;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SMCreditSubject</span></span></div><div class="line"></div><div class="line">+ (SMCreditSubject *)create &#123;</div><div class="line">    SMCreditSubject *subject = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="keyword">return</span> subject;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (SMCreditSubject *)sendNext:(<span class="built_in">NSUInteger</span>)credit &#123;</div><div class="line">    <span class="keyword">self</span>.credit = credit;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.blockArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (SubscribeNextActionBlock block <span class="keyword">in</span> <span class="keyword">self</span>.blockArray) &#123;</div><div class="line">            block(<span class="keyword">self</span>.credit);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (SMCreditSubject *)subscribeNext:(SubscribeNextActionBlock)block &#123;</div><div class="line">    <span class="keyword">if</span> (block) &#123;</div><div class="line">        block(<span class="keyword">self</span>.credit);</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.blockArray addObject:block];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Getter</span></div><div class="line">- (<span class="built_in">NSMutableArray</span> *)blockArray &#123;</div><div class="line">    <span class="keyword">if</span> (!_blockArray) &#123;</div><div class="line">        _blockArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _blockArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Demo地址：<a href="https://github.com/ming1016/RACStudy" target="_blank" rel="external">https://github.com/ming1016/RACStudy</a></p>
<p>主要思路就是subscribeNext时将参数block的实现输入添加到一个数组中，sendNext时记录输入的积分，同时遍历那个记录subscribeNext的block的数组使那些block再按照新积分再实现一次输入，达到更新积分通知多个subscriber来实现新值的效果。</p>
<p>除了block还可以将每次sendNext的积分放入一个数组记录每次的积分变化，在RAC中的Signal就是这样处理的，如下图，这样新加入的subscirber能够读取到积分变化历史记录。</p>
<p>所以不用ReactiveCocoa库也能够按照函数式编程方式改造现有项目达到同样的效果。</p>
<p>上面的例子也能够看出FRP的另一个响应式编程的特性。说响应式编程之前可以先看看我之前关于解耦的那篇文章里的Demo<a href="https://github.com/ming1016/DecoupleDemo" target="_blank" rel="external">https://github.com/ming1016/DecoupleDemo</a>，里面使用了Model作为连接视图，请求存储和控制器之间的纽带，通过KVO使它们能够通过Model的属性来相互监听来避免它们之间的相互依赖达到解耦的效果。</p>
<p>像上面的例子那样其实也能够达到同样的效果，创建一个Model然后通过各个Subject来贯穿视图层和数据层进行send值和多subscribe值的处理。</p>
<p>了解了这种编程模型，再去了解下ReactiveCocoa使用的三种设计模式就能够更容易的将它学以致用了，下面配上这三种贯穿ReactiveCocoa的设计模式，看这些图里的方法名是不是很眼熟。</p>
<p>ReactiveCocoa里面还有很多可以学习的地方，比如宏的运用，可以看看sunnyxx的那篇《Reactive Cocoa Tutorial [1] = 神奇的Macros》<a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/03/06/rac_1_macros/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从知道ReactiveCocoa开始就发现对这个库有不同的声音，上次参加&lt;t&gt;技术沙龙时唐巧对在项目中已全面使用FRP的代码家提出为什么这种编程模型出现了这么长时间怎么像ReactiveCocoa这种完全按FRP编写的库没能够流行起来这个问题。对这个问题的回答一般都是门槛高
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://ming1016.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>竭尽全力的去解耦的一次实践，封装一个TableView和一些功能组合的控件</title>
    <link href="http://ming1016.github.io/2016/05/23/try-to-decouple-with-demo/"/>
    <id>http://ming1016.github.io/2016/05/23/try-to-decouple-with-demo/</id>
    <published>2016-05-23T13:24:25.000Z</published>
    <updated>2017-05-27T06:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以先看看这个Demo：<a href="https://github.com/ming1016/DecoupleDemo" target="_blank" rel="external">https://github.com/ming1016/DecoupleDemo</a>。从这个Demo里可以看到Controller和View还有Store的头文件里没有任何Delegate，Block回调，只有初始化和更新ViewModel的方法。所有这些控件，请求，ViewController和视图之间的联系都是通过ViewModel来进行的，而viewModel也不进行任何逻辑处理，只是简单的起到描述和默认值设置的作用。ViewController也被减轻的小得不能再小了，只需要初始化视图和Store即可。这也是我的一次尝试，看看如何利用KVO能够做到最大限度的解耦，和最大限度的减少代码和接口。</p>
<p>可以先看看以前代码最臃肿的地方在使用了新的思路后会变成怎么样，首先是ViewController<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [<span class="keyword">self</span> addKVO];</div><div class="line">    [<span class="keyword">self</span> buildConstraints];</div><div class="line">    <span class="keyword">self</span>.tbStore = [[TestTableStore alloc] initWithViewModel:<span class="keyword">self</span>.tbView.viewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到里面仅仅做了添加KVO，布局控件和初始化Store的工作。</p>
<p>封装的TableView作为一个通用控件是不会去设置管理不同的Cell的，可以看看不用Delegate和Block是如何处理的。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="keyword">self</span>.viewModel.tableViewIdentifier = smTableViewIdentifier;</div><div class="line">    <span class="keyword">self</span>.viewModel.tableView = tableView;</div><div class="line">    <span class="keyword">self</span>.viewModel.cellIndexPath = indexPath;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.viewModel.cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我觉得这样应该很简化了。当触发到UITableView这个配置Cell的回调时，通过对ViewModel的键值的监听就能够在任何地方对Cell进行配置了，而不用通过繁琐的Delegate和Block来层层回调了。</p>
<p>除了这里外，其它地方也用同样的方法进行了处理，比如说对新出现消息提示点击使其消失只需要设置ViewModel里的isHideHintView的值的处理，还有对请求不同状态显示不同引导页，只要是以前需要通过接口和回调的全部干掉，用ViewModel去控制，下面可以看看我写的ViewModel中，我将KVO分成了View Side和Data Side，前者主要是响应视图方面的逻辑变化，后者Data Side是响应不同的动作来产生对数据不同的处理，其它就都是些关于样式和数据配置相关的了。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="comment">//           KVO View Side</span></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isHideGuideView;             <span class="comment">//是否显示guide view</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isHideHintView;              <span class="comment">//是否显示hint view</span></div><div class="line"><span class="comment">//下拉刷新上拉加载更多</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SMTableRequestStatus requestStatus; <span class="comment">//刷新状态</span></div><div class="line"><span class="comment">//TableView Delegate</span></div><div class="line"><span class="comment">//通用</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITableView</span> *tableView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *tableViewIdentifier;</div><div class="line"><span class="comment">//Cell</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *cellIndexPath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITableViewCell</span> *cell;</div><div class="line"><span class="comment">//CellHeight</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *cellHeightIndexPath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;</div><div class="line"></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="comment">//          KVO Data Side</span></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SMTableRefreshingStatus dataSourceRefreshingStatus; <span class="comment">//请求状态</span></div></pre></td></tr></table></figure></p>
<p>纵观整个项目，头文件都很干净，唯一有方法需要参数的也就是ViewModel。这种完全面向对象思路的编程方式在需求经常变更的情况下优势就会慢慢显露出来，对吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以先看看这个Demo：&lt;a href=&quot;https://github.com/ming1016/DecoupleDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ming1016/DecoupleDemo&lt;/a
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Pattern" scheme="http://ming1016.github.io/tags/Pattern/"/>
    
  </entry>
  
  <entry>
    <title>细说 GCD（Grand Central Dispatch）如何用</title>
    <link href="http://ming1016.github.io/2016/01/13/how-to-use-gcd/"/>
    <id>http://ming1016.github.io/2016/01/13/how-to-use-gcd/</id>
    <published>2016-01-13T09:20:08.000Z</published>
    <updated>2017-05-27T06:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 <a href="https://github.com/ming1016/GCDDemo" target="_blank" rel="external">https://github.com/ming1016/GCDDemo</a> 对着文章试着来调demo体会更深哦，细细嚼消化好:)</p>
<h1 id="GCD（Grand-Central-Dispatch）-介绍"><a href="#GCD（Grand-Central-Dispatch）-介绍" class="headerlink" title="GCD（Grand Central Dispatch） 介绍"></a>GCD（Grand Central Dispatch） 介绍</h1><p>GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址<a href="http://libdispatch.macosforge.org" target="_blank" rel="external">http://libdispatch.macosforge.org</a>。GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。</p>
<h2 id="GCD概要"><a href="#GCD概要" class="headerlink" title="GCD概要"></a>GCD概要</h2><ul>
<li>和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。</li>
<li>公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O）</li>
<li>可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。</li>
<li>操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在主线程执行了</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>系统标准两个队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//全局队列，一个并行的队列</span></div><div class="line">dispatch_get_global_queue</div><div class="line"><span class="comment">//主队列，主线程中的唯一队列，一个串行队列</span></div><div class="line">dispatch_get_main_queue</div></pre></td></tr></table></figure>
<ul>
<li>自定义队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//串行队列</span></div><div class="line">dispatch_queue_create(<span class="string">"com.starming.serialqueue"</span>, DISPATCH_QUEUE_SERIAL)</div><div class="line"><span class="comment">//并行队列</span></div><div class="line">dispatch_queue_create(<span class="string">"com.starming.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT)</div></pre></td></tr></table></figure>
<ul>
<li>同步异步线程创建</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步线程</span></div><div class="line"><span class="built_in">dispatch_sync</span>(..., ^(block))</div><div class="line"><span class="comment">//异步线程</span></div><div class="line"><span class="built_in">dispatch_async</span>(..., ^(block))</div></pre></td></tr></table></figure>
<h1 id="队列（dispatch-queue）"><a href="#队列（dispatch-queue）" class="headerlink" title="队列（dispatch queue）"></a>队列（dispatch queue）</h1><ul>
<li>Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。</li>
<li>Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。</li>
<li>Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dipatch_queue_t queue;</div><div class="line">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<ul>
<li>user create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<ul>
<li>自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dipatch_queue_attr_make_with_qos_class</span></div><div class="line">dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class="number">-1</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.qosqueue"</span>, attr);</div><div class="line"></div><div class="line"><span class="comment">//dispatch_set_target_queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.settargetqueue"</span>,<span class="literal">NULL</span>); <span class="comment">//需要设置优先级的queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>); <span class="comment">//参考优先级</span></div><div class="line">dispatch_set_target_queue(queue, referQueue); <span class="comment">//设置queue和referQueue的优先级一样</span></div></pre></td></tr></table></figure>
<ul>
<li>dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_queue_t</span> firstQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.firstqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_queue_t</span> secondQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.secondqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_set_target_queue(firstQueue, serialQueue);</div><div class="line">dispatch_set_target_queue(secondQueue, serialQueue);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(firstQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.</span>f];</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(secondQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(secondQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h2><p>队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init;</div><div class="line">&#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">          <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.isolation.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</div><div class="line">          <span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</div><div class="line"></div><div class="line">          label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.work.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</div><div class="line">          <span class="keyword">self</span>.workQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<p>示例：后台加载显示图片<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">     dispatch_async(dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INITIATED</span>.value), <span class="number">0</span>)) &#123; <span class="comment">// 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成，</span></div><div class="line">          <span class="keyword">let</span> overlayImage = <span class="keyword">self</span>.faceOverlayImageFromImage(<span class="keyword">self</span>.image)</div><div class="line">          dispatch_async(dispatch_get_main_queue()) &#123; <span class="comment">// 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。</span></div><div class="line">               <span class="keyword">self</span>.fadeInNewImage(overlayImage) <span class="comment">// 更新UI</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>何时使用何种队列类型</p>
<ul>
<li>主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。</li>
<li>并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。</li>
<li>自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。</li>
</ul>
<p>可以使用下面的方法简化QoS等级参数的写法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="type">GlobalMainQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_main_queue()</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUserInteractiveQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INTERACTIVE</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUserInitiatedQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INITIATED</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUtilityQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_UTILITY</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalBackgroundQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_BACKGROUND</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用起来就是这样，易读而且容易看出在使用哪个队列</span></div><div class="line">dispatch_async(<span class="type">GlobalUserInitiatedQueue</span>) &#123;</div><div class="line">     <span class="keyword">let</span> overlayImage = <span class="keyword">self</span>.faceOverlayImageFromImage(<span class="keyword">self</span>.image)</div><div class="line">     dispatch_async(<span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">self</span>.fadeInNewImage(overlayImage)</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-once用法"><a href="#dispatch-once用法" class="headerlink" title="dispatch_once用法"></a>dispatch_once用法</h2><p>dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIColor</span> *)boringColor;</div><div class="line">&#123;</div><div class="line">     <span class="keyword">static</span> <span class="built_in">UIColor</span> *color;</div><div class="line">     <span class="comment">//只运行一次</span></div><div class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">          color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.380</span>f green:<span class="number">0.376</span>f blue:<span class="number">0.376</span>f alpha:<span class="number">1.000</span>f];</div><div class="line">     &#125;);</div><div class="line">     <span class="keyword">return</span> color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h2><p>设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)processImage:(<span class="built_in">UIImage</span> *)image completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> success))handler;</div><div class="line">&#123;</div><div class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.isolationQueue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">          <span class="comment">// do actual processing here</span></div><div class="line">          <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.resultQueue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">               handler(<span class="literal">YES</span>);</div><div class="line">          &#125;);</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码框架</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">     <span class="comment">// 耗时的操作</span></div><div class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">          <span class="comment">// 更新界面</span></div><div class="line">     &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//下载图片的示例</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">     <span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg"</span>];</div><div class="line">     <span class="built_in">NSData</span> * data = [[<span class="built_in">NSData</span> alloc]initWithContentsOfURL:url];</div><div class="line">     <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc]initWithData:data];</div><div class="line">     <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">               <span class="keyword">self</span>.imageView.image = image;</div><div class="line">          &#125;);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-after延后执行"><a href="#dispatch-after延后执行" class="headerlink" title="dispatch_after延后执行"></a>dispatch_after延后执行</h2><p>dispatch_after只是延时提交block，不是延时立刻执行。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)foo</div><div class="line">&#123;</div><div class="line">     <span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</div><div class="line">     dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">     dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">          [<span class="keyword">self</span> bar];</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showOrHideNavPrompt</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">let</span> delayInSeconds = <span class="number">1.0</span></div><div class="line">     <span class="keyword">let</span> popTime = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>,</div><div class="line">          <span class="type">Int64</span>(delayInSeconds * <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>))) <span class="comment">// 在这里声明推迟的时间</span></div><div class="line">     dispatch_after(popTime, <span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 等待delayInSeconds将闭包异步到主队列</span></div><div class="line">          <span class="keyword">let</span> <span class="built_in">count</span> = <span class="type">PhotoManager</span>.sharedManager.photos.<span class="built_in">count</span></div><div class="line">          <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">               <span class="keyword">self</span>.navigationItem.prompt = <span class="literal">nil</span></div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">self</span>.navigationItem.prompt = <span class="string">"Add photos with faces to Googlyify them!"</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子中的dispatch time的参数，可以先看看函数原型<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );</div></pre></td></tr></table></figure></p>
<p>第一个参数为DISPATCH_TIME_NOW表示当前。第二个参数的delta表示纳秒，一秒对应的纳秒为1000000000，系统提供了一些宏来简化<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒</span></div><div class="line"><span class="meta">#define USEC_PER_SEC 1000000ull    //每秒有多少毫秒</span></div><div class="line"><span class="meta">#define NSEC_PER_USEC 1000ull      //每毫秒有多少纳秒</span></div></pre></td></tr></table></figure></p>
<p>这样如果要表示一秒就可以这样写<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_time(DISPATCH_TIME_NOW, <span class="number">1000</span> * USEC_PER_SEC);</div><div class="line">dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * <span class="built_in">NSEC_PER_USEC</span>);</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁"><a href="#dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁" class="headerlink" title="dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁"></a>dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁</h2><p>Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建队列</span></div><div class="line"><span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="comment">//改变setter</span></div><div class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSUInteger</span>)count forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">     key = [key <span class="keyword">copy</span>];</div><div class="line">     <span class="comment">//确保所有barrier都是async异步的</span></div><div class="line">     dispatch_barrier_async(<span class="keyword">self</span>.isolationQueue, ^()&#123;</div><div class="line">          <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">               [<span class="keyword">self</span>.counts removeObjectForKey:key];</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">self</span>.counts[key] = @(count);</div><div class="line">          &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dispatchBarrierAsyncDemo &#123;</div><div class="line">    <span class="comment">//防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> dataQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.dataqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 1"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//等待前面的都完成，在执行barrier后面的</span></div><div class="line">    dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"write data 1"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 3"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 4"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swift示例<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> concurrentPhotoQueue = dispatch_queue_create(</div><div class="line"><span class="string">"com.raywenderlich.GooglyPuff.photoQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(photo: Photo)</span></span> &#123;</div><div class="line">     dispatch_barrier_async(concurrentPhotoQueue) &#123; <span class="comment">// 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。</span></div><div class="line">          <span class="keyword">self</span>._photos.append(photo) <span class="comment">// barrier能够保障不会和其他任务同时进行。</span></div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。</span></div><div class="line">               <span class="keyword">self</span>.postContentAddedNotification()</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。</span></div><div class="line"><span class="keyword">var</span> photos: [<span class="type">Photo</span>] &#123;</div><div class="line">     <span class="keyword">var</span> photosCopy: [<span class="type">Photo</span>]!</div><div class="line">     dispatch_sync(concurrentPhotoQueue) &#123; <span class="comment">// 同步调度到concurrentPhotoQueue队列执行读操作</span></div><div class="line">          photosCopy = <span class="keyword">self</span>._photos <span class="comment">// 保存</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> photosCopy</div><div class="line">&#125;</div><div class="line"><span class="comment">//这样读写问题都解决了。</span></div></pre></td></tr></table></figure></p>
<p>都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。</p>
<h2 id="dispatch-apply进行快速迭代"><a href="#dispatch-apply进行快速迭代" class="headerlink" title="dispatch_apply进行快速迭代"></a>dispatch_apply进行快速迭代</h2><p>类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (size_t y = <span class="number">0</span>; y &lt; height; ++y) &#123;</div><div class="line">     <span class="keyword">for</span> (size_t x = <span class="number">0</span>; x &lt; width; ++x) &#123;</div><div class="line">          <span class="comment">// Do something with x and y here</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//因为可以并行执行，所以使用dispatch_apply可以运行的更快</span></div><div class="line">- (<span class="keyword">void</span>)dispatchApplyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_apply(<span class="number">10</span>, concurrentQueue, ^(size_t i) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>,i);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The end"</span>); <span class="comment">//这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispatch_apply能避免线程爆炸，因为GCD会管理并发<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealWiththreadWithMaybeExplode:(<span class="built_in">BOOL</span>)explode &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="keyword">if</span> (explode) &#123;</div><div class="line">        <span class="comment">//有问题的情况，可能会死锁</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span> ; i++) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"wrong %d"</span>,i);</div><div class="line">                <span class="comment">//do something hard</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//会优化很多，能够利用GCD管理</span></div><div class="line">        dispatch_apply(<span class="number">999</span>, concurrentQueue, ^(size_t i)&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"correct %zu"</span>,i);</div><div class="line">            <span class="comment">//do something hard</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</div><div class="line">     <span class="keyword">let</span> addresses = [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line"></div><div class="line">     dispatch_apply(<span class="type">UInt</span>(addresses.<span class="built_in">count</span>), <span class="type">GlobalUserInitiatedQueue</span>) &#123;</div><div class="line">          i <span class="keyword">in</span></div><div class="line">          <span class="keyword">let</span> index = <span class="type">Int</span>(i)</div><div class="line">          <span class="keyword">let</span> address = addresses[index]</div><div class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">               image, error <span class="keyword">in</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                    storedError = error</div><div class="line">               &#125;</div><div class="line">               dispatch_group_leave(downloadGroup)</div><div class="line">          &#125;</div><div class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Block组合Dispatch-groups"><a href="#Block组合Dispatch-groups" class="headerlink" title="Block组合Dispatch_groups"></a>Block组合Dispatch_groups</h2><p>dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。</p>
<p>当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。</p>
<p>第一种使用dispatch_group_wait的swift的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     dispatch_async(<span class="type">GlobalUserInitiatedQueue</span>) &#123; <span class="comment">// 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞</span></div><div class="line">          <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">          <span class="keyword">var</span> downloadGroup = dispatch_group_create() <span class="comment">// 创建一个dispatch group</span></div><div class="line"></div><div class="line">          <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">               <span class="type">SuccessKidURLString</span>,</div><div class="line">               <span class="type">LotsOfFacesURLString</span>]</div><div class="line">          &#123;</div><div class="line">               <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">               dispatch_group_enter(downloadGroup) <span class="comment">// dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。</span></div><div class="line">               <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">                    image, error <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                         storedError = error</div><div class="line">                    &#125;</div><div class="line">                    dispatch_group_leave(downloadGroup) <span class="comment">// 保持和dispatch_group_enter配对。通知任务已经完成</span></div><div class="line">               &#125;</div><div class="line">               <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          dispatch_group_wait(downloadGroup, <span class="type">DISPATCH_TIME_FOREVER</span>) <span class="comment">// dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。</span></div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123; <span class="comment">// 执行闭包内容</span></div><div class="line">                    completion(error: storedError)</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>oc例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchGroupWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="comment">//在group中添加队列的block</span></div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"go on"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种使用dispatch_group_notify的swift的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="comment">// 不用加dispatch_async，因为没有阻塞主进程</span></div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</div><div class="line"></div><div class="line">     <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">               image, error <span class="keyword">in</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                    storedError = error</div><div class="line">               &#125;</div><div class="line">               dispatch_group_leave(downloadGroup)</div><div class="line">          &#125;</div><div class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。</span></div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>oc例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dispatch_group_notify</span></div><div class="line">- (<span class="keyword">void</span>)dispatchGroupNotifyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"can continue"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//dispatch_group_wait</span></div><div class="line">- (<span class="keyword">void</span>)dispatchGroupWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="comment">//在group中添加队列的block</span></div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"can continue"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如何对现有API使用dispatch_group_t<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。</span></div><div class="line">- (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</div><div class="line">          [<span class="keyword">self</span> performBlock:block];</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          dispatch_group_enter(group);</div><div class="line">          [<span class="keyword">self</span> performBlock:^()&#123;</div><div class="line">               block();</div><div class="line">               dispatch_group_leave(group);</div><div class="line">          &#125;];</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//NSURLConnection也可以这样做</span></div><div class="line">+ (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group</div><div class="line">     sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">     queue:(<span class="built_in">NSOperationQueue</span> *)queue</div><div class="line">     completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</div><div class="line">          [<span class="keyword">self</span> sendAsynchronousRequest:request</div><div class="line">               queue:queue</div><div class="line">               completionHandler:handler];</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          dispatch_group_enter(group);</div><div class="line">          [<span class="keyword">self</span> sendAsynchronousRequest:request</div><div class="line">                    queue:queue</div><div class="line">                    completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error)&#123;</div><div class="line">               handler(response, data, error);</div><div class="line">               dispatch_group_leave(group);</div><div class="line">          &#125;];</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意事项</p>
<ul>
<li>dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。</li>
<li>dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。</li>
<li>dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的</li>
</ul>
<h2 id="Dispatch-Block"><a href="#Dispatch-Block" class="headerlink" title="Dispatch Block"></a>Dispatch Block</h2><p>队列执行任务都是block的方式，</p>
<ul>
<li>创建block</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)createDispatchBlock &#123;</div><div class="line">    <span class="comment">//normal way</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_block_t block = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run block"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, block);</div><div class="line"></div><div class="line">    <span class="comment">//QOS way</span></div><div class="line">    dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(<span class="number">0</span>, QOS_CLASS_USER_INITIATED, <span class="number">-1</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run qos block"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, qosBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_wait：可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t block = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"star"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, block);</div><div class="line">    <span class="comment">//设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成</span></div><div class="line">    dispatch_block_wait(block, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ok, now can go on"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_notify：可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的block</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockNotifyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, firstBlock);</div><div class="line">    dispatch_block_t secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"second block run"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//first block执行完才在serial queue中执行second block</span></div><div class="line">    dispatch_block_notify(firstBlock, serialQueue, secondBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_cancel：iOS8后GCD支持对dispatch block的取消</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockCancelDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block end"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_block_t secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"second block run"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, firstBlock);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, secondBlock);</div><div class="line">    <span class="comment">//取消secondBlock</span></div><div class="line">    dispatch_block_cancel(secondBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用dispatch-block-object（调度块）在任务执行前进行取消"><a href="#使用dispatch-block-object（调度块）在任务执行前进行取消" class="headerlink" title="使用dispatch block object（调度块）在任务执行前进行取消"></a>使用dispatch block object（调度块）在任务执行前进行取消</h2><p>dispatch block object可以为队列中的对象设置<br>示例，下载图片中途进行取消<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">let</span> downloadGroup = dispatch_group_create()</div><div class="line">     <span class="keyword">var</span> addresses = [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line">     addresses += addresses + addresses <span class="comment">// 扩展address数组，复制3份</span></div><div class="line">     <span class="keyword">var</span> blocks: [dispatch_block_t] = [] <span class="comment">// 一个保存block的数组</span></div><div class="line"></div><div class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; addresses.<span class="built_in">count</span> &#123;</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> block = dispatch_block_create(<span class="type">DISPATCH_BLOCK_INHERIT_QOS_CLASS</span>) &#123; <span class="comment">// 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS</span></div><div class="line">               <span class="keyword">let</span> index = <span class="type">Int</span>(i)</div><div class="line">               <span class="keyword">let</span> address = addresses[index]</div><div class="line">               <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">               <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">                    image, error <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                         storedError = error</div><div class="line">                    &#125;</div><div class="line">                    dispatch_group_leave(downloadGroup)</div><div class="line">               &#125;</div><div class="line">               <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">          &#125;</div><div class="line">          blocks.append(block)</div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>, block) <span class="comment">// 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">for</span> block <span class="keyword">in</span> blocks[<span class="number">3</span> ..&lt; blocks.<span class="built_in">count</span>] &#123;</div><div class="line">          <span class="keyword">let</span> cancel = arc4random_uniform(<span class="number">2</span>) <span class="comment">// 随机返回一个整数，会返回0或1</span></div><div class="line">          <span class="keyword">if</span> cancel == <span class="number">1</span> &#123;</div><div class="line">               dispatch_block_cancel(block) <span class="comment">// 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。</span></div><div class="line">               dispatch_group_leave(downloadGroup) <span class="comment">// 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-IO-文件操作"><a href="#Dispatch-IO-文件操作" class="headerlink" title="Dispatch IO 文件操作"></a>Dispatch IO 文件操作</h2><p>dispatch io读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文件这样会比单线程要快很多。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 0-99 bytes*/</span>&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 100-199 bytes*/</span>&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 200-299 bytes*/</span>&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li>dispatch_io_create：创建dispatch io</li>
<li>dispatch_io_set_low_water：指定切割文件大小</li>
<li>dispatch_io_read：读取切割的文件然后合并。</li>
</ul>
<p>苹果系统日志API里用到了这个技术，可以在这里查看：<a href="https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c" target="_blank" rel="external">https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">pipe_q = dispatch_queue_create(<span class="string">"PipeQ"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//创建</span></div><div class="line">pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(<span class="keyword">int</span> err)&#123;</div><div class="line">    close(fd);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">*out_fd = fdpair[<span class="number">1</span>];</div><div class="line"><span class="comment">//设置切割大小</span></div><div class="line">dispatch_io_set_low_water(pipe_channel, SIZE_MAX);</div><div class="line"></div><div class="line">dispatch_io_read(pipe_channel, <span class="number">0</span>, SIZE_MAX, pipe_q, ^(<span class="keyword">bool</span> done, dispatch_data_t pipedata, <span class="keyword">int</span> err)&#123;</div><div class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        size_t len = dispatch_data_get_size(pipedata);</div><div class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//对每次切块数据的处理</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *bytes = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">char</span> *encoded;</div><div class="line">            uint32_t eval;</div><div class="line"></div><div class="line">            dispatch_data_t md = dispatch_data_create_map(pipedata, (<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;bytes, &amp;len);</div><div class="line">            encoded = asl_core_encode_buffer(bytes, len);</div><div class="line">            asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded);</div><div class="line">            free(encoded);</div><div class="line">            eval = _asl_evaluate_send(<span class="literal">NULL</span>, (aslmsg)aux, <span class="number">-1</span>);</div><div class="line">            _asl_send_message(<span class="literal">NULL</span>, eval, aux, <span class="literal">NULL</span>);</div><div class="line">            asl_msg_release(aux);</div><div class="line">            dispatch_release(md);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (done)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//semaphore +1使得不需要再等待继续执行下去。</span></div><div class="line">        dispatch_semaphore_signal(sem);</div><div class="line">        dispatch_release(pipe_channel);</div><div class="line">        dispatch_release(pipe_q);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Source-用GCD监视进程"><a href="#Dispatch-Source-用GCD监视进程" class="headerlink" title="Dispatch Source 用GCD监视进程"></a>Dispatch Source 用GCD监视进程</h2><p>Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:left">数据增加</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:left">数据OR</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:left">Mach端口发送</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:left">Mach端口接收</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</td>
<td style="text-align:left">内存情况</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:left">进程事件</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:left">读数据</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:left">信号</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:left">定时器</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:left">文件系统变化</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:left">文件写入</td>
</tr>
</tbody>
</table>
<p>方法</p>
<ul>
<li>dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。</li>
<li>dispatch_source_set_event_handler：设置事件处理handler</li>
<li>dispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。</li>
<li>dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSRunningApplication</span> *mail = [<span class="built_in">NSRunningApplication</span> runningApplicationsWithBundleIdentifier:<span class="string">@"com.apple.mail"</span>];</div><div class="line"><span class="keyword">if</span> (mail == <span class="literal">nil</span>) &#123;</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pid_t <span class="keyword">const</span> pid = mail.processIdentifier;</div><div class="line"><span class="keyword">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^()&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Mail quit."</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//在事件源传到你的事件处理前需要调用dispatch_resume()这个方法</span></div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure>
<p>监视文件夹内文件变化<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *directoryURL; <span class="comment">// assume this is set to a directory</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);</div><div class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">     <span class="keyword">char</span> buffer[<span class="number">80</span>];</div><div class="line">     strerror_r(errno, buffer, <span class="keyword">sizeof</span>(buffer));</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Unable to open \"%@\": %s (%d)"</span>, [directoryURL path], buffer, errno);</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,</div><div class="line">DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> data = dispatch_source_get_data(source);</div><div class="line">     <span class="keyword">if</span> (data &amp; DISPATCH_VNODE_WRITE) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"The directory changed."</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (data &amp; DISPATCH_VNODE_DELETE) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"The directory has been deleted."</span>);</div><div class="line">     &#125;</div><div class="line">&#125;);</div><div class="line">dispatch_source_set_cancel_handler(source, ^()&#123;</div><div class="line">     close(fd);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">self</span>.source = source;</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div><div class="line"><span class="comment">//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听</span></div></pre></td></tr></table></figure></p>
<p>NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,<span class="number">0</span>, <span class="number">0</span>, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Time flies."</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_time_t start</div><div class="line">dispatch_source_set_timer(source, DISPATCH_TIME_NOW, <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>,<span class="number">100</span>ull * <span class="built_in">NSEC_PER_MSEC</span>);</div><div class="line"><span class="keyword">self</span>.source = source;</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Semaphore和的介绍"><a href="#Dispatch-Semaphore和的介绍" class="headerlink" title="Dispatch Semaphore和的介绍"></a>Dispatch Semaphore和的介绍</h2><p>另外一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dispatch semaphore</span></div><div class="line">- (<span class="keyword">void</span>)dispatchSemaphoreDemo &#123;</div><div class="line">    <span class="comment">//创建semaphore</span></div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"semaphore +1"</span>);</div><div class="line">        dispatch_semaphore_signal(semaphore); <span class="comment">//+1 semaphore</span></div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"continue"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>这里简单介绍下iOS中常用的各种锁和他们的性能。</p>
<ul>
<li>NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。</li>
<li>NSDistributedLock：分布锁，基于文件方式的锁机制，可以跨进程访问。</li>
<li>NSConditionLock：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。</li>
<li>OSSpinLock：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用pthread_mutex较好。</li>
<li>pthread_mutex_t：同步锁基于C语言，底层api性能高，使用方法和其它的类似。</li>
<li>@synchronized：更加简单。</li>
</ul>
<h2 id="dispatch-suspend和dispatch-resume挂起和恢复队列"><a href="#dispatch-suspend和dispatch-resume挂起和恢复队列" class="headerlink" title="dispatch_suspend和dispatch_resume挂起和恢复队列"></a>dispatch_suspend和dispatch_resume挂起和恢复队列</h2><p>dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。</p>
<h2 id="dispatch-set-context和dispatch-get-context"><a href="#dispatch-set-context和dispatch-get-context" class="headerlink" title="dispatch_set_context和dispatch_get_context"></a>dispatch_set_context和dispatch_get_context</h2><h2 id="GCD深入操作"><a href="#GCD深入操作" class="headerlink" title="GCD深入操作"></a>GCD深入操作</h2><ul>
<li>缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域</li>
<li>I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close</li>
<li>测试：使用dispatch_benchmark小工具</li>
<li>原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。</li>
</ul>
<h2 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h2><p>当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)deadLockCase1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="comment">//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="comment">//3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase3 &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        <span class="comment">//串行队列里面同步一个串行队列就会死锁</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase4 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        <span class="comment">//将同步的串行队列放到另外一个线程就能够解决</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase5 &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">        <span class="comment">//回到主线程发现死循环后面就没法执行了</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    <span class="comment">//死循环</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="GCD实际使用"><a href="#GCD实际使用" class="headerlink" title="GCD实际使用"></a>GCD实际使用</h1><h2 id="FMDB如何使用dispatch-queue-set-specific和dispatch-get-specific来防止死锁"><a href="#FMDB如何使用dispatch-queue-set-specific和dispatch-get-specific来防止死锁" class="headerlink" title="FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁"></a>FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁</h2><p>作用类似objc_setAssociatedObject跟objc_getAssociatedObject<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;</div><div class="line"><span class="comment">//创建串行队列，所有数据库的操作都在这个队列里</span></div><div class="line">_queue = dispatch_queue_create([[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"fmdb.%@"</span>, <span class="keyword">self</span>] UTF8String], <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//标记队列</span></div><div class="line">dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">//检查是否是同一个队列来避免死锁的方法</span></div><div class="line">- (<span class="keyword">void</span>)inDatabase:(<span class="keyword">void</span> (^)(FMDatabase *db))block &#123;</div><div class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge <span class="keyword">id</span>)dispatch_get_specific(kDispatchQueueSpecificKey);</div><div class="line">    assert(currentSyncQueue != <span class="keyword">self</span> &amp;&amp; <span class="string">"inDatabase: was called reentrantly on the same queue, which would lead to a deadlock"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="iOS系统版本新特性"><a href="#iOS系统版本新特性" class="headerlink" title="iOS系统版本新特性"></a>iOS系统版本新特性</h1><h2 id="iOS8"><a href="#iOS8" class="headerlink" title="iOS8"></a>iOS8</h2><p>iOS8新加了一个功能叫Quality of Service(QoS)，里面提供了一下几个更容易理解的枚举名来使用user interactive，user initiated，utility和background。下面的表做了对比</p>
<table>
<thead>
<tr>
<th style="text-align:left">Global queue</th>
<th style="text-align:left">Corresponding QoS class</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Main thread</td>
<td style="text-align:left">NSQualityOfServiceUserInteractive</td>
<td style="text-align:left">UI相关，交互等</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_HIGH</td>
<td style="text-align:left">NSQualityOfServiceUserInitiated</td>
<td style="text-align:left">用户发起需要马上得到结果进行后续任务</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_DEFAULT</td>
<td style="text-align:left">NSQualityOfServiceDefault</td>
<td style="text-align:left">默认的不应该使用这个设置任务</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_LOW</td>
<td style="text-align:left">NSQualityOfServiceUtility</td>
<td style="text-align:left">花费时间稍多比如下载，需要几秒或几分钟的</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>
<td style="text-align:left">NSQualityOfServiceBackground</td>
<td style="text-align:left">不可见在后台的操作可能需要好几分钟甚至几小时的</td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h2><ul>
<li>Building Responsive and Efficient Apps with GCD：<a href="https://developer.apple.com/videos/play/wwdc2015-718/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-718/</a></li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li>官方文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="external">https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 &lt;a href=&quot;https://github.com/ming1016/GCDDemo&quot; target
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="GCD" scheme="http://ming1016.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Auto Layout，分析iOS各版本新增特性</title>
    <link href="http://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/"/>
    <id>http://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/</id>
    <published>2015-11-03T13:17:54.000Z</published>
    <updated>2017-05-27T02:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>先前写到的一篇Masonry心得文章里已经提到了很多AutoLayout相关的知识，这篇我会更加详细的对其知识要点进行分析和整理。</p>
<h1 id="来历"><a href="#来历" class="headerlink" title="来历"></a>来历</h1><p>一般大家都会认为Auto Layout这个东西是苹果自己搞出来的，其实不然，早在1997年Alan Borning, Kim Marriott, Peter Stuckey等人就发布了《Solving Linear Arithmetic Constraints for User Interface Applications》论文（论文地址：<a href="http://constraints.cs.washington.edu/solvers/uist97.html" target="_blank" rel="external">http://constraints.cs.washington.edu/solvers/uist97.html</a>）提出了在解决布局问题的Cassowary constraint-solving算法实现，并且将代码发布在他们搭建的Cassowary网站上<a href="http://constraints.cs.washington.edu/cassowary/" target="_blank" rel="external">http://constraints.cs.washington.edu/cassowary/</a>。后来更多开发者用各种语言来写Cassowary，比如说pybee用python写的<a href="https://github.com/pybee/cassowary" target="_blank" rel="external">https://github.com/pybee/cassowary</a>。自从它发布以来JavaScript，.NET，JAVA，Smalltall和C++都有相应的库。2011年苹果将这个算法运用到了自家的布局引擎中，美其名曰Auto Layout。</p>
<h2 id="Cassowary"><a href="#Cassowary" class="headerlink" title="Cassowary"></a>Cassowary</h2><p>Cassowary是个解析工具包，能够有效解析线性等式系统和线性不等式系统，用户的界面中总是会出现不等关系和相等关系，Cassowary开发了一种规则系统可以通过约束来描述视图间关系。约束就是规则，能够表示出一个视图相对于另一个视图的位置。</p>
<h1 id="Auto-Layout的生命周期"><a href="#Auto-Layout的生命周期" class="headerlink" title="Auto Layout的生命周期"></a>Auto Layout的生命周期</h1><p>进入下面主题前可以先介绍下加入Auto Layout的生命周期。在得到自己的layout之前Layout Engine会将Views，约束，Priorities（优先级），instrinsicContentSize（主要是UILabel,UIImageView等）通过计算转换成最终的效果。在Layout Engine里会有约束变化到Deferred Layout Pass再到应用Run Loop再回到约束变化这样的循环机制。</p>
<h2 id="约束变化"><a href="#约束变化" class="headerlink" title="约束变化"></a>约束变化</h2><p>触发约束变化包括</p>
<ul>
<li>Activating或Deactivating</li>
<li>设置constant或priority</li>
<li>添加和删除视图</li>
</ul>
<p>这个Engine遇到约束变化会重新计算layout，获取新值后会call它的superview.setNeedsLayout()</p>
<h2 id="Deferred-Layout-Pass"><a href="#Deferred-Layout-Pass" class="headerlink" title="Deferred Layout Pass"></a>Deferred Layout Pass</h2><p>在这个时候主要是做些容错处理，更新约束有些没有确定或者缺失布局声明的视图会在这里处理。接着从上而下调用layoutSubviews()来确定视图各个子视图的位置，这个过程实际上就是将subview的frame从layout engine里拷贝出来。这里要注意重写layoutSubviews()或者执行类似layoutIfNeeded这样可能会立刻唤起layoutSubviews()的方法，如果要这样做需要注意手动处理的这个地方自己的子视图布局的树状关系是否合理。</p>
<h2 id="生命周期中需要注意的事项"><a href="#生命周期中需要注意的事项" class="headerlink" title="生命周期中需要注意的事项"></a>生命周期中需要注意的事项</h2><ul>
<li>不要期望frame会立刻变化。</li>
<li>在重写layoutSubviews()时需要非常小心。</li>
</ul>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>Auto Layout你的视图层级里所有视图通过放置在它们里面的约束来动态计算的它们的大小和位置。一般控件需要四个约束决定位置大小，如果定义了intrinsicContentSize的比如UILabel只需要两个约束即可。</p>
<h2 id="约束方程式"><a href="#约束方程式" class="headerlink" title="约束方程式"></a>约束方程式</h2><p>view1.attribute1 = mutiplier * view2.attribute2 + constant</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redButton.left = <span class="number">1.0</span> * yellowLabel.right + <span class="number">10.0</span> <span class="comment">//红色按钮的左侧距离黄色label有10个point</span></div></pre></td></tr></table></figure>
<h2 id="使用API添加约束"><a href="#使用API添加约束" class="headerlink" title="使用API添加约束"></a>使用API添加约束</h2><p>使用NSLayoutConstraint类（最低支持iOS6）添加约束。NSLayoutConstraint官方参考：<a href="https://developer.apple.com/library/prerelease/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/index.html" target="_blank" rel="external">https://developer.apple.com/library/prerelease/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/index.html</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSLayoutContraint</span> constraintWithItem:view1</div><div class="line">                                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                               relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                    toItem:view2</div><div class="line">                                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                multiplier:<span class="number">1.0</span></div><div class="line">                                                 constant:<span class="number">-5</span>]</div></pre></td></tr></table></figure></p>
<p>把约束用约束中两个view的共同父视图或者两视图中层次高视图的- (void)addConstraint:(NSLayoutConstraint *)constraint方法将约束添加进去。</p>
<h2 id="使用VFL语言添加约束"><a href="#使用VFL语言添加约束" class="headerlink" title="使用VFL语言添加约束"></a>使用VFL语言添加约束</h2><p>先举个简单的例子并排两个view添加约束<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[NSLayoutConstraint constraintWithVisualFormat:@“[view1]-[view2]"</div><div class="line">                                                                  options:0</div><div class="line">                                                                  metrics:nil</div><div class="line">                                                                     views:viewsDictionary;</div></pre></td></tr></table></figure></p>
<p>viewDictionary可以通过NSDictionaryOfVariableBindings方法得到</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">viewsDictionary = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1,view2);</div></pre></td></tr></table></figure>
<h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>可以给这个位掩码传入NSLayoutFormatAlignAllTop使它们顶部对齐，这个值的默认值是NSLayoutFormatDirectionLeadingToTrailing从左到右。可以使用NSLayoutFormatAlignAllTop | NSLayoutFormatAlignAllBottom 表示两个视图的顶部和底部约束相同。</p>
<h3 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h3><p>这个参数作用是替换VFL语句中对应的值<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> viewFrame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1, view2);</div><div class="line"><span class="built_in">NSDictionary</span> *metrics = @&#123;<span class="string">@"left"</span>: @(<span class="built_in">CGRectGetMinX</span>(viewFrame)),</div><div class="line">                                           <span class="string">@"top"</span>: @(<span class="built_in">CGRectGetMinY</span>(viewFrame)),</div><div class="line">                                        <span class="string">@"width"</span>: @(<span class="built_in">CGRectGetWidth</span>(viewFrame)),</div><div class="line">                                       <span class="string">@"height"</span>: @(<span class="built_in">CGRectGetHeight</span>(viewFrame))&#125;;</div><div class="line">[view1 addConstraints:[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-left-[view(&gt;=width)]"</span> options:<span class="number">0</span> metrics:metrics views:views]];</div></pre></td></tr></table></figure></p>
<p>使用NSDictionaryOfVariableBindings(…)快速创建<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *left = @<span class="number">50</span>;</div><div class="line"><span class="built_in">NSNumber</span> *top = @<span class="number">50</span>;</div><div class="line"><span class="built_in">NSNumber</span> *width = @<span class="number">100</span>;</div><div class="line"><span class="built_in">NSNumber</span> *height = @<span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1, view2);</div><div class="line"><span class="built_in">NSDictionary</span> *metrics = <span class="built_in">NSDictionaryOfVariableBindings</span>(left, top, width, height);</div><div class="line"></div><div class="line">[view1 addConstraints:[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-left-[view(&gt;=width)]"</span> options:<span class="number">0</span> metrics:metrics views:views]];</div></pre></td></tr></table></figure></p>
<h3 id="VFL几个基本例子"><a href="#VFL几个基本例子" class="headerlink" title="VFL几个基本例子"></a>VFL几个基本例子</h3><ul>
<li>[view1(50)]-10-[view2(100)] 表示view1宽50，view2宽100，间隔10</li>
<li>[view1(&gt;=50@750)] 表示view1宽度大于50，约束条件优先级为750（优先级越大优先执行该约束，最大1000）</li>
<li>V:[view1][view2(==view1)] 表示按照竖直排，上面是view1下面是一个和它一样大的view2</li>
<li>H:|-[view1]-[view2]-[view3(&gt;=20)]-| 表示按照水平排列，|表示父视图，各个视图之间按照默认宽度来排列</li>
</ul>
<h2 id="VFL介绍"><a href="#VFL介绍" class="headerlink" title="VFL介绍"></a>VFL介绍</h2><p>无论使用哪种方法创建约束都是NSLayoutConstraint类的成员，每个约束都会在一个Objective-C对象中存储y = mx + b规则，然后通过Auto Layout引擎来表达该规则，VFL也不例外。VFL由一个描述布局的文字字符串组成，文本会指出间隔，不等量和优先级。官方对其的介绍：Visual Format Language <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html</a></p>
<h2 id="VFL的语法"><a href="#VFL的语法" class="headerlink" title="VFL的语法"></a>VFL的语法</h2><ul>
<li>标准间隔：[button]-[textField]</li>
<li>宽约束：[button(&gt;=50)]</li>
<li>与父视图的关系：|-50-[purpleBox]-50-|</li>
<li>垂直布局：V:[topField]-10-[bottomField]</li>
<li>Flush Views：[maroonView][buleView]</li>
<li>权重：[button(100@20)]</li>
<li>等宽：[button(==button2)]</li>
<li>Multiple Predicates：[flexibleButton(&gt;=70,&lt;=100)]</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>创建这种字符串时需要注意一下几点：</p>
<ul>
<li>H:和V:每次都使用一个。</li>
<li>视图变量名出现在方括号中，例如[view]。</li>
<li>字符串中顺序是按照从顶到底，从左到右</li>
<li>视图间隔以数字常量出现，例如-10-。</li>
<li>|表示父视图</li>
</ul>
<h1 id="使用Auto-Layout时需要注意的点"><a href="#使用Auto-Layout时需要注意的点" class="headerlink" title="使用Auto Layout时需要注意的点"></a>使用Auto Layout时需要注意的点</h1><ul>
<li>注意禁用Autoresizing Masks。对于每个需要使用Auto Layout的视图需要调用setTranslatesAutoresizingMaskIntoConstraints:NO</li>
<li>VFL语句里不能包含空格和&gt;，&lt;这样的约束</li>
<li>布局原理是由外向里布局，最先屏幕尺寸，再一层一层往里决定各个元素大小。</li>
<li>删除视图时直接使用removeConstraint和removeConstraints时需要注意这样删除是没法删除视图不支持的约束导致view中还包含着那个约束（使用第三方库时需要特别注意下）。解决这个的办法就是添加约束时用一个局部变量保存下，删除时进行比较删掉和先前那个，还有个办法就是设置标记，constraint.identifier = @“What you want to call”。</li>
</ul>
<h1 id="布局约束规则"><a href="#布局约束规则" class="headerlink" title="布局约束规则"></a>布局约束规则</h1><p>表达布局约束的规则可以使用一些简单的数学术语，如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图位置</td>
<td style="text-align:left">NSLayoutAttributeLeft, NSLayoutAttributeRight, NSLayoutAttributeTop, NSLayoutAttributeBottom</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图前面后面</td>
<td style="text-align:left">NSLayoutAttributeLeading, NSLayoutAttributeTrailing</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图的宽度和高度</td>
<td style="text-align:left">NSLayoutAttributeWidth, NSLayoutAttributeHeight</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图中心</td>
<td style="text-align:left">NSLayoutAttributeCenterX, NSLayoutAttributeCenterY</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图的基线，在视图底部上方放置文字的地方</td>
<td style="text-align:left">NSLayoutAttributeBaseline</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">占位符，在与另一个约束的关系中没有用到某个属性时可以使用占位符</td>
<td style="text-align:left">NSLayoutAttributeNotAnAttribute</td>
</tr>
<tr>
<td style="text-align:left">关系</td>
<td style="text-align:left">允许将属性通过等式和不等式相互关联</td>
<td style="text-align:left">NSLayoutRelationLessThanOrEqual, NSLayoutRelationEqual, NSLayoutRelationGreaterThanOrEqual</td>
</tr>
<tr>
<td style="text-align:left">数学运算</td>
<td style="text-align:left">每个约束的乘数和相加性常数</td>
<td style="text-align:left">CGFloat值</td>
</tr>
</tbody>
</table>
<h1 id="约束层级"><a href="#约束层级" class="headerlink" title="约束层级"></a>约束层级</h1><p>约束引用两视图时，这两个视图需要属于同一个视图层次结构，对于引用两个视图的约束只有两个情况是允许的。第一种是一个视图是另一个视图的父视图，第二个情况是两个视图在一个窗口下有一个非nil的共同父视图。</p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>哪个约束优先级高会先满足其约束，系统内置优先级枚举值UILayoutPriority<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="built_in">UILayoutPriorityRequired</span> = <span class="number">1000</span>, <span class="comment">//默认的优先级，意味着默认约束一旦冲突就会crash</span></div><div class="line">    <span class="built_in">UILayoutPriorityDefaultHigh</span> = <span class="number">750</span>,</div><div class="line">    <span class="built_in">UILayoutPriorityDefaultLow</span> = <span class="number">250</span>,</div><div class="line">    <span class="built_in">UILayoutPriorityFittingSizeLevel</span> = <span class="number">50</span>,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> <span class="built_in">UILayoutPriority</span>;</div></pre></td></tr></table></figure></p>
<h1 id="IntrinsicContentSize-Compression-Resistance-Priority-Hugging-Priority"><a href="#IntrinsicContentSize-Compression-Resistance-Priority-Hugging-Priority" class="headerlink" title="IntrinsicContentSize / Compression Resistance Priority / Hugging Priority"></a>IntrinsicContentSize / Compression Resistance Priority / Hugging Priority</h1><p>具有instrinsic content size的控件，比如UILabel，UIButton，选择控件，进度条和分段等等，可以自己计算自己的大小，比如label设置text和font后大小是可以计算得到的。这时可以通过设置Hugging priority让这些控件不要大于某个设定的值,默认优先级为250。设置Content Compression Resistance就是让控件不要小于某个设定的值，默认优先级为750。加这些值可以当作是加了个额外的约束值来约束宽。</p>
<h1 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h1><p>updateConstraints -&gt; layoutSubViews -&gt; drawRect</p>
<h2 id="viewDidLayoutSubviews，-layoutSubviews"><a href="#viewDidLayoutSubviews，-layoutSubviews" class="headerlink" title="viewDidLayoutSubviews，-layoutSubviews"></a>viewDidLayoutSubviews，-layoutSubviews</h2><p>使用Auto Layout的view会在viewDidLayoutSubviews或－layoutSubview调用super转换成具有正确显示的frame值。</p>
<h2 id="View的改变会调用哪些方法"><a href="#View的改变会调用哪些方法" class="headerlink" title="View的改变会调用哪些方法"></a>View的改变会调用哪些方法</h2><ul>
<li>改变frame.origin不会掉用layoutSubviews</li>
<li>改变frame.size会使 superVIew的layoutSubviews调用</li>
<li>改变bounds.origin和bounds.size都会调用superView和自己view的layoutSubviews方法</li>
</ul>
<h1 id="Auto-Layout的Debug"><a href="#Auto-Layout的Debug" class="headerlink" title="Auto Layout的Debug"></a>Auto Layout的Debug</h1><p>Auto Layout以下几种情况会出错</p>
<ul>
<li>Unsatisfiable Layouts：约束冲突，同一时刻约束没法同时满足。系统发现时会先检测那些冲突的约束，然后会一直拆掉冲突的约束再检查布局直到找到合适的布局，最后日志会将冲突的约束和拆掉的约束打印在控制台上。</li>
<li>Ambiguous Layouts：约束有缺失，比如说位置或者大小没有全指定到。还有种情况就是两个冲突的约束的权重是一样的就会崩。</li>
<li>Logical Errors：布局中的逻辑错误。</li>
<li>不含视图项的约束不合法，每个约束至少需要引用一个视图，不然会崩。在删除视图时一定要注意。<h2 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h2></li>
<li>po [[UIWindow keyWindow] _autolayoutTrace]<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>参考官方文档：<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html</a></li>
</ul>
<h1 id="容易出问题的Bug-Case"><a href="#容易出问题的Bug-Case" class="headerlink" title="容易出问题的Bug Case"></a>容易出问题的Bug Case</h1><ul>
<li>无共同父视图的视图之间相互添加约束会有问题。</li>
<li>调用了setNeedsLayout后不能通过frame改变视图和控件</li>
<li>为了让在设置了setTranslatesAutoresizingMaskIntoConstraints:NO视图里更改的frame立刻生效而执行了没有标记立刻刷新的layoutIfNeeded的方式是不可取的。</li>
</ul>
<h1 id="实践中碰到的非必现低配置机器崩溃bug分析"><a href="#实践中碰到的非必现低配置机器崩溃bug分析" class="headerlink" title="实践中碰到的非必现低配置机器崩溃bug分析"></a>实践中碰到的非必现低配置机器崩溃bug分析</h1><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>一个视图缺少高宽约束，在设置完了约束后执行layoutIfNeeded，然后设置宽高，这种情况在低配机器上可能会出现崩问题。原因在于layoutIfNeeded需要有标记才会立刻调用layoutSubview得到宽高，不然是不会马上调用的。页面第一次显示是会自动标记上需要刷新这个标记的，所以第一次看显示都是看不出问题的，但页面再次调用layoutIfNeeded时是不会立刻执行layoutSubview的（但之前加上setNeedsLayout就会立刻执行），这时改变的宽高值会在上文生命周期中提到的Auto Layout Cycle中的Engine里的Deferred Layout Pass里执行layoutSubview，手动设置的layoutIfNeeded也会执行一遍layoutSubview，但是这个如果发生在Deferred Layout Pass之后就会出现崩的问题，因为当视图设置为setTranslatesAutoresizingMaskIntoConstraints:NO时会严格按照约束-&gt;Engine-&gt;显示这种流程，如在Deferred Layout Pass之前设置好是没有问题的，之后强制执行LayoutSubview会产生一个权重和先前一样的约束在类似动画block里更新布局让Engine执行导致Ambiguous Layouts这种权重相同冲突崩溃的情况发生。</p>
<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p>将多个有相互约束关系视图removeFromSuperView后更新布局在低配机器上出现崩的问题。这个原因主要是根据不含视图项的约束不合法这个原则来的，同时会抛出野指针的错误。在内存吃紧机器上，当应用占内存较多系统会抓住任何可以释放heap区内存的机会视图被移除后会立刻被清空，这时约束如果还没有被释就满足不含视图项的约束会崩的情况了。</p>
<h1 id="推荐Auto-Layout第三方库"><a href="#推荐Auto-Layout第三方库" class="headerlink" title="推荐Auto Layout第三方库"></a>推荐Auto Layout第三方库</h1><h2 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h2><p>Github地址：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">https://github.com/SnapKit/Masonry</a></p>
<h2 id="Cartography"><a href="#Cartography" class="headerlink" title="Cartography"></a>Cartography</h2><p>Github地址：<a href="https://github.com/robb/Cartography" target="_blank" rel="external">https://github.com/robb/Cartography</a></p>
<h1 id="Masonry-1"><a href="#Masonry-1" class="headerlink" title="Masonry"></a>Masonry</h1><p>可以参看我上篇文章《AutoLayout框架Masonry使用心得》:<a href="http://www.starming.com/index.php?v=index&amp;view=81" target="_blank" rel="external">http://www.starming.com/index.php?v=index&amp;view=81</a></p>
<h1 id="各版本iOS中AutoLayout的区别"><a href="#各版本iOS中AutoLayout的区别" class="headerlink" title="各版本iOS中AutoLayout的区别"></a>各版本iOS中AutoLayout的区别</h1><p>完整记录可以到官方网站进行核对和查找：What’s New in iOS <a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html</a></p>
<h2 id="iOS6"><a href="#iOS6" class="headerlink" title="iOS6"></a>iOS6</h2><p>苹果在这个版本引入Auto Layout，具备了所有核心功能。</p>
<h2 id="iOS7"><a href="#iOS7" class="headerlink" title="iOS7"></a>iOS7</h2><ul>
<li>NavigationBar,TabBar和ToolBar的translucent属性默认为YES，当前ViewController的高度是整个屏幕的高度，为了确保不被这些Bar覆盖可以在布局中使用topLayoutGuide和bottomLayoutGuide属性。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:[topLayoutGuide]-[view1]"</span> options:<span class="number">0</span> metrics:<span class="literal">nil</span> views:view2];</div></pre></td></tr></table></figure>
<h2 id="iOS8"><a href="#iOS8" class="headerlink" title="iOS8"></a>iOS8</h2><ul>
<li>Self Sizing Cells <a href="http://www.appcoda.com/self-sizing-cells/" target="_blank" rel="external">http://www.appcoda.com/self-sizing-cells/</a></li>
<li>UIViewController新增两个方法，用来处理UITraitEnvironment协议，UIKit里有UIScreen，UIViewController，UIView和UIPresentationController支持这个协议，当视图traitCollection改变时UIViewController时可以捕获到这个消息进行处理的。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setOverrideTraitCollection:(<span class="built_in">UITraitCollection</span> *)collection forChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="built_in">UITraitCollection</span> *)overrideTraitCollectionForChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure>
<ul>
<li>Size Class的出现UIViewController提供了一组新协议来支持UIContentContainer</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)systemLayoutFittingSizeDidChangeForChildContentContainer:(<span class="keyword">id</span> )container <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="built_in">CGSize</span>)sizeForChildContentContainer:(<span class="keyword">id</span> )container withParentContainerSize:(<span class="built_in">CGSize</span>)parentSize <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)willTransitionToTraitCollection:(<span class="built_in">UITraitCollection</span> *)newCollection withTransitionCoordinator:(<span class="keyword">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure>
<ul>
<li>UIView的Margin新增了3个API，NSLayoutMargins可以定义view之间的距离，这个只对Auto Layout有效，并且默认值为{8,8,8,8}。NSLayoutAttribute的枚举值也有相应的更新</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UIView的3个Margin相关API</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIEdgeInsets</span> layoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> preservesSuperviewLayoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)layoutMarginsDidChange <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">//NSLayoutAttribute的枚举值更新</span></div><div class="line"><span class="built_in">NSLayoutAttributeLeftMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeRightMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeTopMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeBottomMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeLeadingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeTrailingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeCenterXWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeCenterYWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div></pre></td></tr></table></figure>
<h2 id="iOS9"><a href="#iOS9" class="headerlink" title="iOS9"></a>iOS9</h2><h3 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h3><p>苹果一直希望能够让更多的人来用Auto Layout，除了弄出一个VFL现在又弄出一个不需要约束的方法，使用Stack view使大家使用Auto Layout时不用触碰到约束，官方口号是“Start with Stack View, use constraints as needed”。 更多细节可以查看官方介绍：UIKit Framework Reference  UIStackView Class Reference<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html</a></p>
<p>Stack Views ：<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html</a></p>
<p>Stack View提供了更加简便的自动布局方法比如Alignment的Fill，Leading，Center，Trailing。Distribution的Fill，Fill Equally，Fill Proportionally，Equal Spacing。</p>
<p>如果希望在iOS9之前的系统也能够使用Stack view可以用sunnyxx的FDStackView<a href="https://github.com/forkingdog/FDStackView" target="_blank" rel="external">https://github.com/forkingdog/FDStackView</a>，利用运行时替换元素的方法来支持iOS6+系统。</p>
<h3 id="NSLayoutAnchorAPI"><a href="#NSLayoutAnchorAPI" class="headerlink" title="NSLayoutAnchorAPI"></a>NSLayoutAnchorAPI</h3><p>新增这个API能够让约束的声明更加清晰，还能够通过静态类型检查确保约束的正常工作。具体可以查看官方文档<a href="https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLayoutConstraint</span> *constraint = [view1.leadingAnchor constraintEqualToAnchor:view2.topAnchor];</div></pre></td></tr></table></figure></p>
<h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul>
<li>Auto Layout Guide <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/index.html</a></li>
<li>UIScrollView And Autolayout <a href="https://developer.apple.com/library/ios/technotes/tn2154/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/technotes/tn2154/_index.html</a></li>
<li>IB中使用Auto Layout：Auto Layout Help <a href="https://developer.apple.com/library/ios/recipes/xcode_help-IB_auto_layout/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/recipes/xcode_help-IB_auto_layout/_index.html</a></li>
<li>What’s New in iOS <a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html</a></li>
</ul>
<h2 id="WWDC视频"><a href="#WWDC视频" class="headerlink" title="WWDC视频"></a>WWDC视频</h2><ul>
<li>WWDC 2012: Introduction to Auto Layout for iOS and OS X <a href="https://developer.apple.com/videos/wwdc/2012/?id=202" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=202</a></li>
<li>WWDC 2012: Introducing Collection Views <a href="https://developer.apple.com/videos/play/wwdc2012-205/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2012-205/</a></li>
<li>WWDC 2012: Advanced Collection Views and Building Custom Layouts <a href="https://developer.apple.com/videos/play/wwdc2012-219" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2012-219</a></li>
<li>WWDC 2012: Best Practices for Mastering Auto Layout <a href="https://developer.apple.com/videos/wwdc/2012/?id=228" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=228</a></li>
<li>WWDC 2012: Auto Layout by Example <a href="https://developer.apple.com/videos/wwdc/2012/?id=232" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=232</a></li>
<li>WWDC 2013: Interface Builder Core Concepts <a href="https://developer.apple.com/videos/play/wwdc2013-405" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2013-405</a></li>
<li>WWDC 2013: Taking Control of Auto Layout in Xcode 5 <a href="https://developer.apple.com/videos/wwdc/2013/?id=406" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2013/?id=406</a></li>
<li>WWDC 2015: Mysteries of Auto Layout, Part 1 内容包含了Auto Layout更高封装stack view的介绍 <a href="https://developer.apple.com/videos/play/wwdc2015-218/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-218/</a></li>
<li>WWDC 2015: Mysteries of Auto Layout, Part 2 包含Auto Layout生命周期和调试Auto Layout的一些方法介绍<a href="https://developer.apple.com/videos/play/wwdc2015-219/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-219/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先前写到的一篇Masonry心得文章里已经提到了很多AutoLayout相关的知识，这篇我会更加详细的对其知识要点进行分析和整理。&lt;/p&gt;
&lt;h1 id=&quot;来历&quot;&gt;&lt;a href=&quot;#来历&quot; class=&quot;headerlink&quot; title=&quot;来历&quot;&gt;&lt;/a&gt;来历&lt;/h1&gt;
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Autolayout" scheme="http://ming1016.github.io/tags/Autolayout/"/>
    
  </entry>
  
  <entry>
    <title>Objc Runtime 总结</title>
    <link href="http://ming1016.github.io/2015/04/01/objc-runtime/"/>
    <id>http://ming1016.github.io/2015/04/01/objc-runtime/</id>
    <published>2015-04-01T12:24:27.000Z</published>
    <updated>2017-05-27T06:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。Runtime是C和汇编编写的，这里<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="external">http://www.opensource.apple.com/source/objc4/</a>可以下到苹果维护的开源代码，GNU也有一个开源的runtime版本，他们都努力的保持一致。<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">苹果官方的Runtime编程指南</a></p>
<h2 id="Runtime函数"><a href="#Runtime函数" class="headerlink" title="Runtime函数"></a>Runtime函数</h2><p>Runtime系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/usr/include/objc目录下可以看到头文件，可以用其中一些函数通过C语言实现objectivec中一样的功能。苹果官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html</a> 里有详细的Runtime函数文档。</p>
<h1 id="Class和Object基础数据结构"><a href="#Class和Object基础数据结构" class="headerlink" title="Class和Object基础数据结构"></a>Class和Object基础数据结构</h1><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>objc/runtime.h中objc_class结构体的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">Class isa OBJC_ISA_AVAILABILITY; <span class="comment">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">Class super_class OBJC2_UNAVAILABLE; <span class="comment">// 父类</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></div><div class="line"><span class="keyword">long</span> version OBJC2_UNAVAILABLE; <span class="comment">// 类的版本信息，默认为0</span></div><div class="line"><span class="keyword">long</span> info OBJC2_UNAVAILABLE; <span class="comment">// 类信息，供运行期使用的一些位标识</span></div><div class="line"><span class="keyword">long</span> instance_size OBJC2_UNAVAILABLE; <span class="comment">// 该类的实例变量大小</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 该类的成员变量链表</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法定义的链表</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 协议链表</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>objc_ivar_list和objc_method_list的定义<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//objc_ivar_list结构体存储objc_ivar数组列表</span></div><div class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</div><div class="line">     <span class="keyword">int</span> ivar_count OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">     <span class="keyword">int</span> space OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">     <span class="comment">/* variable length structure */</span></div><div class="line">     <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>] OBJC2_UNAVAILABLE;</div><div class="line">&#125; OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line"><span class="comment">//objc_method_list结构体存储着objc_method的数组列表</span></div><div class="line"><span class="keyword">struct</span> objc_method_list &#123;</div><div class="line">     <span class="keyword">struct</span> objc_method_list *obsolete OBJC2_UNAVAILABLE;</div><div class="line">     <span class="keyword">int</span> method_count OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">     <span class="keyword">int</span> space OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">     <span class="comment">/* variable length structure */</span></div><div class="line">     <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>] OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="objc-object与id"><a href="#objc-object与id" class="headerlink" title="objc_object与id"></a>objc_object与id</h2><p>objc_object是一个类的实例结构体，objc/objc.h中objc_object是一个类的实例结构体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></div><div class="line">Class isa OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></div></pre></td></tr></table></figure></p>
<p>向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。</p>
<h2 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h2><p>objc_class结构体中的cache字段用于缓存调用过的method。cache指针指向objc_cache结构体，这个结构体的定义如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> &#123;</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span> OBJC2_UNAVAILABLE; <span class="comment">//指定分配缓存bucket的总数。runtime使用这个字段确定线性查找数组的索引位置</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> occupied OBJC2_UNAVAILABLE; <span class="comment">//实际占用缓存bucket总数</span></div><div class="line">Method buckets[<span class="number">1</span>] OBJC2_UNAVAILABLE; <span class="comment">//指向Method数据结构指针的数组，这个数组的总数不能超过mask+1，但是指针是可能为空的，这就表示缓存bucket没有被占用，数组会随着时间增长。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="Meta-Class"><a href="#Meta-Class" class="headerlink" title="Meta Class"></a>Meta Class</h2><p>meta class是一个类对象的类，当向对象发消息，runtime会在这个对象所属类方法列表中查找发送消息对应的方法，但当向类发送消息时，runtime就会在这个类的meta class方法列表里查找。所有的meta class，包括Root class，Superclass，Subclass的isa都指向Root class的meta class，这样能够形成一个闭环。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> TestMetaClass(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line"></div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"This objcet is %p"</span>, <span class="keyword">self</span>);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Class is %@, super class is %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</div><div class="line"></div><div class="line">     Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">     <span class="comment">//</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Following the isa pointer %d times gives %p"</span>, i, currentClass);</div><div class="line">          <span class="comment">//通过objc_getClass获得对象isa，这样可以回溯到Root class及NSObject的meta class，可以看到最后指针指向的是0x0和NSObject的meta class类地址一样。</span></div><div class="line">          currentClass = objc_getClass((__bridge <span class="keyword">void</span> *)currentClass);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"NSObject's class is %p"</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"NSObject's meta class is %p"</span>, objc_getClass((__bridge <span class="keyword">void</span> *)[<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">void</span>)ex_registerClassPair &#123;</div><div class="line"></div><div class="line">     Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> <span class="keyword">class</span>], <span class="string">"TestClass"</span>, <span class="number">0</span>);</div><div class="line">     class_addMethod(newClass, <span class="keyword">@selector</span>(testMetaClass), (IMP)TestMetaClass, <span class="string">"v@:"</span>);</div><div class="line">     objc_registerClassPair(newClass);</div><div class="line"></div><div class="line">     <span class="keyword">id</span> instance = [[newClass alloc] initWithDomain:<span class="string">@"some domain"</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</div><div class="line">     [instance performSelector:<span class="keyword">@selector</span>(testMetaClass)];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] NSObject's class is 0xe10000</div><div class="line">2014-10-20 22:57:07.354 mountain[1303:41490] NSObject's meta class is 0x0</div></pre></td></tr></table></figure></p>
<p>举个例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          <span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isKindOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isMemberOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%d %d %d %d"</span>, res1, res2, res3, res4);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">45</span>:<span class="number">08.474</span> Test[<span class="number">9412</span>:<span class="number">721945</span>] <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>先看看isKindOfClass和isMemberOfClass在Object.mm中的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isKindOf:aClass</div><div class="line">&#123;</div><div class="line">     Class cls;</div><div class="line">     <span class="keyword">for</span> (cls = isa; cls; cls = cls-&gt;superclass)</div><div class="line">          <span class="keyword">if</span> (cls == (Class)aClass)</div><div class="line">               <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">     <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)isMemberOf:aClass</div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> isa == (Class)aClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>res1中，可以从isKindOfClass看出NSObject class的isa第一次会指向NSObject的Meta Class，接着Super class时会NSObject的Meta Class根据前面讲的闭环可以知道是会指到NSObject class，这样res1的bool值就是真了。</p>
<p>res2的话因为是isMemberOf就只有一次，那么是NSObject的Meta Class和NSObject class不同返回的bool值就是false了。</p>
<p>res3第一次是Sark Meta Class，第二次super class 后就是NSObject Meta Class了，返回也是false</p>
<p>res4是Sark Meta Class，所以返回也是false</p>
<h1 id="类与对象操作函数"><a href="#类与对象操作函数" class="headerlink" title="类与对象操作函数"></a>类与对象操作函数</h1><p>runtime有很多的函数可以操作类和对象。类相关的是class为前缀，对象相关操作是objc或object_为前缀。</p>
<h2 id="类相关操作函数"><a href="#类相关操作函数" class="headerlink" title="类相关操作函数"></a>类相关操作函数</h2><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</div></pre></td></tr></table></figure>
<h3 id="super-class和meta-class"><a href="#super-class和meta-class" class="headerlink" title="super_class和meta-class"></a>super_class和meta-class</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类的父类</span></div><div class="line">Class class_getSuperclass ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 判断给定的Class是否是一个meta class</span></div><div class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</div></pre></td></tr></table></figure>
<h3 id="instance-size"><a href="#instance-size" class="headerlink" title="instance_size"></a>instance_size</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取实例大小</span></div><div class="line">size_t class_getInstanceSize ( Class cls );</div></pre></td></tr></table></figure>
<h3 id="成员变量-ivars-及属性"><a href="#成员变量-ivars-及属性" class="headerlink" title="成员变量(ivars)及属性"></a>成员变量(ivars)及属性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//成员变量操作函数</span></div><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types ); <span class="comment">//这个只能够向在runtime时创建的类添加成员变量</span></div><div class="line"></div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount ); <span class="comment">//必须使用free()来释放这个数组</span></div><div class="line"></div><div class="line"><span class="comment">//属性操作函数</span></div><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"></div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<h3 id="methodLists"><a href="#methodLists" class="headerlink" title="methodLists"></a>methodLists</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加方法</span></div><div class="line"><span class="built_in">BOOL</span> class_addMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types ); <span class="comment">//和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation</span></div><div class="line"></div><div class="line"><span class="comment">// 获取实例方法</span></div><div class="line">Method class_getInstanceMethod ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 获取类方法</span></div><div class="line">Method class_getClassMethod ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 获取所有方法的数组</span></div><div class="line">Method * class_copyMethodList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 替代方法的实现</span></div><div class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"></div><div class="line"><span class="comment">// 返回方法的具体实现</span></div><div class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</div><div class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</div><div class="line"></div><div class="line"><span class="comment">// 类实例是否响应指定的selector</span></div><div class="line"><span class="built_in">BOOL</span> class_respondsToSelector ( Class cls, SEL sel );</div></pre></td></tr></table></figure>
<h3 id="objc-protocol-list"><a href="#objc-protocol-list" class="headerlink" title="objc_protocol_list"></a>objc_protocol_list</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加协议</span></div><div class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</div><div class="line"></div><div class="line"><span class="comment">// 返回类是否实现指定的协议</span></div><div class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</div><div class="line"></div><div class="line"><span class="comment">// 返回类实现的协议列表</span></div><div class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取版本号</span></div><div class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 设置版本号</span></div><div class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</div></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>通过实例来消化下上面的那些函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// MyClass.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</div><div class="line">- (<span class="keyword">void</span>)method1;</div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line">+ (<span class="keyword">void</span>)classMethod1;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// MyClass.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</div><div class="line"><span class="built_in">NSInteger</span> _instance1;</div><div class="line"><span class="built_in">NSString</span> * _instance2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> integer;</div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"call method method1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"arg1 : %ld, arg2 : %@"</span>, arg1, arg2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//-----------------------------------------------------------</span></div><div class="line"><span class="comment">// main.h</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"MySubClass.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          MyClass *myClass = [[MyClass alloc] init];</div><div class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">          Class cls = myClass.class;</div><div class="line">          <span class="comment">// 类名</span></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));    </div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 父类</span></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"super class name: %s"</span>, class_getName(class_getSuperclass(cls)));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 是否是元类</span></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ a meta-class"</span>, (class_isMetaClass(cls) ? <span class="string">@""</span> : <span class="string">@"not"</span>));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          Class meta_class = objc_getMetaClass(class_getName(cls));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%s's meta-class is %s"</span>, class_getName(cls), class_getName(meta_class));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 变量实例大小</span></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"instance size: %zu"</span>, class_getInstanceSize(cls));</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 成员变量</span></div><div class="line">          Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">               Ivar ivar = ivars[i];</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"instance variable's name: %s at index: %d"</span>, ivar_getName(ivar), i);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          free(ivars);</div><div class="line"></div><div class="line">          Ivar string = class_getInstanceVariable(cls, <span class="string">"_string"</span>);</div><div class="line">          <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"instace variable %s"</span>, ivar_getName(string));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 属性操作</span></div><div class="line">          objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">               objc_property_t property = properties[i];</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"property's name: %s"</span>, property_getName(property));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          free(properties);</div><div class="line"></div><div class="line">          objc_property_t array = class_getProperty(cls, <span class="string">"array"</span>);</div><div class="line">          <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"property %s"</span>, property_getName(array));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 方法操作</span></div><div class="line">          Method *methods = class_copyMethodList(cls, &amp;outCount);</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">               Method method = methods[i];</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"method's signature: %s"</span>, method_getName(method));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          free(methods);</div><div class="line"></div><div class="line">          Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">          <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"method %s"</span>, method_getName(method1));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</div><div class="line">          <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"class method : %s"</span>, method_getName(classMethod));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"MyClass is%@ responsd to selector: method3WithArg1:arg2:"</span>, class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:)) ? <span class="string">@""</span> : <span class="string">@" not"</span>);</div><div class="line"></div><div class="line">          IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">          imp();</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line"></div><div class="line">          <span class="comment">// 协议</span></div><div class="line">          Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</div><div class="line">          Protocol * protocol;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">               protocol = protocols[i];</div><div class="line">               <span class="built_in">NSLog</span>(<span class="string">@"protocol name: %s"</span>, protocol_getName(protocol));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"MyClass is%@ responsed to protocol %s"</span>, class_conformsToProtocol(cls, protocol) ? <span class="string">@""</span> : <span class="string">@" not"</span>, protocol_getName(protocol));</div><div class="line"></div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"=========================================================="</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">2014-10-22 19:41:37.452 RuntimeTest[3189:156810] class name: MyClass</div><div class="line">2014-10-22 19:41:37.453 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] super class name: NSObject</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass is not a meta-class</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass's meta-class is MyClass</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 48</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance1 at index: 0</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance2 at index: 1</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _array at index: 2</div><div class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _string at index: 3</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable's name: _integer at index: 4</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instace variable _string</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: array</div><div class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: string</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property's name: integer</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method1</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method2</div><div class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method3WithArg1:arg2:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: integer</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setInteger:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: array</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: string</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setString:</div><div class="line">2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setArray:</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method's signature: .cxx_destruct</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method method1</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] class method : classMethod1</div><div class="line">2014-10-22 19:41:37.466 RuntimeTest[3189:156810] MyClass is responsd to selector: method3WithArg1:arg2:</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] call method method1</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] ==========================================================</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCopying</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCoding</div><div class="line">2014-10-22 19:41:37.467 RuntimeTest[3189:156810] MyClass is responsed to protocol NSCoding</div><div class="line">2014-10-22 19:41:37.468 RuntimeTest[3189:156810] ======================================</div></pre></td></tr></table></figure></p>
<h2 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h2><h3 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个新类和元类</span></div><div class="line">Class objc_allocateClassPair ( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes ); <span class="comment">//如果创建的是root class，则superclass为Nil。extraBytes通常为0</span></div><div class="line"></div><div class="line"><span class="comment">// 销毁一个类及其相关联的类</span></div><div class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls ); <span class="comment">//在运行中还存在或存在子类实例，就不能够调用这个。</span></div><div class="line"></div><div class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></div><div class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls ); <span class="comment">//创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。</span></div></pre></td></tr></table></figure>
<p>使用实例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>);</div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_addIvar(cls, <span class="string">"_ivar1"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">"i"</span>);</div><div class="line"></div><div class="line">objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</div><div class="line">objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</div><div class="line">objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</div><div class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class="line"></div><div class="line">class_addProperty(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>);</div><div class="line">objc_registerClassPair(cls);</div><div class="line"></div><div class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></div></pre></td></tr></table></figure></p>
<h3 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建类实例</span></div><div class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes ); <span class="comment">//会在heap里给类分配内存。这个方法和+alloc方法类似。</span></div><div class="line"></div><div class="line"><span class="comment">// 在指定位置创建类实例</span></div><div class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes ); </div><div class="line"></div><div class="line"><span class="comment">// 销毁类实例</span></div><div class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj ); <span class="comment">//不会释放移除任何相关引用</span></div></pre></td></tr></table></figure>
<p>测试下效果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//可以看出class_createInstance和alloc的不同</span></div><div class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line"><span class="keyword">id</span> str1 = [theObject init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</div><div class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</div></pre></td></tr></table></figure></p>
<h2 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h2><p>这些函数是针对创建的实例对象的一系列操作函数。</p>
<h3 id="整个对象操作的函数"><a href="#整个对象操作的函数" class="headerlink" title="整个对象操作的函数"></a>整个对象操作的函数</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回指定对象的一份拷贝</span></div><div class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</div><div class="line"><span class="comment">// 释放指定对象占用的内存</span></div><div class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure>
<p>应用场景<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//把a转换成占用更多空间的子类b</span></div><div class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</div><div class="line">object_setClass(newB, MyClass.class);</div><div class="line">object_dispose(a);</div></pre></td></tr></table></figure></p>
<h3 id="对象实例变量进行操作的函数"><a href="#对象实例变量进行操作的函数" class="headerlink" title="对象实例变量进行操作的函数"></a>对象实例变量进行操作的函数</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 修改类实例的实例变量的值</span></div><div class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</div><div class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></div><div class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象中实例变量的值</span></div><div class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</div><div class="line"><span class="comment">// 设置对象中实例变量的值</span></div><div class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</div></pre></td></tr></table></figure>
<h3 id="对对象类操作"><a href="#对对象类操作" class="headerlink" title="对对象类操作"></a>对对象类操作</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回给定对象的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象的类</span></div><div class="line">Class object_getClass ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 设置对象的类</span></div><div class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</div></pre></td></tr></table></figure>
<h2 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取已注册的类定义的列表</span></div><div class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</div><div class="line"></div><div class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></div><div class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的类定义</span></div><div class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的元类</span></div><div class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure>
<p>演示如何使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> numClasses;</div><div class="line">Class * classes = <span class="literal">NULL</span>;</div><div class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</div><div class="line">     classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</div><div class="line">     numClasses = objc_getClassList(classes, numClasses);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"number of classes: %d"</span>, numClasses);</div><div class="line"></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</div><div class="line">          Class cls = classes[i];</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));</div><div class="line">     &#125;</div><div class="line">     free(classes);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] number of classes: <span class="number">1282</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: DDTokenRegexp</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _PFRoutines</div><div class="line">......还有大量输出</div></pre></td></tr></table></figure></p>
<h1 id="成员变量与属性"><a href="#成员变量与属性" class="headerlink" title="成员变量与属性"></a>成员变量与属性</h1><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p>实例变量类型，指向objc_ivar结构体的指针，ivar指针地址是根据class结构体的地址加上基地址偏移字节得到的。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line"><span class="keyword">char</span> *ivar_name OBJC2_UNAVAILABLE; <span class="comment">// 变量名</span></div><div class="line"><span class="keyword">char</span> *ivar_type OBJC2_UNAVAILABLE; <span class="comment">// 变量类型</span></div><div class="line"><span class="keyword">int</span> ivar_offset OBJC2_UNAVAILABLE; <span class="comment">// 基地址偏移字节</span></div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line"><span class="keyword">int</span> space OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h3><p>属性类型，指向objc_property结构体<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</div></pre></td></tr></table></figure></p>
<p>通过class_copyPropertyList和protocol_copyPropertyList方法获取类和协议的属性<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div><div class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</div></pre></td></tr></table></figure></p>
<p>示例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">     <span class="keyword">float</span> alone;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@property</span> <span class="keyword">float</span> alone;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//获取属性列表</span></div><div class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</div><div class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</div><div class="line"></div><div class="line"><span class="comment">//查找属性名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property)</div><div class="line"></div><div class="line"><span class="comment">//通过给出的名称来在类和协议中获取属性的引用</span></div><div class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</div><div class="line">objc_property_t protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</div><div class="line"></div><div class="line"><span class="comment">//发掘属性名称和@encode类型字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</div><div class="line"></div><div class="line"><span class="comment">//从一个类中获取它的属性</span></div><div class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</div><div class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">     objc_property_t property = properties[i];</div><div class="line">     fprintf(stdout, <span class="string">"%s %s\n"</span>, property_getName(property), property_getAttributes(property));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="objc-property-attribute-t"><a href="#objc-property-attribute-t" class="headerlink" title="objc_property_attribute_t"></a>objc_property_attribute_t</h3><p>也是结构体，定义属性的attribute<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 特性名</span></div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *value; <span class="comment">// 特性值</span></div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面代码会编译出错，Runtime Crash还是正常输出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></div><div class="line">- (<span class="keyword">void</span>)speak</div><div class="line">&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"my name is %@"</span>, <span class="keyword">self</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">          <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</div><div class="line">          <span class="keyword">void</span> *obj = &amp;cls;</div><div class="line">          [(__bridge <span class="keyword">id</span>)obj speak];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          [[Test alloc] init];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//结果正常输出</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-07</span> <span class="number">14</span>:<span class="number">08</span>:<span class="number">25.698</span> Test[<span class="number">1097</span>:<span class="number">57255</span>] my name is</div></pre></td></tr></table></figure></p>
<p>obj为指向Sark Class的指针，相当于Sark的实例对象但是还是不一样，根据objc_msgSend流程，obj指针能够在方法列表中找到speak方法，所以运行正常。</p>
<p>为了得到self.name能够输出的原因，可以加入调试代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)speak</div><div class="line">&#123;</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfIvars = <span class="number">0</span>;</div><div class="line">     Ivar *ivars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;numberOfIvars);</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">const</span> Ivar *p = ivars; p &lt; ivars+numberOfIvars; p++) &#123;</div><div class="line">          Ivar <span class="keyword">const</span> ivar = *p;</div><div class="line">          ptrdiff_t offset = ivar_getOffset(ivar);</div><div class="line">          <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Sark ivar name = %s, offset = %td"</span>, name, offset);</div><div class="line">     &#125;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"my name is %p"</span>, &amp;_name);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"my name is %@"</span>, *(&amp;_name));</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Test instance = %@"</span>, <span class="keyword">self</span>);</div><div class="line">          <span class="keyword">void</span> *self2 = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Test instance pointer = %p"</span>, &amp;self2);</div><div class="line">          <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Class instance address = %p"</span>, cls);</div><div class="line">          <span class="keyword">void</span> *obj = &amp;cls;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Void *obj = %@"</span>, obj);</div><div class="line">          [(__bridge <span class="keyword">id</span>)obj speak];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.464</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Test instance = <span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.464</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Test instance pointer = <span class="number">0x7fff5fbff7c8</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Class instance address = <span class="number">0x1000023c8</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Void *obj = <span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] Sark ivar name = _name, offset = <span class="number">8</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] my name is <span class="number">0x7fff5fbff7c8</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-11</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">02.465</span> Test[<span class="number">10475</span>:<span class="number">1071029</span>] my name is</div></pre></td></tr></table></figure></p>
<p>Sark中Propertyname会被转换成ivar到类的结构里，runtime会计算ivar的地址偏移来找ivar的最终地址，根据输出可以看出Sark class的指针地址加上ivar的偏移量正好跟Test对象指针地址。</p>
<h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>关联对象是在运行时添加的类似成员。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将一个对象连接到其它对象</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> myKey;</div><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</div><div class="line"><span class="comment">//获取一个新的关联的对象</span></div><div class="line"><span class="keyword">id</span> anObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;myKey);</div><div class="line"><span class="comment">//使用objc_removeAssociatedObjects函数移除一个关联对象</span></div></pre></td></tr></table></figure></p>
<p>实例演示关联对象使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//动态的将一个Tap手势操作连接到任何UIView中。</span></div><div class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block</div><div class="line">&#123;</div><div class="line">     <span class="built_in">UITapGestureRecognizer</span> *gesture = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey);</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!gesture)</div><div class="line">     &#123;</div><div class="line">          gesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(__handleActionForTapGesture:)];</div><div class="line">          [<span class="keyword">self</span> addGestureRecognizer:gesture];</div><div class="line">          <span class="comment">//将创建的手势对象和block作为关联对象</span></div><div class="line">          objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//手势识别对象的target和action</span></div><div class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(<span class="built_in">UITapGestureRecognizer</span> *)gesture</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (gesture.state == <span class="built_in">UIGestureRecognizerStateRecognized</span>)</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">void</span>(^action)(<span class="keyword">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey);</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (action)</div><div class="line">          &#123;</div><div class="line">               action();</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="成员变量和属性的操作方法"><a href="#成员变量和属性的操作方法" class="headerlink" title="成员变量和属性的操作方法"></a>成员变量和属性的操作方法</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取成员变量名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量类型编码</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量的偏移量</span></div><div class="line">ptrdiff_t ivar_getOffset ( Ivar v );</div></pre></td></tr></table></figure>
<h3 id="Associated-Objects"><a href="#Associated-Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置关联对象</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</div><div class="line"><span class="comment">// 获取关联对象</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</div><div class="line"><span class="comment">// 移除关联对象</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</div><div class="line"></div><div class="line"><span class="comment">//上面方法以键值对的形式动态的向对象添加，获取或者删除关联值。其中关联政策是一组枚举常量。这些常量对应着引用关联值机制，也就是Objc内存管理的引用计数机制。</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">     OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</div><div class="line">     OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</div><div class="line">     OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</div><div class="line">     OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</div><div class="line">     OBJC_ASSOCIATION_COPY = <span class="number">01403</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取属性名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性特性描述字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性中指定的特性</span></div><div class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</div><div class="line"><span class="comment">// 获取属性的特性列表</span></div><div class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>两个接口同样数据不同的字段名处理<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span>: <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * status;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//返回字典数据有不同的字段名，一般是写两个方法，但是如果灵活用runtime只用写一个方法</span></div><div class="line">@&#123;<span class="string">@"name1"</span>: <span class="string">"张三"</span>, <span class="string">@"status1"</span>: <span class="string">@"start"</span>&#125;</div><div class="line">@&#123;<span class="string">@"name2"</span>: <span class="string">"张三"</span>, <span class="string">@"status2"</span>: <span class="string">@"end"</span>&#125;</div><div class="line"><span class="comment">//定义一个映射字典（全局）</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *map = <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">map = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line"></div><div class="line">map[<span class="string">@"name1"</span>] = <span class="string">@"name"</span>;</div><div class="line">map[<span class="string">@"status1"</span>] = <span class="string">@"status"</span>;</div><div class="line">map[<span class="string">@"name2"</span>] = <span class="string">@"name"</span>;</div><div class="line">map[<span class="string">@"status2"</span>] = <span class="string">@"status"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//不同字段映射到MyObject相同属性上</span></div><div class="line">- (<span class="keyword">void</span>)setDataWithDic:(<span class="built_in">NSDictionary</span> *)dic</div><div class="line">&#123;</div><div class="line">     [dic enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line"></div><div class="line">          <span class="built_in">NSString</span> *propertyKey = [<span class="keyword">self</span> propertyForKey:key];</div><div class="line">          <span class="keyword">if</span> (propertyKey)</div><div class="line">          &#123;</div><div class="line">               objc_property_t property = class_getProperty([<span class="keyword">self</span> <span class="keyword">class</span>], [propertyKey UTF8String]);</div><div class="line"></div><div class="line">               <span class="comment">// <span class="doctag">TODO:</span> 针对特殊数据类型做处理</span></div><div class="line">               <span class="built_in">NSString</span> *attributeString = [<span class="built_in">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">               ...</div><div class="line">               [<span class="keyword">self</span> setValue:obj forKey:propertyKey];</div><div class="line">          &#125;</div><div class="line">     &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Method和消息"><a href="#Method和消息" class="headerlink" title="Method和消息"></a>Method和消息</h1><h2 id="Method和消息的基础数据类型"><a href="#Method和消息的基础数据类型" class="headerlink" title="Method和消息的基础数据类型"></a>Method和消息的基础数据类型</h2><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>选择器表示一个方法的selector的指针，可以理解为Method中的ID类型<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div><div class="line"><span class="comment">//objc_selector编译时会根据每个方法名字参数序列生成唯一标识</span></div><div class="line">SEL sel1 = <span class="keyword">@selector</span>(method1);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"sel : %p"</span>, sel1);</div><div class="line">输出</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-30</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52734</span>:<span class="number">466626</span>] sel : <span class="number">0x100002d72</span></div></pre></td></tr></table></figure></p>
<p>获取SEL的三个方法：</p>
<ul>
<li>sel_registerName函数</li>
<li>objectivec编译器提供的@selector()</li>
<li>NSSelectorFromString()方法</li>
</ul>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>是函数指针，指向方法的首地址，通过SEL快速得到对应IMP，这时可以跳过Runtime消息传递机制直接执行函数，比直接向对象发消息高效。定义如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...)</div></pre></td></tr></table></figure></p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>用于表示类定义中的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">     SEL method_name OBJC2_UNAVAILABLE; <span class="comment">// 方法名</span></div><div class="line">     <span class="keyword">char</span> *method_types OBJC2_UNAVAILABLE; <span class="comment">//是个char指针，存储着方法的参数类型和返回值类型</span></div><div class="line">     IMP method_imp OBJC2_UNAVAILABLE; <span class="comment">// 方法实现，函数指针</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Method相关操作函数"><a href="#Method相关操作函数" class="headerlink" title="Method相关操作函数"></a>Method相关操作函数</h2><h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快</span></div><div class="line"><span class="keyword">id</span> method_invoke ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></div><div class="line"><span class="keyword">void</span> method_invoke_stret ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 获取方法名，希望获得方法明的C字符串，使用sel_getName(method_getName(method))</span></div><div class="line">SEL method_getName ( Method m );</div><div class="line"><span class="comment">// 返回方法的实现</span></div><div class="line">IMP method_getImplementation ( Method m );</div><div class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding ( Method m );</div><div class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyReturnType ( Method m );</div><div class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index );</div><div class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getReturnType ( Method m, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回方法的参数的个数</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments ( Method m );</div><div class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * method_getDescription ( Method m );</div><div class="line"><span class="comment">// 设置方法的实现</span></div><div class="line">IMP method_setImplementation ( Method m, IMP imp );</div><div class="line"><span class="comment">// 交换两个方法的实现</span></div><div class="line"><span class="keyword">void</span> method_exchangeImplementations ( Method m1, Method m2 );</div></pre></td></tr></table></figure>
<h3 id="Method的SEL"><a href="#Method的SEL" class="headerlink" title="Method的SEL"></a>Method的SEL</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sel_getName ( SEL sel );</div><div class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></div><div class="line">SEL sel_registerName ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法</span></div><div class="line">SEL sel_getUid ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"><span class="comment">// 比较两个选择器</span></div><div class="line"><span class="built_in">BOOL</span> sel_isEqual ( SEL lhs, SEL rhs );</div></pre></td></tr></table></figure>
<h2 id="Method调用流程"><a href="#Method调用流程" class="headerlink" title="Method调用流程"></a>Method调用流程</h2><p>消息函数，Objc中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个函数将消息接收者和方法名作为基础参数。消息发送给一个对象时，objc_msgSend通过对象的isa指针获得类的结构体，先在Cache里找，找到就执行，没找到就在分发列表里查找方法的selector，没找到就通过objc_msgSend结构体中指向父类的指针找到父类，然后在父类分发列表找，直到root class（NSObject）。</span></div><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure></p>
<p>编译器会根据情况在objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，或objc_msgSendSuper_stret四个方法中选一个调用。如果是传递给超类就会调用带super的函数，如果返回是数据结构而不是一个值就会调用带stret的函数。在i386平台返回类型为浮点消息会调用objc_msgSend_fpret函数。</p>
<p>举个例子，NSStringFromClass([self class])和NSStringFromClass([super class])输出都是self的类名。原因如下</p>
<p>调用[self class]的时候先调用objc_msgSend，发现self没有class这个方法，然后用objc_msgSendSuper就去父类找，还是没有，继续用objc_msgSendSuper到NSObject里找，结果找到了，查找NSObject中class方法的runtime源码会发现它会返回self，所以[self class]会返回self本身。同理[super class]相对前者就是少了objc_msgSend这一步，最后也会找到NSObject根类里的class方法，自然结果也是返回了self。</p>
<h3 id="Method中的接收消息对象参数和方法选择器参数"><a href="#Method中的接收消息对象参数和方法选择器参数" class="headerlink" title="Method中的接收消息对象参数和方法选择器参数"></a>Method中的接收消息对象参数和方法选择器参数</h3><p>在Method中使用self关键字来引用实例本身，self的内容即接收消息的对象是在Method运行时被传入的同时还有方法选择器。</p>
<h3 id="获取Method地址"><a href="#获取Method地址" class="headerlink" title="获取Method地址"></a>获取Method地址</h3><p>使用NSObject提供的methodForSelector:方法可以获得Method的指针，通过指针调用实现代码。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target</div><div class="line">     methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</div><div class="line">     <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure></p>
<h2 id="Method转发"><a href="#Method转发" class="headerlink" title="Method转发"></a>Method转发</h2><p>如果使用[object message]调用方法，object无法响应message时就会报错。用performSelector…调用就要等到运行时才确定是否能接受，不能才崩溃。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先调用respondsToSelector:来判断一下</span></div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</div><div class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Method转发机制分为三步：</p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</div><div class="line">     <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method1"</span>]) &#123;</div><div class="line">          class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">"@:"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以动态的提供一个方法的实现。例如可以用@dynamic关键字在类的实现文件中写个属性<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个表明会为这个属性动态提供set get方法，就是编译器是不会默认生成setPropertyName:和propertyName方法，需要动态提供。可以通过重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法和类方法实现。最后用class_addMethod完成添加特定方法实现的操作</span></div><div class="line"><span class="keyword">@dynamic</span> propertyName;</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">     <span class="comment">// implementation ....</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</div><div class="line">          <span class="comment">//v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</span></div><div class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</div><div class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="重定向接收者"><a href="#重定向接收者" class="headerlink" title="重定向接收者"></a>重定向接收者</h3><p>如果无法处理消息会继续调用下面的方法，同时在这里Runtime系统实际上是给了一个替换消息接收者的机会，但是替换的对象千万不要是self，那样会进入死循环。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))&#123;</div><div class="line">          <span class="keyword">return</span> alternateObject;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这个方法通常在对象内部，如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethodHelper</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethodHelper</span></span></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethod</span> () </span>&#123;</div><div class="line">     SUTRuntimeMethodHelper *_helper;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethod</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)object &#123;</div><div class="line">     <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">          _helper = [[SUTRuntimeMethodHelper alloc] init];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method2)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</div><div class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</div><div class="line"></div><div class="line">     <span class="comment">// 将消息转发给_helper来处理</span></div><div class="line">     <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method2"</span>]) &#123;</div><div class="line">          <span class="keyword">return</span> _helper;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="最后进行转发"><a href="#最后进行转发" class="headerlink" title="最后进行转发"></a>最后进行转发</h3><p>如果以上两种都没法处理未知消息就需要完整消息转发了。调用如下方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的selector，target和参数都封装在anInvocation中。forwardInvocation:像未知消息分发中心，将未知消息转发给其它对象。注意的是forwardInvocation:方法只有在消息接收对象无法正常响应消息时才被调用。</span></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div><div class="line"><span class="comment">//必须重写这个方法，消息转发使用这个方法获得的信息创建NSInvocation对象。</span></div><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>
<p>范例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">     <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!signature) &#123;</div><div class="line">          <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class="line">               signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</div><div class="line">     <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">          [anInvocation invokeWithTarget:_helper];</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h3><p>转发和继承相似，一个Object把消息转发出去就好像它继承了另一个Object的方法一样。</p>
<h3 id="Message消息的参考文章"><a href="#Message消息的参考文章" class="headerlink" title="Message消息的参考文章"></a>Message消息的参考文章</h3><ul>
<li>Message forwarding <a href="https://mikeash.com/pyblog/friday-qa-2009-03-27-objectivec-message-forwarding.html" target="_blank" rel="external">https://mikeash.com/pyblog/friday-qa-2009-03-27-objectivec-message-forwarding.html</a></li>
<li>objectivec messaging <a href="https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objectivec-messaging.html" target="_blank" rel="external">https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objectivec-messaging.html</a></li>
<li>The faster objc_msgSend <a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html" target="_blank" rel="external">http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html</a></li>
</ul>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p>是改变一个selector实际实现的技术，可以在运行时修改selector对应的函数来修改Method的实现。前面的消息转发很强大，但是需要能够修改对应类的源码，但是对于有些类无法修改其源码时又要更改其方法实现时可以使用Method Swizzling，通过重新映射方法来达到目的，但是跟消息转发比起来调试会困难。</p>
<h3 id="使用method-swizzling需要注意的问题"><a href="#使用method-swizzling需要注意的问题" class="headerlink" title="使用method swizzling需要注意的问题"></a>使用method swizzling需要注意的问题</h3><ul>
<li>Swizzling应该总在+load中执行：objectivec在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载</li>
<li>Swizzling应该总是在dispatch_once中执行：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。</li>
<li>Selector，Method和Implementation：这几个之间关系可以这样理解，一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个Method，其中key是一个特定的名称，及SEL，与其对应的实现是IMP即指向底层C函数的指针。</li>
</ul>
<p>举例说明如何使用Method Swizzling对一个类中注入一些我们的新的操作。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">          Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">          <span class="comment">// When swizzling a class method, use the following:</span></div><div class="line">          <span class="comment">// Class class = object_getClass((id)self);</span></div><div class="line">          </div><div class="line">          <span class="comment">//通过method swizzling修改了UIViewController的@selector(viewWillAppear:)的指针使其指向了自定义的xxx_viewWillAppear</span></div><div class="line">          SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</div><div class="line">          SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</div><div class="line"></div><div class="line">          Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">          Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</div><div class="line"></div><div class="line">          <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</div><div class="line">               originalSelector,</div><div class="line">               method_getImplementation(swizzledMethod),</div><div class="line">               method_getTypeEncoding(swizzledMethod));</div><div class="line">          </div><div class="line">          <span class="comment">//如果类中不存在要替换的方法，就先用class_addMethod和class_replaceMethod函数添加和替换两个方法实现。但如果已经有了要替换的方法，就调用method_exchangeImplementations函数交换两个方法的Implementation。</span></div><div class="line">          <span class="keyword">if</span> (didAddMethod) &#123;</div><div class="line">               class_replaceMethod(<span class="keyword">class</span>,</div><div class="line">                    swizzledSelector,</div><div class="line">                    method_getImplementation(originalMethod),</div><div class="line">               method_getTypeEncoding(originalMethod));</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">          &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Method Swizzling</span></div><div class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">     [<span class="keyword">self</span> xxx_viewWillAppear:animated];</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>method_exchangeImplementations做的事情和如下代码是一样的<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IMP imp1 = method_getImplementation(m1);</div><div class="line">IMP imp2 = method_getImplementation(m2);</div><div class="line">method_setImplementation(m1, imp2);</div><div class="line">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p>
<p>另一种Method Swizzling的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)replacementReceiveMessage:(<span class="keyword">const</span> <span class="keyword">struct</span> BInstantMessage *)arg1 &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"arg1 is %@"</span>, arg1);</div><div class="line">     [<span class="keyword">self</span> replacementReceiveMessage:arg1];</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">     SEL originalSelector = <span class="keyword">@selector</span>(ReceiveMessage:);</div><div class="line">     SEL overrideSelector = <span class="keyword">@selector</span>(replacementReceiveMessage:);</div><div class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</div><div class="line">     Method overrideMethod = class_getInstanceMethod(<span class="keyword">self</span>, overrideSelector);</div><div class="line">     <span class="keyword">if</span> (class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) &#123;</div><div class="line">          class_replaceMethod(<span class="keyword">self</span>, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          method_exchangeImplementations(originalMethod, overrideMethod);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有几个关于Method Swizzling的资源可以参考</p>
<ul>
<li>How do I implement method swizzling? <a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="external">http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling</a></li>
<li>Method Swizzling <a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">http://nshipster.com/method-swizzling/</a></li>
<li>What are the Dangers of Method Swizzling in Objective C? <a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objectivec" target="_blank" rel="external">http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objectivec</a></li>
<li>JRSwizzle <a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="external">https://github.com/rentzsch/jrswizzle</a></li>
</ul>
<h1 id="Protocol和Category"><a href="#Protocol和Category" class="headerlink" title="Protocol和Category"></a>Protocol和Category</h1><h2 id="基础数据类型-1"><a href="#基础数据类型-1" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>指向分类的结构体的指针<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_category &#123;</div><div class="line">     <span class="keyword">char</span> *category_name OBJC2_UNAVAILABLE; <span class="comment">// 分类名</span></div><div class="line">     <span class="keyword">char</span> *class_name OBJC2_UNAVAILABLE; <span class="comment">// 分类所属的类名</span></div><div class="line">     <span class="keyword">struct</span> objc_method_list *instance_methods OBJC2_UNAVAILABLE; <span class="comment">// 实例方法列表</span></div><div class="line">     <span class="keyword">struct</span> objc_method_list *class_methods OBJC2_UNAVAILABLE; <span class="comment">// 类方法列表，Meta Class方法列表的子集</span></div><div class="line">     <span class="keyword">struct</span> objc_protocol_list *protocols OBJC2_UNAVAILABLE; <span class="comment">// 分类所实现的协议列表</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Category里面的方法加载过程，objc源码中找到objc-os.mm，函数_objc_init就是runtime的加载入口由libSystem调用，开始初始化，之后objc-runtime-new.mm里的map_images会加载map到内存，_read_images开始初始化这个map，这时会load所有Class，Protocol和Category，NSObject的+load方法就是这个时候调用的。下面是加载代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Discover categories.</span></div><div class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</div><div class="line">     category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</div><div class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">          category_t *cat = catlist[i];</div><div class="line">          Class cls = remapClass(cat-&gt;cls);</div><div class="line">          <span class="keyword">if</span> (!cls) &#123;</div><div class="line">               <span class="comment">// Category's target class is missing (probably weak-linked).</span></div><div class="line">               <span class="comment">// Disavow any knowledge of this category.</span></div><div class="line">               catlist[i] = <span class="literal">nil</span>;</div><div class="line">               <span class="keyword">if</span> (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></div><div class="line">                         <span class="string">"missing weak-linked target class"</span>,</div><div class="line">                         cat-&gt;name, cat);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// Process this category.</span></div><div class="line">          <span class="comment">// First, register the category with its target class.</span></div><div class="line">          <span class="comment">// Then, rebuild the class's method lists (etc) if</span></div><div class="line">          <span class="comment">// the class is realized.</span></div><div class="line">          <span class="built_in">BOOL</span> classExists = <span class="literal">NO</span>;</div><div class="line">          <span class="keyword">if</span> (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties)</div><div class="line">          &#123;</div><div class="line">               addUnattachedCategoryForClass(cat, cls, hi);</div><div class="line">               <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls);</div><div class="line">                    classExists = <span class="literal">YES</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>,</div><div class="line">                         cls-&gt;nameForLogging(), cat-&gt;name,</div><div class="line">                         classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (cat-&gt;classMethods || cat-&gt;protocols <span class="comment">/* || cat-&gt;classProperties */</span>)</div><div class="line">          &#123;</div><div class="line">               addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</div><div class="line">               <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls-&gt;ISA());</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>,</div><div class="line">                         cls-&gt;nameForLogging(), cat-&gt;name);</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用remethodizeClass方法，在其实现里调用attachCategoryMethods</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">attachCategoryMethods(Class cls, category_list *cats, <span class="keyword">bool</span> flushCaches)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</div><div class="line">     <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line">     <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class="line">     method_list_t **mlists = (method_list_t **)</div><div class="line">          _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</div><div class="line">     <span class="comment">// Count backwards through cats to get newest categories first</span></div><div class="line">     <span class="keyword">int</span> mcount = <span class="number">0</span>;</div><div class="line">     <span class="keyword">int</span> i = cats-&gt;count;</div><div class="line">     <span class="built_in">BOOL</span> fromBundle = <span class="literal">NO</span>;</div><div class="line">     <span class="keyword">while</span> (i--) &#123;</div><div class="line">          method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</div><div class="line">          <span class="keyword">if</span> (mlist) &#123;</div><div class="line">               mlists[mcount++] = mlist;</div><div class="line">               fromBundle |= cats-&gt;list[i].fromBundle;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">     attachMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle, flushCaches);</div><div class="line">     _free_internal(mlists);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例，下面的代码会编译错误，Runtime Crash还是会正常输出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></div><div class="line">+ (<span class="keyword">void</span>)foo;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></div><div class="line">- (<span class="keyword">void</span>)foo</div><div class="line">&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"IMP: -[NSObject(Sark) foo]"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          [<span class="built_in">NSObject</span> foo];</div><div class="line">          [[<span class="built_in">NSObject</span> new] foo];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果，正常输出结果如下</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-06</span> <span class="number">13</span>:<span class="number">11</span>:<span class="number">46.694</span> Test[<span class="number">14872</span>:<span class="number">1110786</span>] IMP: -[<span class="built_in">NSObject</span>(Sark) foo]</div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-06</span> <span class="number">13</span>:<span class="number">11</span>:<span class="number">46.695</span> Test[<span class="number">14872</span>:<span class="number">1110786</span>] IMP: -[<span class="built_in">NSObject</span>(Sark) foo]</div></pre></td></tr></table></figure></p>
<p>objc runtime加载后NSObject的Sark Category被加载，头文件+(void)foo没有IMP，只会出现一个warning。被加到Class的Method list里的方法只有-(void)foo，Meta Class的方法列表里没有。</p>
<p>执行[NSObject foo]时，会在Meta Class的Method list里找，找不着就继续往super class里找，NSObject Meta Clas的super class是NSObject本身，这时在NSObject的Method list里就有foo这个方法了，能够正常输出。</p>
<p>执行[[NSObject new] foo]就简单的多了，[NSObject new]生成一个实例，实例的Method list是有foo方法的，于是正常输出。</p>
<h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>Protocol其实就是一个对象结构体<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Protocol;</div></pre></td></tr></table></figure></p>
<h2 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h2><p>Category操作函数信息都包含在objc_class中，我们可以通过objc_class的操作函数来获取分类的操作函数信息。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">@interface RuntimeCategoryClass : NSObject</div><div class="line">- (void)method1;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface RuntimeCategoryClass (Category)</div><div class="line">- (void)method2;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation RuntimeCategoryClass</div><div class="line">- (void)method1 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation RuntimeCategoryClass (Category)</div><div class="line">- (void)method2 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#pragma mark -</div><div class="line">NSLog(@"测试objc_class中的方法列表是否包含分类中的方法");</div><div class="line">unsigned int outCount = 0;</div><div class="line">Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);</div><div class="line"></div><div class="line">for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">     Method method = methodList[i];</div><div class="line"></div><div class="line">     const char *name = sel_getName(method_getName(method));</div><div class="line"></div><div class="line">     NSLog(@"RuntimeCategoryClass's method: %s", name);</div><div class="line"></div><div class="line">     if (strcmp(name, sel_getName(@selector(method2)))) &#123;</div><div class="line">          NSLog(@"分类方法method2在objc_class的方法列表中");</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//输出</div><div class="line">2014-11-08 10:36:39.213 [561:151847] 测试objc_class中的方法列表是否包含分类中的方法</div><div class="line">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method2</div><div class="line">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method1</div><div class="line">2014-11-08 10:36:39.215 [561:151847] 分类方法method2在objc_class的方法列表中</div></pre></td></tr></table></figure></p>
<p>Runtime提供了Protocol的一系列函数操作，函数包括<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回指定的协议</span></div><div class="line">Protocol * objc_getProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></div><div class="line">Protocol ** objc_copyProtocolList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 创建新的协议实例</span></div><div class="line">Protocol * objc_allocateProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 在运行时中注册新创建的协议</span></div><div class="line"><span class="keyword">void</span> objc_registerProtocol ( Protocol *proto ); <span class="comment">//创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></div><div class="line"><span class="comment">// 为协议添加方法</span></div><div class="line"><span class="keyword">void</span> protocol_addMethodDescription ( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></div><div class="line"><span class="keyword">void</span> protocol_addProtocol ( Protocol *proto, Protocol *addition );</div><div class="line"><span class="comment">// 为协议添加属性</span></div><div class="line"><span class="keyword">void</span> protocol_addProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"><span class="comment">// 返回协议名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * protocol_getName ( Protocol *p );</div><div class="line"><span class="comment">// 测试两个协议是否相等</span></div><div class="line"><span class="built_in">BOOL</span> protocol_isEqual ( Protocol *proto, Protocol *other );</div><div class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></div><div class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"><span class="comment">// 获取协议中的属性列表</span></div><div class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取协议的指定属性</span></div><div class="line">objc_property_t protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"><span class="comment">// 获取协议采用的协议</span></div><div class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></div><div class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</div></pre></td></tr></table></figure></p>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><p>runtime中一些支持block操作的函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></div><div class="line">IMP imp_implementationWithBlock ( <span class="keyword">id</span> block );</div><div class="line"></div><div class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></div><div class="line"><span class="keyword">id</span> imp_getBlock ( IMP anImp );</div><div class="line"></div><div class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></div><div class="line"><span class="built_in">BOOL</span> imp_removeBlock ( IMP anImp );</div></pre></td></tr></table></figure></p>
<p>测试代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyRuntimeBlock</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyRuntimeBlock</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">IMP imp = imp_implementationWithBlock(^(<span class="keyword">id</span> obj, <span class="built_in">NSString</span> *str) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</div><div class="line">&#125;);</div><div class="line">class_addMethod(MyRuntimeBlock.class, <span class="keyword">@selector</span>(testBlock:), imp, <span class="string">"v@:@"</span>);</div><div class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</div><div class="line">[runtime performSelector:<span class="keyword">@selector</span>(testBlock:) withObject:<span class="string">@"hello world!"</span>];</div><div class="line"></div><div class="line"><span class="comment">//结果</span></div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-09</span> <span class="number">14</span>:<span class="number">03</span>:<span class="number">19.779</span> [<span class="number">1172</span>:<span class="number">395446</span>] hello world!</div></pre></td></tr></table></figure></p>
<h1 id="Runtime的应用"><a href="#Runtime的应用" class="headerlink" title="Runtime的应用"></a>Runtime的应用</h1><h2 id="获取系统提供的库相关信息"><a href="#获取系统提供的库相关信息" class="headerlink" title="获取系统提供的库相关信息"></a>获取系统提供的库相关信息</h2><p>主要函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取所有加载的objectivec框架和动态库的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyImageNames ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 获取指定类所在动态库</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getImageName ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyClassNamesForImage ( <span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<p>通过这些函数就能够获取某个类所有的库，以及某个库中包含哪些类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">NSLog(@"获取指定类所在动态库");</div><div class="line"></div><div class="line">NSLog(@"UIView's Framework: %s", class_getImageName(NSClassFromString(@"UIView")));</div><div class="line"></div><div class="line">NSLog(@"获取指定库或框架中所有类的类名");</div><div class="line">const char ** classes = objc_copyClassNamesForImage(class_getImageName(NSClassFromString(@"UIView")), &amp;outCount);</div><div class="line">for (int i = 0; i &lt; outCount; i++) &#123;</div><div class="line">     NSLog(@"class name: %s", classes[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//结果</div><div class="line">2014-11-08 12:57:32.689 [747:184013] 获取指定类所在动态库</div><div class="line">2014-11-08 12:57:32.690 [747:184013] UIView's Framework: /System/Library/Frameworks/UIKit.framework/UIKit</div><div class="line">2014-11-08 12:57:32.690 [747:184013] 获取指定库或框架中所有类的类名</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: UIKeyboardPredictiveSettings</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: _UIPickerViewTopFrame</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: _UIOnePartImageView</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewSelectionBar</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerWheelView</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewTestParameters</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="对App的用户行为进行追踪"><a href="#对App的用户行为进行追踪" class="headerlink" title="对App的用户行为进行追踪"></a>对App的用户行为进行追踪</h2><p>就是用户点击时把事件记录下来。一般比较做法就是在viewDidAppear里记录事件，这样会让这样记录事件的代码遍布整个项目中。继承或类别也会有问题。这时利用Method Swizzling把一个方法的实现和另一个方法的实现进行替换。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先定义一个类别，添加要Swizzled的方法</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)- (<span class="title">void</span>)<span class="title">swizzled_viewDidAppear</span>:(<span class="title">BOOL</span>)<span class="title">animated</span></span></div><div class="line">&#123; <span class="comment">// call original implementation</span></div><div class="line">     [<span class="keyword">self</span> swizzled_viewDidAppear:animated]; <span class="comment">// Logging</span></div><div class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div><div class="line"><span class="comment">//接下来实现swizzle方法</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)<span class="title">void</span> <span class="title">swizzleMethod</span>(<span class="title">Class</span> <span class="title">class</span>, <span class="title">SEL</span> <span class="title">originalSelector</span>, <span class="title">SEL</span> <span class="title">swizzledSelector</span>) </span>&#123; <span class="comment">// the method might not exist in the class, but in its superclass</span></div><div class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">     Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector); <span class="comment">// class_addMethod will fail if original method already exists</span></div><div class="line">     <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); <span class="comment">// the method doesn’t exist and we just added one</span></div><div class="line">     <span class="keyword">if</span> (didAddMethod) &#123;</div><div class="line">          class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">else</span> &#123;</div><div class="line">          method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最后要确保在程序启动的时候调用swizzleMethod方法在之前的UIViewController的Logging类别里添加+load:方法，然后在+load:里把viewDidAppear替换掉</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)+ (<span class="title">void</span>)<span class="title">load</span></span></div><div class="line">&#123;</div><div class="line">     swizzleMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:), <span class="keyword">@selector</span>(swizzled_viewDidAppear:));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//更简化直接用新的IMP取代原IMP，不是替换，只需要有全局的函数指针指向原IMP即可。</span></div><div class="line"><span class="keyword">void</span> (gOriginalViewDidAppear)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);<span class="keyword">void</span> newViewDidAppear(<span class="built_in">UIViewController</span> *<span class="keyword">self</span>, SEL _cmd, <span class="built_in">BOOL</span> animated)</div><div class="line">&#123; <span class="comment">// call original implementation</span></div><div class="line">     gOriginalViewDidAppear(<span class="keyword">self</span>, _cmd, animated); <span class="comment">// Logging</span></div><div class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewDidAppear:));</div><div class="line">     gOriginalViewDidAppear = (<span class="keyword">void</span> *)method_getImplementation(originalMethod); <span class="keyword">if</span>(!class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewDidAppear:), (IMP) newViewDidAppear, method_getTypeEncoding(originalMethod))) &#123;</div><div class="line">          method_setImplementation(originalMethod, (IMP) newViewDidAppear);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过Method Swizzling可以把事件代码或Logging，Authentication，Caching等跟主要业务逻辑代码解耦。这种处理方式叫做Cross Cutting Concerns<a href="http://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="external">http://en.wikipedia.org/wiki/Cross-cutting_concern</a> 用Method Swizzling动态给指定的方法添加代码解决Cross Cutting Concerns的编程方式叫Aspect Oriented Programming <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="external">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a> 目前有些第三方库可以很方便的使用AOP，比如Aspects <a href="https://github.com/steipete/Aspects" target="_blank" rel="external">https://github.com/steipete/Aspects</a> 这里是使用Aspects的范例<a href="https://github.com/okcomp/AspectsDemo" target="_blank" rel="external">https://github.com/okcomp/AspectsDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。Runtime是C和汇编编写的，这里&lt;a
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="runtime" scheme="http://ming1016.github.io/tags/runtime/"/>
    
  </entry>
  
</feed>
