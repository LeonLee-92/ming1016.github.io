<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星光社 - 戴铭的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ming1016.github.io/"/>
  <updated>2017-08-17T13:00:10.000Z</updated>
  <id>http://ming1016.github.io/</id>
  
  <author>
    <name>戴铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入剖析 iOS 性能优化</title>
    <link href="http://ming1016.github.io/2017/06/20/deeply-ios-performance-optimization/"/>
    <id>http://ming1016.github.io/2017/06/20/deeply-ios-performance-optimization/</id>
    <published>2017-06-20T02:25:42.000Z</published>
    <updated>2017-08-17T13:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题种类"><a href="#问题种类" class="headerlink" title="问题种类"></a>问题种类</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在集合里数据量小的情况下时间复杂度对于性能的影响看起来微乎其微。但如果某个开发的功能是一个公共功能，无法预料调用者传入数据的量时，这个复杂度的优化显得非常重要了。<br><img src="/uploads/deeply-ios-performance-optimization/01.png" alt=""><br>上图列出了各种情况的时间复杂度，比如高效的排序算法一般都是 O(n log n)。接下来看看下图：<br><img src="/uploads/deeply-ios-performance-optimization/02.png" alt=""><br>图中可以看出 O(n) 是个分水岭，大于它对于性能就具有很大的潜在影响，如果是个公共的接口一定要加上说明，自己调用也要做到心中有数。当然最好是通过算法优化或者使用合适的系统接口方法，权衡内存消耗争取通过空间来换取时间。</p>
<p>下面通过集合里是否有某个值来举个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//O(1)</span></div><div class="line"><span class="keyword">return</span> array[idx] == value;</div><div class="line"></div><div class="line"><span class="comment">//O(n)</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (array[i] == value) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="comment">//O(n2) 找重复的值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) &#123;</div><div class="line">        <span class="keyword">if</span> ( i != j &amp;&amp; array[i] == array[j]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div></pre></td></tr></table></figure></p>
<p>那么 OC 里几种常用集合对象提供的接口方法时间复杂度是怎么样的。</p>
<h3 id="NSArray-NSMutableArray"><a href="#NSArray-NSMutableArray" class="headerlink" title="NSArray / NSMutableArray"></a>NSArray / NSMutableArray</h3><p>首先我们发现他们是有排序，并允许重复元素存在的，那么这么设计就表明了集合存储没法使用里面的元素做 hash table 的 key 进行相关的快速操作，。所以不同功能接口方法性能是会有很大的差异。</p>
<ul>
<li>containsObject:，containsObject:，indexOfObject*，removeObject: 会遍历里面元素查看是否与之匹对，所以复杂度等于或大于 O(n)</li>
<li>objectAtIndex:，firstObject:，lastObject:，addObject:，removeLastObject: 这些只针对栈顶栈底操作的时间复杂度都是 O(1)</li>
<li>indexOfObject:inSortedRange:options:usingComparator: 使用的是二分查找，时间复杂度是 O(log n)</li>
</ul>
<h3 id="NSSet-NSMutableSet-NSCountedSet"><a href="#NSSet-NSMutableSet-NSCountedSet" class="headerlink" title="NSSet / NSMutableSet / NSCountedSet"></a>NSSet / NSMutableSet / NSCountedSet</h3><p>这些集合类型是无序没有重复元素。这样就可以通过 hash table 进行快速的操作。比如 addObject:, removeObject:, containsObject: 都是按照 O(1) 来的。需要注意的是将数组转成 Set 时会将重复元素合成一个，同时失去排序。</p>
<h3 id="NSDictionary-NSMutableDictionary"><a href="#NSDictionary-NSMutableDictionary" class="headerlink" title="NSDictionary / NSMutableDictionary"></a>NSDictionary / NSMutableDictionary</h3><p>和 Set 差不多，多了键值对应。添加删除和查找都是 O(1) 的。需要注意的是 Keys 必须是符合 NSCopying。</p>
<h3 id="containsObject-方法在数组和-Set-里不同的实现"><a href="#containsObject-方法在数组和-Set-里不同的实现" class="headerlink" title="containsObject 方法在数组和 Set 里不同的实现"></a>containsObject 方法在数组和 Set 里不同的实现</h3><p>在数组中的实现<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>) containsObject: (<span class="keyword">id</span>)anObject</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> ([<span class="keyword">self</span> indexOfObject: anObject] != <span class="built_in">NSNotFound</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSUInteger</span>) indexOfObject: (<span class="keyword">id</span>)anObject</div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span>	c = [<span class="keyword">self</span> count];</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; anObject != <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">unsigned</span>	i;</div><div class="line">      IMP	get = [<span class="keyword">self</span> methodForSelector: oaiSel];</div><div class="line">      <span class="built_in">BOOL</span>	(*eq)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>)</div><div class="line">	= (<span class="built_in">BOOL</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[anObject methodForSelector: eqSel];</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++)</div><div class="line">	<span class="keyword">if</span> ((*eq)(anObject, eqSel, (*get)(<span class="keyword">self</span>, oaiSel, i)) == <span class="literal">YES</span>)</div><div class="line">	  <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">NSNotFound</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到会遍历所有元素在查找到后才进行返回.</p>
<p>接下来可以看看 containsObject 在 Set 里的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>) containsObject: (<span class="keyword">id</span>)anObject</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> (([<span class="keyword">self</span> member: anObject]) ? <span class="literal">YES</span> : <span class="literal">NO</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//在 GSSet,m 里有对 member 的实现</span></div><div class="line">- (<span class="keyword">id</span>) member: (<span class="keyword">id</span>)anObject</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (anObject != <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">      GSIMapNode node = GSIMapNodeForKey(&amp;map, (GSIMapKey)anObject);</div><div class="line">      <span class="keyword">if</span> (node != <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">	  <span class="keyword">return</span> node-&gt;key.obj;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找元素时是通过键值方式从 map 映射表里取出，因为 Set 里元素是唯一的，所以可以 hash 元素对象作为 key 达到快速获取值的目的。</p>
<h2 id="用-GCD-来做优化"><a href="#用-GCD-来做优化" class="headerlink" title="用 GCD 来做优化"></a>用 GCD 来做优化</h2><p>我们可以通过 GCD 提供的方法来将一些需要耗时操作放到非主线程上做，使得 App 能够运行的更加流畅响应更快。但是使用 GCD 时需要注意避免可能引起线程爆炸和死锁的情况，还有非主线程处理任务也不是万能的，如果一个处理需要消耗大量内存或者大量CPU操作 GCD 也没法帮你，只能通过将处理进行拆解分步骤分时间进行处理才比较妥当。</p>
<h3 id="异步处理事件"><a href="#异步处理事件" class="headerlink" title="异步处理事件"></a>异步处理事件</h3><p><img src="/uploads/deeply-ios-performance-optimization/03.png" alt=""><br>上图是最典型的异步处理事件的方法</p>
<h3 id="需要耗时长的任务"><a href="#需要耗时长的任务" class="headerlink" title="需要耗时长的任务"></a>需要耗时长的任务</h3><p><img src="/uploads/deeply-ios-performance-optimization/04.png" alt=""><br>将 GCD 的 block 通过 dispatch_block_create_with_qos_class 方法指定队列的 QoS 为 QOS_CLASS_UTILITY。这种 QoS 系统会针对大的计算，I/O，网络以及复杂数据处理做电量优化。</p>
<h3 id="避免线程爆炸"><a href="#避免线程爆炸" class="headerlink" title="避免线程爆炸"></a>避免线程爆炸</h3><ul>
<li>使用串行队列</li>
<li>使用 NSOperationQueues 的并发限制方法 NSOperationQueue.maxConcurrentOperationCount</li>
</ul>
<p>举个例子，下面的写法就比较危险，可能会造成线程爆炸和死锁<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span>; i++) &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(q, ^&#123;...&#125;);</div><div class="line">&#125;</div><div class="line">dispatch_barrier_sync(q, ^&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/deeply-ios-performance-optimization/05.png" alt=""></p>
<p>那么怎么能够避免呢？首先可以使用 dispatch_apply<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_apply(<span class="number">999</span>, q, ^(size_t i)&#123;...&#125;);</div></pre></td></tr></table></figure></p>
<p>或者使用 dispatch_semaphore<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define CONCURRENT_TASKS 4</span>sema = dispatch_semaphore_create(CONCURRENT_TASKS);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span>; i++)&#123;    <span class="built_in">dispatch_async</span>(q, ^&#123;        dispatch_semaphore_signal(sema);    &#125;);    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);&#125;</div></pre></td></tr></table></figure></p>
<h3 id="GCD-相关-Crash-日志"><a href="#GCD-相关-Crash-日志" class="headerlink" title="GCD 相关 Crash 日志"></a>GCD 相关 Crash 日志</h3><p>管理线程问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread 1:: Dispatch queue: com.apple.libdispatch-manager</div><div class="line">0   libsystem_kernel.dylib   0x00007fff8967e08a kevent_qos + 10</div><div class="line">1   libdispatch.dylib        0x00007fff8be05811 _dispatch_mgr_invoke + 251</div><div class="line">2   libdispatch.dylib        0x00007fff8be05465 _dispatch_mgr_thread + 52</div></pre></td></tr></table></figure></p>
<p>线程闲置时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread 6:</div><div class="line">0   libsystem_kernel.dylib       0x00007fff8967d772 __workq_kernreturn + 10</div><div class="line">1   libsystem_pthread.dylib      0x00007fff8fd317d9 _pthread_wqthread + 1283</div><div class="line">2   libsystem_pthread.dylib      0x00007fff8fd2ed95 start_wqthread + 13</div></pre></td></tr></table></figure></p>
<p>线程活跃时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread 3 Crashed:: Dispatch queue: &lt;queue name&gt;</div><div class="line">&lt;my code&gt;</div><div class="line">7   libdispatch.dylib        0x07fff8fcfd323 _dispatch_call_block_and_release</div><div class="line">8   libdispatch.dylib        0x07fff8fcf8c13 _dispatch_client_callout + 8</div><div class="line">9   libdispatch.dylib        0x07fff8fcfc365 _dispatch_queue_drain + 1100</div><div class="line">10  libdispatch.dylib        0x07fff8fcfdecc _dispatch_queue_invoke + 202</div><div class="line">11  libdispatch.dylib        0x07fff8fcfb6b7 _dispatch_root_queue_drain + 463</div><div class="line">12  libdispatch.dylib        0x07fff8fd09fe4 _dispatch_worker_thread3 + 91</div><div class="line">13  libsystem_pthread.dylib  0x07fff93c17637 _pthread_wqthread + 729</div><div class="line">14  libsystem_pthread.dylib  0x07fff93c1540d start_wqthread + 13</div></pre></td></tr></table></figure></p>
<p>主线程闲置时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread 0 Crashed:: Dispatch queue: com.apple.main-thread</div><div class="line">0   libsystem_kernel.dylib     0x00007fff906614de mach_msg_trap + 10</div><div class="line">1   libsystem_kernel.dylib     0x00007fff9066064f mach_msg + 55</div><div class="line">2   com.apple.CoreFoundation   0x00007fff9a8c1eb4 __CFRunLoopServiceMachPort</div><div class="line">3   com.apple.CoreFoundation   0x00007fff9a8c137b __CFRunLoopRun + 1371</div><div class="line">4   com.apple.CoreFoundation   0x00007fff9a8c0bd8 CFRunLoopRunSpecific + 296</div><div class="line">...</div><div class="line">10  com.apple.AppKit           0x00007fff8e823c03 -[NSApplication run] + 594</div><div class="line">11  com.apple.AppKit           0x00007fff8e7a0354 NSApplicationMain + 1832</div><div class="line">12  com.example                0x00000001000013b4 start + 52</div></pre></td></tr></table></figure></p>
<p>主队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Thread 0 Crashed:: Dispatch queue: com.apple.main-thread</div><div class="line">&lt;my code&gt;</div><div class="line">12  com.apple.Foundation      0x00007fff931157e8 __NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 7</div><div class="line">13  com.apple.Foundation      0x00007fff931155b5 -[NSBlockOperation main] + 9</div><div class="line">14  com.apple.Foundation      0x00007fff93114a6c -[__NSOperationInternal _start:] + 653</div><div class="line">15  com.apple.Foundation      0x00007fff93114543 __NSOQSchedule_f + 184</div><div class="line">16  libdispatch.dylib         0x00007fff935d6c13 _dispatch_client_callout + 8</div><div class="line">17  libdispatch.dylib         0x00007fff935e2cbf _dispatch_main_queue_callback_4CF + 861</div><div class="line">18  com.apple.CoreFoundation  0x00007fff8d9223f9 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</div><div class="line">19  com.apple.CoreFoundation  0x00007fff8d8dd68f __CFRunLoopRun + 2159</div><div class="line">20  com.apple.CoreFoundation  0x00007fff8d8dcbd8 CFRunLoopRunSpecific + 296</div><div class="line">...</div><div class="line">26  com.apple.AppKit          0x00007fff999a1bd3 -[NSApplication run] + 594</div><div class="line">27  com.apple.AppKit          0x00007fff9991e324 NSApplicationMain + 1832</div><div class="line">28  libdyld.dylib             0x00007fff9480f5c9 start + 1</div></pre></td></tr></table></figure></p>
<h2 id="I-O-性能优化"><a href="#I-O-性能优化" class="headerlink" title="I/O 性能优化"></a>I/O 性能优化</h2><p>I/O 是性能消耗大户，任何的 I/O 操作都会使低功耗状态被打破，所以减少 I/O 次数是这个性能优化的关键点，为了达成这个目下面列出一些方法。</p>
<ul>
<li>将零碎的内容作为一个整体进行写入</li>
<li>使用合适的 I/O 操作 API</li>
<li>使用合适的线程</li>
<li>使用 NSCache 做缓存能够减少 I/O</li>
</ul>
<h3 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h3><p><img src="/uploads/deeply-ios-performance-optimization/06.png" alt=""><br>达到如图的目的为何不直接用字典来做呢？<br>NSCache 具有字典的所有功能，同时还有如下的特性：</p>
<ul>
<li>自动清理系统占用内存</li>
<li>NSCache 是线程安全</li>
<li>-(void)cache:(NSCache *)cache willEvictObject:(id)obj;   缓存对象将被清理时的回调 </li>
<li>evictsObjectsWithDiscardedContent 可以控制是否清理</li>
</ul>
<p>那么 NSCache是如何做到这些特性的呢？</p>
<p>接下来学习下 NSCache 是如何做的。首先 NSCache 是会持有一个 NSMutableDictionary。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@implementation NSCache</div><div class="line">- (id) init</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (nil == (self = [super init]))</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> nil;</div><div class="line">    &#125;</div><div class="line">  _objects = [NSMutableDictionary <span class="keyword">new</span>];</div><div class="line">  _accesses = [NSMutableArray <span class="keyword">new</span>];</div><div class="line">  <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要设计一个 Cached 对象结构来保存一些额外的信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@interface _GSCachedObject : NSObject</div><div class="line">&#123;</div><div class="line">  @<span class="keyword">public</span></div><div class="line">  id object; <span class="comment">//cache 的值</span></div><div class="line">  NSString *key; <span class="comment">//设置 cache 的 key</span></div><div class="line">  <span class="keyword">int</span> accessCount; <span class="comment">//保存访问次数，用于自动清理</span></div><div class="line">  NSUInteger cost; <span class="comment">//setObject:forKey:cost:</span></div><div class="line">  BOOL isEvictable; <span class="comment">//线程安全</span></div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>在 Cache 读取的时候会对 _accesses 数组的添加删除通过 isEvictable 布尔值来保证线程安全操作。使用 Cached 对象里的 accessCount 属性进行 +1 操作为后面自动清理的条件判断做准备。具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (id) objectForKey: (id)key</div><div class="line">&#123;</div><div class="line">  _GSCachedObject *obj = [_objects objectForKey: key];</div><div class="line">  <span class="keyword">if</span> (nil == obj)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> nil;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">if</span> (obj-&gt;isEvictable) <span class="comment">//保证添加删除操作线程安全</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">// 将 obj 移到 access list 末端</span></div><div class="line">      [_accesses removeObjectIdenticalTo: obj];</div><div class="line">      [_accesses addObject: obj];</div><div class="line">    &#125;</div><div class="line">  obj-&gt;accessCount++;</div><div class="line">  _totalAccesses++;</div><div class="line">  <span class="keyword">return</span> obj-&gt;object;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在每次 Cache 添加时会先去检查是否自动清理，会创建一个 Cached 对象将 key，object，cost 等信息记录下添加到 _accesses 数组和 _objects 字典里。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) setObject: (id)obj forKey: (id)key cost: (NSUInteger)num</div><div class="line">&#123;</div><div class="line">  _GSCachedObject *oldObject = [_objects objectForKey: key];</div><div class="line">  _GSCachedObject *newObject;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (nil != oldObject)</div><div class="line">    &#123;</div><div class="line">      [self removeObjectForKey: oldObject-&gt;key];</div><div class="line">    &#125;</div><div class="line">  [self _evictObjectsToMakeSpaceForObjectWithCost: num];</div><div class="line">  newObject = [_GSCachedObject <span class="keyword">new</span>];</div><div class="line">  <span class="comment">// Retained here, released when obj is dealloc'd</span></div><div class="line">  newObject-&gt;object = RETAIN(obj);</div><div class="line">  newObject-&gt;key = RETAIN(key);</div><div class="line">  newObject-&gt;cost = num;</div><div class="line">  <span class="keyword">if</span> ([obj conformsToProtocol: @protocol(NSDiscardableContent)])</div><div class="line">    &#123;</div><div class="line">      newObject-&gt;isEvictable = YES;</div><div class="line">      [_accesses addObject: newObject];</div><div class="line">    &#125;</div><div class="line">  [_objects setObject: newObject forKey: key];</div><div class="line">  RELEASE(newObject);</div><div class="line">  _totalCost += num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么上面提到的自动清理内存的方法是如何实现的呢？<br>既然是自动清理必定需要有触发时机和进入清理的条件判断，触发时机一个是发生在添加 Cache 内容时，一个是发生在内存警告时。条件判断代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// cost 在添加新 cache 值时指定的 cost</span></div><div class="line"><span class="comment">// _costLimit 是 totalCostLimit 属性值</span></div><div class="line"><span class="keyword">if</span> (_costLimit &gt; <span class="number">0</span> &amp;&amp; _totalCost + cost &gt; _costLimit)&#123;</div><div class="line">	spaceNeeded = _totalCost + cost - _costLimit;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 只有当 cost 大于人工限制时才会清理</span></div><div class="line"><span class="comment">// 或者 cost 设置为0不进行人工干预</span></div><div class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; (spaceNeeded &gt; <span class="number">0</span> || count &gt;= _countLimit))</div></pre></td></tr></table></figure></p>
<p>所以 NSCache 的 totalCostLimit 的值会和每次 Cache 添加的 cost 之和对比，超出限制必然触发内存清理。</p>
<p>清理时会对经常访问的 objects 不清理，主要是通过 _totalAccesses 和总数获得平均访问频率，如果那个对象的访问次数是小于平均值的才需要清理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//_totalAccesses 所有的值的访问都会 +1</span></div><div class="line">NSUInteger averageAccesses = (_totalAccesses / count * <span class="number">0.2</span>) + <span class="number">1</span>;</div><div class="line"><span class="comment">//accessCount 每次 obj 取值时会 +1</span></div><div class="line"><span class="keyword">if</span> (obj-&gt;accessCount &lt; averageAccesses &amp;&amp; obj-&gt;isEvictable)</div></pre></td></tr></table></figure></p>
<p>在清理之前还需要一些准备工作，包括标记 Cached 对象的 isEvictable 防止后面有不安全的线程操作。将满足条件的清理 objects 放到清理数组里，如果空间释放足够就不用再把更多的 objects 加到清理数组里了，最后遍历清理数组进行逐个清理即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NSUInteger cost = obj-&gt;cost;</div><div class="line">obj-&gt;cost = <span class="number">0</span>;</div><div class="line"><span class="comment">// 不会被再次清除</span></div><div class="line">obj-&gt;isEvictable = NO;</div><div class="line"><span class="comment">// 添加到 remove list 里</span></div><div class="line"><span class="keyword">if</span> (_evictsObjectsWithDiscardedContent)</div><div class="line">&#123;</div><div class="line">    [evictedKeys addObject: obj-&gt;key];</div><div class="line">&#125;</div><div class="line">_totalCost -= cost;</div><div class="line"><span class="comment">// 如果已经释放了足够空间就不用后面操作了</span></div><div class="line"><span class="keyword">if</span> (cost &gt; spaceNeeded)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">spaceNeeded -= cost;</div></pre></td></tr></table></figure></p>
<p>在清理时会执行回调内容，这样如果有些缓存数据需要持续化存储可以在回调里进行处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) removeObjectForKey: (id)key</div><div class="line">&#123;</div><div class="line">    _GSCachedObject *obj = [_objects objectForKey: key];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (nil != obj)</div><div class="line">    &#123;</div><div class="line">        [_delegate cache: self willEvictObject: obj-&gt;object];</div><div class="line">        _totalAccesses -= obj-&gt;accessCount;</div><div class="line">        [_objects removeObjectForKey: key];</div><div class="line">        [_accesses removeObjectIdenticalTo: obj];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整的实现可以查看 GNUstep Base 的 NSCache.m 文件。</p>
<p>下面可以看看 NSCache 在 SDWebImage 的运用是怎么样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">// 检查 NSCache 里是否有</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 从磁盘里读</span></div><div class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">    <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">        [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> diskImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出利用 NSCache 自动释放内存的特点将图片都放到 NSCache 里这样在内存不够用时可以自动清理掉不常用的那些图片，在读取 Cache 里内容时如果没有被清理会直接返回图片数据，清理了的话才会执行 I/O 从磁盘读取图片，通过这种方式能够利用空间减少磁盘操作，空间也能够更加有效的控制释放。</p>
<h2 id="控制-App-的-Wake-次数"><a href="#控制-App-的-Wake-次数" class="headerlink" title="控制 App 的 Wake 次数"></a>控制 App 的 Wake 次数</h2><p>通知，VoIP，定位，蓝牙等都会使设备从 Standby 状态唤起。唤起这个过程会有比较大的消耗，应该避免频繁发生。通知方面主要要在产品层面多做考虑。定位方面，下面可以看看定位的一些 API 看看它们对性能的不同影响，便于考虑采用合适的接口。</p>
<p>连续的位置更新<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[locationManager startUpdatingLocation]</div></pre></td></tr></table></figure></p>
<p>这个方法会时设备一直处于活跃状态。</p>
<p>延时有效定位<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[locationManager allowDeferredLocationUpdatesUntilTraveled: timeout:]</div><div class="line">``` </div><div class="line">高效节能的定位方式，数据会缓存在位置硬件上。适合于跑步应用应该都采用这种方式。</div><div class="line"></div><div class="line">重大位置变化</div><div class="line">```objc</div><div class="line">[locationManager startMonitoringSignificantLocationChanges]</div></pre></td></tr></table></figure></p>
<p>会更节能，对于那些只有在位置有很大变化的才需要回调的应用可以采用这种，比如天气应用。</p>
<p>区域监测<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[locationManager startMonitoringForRegion:(<span class="built_in">CLRegion</span> *)]</div></pre></td></tr></table></figure></p>
<p>也是一种节能的定位方式，比如在博物馆里按照不同区域监测展示不同信息之类的应用比较适合这种定位。</p>
<p>经常访问的地方<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Start monitoring</span>locationManager.startMonitoringVisits()<span class="comment">// Stop monitoring when no longer needed</span>locationManager.stopMonitoringVisits()</div></pre></td></tr></table></figure></p>
<p>总的来说，不要轻易使用 startUpdatingLocation() 除非万不得已，尽快的使用 stopUpdatingLocation() 来结束定位还用户一个节能设备。</p>
<h2 id="内存对于性能的影响"><a href="#内存对于性能的影响" class="headerlink" title="内存对于性能的影响"></a>内存对于性能的影响</h2><p>首先 Reclaiming 内存是需要时间的，突然的大量内存需求是会影响响应的。</p>
<h1 id="如何预防这些性能问题，需要刻意预防么"><a href="#如何预防这些性能问题，需要刻意预防么" class="headerlink" title="如何预防这些性能问题，需要刻意预防么"></a>如何预防这些性能问题，需要刻意预防么</h1><p>坚持下面几个原则争取在编码阶段避免一些性能问题。</p>
<ul>
<li>优化计算的复杂度从而减少 CPU 的使用</li>
<li>在应用响应交互的时候停止没必要的任务处理</li>
<li>设置合适的 QoS</li>
<li>将定时器任务合并，让 CPU 更多时候处于 idle 状态</li>
</ul>
<p>那么如果写需求时来不及注意这些问题做不到预防的话，可以通过自动化代码检查的方式来避免这些问题吗？</p>
<h1 id="如何检查"><a href="#如何检查" class="headerlink" title="如何检查"></a>如何检查</h1><p>根据这些问题在代码里查，写工具或用工具自动化查？虽然可以，但是需要考虑的情况太多，现有工具支持不好，自己写需要考虑的点太多需要花费太长的时间，那么什么方式会比较好呢？</p>
<h1 id="通过监听主线程方式来监察"><a href="#通过监听主线程方式来监察" class="headerlink" title="通过监听主线程方式来监察"></a>通过监听主线程方式来监察</h1><p>首先用 CFRunLoopObserverCreate 创建一个观察者里面接受 CFRunLoopActivity 的回调，然后用 CFRunLoopAddObserver 将观察者添加到 CFRunLoopGetMain() 主线程 Runloop 的 kCFRunLoopCommonModes 模式下进行观察。</p>
<p>接下来创建一个子线程来进行监控，使用 dispatch_semaphore_wait 定义区间时间，标准是 16 或 20 微秒一次监控的话基本可以把影响响应的都找出来。监控结果的标准是根据两个 Runloop 的状态 BeforeSources 和 AfterWaiting 在区间时间是否能检测到来判断是否卡顿。</p>
<h1 id="如何打印堆栈信息，保存现场"><a href="#如何打印堆栈信息，保存现场" class="headerlink" title="如何打印堆栈信息，保存现场"></a>如何打印堆栈信息，保存现场</h1><p>打印堆栈整体思路是获取线程的信息得到线程的 state 从而得到线程里所有栈的指针，根据这些指针在 符号表里找到对应的描述即符号化解析，这样就能够展示出可读的堆栈信息。具体实现是怎样的呢？下面详细说说：</p>
<h2 id="获取线程的信息"><a href="#获取线程的信息" class="headerlink" title="获取线程的信息"></a>获取线程的信息</h2><p>这里首先是要通过 task_threads 取到所有的线程，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">thread_act_array_t</span> threads; <span class="comment">//int 组成的数组比如 thread[1] = 5635</span></div><div class="line"><span class="keyword">mach_msg_type_number_t</span> thread_count = <span class="number">0</span>; <span class="comment">//mach_msg_type_number_t 是 int 类型</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">task_t</span> this_task = mach_task_self(); <span class="comment">//int</span></div><div class="line"><span class="comment">//根据当前 task 获取所有线程</span></div><div class="line"><span class="keyword">kern_return_t</span> kr = task_threads(this_task, &amp;threads, &amp;thread_count);</div></pre></td></tr></table></figure></p>
<p>遍历时通过 thread_info 获取各个线程的详细信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">SMThreadInfoStruct threadInfoSt = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">thread_info_data_t</span> threadInfo;</div><div class="line"><span class="keyword">thread_basic_info_t</span> threadBasicInfo;</div><div class="line"><span class="keyword">mach_msg_type_number_t</span> threadInfoCount = THREAD_INFO_MAX;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (thread_info((<span class="keyword">thread_act_t</span>)thread, THREAD_BASIC_INFO, (<span class="keyword">thread_info_t</span>)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) &#123;</div><div class="line">    threadBasicInfo = (<span class="keyword">thread_basic_info_t</span>)threadInfo;</div><div class="line">    <span class="keyword">if</span> (!(threadBasicInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</div><div class="line">        threadInfoSt.cpuUsage = threadBasicInfo-&gt;cpu_usage / <span class="number">10</span>;</div><div class="line">        threadInfoSt.userTime = threadBasicInfo-&gt;system_time.microseconds;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">uintptr_t</span> buffer[<span class="number">100</span>];</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">NSMutableString *reStr = [NSMutableString stringWithFormat:@<span class="string">"Stack of thread: %u:\n CPU used: %.1f percent\n user time: %d second\n"</span>, thread, threadInfoSt.cpuUsage, threadInfoSt.userTime];</div></pre></td></tr></table></figure></p>
<h2 id="获取线程里所有栈的信息"><a href="#获取线程里所有栈的信息" class="headerlink" title="获取线程里所有栈的信息"></a>获取线程里所有栈的信息</h2><p>可以通过 thread_get_state 得到 machine context 里面包含了线程栈里所有的栈指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_STRUCT_MCONTEXT machineContext; <span class="comment">//线程栈里所有的栈指针</span></div><div class="line"><span class="comment">//通过 thread_get_state 获取完整的 machineContext 信息，包含 thread 状态信息</span></div><div class="line"><span class="keyword">mach_msg_type_number_t</span> state_count = smThreadStateCountByCPU();</div><div class="line"><span class="keyword">kern_return_t</span> kr = thread_get_state(thread, smThreadStateByCPU(), (<span class="keyword">thread_state_t</span>)&amp;machineContext.__ss, &amp;state_count);</div></pre></td></tr></table></figure></p>
<p>创建一个栈结构体用来保存栈的数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为通用回溯设计结构支持栈地址由小到大，地址里存储上个栈指针的地址</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SMStackFrame</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">SMStackFrame</span> *<span class="title">const</span> <span class="title">previous</span>;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uintptr_t</span> return_address;</div><div class="line">&#125; SMStackFrame;</div><div class="line"></div><div class="line">SMStackFrame stackFrame = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="comment">//通过栈基址指针获取当前栈帧地址</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uintptr_t</span> framePointer = smMachStackBasePointerByCPU(&amp;machineContext);</div><div class="line"><span class="keyword">if</span> (framePointer == <span class="number">0</span> || smMemCopySafely((<span class="keyword">void</span> *)framePointer, &amp;stackFrame, <span class="keyword">sizeof</span>(stackFrame)) != KERN_SUCCESS) &#123;</div><div class="line">    <span class="keyword">return</span> @<span class="string">"Fail frame pointer"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (; i &lt; <span class="number">32</span>; i++) &#123;</div><div class="line">    buffer[i] = stackFrame.return_address;</div><div class="line">    <span class="keyword">if</span> (buffer[i] == <span class="number">0</span> || stackFrame.previous == <span class="number">0</span> || smMemCopySafely(stackFrame.previous, &amp;stackFrame, <span class="keyword">sizeof</span>(stackFrame)) != KERN_SUCCESS) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h2><p>符号化主要思想就是通过栈指针地址减去 Slide 地址得到 ASLR 偏移量，通过这个偏移量可以在 __LINKEDIT segment 查找到字符串和符号表的位置。具体代码实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">info-&gt;dli_fname = <span class="literal">NULL</span>;</div><div class="line">info-&gt;dli_fbase = <span class="literal">NULL</span>;</div><div class="line">info-&gt;dli_sname = <span class="literal">NULL</span>;</div><div class="line">info-&gt;dli_saddr = <span class="literal">NULL</span>;</div><div class="line"><span class="comment">//根据地址获取是哪个 image</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> idx = smDyldImageIndexFromAddress(address);</div><div class="line"><span class="keyword">if</span> (idx == UINT_MAX) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> Header</div><div class="line"> ------------------</div><div class="line"> Load commands</div><div class="line"> Segment command 1 -------------|</div><div class="line"> Segment command 2              |</div><div class="line"> ------------------             |</div><div class="line"> Data                           |</div><div class="line"> Section 1 data |segment 1 &lt;----|</div><div class="line"> Section 2 data |          &lt;----|</div><div class="line"> Section 3 data |          &lt;----|</div><div class="line"> Section 4 data |segment 2</div><div class="line"> Section 5 data |</div><div class="line"> ...            |</div><div class="line"> Section n data |</div><div class="line"> */</div><div class="line"><span class="comment">/*----------Mach Header---------*/</span></div><div class="line"><span class="comment">//根据 image 的序号获取 mach_header</span></div><div class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>* <span class="title">machHeader</span> = _<span class="title">dyld_get_image_header</span>(<span class="title">idx</span>);</span></div><div class="line"><span class="comment">//返回 image_index 索引的 image 的虚拟内存地址 slide 的数量，如果 image_index 超出范围返回0</span></div><div class="line"><span class="comment">//动态链接器加载 image 时，image 必须映射到未占用地址的进程的虚拟地址空间。动态链接器通过添加一个值到 image 的基地址来实现，这个值是虚拟内存 slide 数量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uintptr_t</span> imageVMAddressSlide = (<span class="keyword">uintptr_t</span>)_dyld_get_image_vmaddr_slide(idx);</div><div class="line"><span class="comment">/*-----------ASLR 的偏移量---------*/</span></div><div class="line"><span class="comment">//https://en.wikipedia.org/wiki/Address_space_layout_randomization</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uintptr_t</span> addressWithSlide = address - imageVMAddressSlide;</div><div class="line"><span class="comment">//根据 Image 的 Index 来获取 segment 的基地址</span></div><div class="line"><span class="comment">//段定义Mach-O文件中的字节范围以及动态链接器加载应用程序时这些字节映射到虚拟内存中的地址和内存保护属性。 因此，段总是虚拟内存页对齐。 片段包含零个或多个节。</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uintptr_t</span> segmentBase = smSegmentBaseOfImageIndex(idx) + imageVMAddressSlide;</div><div class="line"><span class="keyword">if</span> (segmentBase == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">info-&gt;dli_fname = _dyld_get_image_name(idx);</div><div class="line">info-&gt;dli_fbase = (<span class="keyword">void</span>*)machHeader;</div><div class="line"></div><div class="line"><span class="comment">/*--------------Mach Segment-------------*/</span></div><div class="line"><span class="comment">//地址最匹配的symbol</span></div><div class="line"><span class="keyword">const</span> nlistByCPU* bestMatch = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">uintptr_t</span> bestDistance = ULONG_MAX;</div><div class="line"><span class="keyword">uintptr_t</span> cmdPointer = smCmdFirstPointerFromMachHeader(machHeader);</div><div class="line"><span class="keyword">if</span> (cmdPointer == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//遍历每个 segment 判断目标地址是否落在该 segment 包含的范围里</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> iCmd = <span class="number">0</span>; iCmd &lt; machHeader-&gt;ncmds; iCmd++) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">loadCmd</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)<span class="title">cmdPointer</span>;</span></div><div class="line">    <span class="comment">/*----------目标 Image 的符号表----------*/</span></div><div class="line">    <span class="comment">//Segment 除了 __TEXT 和 __DATA 外还有 __LINKEDIT segment，它里面包含动态链接器的使用的原始数据，比如符号，字符串和重定位表项。</span></div><div class="line">    <span class="comment">//LC_SYMTAB 描述了 __LINKEDIT segment 内查找字符串和符号表的位置</span></div><div class="line">    <span class="keyword">if</span> (loadCmd-&gt;cmd == LC_SYMTAB) &#123;</div><div class="line">        <span class="comment">//获取字符串和符号表的虚拟内存偏移量。</span></div><div class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtabCmd</span> = (<span class="title">struct</span> <span class="title">symtab_command</span>*)<span class="title">cmdPointer</span>;</span></div><div class="line">        <span class="keyword">const</span> nlistByCPU* symbolTable = (nlistByCPU*)(segmentBase + symtabCmd-&gt;symoff);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">uintptr_t</span> stringTable = segmentBase + symtabCmd-&gt;stroff;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> iSym = <span class="number">0</span>; iSym &lt; symtabCmd-&gt;nsyms; iSym++) &#123;</div><div class="line">            <span class="comment">//如果 n_value 是0，symbol 指向外部对象</span></div><div class="line">            <span class="keyword">if</span> (symbolTable[iSym].n_value != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//给定的偏移量是文件偏移量，减去 __LINKEDIT segment 的文件偏移量获得字符串和符号表的虚拟内存偏移量</span></div><div class="line">                <span class="keyword">uintptr_t</span> symbolBase = symbolTable[iSym].n_value;</div><div class="line">                <span class="keyword">uintptr_t</span> currentDistance = addressWithSlide - symbolBase;</div><div class="line">                <span class="comment">//寻找最小的距离 bestDistance，因为 addressWithSlide 是某个方法的指令地址，要大于这个方法的入口。</span></div><div class="line">                <span class="comment">//离 addressWithSlide 越近的函数入口越匹配</span></div><div class="line">                <span class="keyword">if</span> ((addressWithSlide &gt;= symbolBase) &amp;&amp; (currentDistance &lt;= bestDistance)) &#123;</div><div class="line">                    bestMatch = symbolTable + iSym;</div><div class="line">                    bestDistance = currentDistance;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (bestMatch != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">//将虚拟内存偏移量添加到 __LINKEDIT segment 的虚拟内存地址可以提供字符串和符号表的内存 address。</span></div><div class="line">            info-&gt;dli_saddr = (<span class="keyword">void</span>*)(bestMatch-&gt;n_value + imageVMAddressSlide);</div><div class="line">            info-&gt;dli_sname = (<span class="keyword">char</span>*)((<span class="keyword">intptr_t</span>)stringTable + (<span class="keyword">intptr_t</span>)bestMatch-&gt;n_un.n_strx);</div><div class="line">            <span class="keyword">if</span> (*info-&gt;dli_sname == <span class="string">'_'</span>) &#123;</div><div class="line">                info-&gt;dli_sname++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//所有的 symbols 的已经被处理好了</span></div><div class="line">            <span class="keyword">if</span> (info-&gt;dli_saddr == info-&gt;dli_fbase &amp;&amp; bestMatch-&gt;n_type == <span class="number">3</span>) &#123;</div><div class="line">                info-&gt;dli_sname = <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cmdPointer += loadCmd-&gt;cmdsize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>需要注意的是这个程序有消耗性能的地方 thread get state。这个也会被监控检查出，所以可以过滤掉这样的堆栈信息。</p>
<h1 id="能够获取更多信息的方法"><a href="#能够获取更多信息的方法" class="headerlink" title="能够获取更多信息的方法"></a>能够获取更多信息的方法</h1><p>获取更多信息比如全层级方法调用和每个方法消耗的时间，那么这样做的好处在哪呢？</p>
<p>可以更细化的测量时间消耗，找到耗时方法，更快的交互操作能使用户体验更好，下面是一些可以去衡量的场景：</p>
<ul>
<li>响应能力</li>
<li>按钮点击</li>
<li>手势操作</li>
<li>Tab 切换</li>
<li>vc 的切换和转场</li>
</ul>
<p>可以给优化定个目标，比如滚动和动画达到 60fps，响应用户操作在 100ms 内完成。然后逐个检测出来 fix 掉。</p>
<p>如何获取到更多信息呢？</p>
<p>通过 hook objc_msgSend 方法能够获取所有被调用的方法，记录深度就能够得到方法调用的树状结构，通过执行前后时间的记录能够得到每个方法的耗时，这样就能获取一份完整的性能消耗信息了。</p>
<p>hook c 函数可以使用 facebook 的 <a href="https://github.com/facebook/fishhook" target="_blank" rel="external">fishhook</a>， 获取方法调用树状结构可以使用 <a href="https://github.com/DavidGoldman/InspectiveC" target="_blank" rel="external">InspectiveC</a>，下面对于他们的实现详细介绍一下：</p>
<h2 id="获取方法调用树结构"><a href="#获取方法调用树结构" class="headerlink" title="获取方法调用树结构"></a>获取方法调用树结构</h2><p>首先设计两个结构体，CallRecord 记录调用方法详细信息，包括 obj 和 SEL 等，ThreadCallStack 里面需要用 index 记录当前调用方法树的深度。有了 SEL 再通过 NSStringFromSelector 就能够取得方法名，有了 obj 通过 object_getClass 能够得到 Class 再用 NSStringFromClass 就能够获得类名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Shared structures.</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CallRecord_</span> &#123;</span></div><div class="line">  id obj;   <span class="comment">//通过 object_getClass 能够得到 Class 再通过 NSStringFromClass 能够得到类名</span></div><div class="line">  SEL _cmd; <span class="comment">//通过 NSStringFromSelector 方法能够得到方法名</span></div><div class="line">  <span class="keyword">uintptr_t</span> lr;</div><div class="line">  <span class="keyword">int</span> prevHitIndex;</div><div class="line">  <span class="keyword">char</span> isWatchHit;</div><div class="line">&#125; CallRecord;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadCallStack_</span> &#123;</span></div><div class="line">  FILE *file;</div><div class="line">  <span class="keyword">char</span> *spacesStr;</div><div class="line">  CallRecord *<span class="built_in">stack</span>;</div><div class="line">  <span class="keyword">int</span> allocatedLength;</div><div class="line">  <span class="keyword">int</span> index; <span class="comment">//index 记录当前调用方法树的深度</span></div><div class="line">  <span class="keyword">int</span> numWatchHits;</div><div class="line">  <span class="keyword">int</span> lastPrintedIndex;</div><div class="line">  <span class="keyword">int</span> lastHitIndex;</div><div class="line">  <span class="keyword">char</span> isLoggingEnabled;</div><div class="line">  <span class="keyword">char</span> isCompleteLoggingEnabled;</div><div class="line">&#125; ThreadCallStack;</div></pre></td></tr></table></figure></p>
<h2 id="存储读取-ThreadCallStack"><a href="#存储读取-ThreadCallStack" class="headerlink" title="存储读取 ThreadCallStack"></a>存储读取 ThreadCallStack</h2><p>pthread_setspecific() 可以将私有数据设置在指定线程上，pthread_getspecific() 用来读取这个私有数据，利用这个特性可以就可以将 ThreadCallStack 的数据和该线程绑定在一起，随时进行数据的存取。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> ThreadCallStack * <span class="title">getThreadCallStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  ThreadCallStack *cs = (ThreadCallStack *)pthread_getspecific(threadKey); <span class="comment">//读取</span></div><div class="line">  <span class="keyword">if</span> (cs == <span class="literal">NULL</span>) &#123;</div><div class="line">    cs = (ThreadCallStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadCallStack));</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAIN_THREAD_ONLY</span></div><div class="line">    cs-&gt;file = (pthread_main_np()) ? newFileForThread() : <span class="literal">NULL</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    cs-&gt;file = newFileForThread();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    cs-&gt;isLoggingEnabled = (cs-&gt;file != <span class="literal">NULL</span>);</div><div class="line">    cs-&gt;isCompleteLoggingEnabled = <span class="number">0</span>;</div><div class="line">    cs-&gt;spacesStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(DEFAULT_CALLSTACK_DEPTH + <span class="number">1</span>);</div><div class="line">    <span class="built_in">memset</span>(cs-&gt;spacesStr, <span class="string">' '</span>, DEFAULT_CALLSTACK_DEPTH);</div><div class="line">    cs-&gt;spacesStr[DEFAULT_CALLSTACK_DEPTH] = <span class="string">'\0'</span>;</div><div class="line">    cs-&gt;<span class="built_in">stack</span> = (CallRecord *)<span class="built_in">calloc</span>(DEFAULT_CALLSTACK_DEPTH, <span class="keyword">sizeof</span>(CallRecord)); <span class="comment">//分配 CallRecord 默认空间</span></div><div class="line">    cs-&gt;allocatedLength = DEFAULT_CALLSTACK_DEPTH;</div><div class="line">    cs-&gt;index = cs-&gt;lastPrintedIndex = cs-&gt;lastHitIndex = <span class="number">-1</span>;</div><div class="line">    cs-&gt;numWatchHits = <span class="number">0</span>;</div><div class="line">    pthread_setspecific(threadKey, cs); <span class="comment">//保存数据</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="记录方法调用深度"><a href="#记录方法调用深度" class="headerlink" title="记录方法调用深度"></a>记录方法调用深度</h2><p>因为要记录深度，而一个方法的调用里会有更多的方法调用，所以方法的调用写两个方法分别记录开始 pushCallRecord 和记录结束的时刻 popCallRecord，这样才能够通过在开始时对深度加一在结束时减一。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开始时</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushCallRecord</span><span class="params">(id obj, <span class="keyword">uintptr_t</span> lr, SEL _cmd, ThreadCallStack *cs)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> nextIndex = (++cs-&gt;index); <span class="comment">//增加深度</span></div><div class="line">  <span class="keyword">if</span> (nextIndex &gt;= cs-&gt;allocatedLength) &#123;</div><div class="line">    cs-&gt;allocatedLength += CALLSTACK_DEPTH_INCREMENT;</div><div class="line">    cs-&gt;<span class="built_in">stack</span> = (CallRecord *)<span class="built_in">realloc</span>(cs-&gt;<span class="built_in">stack</span>, cs-&gt;allocatedLength * <span class="keyword">sizeof</span>(CallRecord));</div><div class="line">    cs-&gt;spacesStr = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(cs-&gt;spacesStr, cs-&gt;allocatedLength + <span class="number">1</span>);</div><div class="line">    <span class="built_in">memset</span>(cs-&gt;spacesStr, <span class="string">' '</span>, cs-&gt;allocatedLength);</div><div class="line">    cs-&gt;spacesStr[cs-&gt;allocatedLength] = <span class="string">'\0'</span>;</div><div class="line">  &#125;</div><div class="line">  CallRecord *newRecord = &amp;cs-&gt;<span class="built_in">stack</span>[nextIndex];</div><div class="line">  newRecord-&gt;obj = obj;</div><div class="line">  newRecord-&gt;_cmd = _cmd;</div><div class="line">  newRecord-&gt;lr = lr;</div><div class="line">  newRecord-&gt;isWatchHit = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结束时</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> CallRecord * <span class="title">popCallRecord</span><span class="params">(ThreadCallStack *cs)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> &amp;cs-&gt;<span class="built_in">stack</span>[cs-&gt;index--]; <span class="comment">//减少深度</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="在-objc-msgSend-前后插入执行方法"><a href="#在-objc-msgSend-前后插入执行方法" class="headerlink" title="在 objc_msgSend 前后插入执行方法"></a>在 objc_msgSend 前后插入执行方法</h2><p>最后是 hook objc_msgSend 需要在调用前和调用后分别加入 pushCallRecord 和 popCallRecord。因为需要在调用后这个时机插入一个方法，而且不可能编写一个保留未知参数并跳转到 c 中任意函数指针的函数，那么这就需要用到汇编来做到。</p>
<p>下面针对 arm64 进行分析，arm64 有31个64 bit 的整数型寄存器，用 x0 到 x30 表示，主要思路就是先入栈参数，参数寄存器是 x0 - x7，对于objc_msgSend方法来说 x0 第一个参数是传入对象，x1 第二个参数是选择器 _cmd。 syscall 的 number 会放到 x8 里。然后交换寄存器中，将用于返回的寄存器 lr 移到 x1 里。先让 pushCallRecord 能够执行，再执行原始的 objc_msgSend，保存返回值，最后让 popCallRecord 能执行。具体代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replacementObjc_msgSend</span><span class="params">()</span> </span>&#123;</div><div class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(</span></span></div><div class="line">    <span class="comment">// sp 是堆栈寄存器，存放栈的偏移地址，每次都指向栈顶。</span></div><div class="line">    <span class="comment">// 保存 &#123;q0-q7&#125; 偏移地址到 sp 寄存器</span></div><div class="line">      <span class="string">"stp q6, q7, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q4, q5, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q2, q3, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q0, q1, [sp, #-32]!\n"</span></div><div class="line">    <span class="comment">// 保存 &#123;x0-x8, lr&#125;</span></div><div class="line">      <span class="string">"stp x8, lr, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x6, x7, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x4, x5, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x2, x3, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x0, x1, [sp, #-16]!\n"</span></div><div class="line">    <span class="comment">// 交换参数.</span></div><div class="line">      <span class="string">"mov x2, x1\n"</span></div><div class="line">      <span class="string">"mov x1, lr\n"</span></div><div class="line">      <span class="string">"mov x3, sp\n"</span></div><div class="line">    <span class="comment">// 调用 preObjc_msgSend，使用 bl label 语法。bl 执行一个分支链接操作，label 是无条件分支的，是和本指令的地址偏移，范围是 -128MB 到 +128MB</span></div><div class="line">      <span class="string">"bl __Z15preObjc_msgSendP11objc_objectmP13objc_selectorP9RegState_\n"</span></div><div class="line">      <span class="string">"mov x9, x0\n"</span></div><div class="line">      <span class="string">"mov x10, x1\n"</span></div><div class="line">      <span class="string">"tst x10, x10\n"</span></div><div class="line">    <span class="comment">// 读取 &#123;x0-x8, lr&#125; 从保存到 sp 栈顶的偏移地址读起</span></div><div class="line">      <span class="string">"ldp x0, x1, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x2, x3, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x4, x5, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x6, x7, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x8, lr, [sp], #16\n"</span></div><div class="line">    <span class="comment">// 读取 &#123;q0-q7&#125;</span></div><div class="line">      <span class="string">"ldp q0, q1, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q2, q3, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q4, q5, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q6, q7, [sp], #32\n"</span></div><div class="line">      <span class="string">"b.eq Lpassthrough\n"</span></div><div class="line">    <span class="comment">// 调用原始 objc_msgSend。使用 blr xn 语法。blr 除了从指定寄存器读取新的 PC 值外效果和 bl 一样。xn 是通用寄存器的64位名称分支地址，范围0到31</span></div><div class="line">      <span class="string">"blr x9\n"</span></div><div class="line">    <span class="comment">// 保存 &#123;x0-x9&#125;</span></div><div class="line">      <span class="string">"stp x0, x1, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x2, x3, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x4, x5, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x6, x7, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x8, x9, [sp, #-16]!\n"</span></div><div class="line">    <span class="comment">// 保存 &#123;q0-q7&#125;</span></div><div class="line">      <span class="string">"stp q0, q1, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q2, q3, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q4, q5, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q6, q7, [sp, #-32]!\n"</span></div><div class="line">    <span class="comment">// 调用 postObjc_msgSend hook.</span></div><div class="line">      <span class="string">"bl __Z16postObjc_msgSendv\n"</span></div><div class="line">      <span class="string">"mov lr, x0\n"</span></div><div class="line">    <span class="comment">// 读取 &#123;q0-q7&#125;</span></div><div class="line">      <span class="string">"ldp q6, q7, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q4, q5, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q2, q3, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q0, q1, [sp], #32\n"</span></div><div class="line">    <span class="comment">// 读取 &#123;x0-x9&#125;</span></div><div class="line">      <span class="string">"ldp x8, x9, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x6, x7, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x4, x5, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x2, x3, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x0, x1, [sp], #16\n"</span></div><div class="line">      <span class="string">"ret\n"</span></div><div class="line">      <span class="string">"Lpassthrough:\n"</span></div><div class="line">    <span class="comment">// br 无条件分支到寄存器中的地址</span></div><div class="line">      <span class="string">"br x9"</span></div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="记录时间的方法"><a href="#记录时间的方法" class="headerlink" title="记录时间的方法"></a>记录时间的方法</h2><p>为了记录耗时，这样就需要在 pushCallRecord 和 popCallRecord 里记录下时间。下面列出一些计算一段代码开始到结束的时间的方法</p>
<p>第一种： NSDate 微秒<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDate</span>* tmpStartData = [<span class="built_in">NSDate</span> date];</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line"><span class="keyword">double</span> deltaTime = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:tmpStartData];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cost time: %f s"</span>, deltaTime);</div></pre></td></tr></table></figure></p>
<p>第二种：clock_t 微秒clock_t计时所表示的是占用CPU的时钟单元<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">clock_t start = clock();</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line">clock_t end = clock();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cost time: %f s"</span>, (<span class="keyword">double</span>)(end - start)/<span class="built_in">CLOCKS_PER_SEC</span>);</div></pre></td></tr></table></figure></p>
<p>第三种：CFAbsoluteTime 微秒<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFAbsoluteTime</span> start = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line"><span class="built_in">CFAbsoluteTime</span> end = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cost time = %f s"</span>, end - start); <span class="comment">//s</span></div></pre></td></tr></table></figure></p>
<p>第四种：CFTimeInterval 纳秒<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFTimeInterval</span> start = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line"><span class="built_in">CFTimeInterval</span> end = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cost time: %f s"</span>, end - start);</div><div class="line">```第五种：mach_absolute_time 纳秒</div><div class="line">```objc</div><div class="line">uint64_t start = mach_absolute_time ();</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line">uint64_t end = mach_absolute_time ();</div><div class="line">uint64_t elapsed = <span class="number">1e-9</span> *(end - start);</div></pre></td></tr></table></figure></p>
<p>最后两种可用，本质区别<br>NSDate 或 CFAbsoluteTimeGetCurrent() 返回的时钟时间将会会网络时间同步，从时钟 偏移量的角度。mach_absolute_time() 和 CACurrentMediaTime() 是基于内建时钟的。选择一种，加到 pushCallRecord 和 popCallRecord 里，相减就能够获得耗时。</p>
<h1 id="如何-hook-msgsend-方法"><a href="#如何-hook-msgsend-方法" class="headerlink" title="如何 hook msgsend 方法"></a>如何 hook msgsend 方法</h1><p>那么 objc_msgSend 这个 c 方法是如何 hook 到的呢。首先了解下 dyld 是通过更新 Mach-O 二进制的 __DATA segment 特定的部分中的指针来邦定 lazy 和 non-lazy 符号，通过确认传递给 rebind_symbol 里每个符号名称更新的位置就可以找出对应替换来重新绑定这些符号。下面针对关键代码进行分析：</p>
<h2 id="遍历-dyld"><a href="#遍历-dyld" class="headerlink" title="遍历 dyld"></a>遍历 dyld</h2><p>首先是遍历 dyld 里的所有的 image，取出 image header 和 slide。注意第一次调用时主要注册 callback。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</div><div class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</div><div class="line">        _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="找出符号表相关-Command"><a href="#找出符号表相关-Command" class="headerlink" title="找出符号表相关 Command"></a>找出符号表相关 Command</h2><p>接下来需要找到符号表相关的 command，包括 linkedit segment command，symtab command 和 dysymtab command。方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">segment_command_t</span> *cur_seg_cmd;</div><div class="line"><span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></div><div class="line"></div><div class="line"><span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</div><div class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</div><div class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</div><div class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</div><div class="line">            linkedit_segment = cur_seg_cmd;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</div><div class="line">        symtab_cmd = (struct symtab_command*)cur_seg_cmd;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</div><div class="line">        dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="获得-base-和-indirect-符号表"><a href="#获得-base-和-indirect-符号表" class="headerlink" title="获得 base 和 indirect 符号表"></a>获得 base 和 indirect 符号表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Find base symbol/string table addresses</span></div><div class="line"><span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</div><div class="line"><span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</div><div class="line"><span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</div><div class="line"></div><div class="line"><span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></div><div class="line"><span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</div></pre></td></tr></table></figure>
<h2 id="进行方法替换"><a href="#进行方法替换" class="headerlink" title="进行方法替换"></a>进行方法替换</h2><p>有了符号表和传入的方法替换数组就可以进行符号表访问指针地址的替换，具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</div><div class="line"><span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</div><div class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</div><div class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</div><div class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</div><div class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</div><div class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</div><div class="line">    <span class="keyword">if</span> (strnlen(symbol_name, <span class="number">2</span>) &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></div><div class="line">    <span class="keyword">while</span> (cur) &#123;</div><div class="line">        <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</div><div class="line">                    indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</div><div class="line">                    *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</div><div class="line">                &#125;</div><div class="line">                indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</div><div class="line">                <span class="keyword">goto</span> symbol_loop;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cur = cur-&gt;next;</div><div class="line">    &#125;</div><div class="line">symbol_loop:;</div></pre></td></tr></table></figure></p>
<h1 id="统计方法调用频次"><a href="#统计方法调用频次" class="headerlink" title="统计方法调用频次"></a>统计方法调用频次</h1><p>在一些应用场景会有一些频繁的方法调用，有些方法的调用实际上是没有必要的，但是首先是需要将那些频繁调用的方法找出来这样才能够更好的定位到潜在的会造成性能浪费的方法使用。这些频繁调用的方法要怎么找呢？</p>
<p>大致的思路是这样，基于上面章节提到的记录方法调用深度的方案，将每个调用方法的路径保存住，调用相同路径的相同方法调用一次加一记录在数据库中，最后做一个视图按照调用次数的排序即可找到调用频繁的那些方法。下图是完成后展示的效果：</p>
<p><img src="/uploads/deeply-ios-performance-optimization/07.PNG" alt=""></p>
<p>接下来看看具体实现方式</p>
<h2 id="设计方法调用频次记录的结构"><a href="#设计方法调用频次记录的结构" class="headerlink" title="设计方法调用频次记录的结构"></a>设计方法调用频次记录的结构</h2><p>在先前时间消耗的 model 基础上增加路径，频次等信息<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *className;       <span class="comment">//类名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *methodName;      <span class="comment">//方法名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isClassMethod;        <span class="comment">//是否是类方法</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeCost;   <span class="comment">//时间消耗</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> callDepth;      <span class="comment">//Call 层级</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *path;              <span class="comment">//路径</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> lastCall;             <span class="comment">//是否是最后一个 Call</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> frequency;      <span class="comment">//访问频次</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;SMCallTraceTimeCostModel *&gt; *subCosts;</div></pre></td></tr></table></figure></p>
<h2 id="拼装方法路径"><a href="#拼装方法路径" class="headerlink" title="拼装方法路径"></a>拼装方法路径</h2><p>在遍历 SMCallTrace 记录的方法 model 和 遍历方法子方法时将路径拼装好，记录到数据库中<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (SMCallTraceTimeCostModel *model <span class="keyword">in</span> arr) &#123;</div><div class="line">    <span class="comment">//记录方法路径</span></div><div class="line">    model.path = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"[%@ %@]"</span>,model.className,model.methodName];</div><div class="line">    [<span class="keyword">self</span> appendRecord:model to:mStr];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)appendRecord:(SMCallTraceTimeCostModel *)cost to:(<span class="built_in">NSMutableString</span> *)mStr &#123;</div><div class="line">    [mStr appendFormat:<span class="string">@"%@\n path%@\n"</span>,[cost des],cost.path];</div><div class="line">    <span class="keyword">if</span> (cost.subCosts.count &lt; <span class="number">1</span>) &#123;</div><div class="line">        cost.lastCall = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//记录到数据库中</span></div><div class="line">    [[[SMLagDB shareInstance] increaseWithClsCallModel:cost] subscribeNext:^(<span class="keyword">id</span> x) &#123;&#125;];</div><div class="line">    <span class="keyword">for</span> (SMCallTraceTimeCostModel *model <span class="keyword">in</span> cost.subCosts) &#123;</div><div class="line">        <span class="comment">//记录方法的子方法的路径</span></div><div class="line">        model.path = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ - [%@ %@]"</span>,cost.path,model.className,model.methodName];</div><div class="line">        [<span class="keyword">self</span> appendRecord:model to:mStr];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="记录方法调用频次数据库"><a href="#记录方法调用频次数据库" class="headerlink" title="记录方法调用频次数据库"></a>记录方法调用频次数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>这里的 lastcall 是记录是否是最后一个方法的调用，展示时只取最后一个方法即可，因为也会有完整路径可以知道父方法和来源方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">_clsCallDBPath = [PATH_OF_DOCUMENT stringByAppendingPathComponent:<span class="string">@"clsCall.sqlite"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:_clsCallDBPath] == <span class="literal">NO</span>) &#123;</div><div class="line">    FMDatabase *db = [FMDatabase databaseWithPath:_clsCallDBPath];</div><div class="line">    <span class="keyword">if</span> ([db open]) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         cid: 主id</div><div class="line">         fid: 父id 暂时不用</div><div class="line">         cls: 类名</div><div class="line">         mtd: 方法名</div><div class="line">         path: 完整路径标识</div><div class="line">         timecost: 方法消耗时长</div><div class="line">         calldepth: 层级</div><div class="line">         frequency: 调用次数</div><div class="line">         lastcall: 是否是最后一个 call</div><div class="line">         */</div><div class="line">        <span class="built_in">NSString</span> *createSql = <span class="string">@"create table clscall (cid INTEGER PRIMARY KEY AUTOINCREMENT  NOT NULL, fid integer, cls text, mtd text, path text, timecost integer, calldepth integer, frequency integer, lastcall integer)"</span>;</div><div class="line">        [db executeUpdate:createSql];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h3><p>添加记录时需要先检查数据库里是否有相同路径的同一个方法调用，这样可以给 frequency 字段加一已达到记录频次的目的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">FMResultSet *rsl = [db executeQuery:<span class="string">@"select cid,frequency from clscall where path = ?"</span>, model.path];</div><div class="line"><span class="keyword">if</span> ([rsl next]) &#123;</div><div class="line">    <span class="comment">//有相同路径就更新路径访问频率</span></div><div class="line">    <span class="keyword">int</span> fq = [rsl intForColumn:<span class="string">@"frequency"</span>] + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> cid = [rsl intForColumn:<span class="string">@"cid"</span>];</div><div class="line">    [db executeUpdate:<span class="string">@"update clscall set frequency = ? where cid = ?"</span>, @(fq), @(cid)];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//没有就添加一条记录</span></div><div class="line">    <span class="built_in">NSNumber</span> *lastCall = @<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (model.lastCall) &#123;</div><div class="line">        lastCall = @<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    [db executeUpdate:<span class="string">@"insert into clscall (cls, mtd, path, timecost, calldepth, frequency, lastcall) values (?, ?, ?, ?, ?, ?, ?)"</span>, model.className, model.methodName, model.path, @(model.timeCost), @(model.callDepth), @<span class="number">1</span>, lastCall];</div><div class="line">&#125;</div><div class="line">[db close];</div><div class="line">[subscriber sendCompleted];</div></pre></td></tr></table></figure></p>
<h3 id="检索记录"><a href="#检索记录" class="headerlink" title="检索记录"></a>检索记录</h3><p>检索时注意按照调用频次字段进行排序即可。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FMResultSet *rs = [db executeQuery:<span class="string">@"select * from clscall where lastcall=? order by frequency desc limit ?, 50"</span>,@<span class="number">1</span>, @(page * <span class="number">50</span>)];</div><div class="line"><span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line"><span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">    SMCallTraceTimeCostModel *model = [<span class="keyword">self</span> clsCallModelFromResultSet:rs];</div><div class="line">    [arr addObject:model];</div><div class="line">    count ++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">    [subscriber sendNext:arr];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    [subscriber sendError:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">[subscriber sendCompleted];</div><div class="line">[db close];</div></pre></td></tr></table></figure></p>
<h1 id="找出-CPU-使用大的线程堆栈"><a href="#找出-CPU-使用大的线程堆栈" class="headerlink" title="找出 CPU 使用大的线程堆栈"></a>找出 CPU 使用大的线程堆栈</h1><p>在前面检测卡顿打印的堆栈里提到使用 thread_info 能够获取到各个线程的 cpu 消耗，但是 cpu 不在主线程即使消耗很大也不一定会造成卡顿导致卡顿检测无法检测出更多 cpu 消耗的情况，所以只能通过轮询监控各线程里的 cpu 使用情况，对于超过标准值比如70%的进行记录来跟踪定位出耗电的那些方法。下图是列出 cpu 过载时的堆栈记录的展示效果：</p>
<p><img src="/uploads/deeply-ios-performance-optimization/08.PNG" alt=""></p>
<p>有了前面的基础，实现起来轻松多了<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//轮询检查多个线程 cpu 情况</span></div><div class="line">+ (<span class="keyword">void</span>)updateCPU &#123;</div><div class="line">    thread_act_array_t threads;</div><div class="line">    mach_msg_type_number_t threadCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">const</span> task_t thisTask = mach_task_self();</div><div class="line">    kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);</div><div class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</div><div class="line">        thread_info_data_t threadInfo;</div><div class="line">        thread_basic_info_t threadBaseInfo;</div><div class="line">        mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;</div><div class="line">        <span class="keyword">if</span> (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) &#123;</div><div class="line">            threadBaseInfo = (thread_basic_info_t)threadInfo;</div><div class="line">            <span class="keyword">if</span> (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</div><div class="line">                integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / <span class="number">10</span>;</div><div class="line">                <span class="keyword">if</span> (cpuUsage &gt; <span class="number">70</span>) &#123;</div><div class="line">                    <span class="comment">//cup 消耗大于 70 时打印和记录堆栈</span></div><div class="line">                    <span class="built_in">NSString</span> *reStr = smStackOfThread(threads[i]);</div><div class="line">                    <span class="comment">//记录数据库中</span></div><div class="line">                    [[[SMLagDB shareInstance] increaseWithStackString:reStr] subscribeNext:^(<span class="keyword">id</span> x) &#123;&#125;];</div><div class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"CPU useage overload thread stack：\n%@"</span>,reStr);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>工具已整合到先前做的 <a href="https://github.com/ming1016/DecoupleDemo" target="_blank" rel="external">DecoupleDemo</a> 里。</p>
<ul>
<li>子线程检测主线程卡顿使用的话在需要开始检测的地方添加 [[SMLagMonitor shareInstance] beginMonitor]; 即可。</li>
<li>需要检测所有方法调用的用法就是在需要检测的地方调用 [SMCallTrace start]; 就可以了，不检测打印出结果的话调用 stop 和 save 就好了。这里还可以设置最大深度和最小耗时检测来过滤不需要看到的信息。</li>
<li>方法调用频次使用可以在需要开始统计的地方加上 [SMCallTrace startWithMaxDepth:3]; 记录时使用 [SMCallTrace stopSaveAndClean]; 记录到到数据库中同时清理内存的占用。可以 hook VC 的 viewWillAppear 和 viewWillDisappear，在 appear 时开始记录，在 disappear 时记录到数据库同时清理一次。结果展示的 view controller 是 SMClsCallViewController，push 出来就能够看到列表结果。</li>
</ul>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><h2 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h2><ul>
<li>WWDC 2013 224 Designing Code for Performance</li>
<li>WWDC 2013 408 Optimizing Your Code Using LLVM</li>
<li>WWDC 2013 712 Energy Best Practices</li>
<li>WWDC 2014 710 writing energy efficient code part 1</li>
<li>WWDC 2014 710 writing energy efficient code part 2</li>
<li>WWDC 2015 230 performance on ios and watchos</li>
<li>WWDC 2015 707 achieving allday battery life</li>
<li>WWDC 2015 708 debugging energy issues</li>
<li>WWDC 2015 718 building responsive and efficient apps with gcd</li>
<li>WWDC 2016 406 optimizing app startup time</li>
<li>WWDC 2016 719 optimizing io for performance and battery life</li>
<li>WWDC 2017 238 writing energy efficient apps</li>
<li>WWDC 2017 706 modernizing grand central dispatch usage</li>
</ul>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h1><p>最近我这需要招一名实习生来滴滴和我一起攻克一个工程开发效率的项目，绝对会成就感满满的，有兴趣的可以将简历发我 daiming@didichuxing.com 或者在微博上联系我 @戴铭</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题种类&quot;&gt;&lt;a href=&quot;#问题种类&quot; class=&quot;headerlink&quot; title=&quot;问题种类&quot;&gt;&lt;/a&gt;问题种类&lt;/h1&gt;&lt;h2 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="http://ming1016.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>GMTC 上分享滴滴出行 iOS 端瘦身实践的 Slides</title>
    <link href="http://ming1016.github.io/2017/06/12/gmtc-ios-slimming-practice/"/>
    <id>http://ming1016.github.io/2017/06/12/gmtc-ios-slimming-practice/</id>
    <published>2017-06-12T06:15:06.000Z</published>
    <updated>2017-06-12T06:30:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这次 GMTC 大会上分享了我们在包大小瘦身实践过程中使用的一些方法和遇到的一些问题，会前也有很多朋友咨询过这方面的问题，相信这些经验对大家会有一些帮助，完整的 Slides 我放到了这里 <a href="http://pan.baidu.com/s/1skPAIID" target="_blank" rel="external">http://pan.baidu.com/s/1skPAIID</a> 这次大会其他讲师的 pdf 在 GMTC 官网已经放出 <a href="http://gmtc.geekbang.org/" target="_blank" rel="external">http://gmtc.geekbang.org/</a></p>
<p>下面我提出 Slides 的内容</p>
<p><img src="/uploads/gmtc-ios-slimming-practice/01.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/02.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/03.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/04.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/05.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/06.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/07.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/08.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/09.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/10.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/11.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/12.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/13.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/14.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/15.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/16.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/17.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/18.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/19.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/20.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/21.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/22.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/23.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/24.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/25.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/26.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/27.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/28.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/29.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/30.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/31.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/32.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/33.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/34.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/35.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/36.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/37.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/38.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/39.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/40.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/41.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/42.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/43.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/44.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/45.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/46.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/47.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/48.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/49.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/50.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/51.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/52.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/53.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/54.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/55.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/56.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/57.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/58.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/59.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/60.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/61.jpeg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这次 GMTC 大会上分享了我们在包大小瘦身实践过程中使用的一些方法和遇到的一些问题，会前也有很多朋友咨询过这方面的问题，相信这些经验对大家会有一些帮助，完整的 Slides 我放到了这里 &lt;a href=&quot;http://pan.baidu.com/s/1skPAIID&quot;
    
    </summary>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
  </entry>
  
  <entry>
    <title>atSwift大会上分享《学习iOS编译原理能做哪些有意思的事情》的 Slides</title>
    <link href="http://ming1016.github.io/2017/05/27/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/"/>
    <id>http://ming1016.github.io/2017/05/27/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/</id>
    <published>2017-05-27T09:54:41.000Z</published>
    <updated>2017-05-28T16:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次 swift 大会上我分享了一个 h5 转 swift 的 demo 还有 llvm backend 相关的知识和应用，分享完后微信，淘宝和 perfect 团队成员都私下表示了对这个主题的兴趣，看来大家对用技术提高效率的决心是一致的。下面是我的 slides ，下载地址是 <a href="https://pan.baidu.com/s/1kVPvPiB" target="_blank" rel="external">https://pan.baidu.com/s/1kVPvPiB</a>。其他嘉宾的 pdf 和 源码在 <a href="https://github.com/atConf/atswift-2017-resources" target="_blank" rel="external">https://github.com/atConf/atswift-2017-resources</a></p>
<p><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/1.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/2.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/3.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/4.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/5.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/6.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/7.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/8.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/9.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/10.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/11.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/12.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/13.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/14.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/15.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/16.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/17.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/18.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/19.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/20.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/21.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/22.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/23.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/24.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/25.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/26.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/27.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/28.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/29.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/30.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/31.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/32.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/33.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次 swift 大会上我分享了一个 h5 转 swift 的 demo 还有 llvm backend 相关的知识和应用，分享完后微信，淘宝和 perfect 团队成员都私下表示了对这个主题的兴趣，看来大家对用技术提高效率的决心是一致的。下面是我的 slides ，下载地
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
      <category term="LLVM" scheme="http://ming1016.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>用 Swift 编写的工程代码静态分析命令行工具 smck</title>
    <link href="http://ming1016.github.io/2017/04/01/build-static-analysis-program-smck-use-swift/"/>
    <id>http://ming1016.github.io/2017/04/01/build-static-analysis-program-smck-use-swift/</id>
    <published>2017-04-01T14:00:31.000Z</published>
    <updated>2017-05-27T02:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几周在用 swift 做一个命令行工具 smck 用来对现有 OC 工程的代码做些分析和处理。日后工程切换成 Swift 可以加上对 Swift 工程代码的支持。昨天看到喵神在微博上说他下周要直播 live coding 一个 swift 的命令行工具，传送门： <a href="http://m.quzhiboapp.com/?liveId=391&amp;fromUserId=12049#!/intro/391" target="_blank" rel="external">现场编程 - 用 Swift 创建命令行工具 fengniao-cli Part1</a> ，其实蛮期待。想想跟喵神挺有缘的，最近下了他开发的 iOS 应用 Mail Me，随时能够记录工作和准备讲座时一些灵感，smck 的一些实现还有模块的设计灵感也是通过这个应用随时记录了下来呢，所以也推荐大家使用，真心方便。还有先前 Segmentfault 邀请我这个月31号在他们的直播平台上做个讲座，传送门： <a href="https://segmentfault.com/l/1500000008514518" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM - 戴铭 - SegmentFault 讲堂</a> ，先前写过一篇文章，直播可能更利于演示和详细说明一些细节吧。看来这段时间我要跟喵神做好多类似的事情了。smck 的代码今天已经放到了 Github 上，地址：<a href="https://github.com/ming1016/smck" target="_blank" rel="external">https://github.com/ming1016/smck</a></p>
<h2 id="smck-可以做哪些事情呢？"><a href="#smck-可以做哪些事情呢？" class="headerlink" title="smck 可以做哪些事情呢？"></a>smck 可以做哪些事情呢？</h2><ul>
<li>简单的比如命名规则的检查，按照团队标准来，如所有继承 UIViewController 的命名末尾统一成 VC，继承 JSONModel 的命名末尾统一成 Model，还有特定功能基类的子类按照一定的命名规则来。</li>
<li>再比如查找所有中文字符串列出每个字符串分别使用在哪个控件上。</li>
<li>根据类是否被初始化或直接调用等规则检查来分析哪些类从来没有调用过来判断是否是没有用的类。</li>
<li>对工程质量的检查，比如 NSString，block，NSArray 的属性检查否是为 copy，还有 protocol 是否为 weak，Array 的操作是否使用具有安全操作的 Category 来做等等。<br>当然需要检查分析和处理的肯定不止这些，所以在 smck 这个程序设计成了一种非常利于添加各种检查功能模块的结构，通过简单的代码编写每个人或团队都可以方便编写添加各种 checker。</li>
</ul>
<h2 id="是怎么做到简单编写就能够添加功能呢？"><a href="#是怎么做到简单编写就能够添加功能呢？" class="headerlink" title="是怎么做到简单编写就能够添加功能呢？"></a>是怎么做到简单编写就能够添加功能呢？</h2><p>因为代码分析的过程会通过一系列已经编写好的 parser 来完成，parser 会完成 token 的分析和上下文还有工程全局分析输出所有节点的数据信息，根据这些完整的信息和已经定义好的一系列具有完整包含关系的结构体就能够进行各种各样功能的定制化了。下面是一些 parser 和功能介绍：</p>
<p><img src="https://github.com/ming1016/smck/blob/master/README/5.png?raw=true" alt="parser"></p>
<ul>
<li>ParsingMethod.swift ：会返回 Method 结构体，包含了方法名，各个参数，方法内使用过的方法，方法内定义的临时变量等信息。</li>
<li>ParsingMethodContent.swift ：会分析方法内的 token 根据语法形成数组结构进行处理。这里需要处理的东西很多，目前还在根据计划添加更多的数据输出。</li>
<li>ParsingMacro.swift ：处理宏定义，主要是输出 token 给其它 parser 来处理。</li>
<li>ParsingImport.swift ：返回 Import 结构体，包含引入的类名，包名</li>
<li>ParsingProperty.swift ：会分析定义的属性 Property 信息</li>
<li>ParsingInterface.swift ：会根据这个分析出一个文件中定义了多少各类，类的结构体 Object 里类名，父类名，类别名会在这里解析出。</li>
<li>ParsingProtocol.swift ：会将分析出的协议设置到 Object 结构体中。</li>
<li>ParsingObject.swift ： 目前主要是分析出使用过的类的信息。</li>
</ul>
<p>生成的 File 结构体里面套装各个子结构体，断点如图：<br><img src="https://github.com/ming1016/smck/blob/master/README/6.png?raw=true" alt="结构体"></p>
<h2 id="如何调试-smck？"><a href="#如何调试-smck？" class="headerlink" title="如何调试 smck？"></a>如何调试 smck？</h2><p>先填上对应的命令行参数和值，设置参数参考下图。然后运行即可。<br><img src="https://github.com/ming1016/smck/blob/master/README/2.png?raw=true" alt="命令行参数"></p>
<h2 id="导出成命令行工具"><a href="#导出成命令行工具" class="headerlink" title="导出成命令行工具"></a>导出成命令行工具</h2><p>在 Xcode 里选择 Product - Archive - Export 即可，如图：<br><img src="https://github.com/ming1016/smck/blob/master/README/3.png?raw=true" alt="导出"><br>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./smck -o /User/your_project_path</div></pre></td></tr></table></figure></p>
<p>输出如下<br><img src="https://github.com/ming1016/smck/blob/master/README/4.png?raw=true" alt="执行效果"></p>
<h2 id="如何编写自己的检查功能？"><a href="#如何编写自己的检查功能？" class="headerlink" title="如何编写自己的检查功能？"></a>如何编写自己的检查功能？</h2><p>由于工程检查规则非常多样化，所以需要编写一些 Plugin，后面我会逐渐抽出一些具有共性的放上来，目前在 Plugin 目录下我放了两个例子，在例子里可以看出来怎么通过订阅 Parser 输出的不同节点的不同数据来进行不同的检查。在控制台管理相关的 Checker 类里关联 Parser 和 Plugin 的代码由于使用了 RxSwift 也变得非常简洁明了，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doO</span><span class="params">(path:String)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> path.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="type">UnUseObjectPlugin</span>().plug(ob: <span class="type">ParsingEntire</span>.parsing(path: path))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近几周在用 swift 做一个命令行工具 smck 用来对现有 OC 工程的代码做些分析和处理。日后工程切换成 Swift 可以加上对 S
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="smck" scheme="http://ming1016.github.io/tags/smck/"/>
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 iOS 编译 Clang / LLVM 直播的 Slides</title>
    <link href="http://ming1016.github.io/2017/04/01/slides-of-deeply-analyse-llvm/"/>
    <id>http://ming1016.github.io/2017/04/01/slides-of-deeply-analyse-llvm/</id>
    <published>2017-04-01T10:27:46.000Z</published>
    <updated>2017-05-27T13:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次直播主要是针对上篇文章：<a href="https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang---LLVM" target="_blank" rel="external">https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang—LLVM</a> 做了些补充，一些不容易用文字表达的知识点做了些详细的说明，同时现场做了些代码和操作的演示。</p>
<p>直播地址：<a href="https://segmentfault.com/l/1500000008514518" target="_blank" rel="external">https://segmentfault.com/l/1500000008514518</a></p>
<p>PPT 下载地址：<a href="https://pan.baidu.com/s/1dFkoaIl" target="_blank" rel="external">https://pan.baidu.com/s/1dFkoaIl</a></p>
<p>下面我贴出 PPT 内容</p>
<p><img src="/uploads/slides-of-deeply-analyse-llvm/1.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/2.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/3.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/4.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/5.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/6.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/7.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/8.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/9.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/10.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/11.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/12.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/13.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/14.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/15.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/16.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/17.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/18.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/19.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/20.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/21.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/22.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/23.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/24.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/25.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/26.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/27.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/28.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/29.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/30.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/31.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/32.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/33.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/34.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/35.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/36.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/37.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/38.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/39.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/40.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/41.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/42.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/43.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/44.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/45.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/46.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/47.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/48.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/49.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/50.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/51.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/52.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/53.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/54.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/55.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次直播主要是针对上篇文章：&lt;a href=&quot;https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang---LLVM&quot; t
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
      <category term="LLVM" scheme="http://ming1016.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 iOS 编译 Clang / LLVM</title>
    <link href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/"/>
    <id>http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/</id>
    <published>2017-03-01T13:58:09.000Z</published>
    <updated>2017-07-31T11:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter <a href="https://twitter.com/clattner_llvm" target="_blank" rel="external">@clattner_llvm</a> ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p>
<p>Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。</p>
<p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</p>
<p>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</p>
<p>LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是  Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。</p>
<p>LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。</p>
<p>LLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</p>
<p>这里是 Clang 官方详细文档： <a href="http://clang.llvm.org/docs/" target="_blank" rel="external">Welcome to Clang’s documentation! — Clang 4.0 documentation</a></p>
<p>这篇是对 LLVM 架构的一个概述： <a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">The Architecture of Open Source Applications</a></p>
<p>将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 <a href="https://book.douban.com/subject/1436811/" target="_blank" rel="external">《linkers and loaders》</a> 这本书就知道了。</p>
<h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><p>在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#define DEFINEEight 8</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int eight = DEFINEEight;</div><div class="line">        int six = 6;</div><div class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</div><div class="line">        int rank = eight + six;</div><div class="line">        NSLog(@“%@ rank %d”, site, rank);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -ccc-print-phases main.m</div></pre></td></tr></table></figure></p>
<p>可以看到编译源文件需要的几个不同的阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: input, “main.m”, objective-c</div><div class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</div><div class="line">2: compiler, &#123;1&#125;, ir</div><div class="line">3: backend, &#123;2&#125;, assembler</div><div class="line">4: assembler, &#123;3&#125;, object</div><div class="line">5: linker, &#123;4&#125;, image</div><div class="line">6: bind-arch, “x86_64”, &#123;5&#125;, image</div></pre></td></tr></table></figure></p>
<p>这样能够了解到过程和重要的信息。<br>查看oc的c实现可以使用如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m</div></pre></td></tr></table></figure></p>
<p>查看操作内部命令，可以使用 -### 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -### main.m -o main</div></pre></td></tr></table></figure></p>
<p>想看清clang的全部过程，可以先通过-E查看clang在预编译处理这步做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -E main.m</div></pre></td></tr></table></figure></p>
<p>执行完后可以看到文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 1 “/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h” 1 3</div><div class="line"># 185 “/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h” 2 3</div><div class="line"># 2 “main.m” 2</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int eight = 8;</div><div class="line">        int six = 6;</div><div class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</div><div class="line">        int rank = eight + six;</div><div class="line">        NSLog(@“%@ rank %d”, site, rank);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个过程的处理包括宏的替换，头文件的导入。下面这些代码也会在这步处理。</p>
<ul>
<li>“#define”</li>
<li>“#include”</li>
<li>“#indef”</li>
<li>注释</li>
<li>“#pragma”</li>
</ul>
<p>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p>
<p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p>
<p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="external">Writing an LLVM Pass — LLVM 5 documentation</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</p>
<p>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure></p>
<p>生成汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure></p>
<p>生成目标文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure></p>
<p>生成可执行文件，这样就能够执行看到输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">clang main.o -o main</div><div class="line">执行</div><div class="line">./main</div><div class="line">输出</div><div class="line">starming rank 14</div></pre></td></tr></table></figure></p>
<p>下面是完整步骤：</p>
<ul>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ul>
<h1 id="Clang-编译-m-文件"><a href="#Clang-编译-m-文件" class="headerlink" title="Clang 编译 .m 文件"></a>Clang 编译 .m 文件</h1><p>在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。</p>
<p>具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CompileC DerivedData path/AFSecurityPolicy.o AFNetworking/AFNetworking/AFSecurityPolicy.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</div></pre></td></tr></table></figure></p>
<p>接下来对会更新工作路径，同时设置 PATH<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods</div><div class="line">    export LANG=en_US.US-ASCII</div><div class="line">    export PATH=“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin”</div></pre></td></tr></table></figure></p>
<p>接下来就是实际的编译命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o</div></pre></td></tr></table></figure></p>
<p>clang 命令参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-x 编译语言比如objective-c</div><div class="line">-arch 编译的架构，比如arm7</div><div class="line">-f 以-f开头的。</div><div class="line">-W 以-W开头的，可以通过这些定制编译警告</div><div class="line">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</div><div class="line">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</div><div class="line">-I 把编译信息写入指定的辅助文件</div><div class="line">-F 需要的Framework</div><div class="line">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</div><div class="line">-o 编译结果</div></pre></td></tr></table></figure></p>
<h2 id="构建-Target"><a href="#构建-Target" class="headerlink" title="构建 Target"></a>构建 Target</h2><p>编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Create product structure</div><div class="line">Process product packaging</div><div class="line">Run custom shell script ‘Check Pods Manifest.lock’</div><div class="line">Compile … 各个项目中的.m文件</div><div class="line">Link /Users/… 路径</div><div class="line">Copy … 静态文件</div><div class="line">Compile asset catalogs</div><div class="line">Compile Storyboard file …</div><div class="line">Process info.plist</div><div class="line">Link Storyboards</div><div class="line">Run custom shell script ‘Embed Pods Frameworks’</div><div class="line">Run custom shell script ‘Copy Pods Resources’</div><div class="line">…</div><div class="line">Touch GCDFetchFeed.app</div><div class="line">Sign GCDFetchFeed.app</div></pre></td></tr></table></figure></p>
<p>从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。</p>
<h2 id="Target-在-Build-过程的控制"><a href="#Target-在-Build-过程的控制" class="headerlink" title="Target 在 Build 过程的控制"></a>Target 在 Build 过程的控制</h2><p>在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。</p>
<h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。</p>
<p>在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。</p>
<p>build phase 还会把静态资源拷贝到 bundle 里。</p>
<p>可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。</p>
<h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>在 build 的过程中各个阶段的选项的设置。</p>
<h3 id="pbxproj工程文件"><a href="#pbxproj工程文件" class="headerlink" title="pbxproj工程文件"></a>pbxproj工程文件</h3><p>build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rootObject = 3EE311301C4E1F0800103FA3 /* Project object */;</div></pre></td></tr></table></figure></p>
<p>然后根据这个 ID 找到 main 工程的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Begin PBXProject section */</div><div class="line">		3EE311301C4E1F0800103FA3 /* Project object */ = &#123;</div><div class="line">			isa = PBXProject;</div><div class="line">			…</div><div class="line">/* End PBXProject section */</div></pre></td></tr></table></figure></p>
<p>在 targets 里会指向各个 taget 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">targets = (</div><div class="line">	3EE311371C4E1F0800103FA3 /* GCDFetchFeed */,</div><div class="line">	3EE311501C4E1F0800103FA3 /* GCDFetchFeedTests */,</div><div class="line">	3EE3115B1C4E1F0800103FA3 /* GCDFetchFeedUITests */,</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">3EE311371C4E1F0800103FA3 /* GCDFetchFeed */ = &#123;</div><div class="line">	isa = PBXNativeTarget;</div><div class="line">	buildConfigurationList = 3EE311651C4E1F0800103FA3 /* configuration list for PBXNativeTarget “GCDFetchFeed” </div><div class="line">	buildPhases = (</div><div class="line">		9527AA01F4AAE11E18397E0C /* Check Pods st.lock */,</div><div class="line">		3EE311341C4E1F0800103FA3 /* Sources */,</div><div class="line">		3EE311351C4E1F0800103FA3 /* Frameworks */,</div><div class="line">		3EE311361C4E1F0800103FA3 /* Resources */,</div><div class="line">		C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks </div><div class="line">		DD33A716222617FAB49F1472 /* Copy Pods Resources </div><div class="line">	);</div><div class="line">	buildRules = (</div><div class="line">	);</div><div class="line">	dependencies = (</div><div class="line">	);</div><div class="line">	name = GCDFetchFeed;</div><div class="line">	productName = GCDFetchFeed;</div><div class="line">	productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */;</div><div class="line">	productType = “com.apple.product-type.application”;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。</p>
<p>接下来详细的看看 Clang 所做的事情吧。</p>
<h1 id="Clang-Static-Analyzer静态代码分析"><a href="#Clang-Static-Analyzer静态代码分析" class="headerlink" title="Clang Static Analyzer静态代码分析"></a>Clang Static Analyzer静态代码分析</h1><p>可以在 <a href="https://code.woboq.org/llvm/clang/" target="_blank" rel="external">llvm/clang/ Source Tree - Woboq Code Browser</a> 上查看 Clang 的代码。</p>
<p>Youtube上一个教程：<a href="https://www.youtube.com/watch?time_continue=280&amp;v=VqCkCDFLSsc" target="_blank" rel="external">The Clang AST - a Tutorial - YouTube</a><br>CMU关于llvm的教案 <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/" target="_blank" rel="external">http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/</a></p>
<p>静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 <a href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def" target="_blank" rel="external">TokensKind.def</a> 里有 Clang 定义的所有 Token。Token 可以分为以下几类</p>
<ul>
<li>关键字：语法中的关键字，if else while for 等。</li>
<li>标识符：变量名</li>
<li>字面量：值，数字，字符串</li>
<li>特殊符号：加减乘除等符号</li>
</ul>
<p>通过下面的命令可以输出所有 token 和所在文件具体位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -E -Xclang -dump-tokens main.m</div><div class="line">``` </div><div class="line">结果如下</div></pre></td></tr></table></figure></p>
<p>annot_module_include ‘#import <fo’ loc="<main.m:2:1"><br>int ‘int’     [StartOfLine]    Loc=<main.m:5:1><br>identifier ‘main’     [LeadingSpace]    Loc=<main.m:5:5><br>l_paren ‘(‘        Loc=<main.m:5:9><br>r_paren ‘)’        Loc=<main.m:5:10><br>l_brace ‘{‘     [LeadingSpace]    Loc=<main.m:5:12><br>at ‘@‘     [StartOfLine] [LeadingSpace]    Loc=<main.m:6:5><br>identifier ‘autoreleasepool’        Loc=<main.m:6:6><br>l_brace ‘{‘     [LeadingSpace]    Loc=<main.m:6:22><br>identifier ‘NSString’     [StartOfLine] [LeadingSpace]    Loc=<main.m:7:9><br>star ‘*’     [LeadingSpace]    Loc=<main.m:7:18><br>identifier ‘a’        Loc=<main.m:7:19><br>equal ‘=‘     [LeadingSpace]    Loc=<main.m:7:21><br>at ‘@‘     [LeadingSpace]    Loc=<main.m:7:23><br>string_literal ‘”aaa”’        Loc=<main.m:7:24><br>semi ‘;’        Loc=<main.m:7:29><br>identifier ‘NSLog’     [StartOfLine] [LeadingSpace]    Loc=<main.m:8:9><br>l_paren ‘(‘        Loc=<main.m:8:14><br>at ‘@‘        Loc=<main.m:8:15><br>string_literal ‘”hi %@“’        Loc=<main.m:8:16><br>comma ‘,’        Loc=<main.m:8:23><br>identifier ‘a’        Loc=<main.m:8:24><br>r_paren ‘)’        Loc=<main.m:8:25><br>semi ‘;’        Loc=<main.m:8:26><br>r_brace ‘}’     [StartOfLine] [LeadingSpace]    Loc=<main.m:9:5><br>return ‘return’     [StartOfLine] [LeadingSpace]    Loc=<main.m:10:5><br>numeric_constant ‘0’     [LeadingSpace]    Loc=<main.m:10:12><br>semi ‘;’        Loc=<main.m:10:13><br>r_brace ‘}’     [StartOfLine]    Loc=<main.m:11:1><br>eof ‘’        Loc=<main.m:11:2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=&lt;main.m:11:1&gt; 这个样的具体位置。</div><div class="line"></div><div class="line">接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。</div><div class="line"></div><div class="line">打个比方，如果遇到 token 是 = 符号进行赋值的处理，遇到加减乘除就先处理乘除，然后处理加减，这些组合经过嵌套后会生成一个语法数的结构。这个过程完成后会进行赋值操作时类型是不是匹配的处理。</div><div class="line"></div><div class="line">打印语法树的命令</div></pre></td></tr></table></figure></main.m:11:2></main.m:11:1></main.m:10:13></main.m:10:12></main.m:10:5></main.m:9:5></main.m:8:26></main.m:8:25></main.m:8:24></main.m:8:23></main.m:8:16></main.m:8:15></main.m:8:14></main.m:8:9></main.m:7:29></main.m:7:24></main.m:7:23></main.m:7:21></main.m:7:19></main.m:7:18></main.m:7:9></main.m:6:22></main.m:6:6></main.m:6:5></main.m:5:12></main.m:5:10></main.m:5:9></main.m:5:5></main.m:5:1></fo’></p>
<p>clang -fmodules -fsyntax-only -Xclang -ast-dump main.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出结果</div></pre></td></tr></table></figure></p>
<p>TranslationUnitDecl 0x7fa80f018ad0 &lt;<invalid sloc="">&gt; <invalid sloc=""><br>|-TypedefDecl 0x7fa80f018fc8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit <strong>int128_t ‘</strong>int128’<br>| <code>-BuiltinType 0x7fa80f018d20 ‘__int128’
|-TypedefDecl 0x7fa80f019028 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t ‘unsigned __int128’
|</code>-BuiltinType 0x7fa80f018d40 ‘unsigned <strong>int128’<br>|-TypedefDecl 0x7fa80f0190b8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit SEL ‘SEL <em>’<br>| `-PointerType 0x7fa80f019080 ‘SEL </em>’<br>|   <code>-BuiltinType 0x7fa80f018f30 ‘SEL’
|-TypedefDecl 0x7fa80f019198 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit id ‘id’
|</code>-ObjCObjectPointerType 0x7fa80f019140 ‘id’ imported<br>|   <code>-ObjCObjectType 0x7fa80f019110 ‘id’ imported
|-TypedefDecl 0x7fa80f019278 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit Class ‘Class’
|</code>-ObjCObjectPointerType 0x7fa80f019220 ‘Class’<br>|   `-ObjCObjectType 0x7fa80f0191f0 ‘Class’<br>|-ObjCInterfaceDecl 0x7fa80f0192c8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit Protocol<br>|-TypedefDecl 0x7fa80f019618 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit </invalid></invalid></invalid></invalid></invalid></invalid></strong>NSConstantString ‘struct <strong>NSConstantString_tag’<br>| `-RecordType 0x7fa80f019430 ‘struct </strong>NSConstantString_tag’<br>|   <code>-Record 0x7fa80f019390 ‘__NSConstantString_tag’
|-TypedefDecl 0x7fa80f0196a8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list ‘char *’
|</code>-PointerType 0x7fa80f019670 ‘char <em>’<br>|   <code>-BuiltinType 0x7fa80f018b60 ‘char’
|-TypedefDecl 0x7fa80f047978 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list ‘struct __va_list_tag [1]’
|</code>-ConstantArrayType 0x7fa80f047920 ‘struct <strong>va_list_tag [1]’ 1<br>|   `-RecordType 0x7fa80f0197a0 ‘struct </strong>va_list_tag’<br>|     <code>-Record 0x7fa80f0196f8 ‘__va_list_tag’
|-ImportDecl 0x7fa80f0486b0 &lt;main.m:2:1&gt; col:1 implicit Foundation
|-FunctionDecl 0x7fa80f048738 &lt;line:5:1, line:11:1&gt; line:5:5 main ‘int ()’
|</code>-CompoundStmt 0x7fa80f393998 <col:12, line:11:1=""><br>|   |-ObjCAutoreleasePoolStmt 0x7fa80f393950 <line:6:5, line:9:5=""><br>|   | <code>-CompoundStmt 0x7fa80f393928 &lt;line:6:22, line:9:5&gt;
|   |   |-DeclStmt 0x7fa80f3a3b38 &lt;line:7:9, col:29&gt;
|   |   |</code>-VarDecl 0x7fa80f3a3580 <col:9, col:24=""> col:19 used a ‘NSString </col:9,></line:6:5,></col:12,></em>’ cinit<br>|   |   |   <code>-ObjCStringLiteral 0x7fa80f3a3648 &lt;col:23, col:24&gt; ‘NSString *’
|   |   |</code>-StringLiteral 0x7fa80f3a3618 <col:24> ‘char [4]’ lvalue “aaa”<br>|   |   <code>-CallExpr 0x7fa80f3938c0 &lt;line:8:9, col:25&gt; ‘void’
|   |     |-ImplicitCastExpr 0x7fa80f3938a8 &lt;col:9&gt; ‘void (*)(id, …)’ &lt;FunctionToPointerDecay&gt;
|   |     |</code>-DeclRefExpr 0x7fa80f3a3b50 <col:9> ‘void (id, …)’ Function 0x7fa80f3a3670 ‘NSLog’ ‘void (id, …)’<br>|   |     |-ImplicitCastExpr 0x7fa80f3938f8 <col:15, col:16=""> ‘id’:’id’ <bitcast><br>|   |     | <code>-ObjCStringLiteral 0x7fa80f393800 &lt;col:15, col:16&gt; ‘NSString *’
|   |     |</code>-StringLiteral 0x7fa80f3a3bb8 <col:16> ‘char [6]’ lvalue “hi %@“<br>|   |     <code>-ImplicitCastExpr 0x7fa80f393910 &lt;col:24&gt; ‘NSString *’ &lt;LValueToRValue&gt;
|   |</code>-DeclRefExpr 0x7fa80f393820 <col:24> ‘NSString <em>’ lvalue Var 0x7fa80f3a3580 ‘a’ ‘NSString </em>’<br>|   <code>-ReturnStmt 0x7fa80f393980 &lt;line:10:5, col:12&gt;
|</code>-IntegerLiteral 0x7fa80f393960 <col:12> ‘int’ 0<br>`-<undeserialized declarations=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。</div><div class="line"></div><div class="line">clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。</div><div class="line"></div><div class="line">可以通过 clang —analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib / StaticAnalyzer / Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker</div></pre></td></tr></table></figure></undeserialized></col:12></col:24></col:16></bitcast></col:15,></col:9></col:24></invalid></invalid></invalid></invalid></p>
<p>debug.ConfigDumper              Dump config table<br>debug.DumpCFG                   Display Control-Flow Graphs<br>debug.DumpCallGraph             Display Call Graph<br>debug.DumpCalls                 Print calls as they are traversed by the engine<br>debug.DumpDominators            Print the dominance tree for a given CFG<br>debug.DumpLiveVars              Print results of live variable analysis<br>debug.DumpTraversal             Print branch conditions as they are traversed by the engine<br>debug.ExprInspection            Check the analyzer’s understanding of expressions<br>debug.Stats                     Emit warnings with analyzer statistics<br>debug.TaintTest                 Mark tainted symbols as such.<br>debug.ViewCFG                   View Control-Flow Graphs using GraphViz<br>debug.ViewCallGraph             View Call Graph using GraphViz<br>debug.ViewExplodedGraph         View Exploded Graphs using GraphViz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。</div><div class="line"></div><div class="line">clang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。</div><div class="line"></div><div class="line">编译的概念（词法-&gt;语法-&gt;语义-&gt;IR-&gt;优化-&gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。</div><div class="line"></div><div class="line">clang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。</div><div class="line"></div><div class="line">整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf 在clang里的具体实现代码可以查看这两个文件 [MemRegion.h](https://code.woboq.org/llvm/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h.html)和 [RegionStore.cpp](https://code.woboq.org/llvm/clang/lib/StaticAnalyzer/Core/RegionStore.cpp.html) 。</div><div class="line"></div><div class="line">下面举个简单例子看看 clang static  analyzer 是如何对源码进行模拟的。</div><div class="line">```c</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int a;</div><div class="line">	int b = 10;</div><div class="line">	a = b;</div><div class="line">	return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的 AST 以及 CFG<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#————————AST—————————</div><div class="line"># clang -cc1 -ast-dump</div><div class="line">TranslationUnitDecl 0xc75b450 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</div><div class="line">|-TypedefDecl 0xc75b740 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list ‘char *’</div><div class="line">`-FunctionDecl 0xc75b7b0 &lt;test.cpp:1:1, line:7:1&gt; line:1:5 main ‘int (void)’</div><div class="line">  `-CompoundStmt 0xc75b978 &lt;line:2:1, line:7:1&gt;</div><div class="line">    |-DeclStmt 0xc75b870 &lt;line:3:2, col:7&gt;</div><div class="line">    | `-VarDecl 0xc75b840 &lt;col:2, col:6&gt; col:6 used a ‘int’</div><div class="line">    |-DeclStmt 0xc75b8d8 &lt;line:4:2, col:12&gt;</div><div class="line">    | `-VarDecl 0xc75b890 &lt;col:2, col:10&gt; col:6 used b ‘int’ cinit</div><div class="line">    |   `-IntegerLiteral 0xc75b8c0 &lt;col:10&gt; ‘int’ 10</div><div class="line"></div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; a = b &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">    |-BinaryOperator 0xc75b928 &lt;line:5:2, col:6&gt; ‘int’ lvalue ‘=‘</div><div class="line">    | |-DeclRefExpr 0xc75b8e8 &lt;col:2&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</div><div class="line">    | `-ImplicitCastExpr 0xc75b918 &lt;col:6&gt; ‘int’ &lt;LValueToRValue&gt;</div><div class="line">    |   `-DeclRefExpr 0xc75b900 &lt;col:6&gt; ‘int’ lvalue Var 0xc75b890 ‘b’ ‘int’</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line"></div><div class="line">    `-ReturnStmt 0xc75b968 &lt;line:6:2, col:9&gt;</div><div class="line">      `-ImplicitCastExpr 0xc75b958 &lt;col:9&gt; ‘int’ &lt;LValueToRValue&gt;</div><div class="line">        `-DeclRefExpr 0xc75b940 &lt;col:9&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</div><div class="line">#————————CFG—————————</div><div class="line"># clang -cc1 -analyze -analyzer-checker=debug.DumpCFG</div><div class="line">int main()</div><div class="line"> [B2 (ENTRY)]</div><div class="line">   Succs (1): B1</div><div class="line"></div><div class="line"> [B1]</div><div class="line">   1: int a;</div><div class="line">   2: 10</div><div class="line">   3: int b = 10;</div><div class="line">   4: b</div><div class="line">   5: [B1.4] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">   6: a</div><div class="line">   7: [B1.6] = [B1.5]</div><div class="line">   8: a</div><div class="line">   9: [B1.8] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">  10: return [B1.9];</div><div class="line">   Preds (1): B2</div><div class="line">   Succs (1): B0</div><div class="line"></div><div class="line"> [B0 (EXIT)]</div><div class="line">   Preds (1): B1</div></pre></td></tr></table></figure></p>
<p>CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。</p>
<p>在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。</p>
<p>官方 AST 相关文档</p>
<ul>
<li><a href="http://clang.llvm.org/docs/Tooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/Tooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="external">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></li>
<li><a href="http://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="external">http://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibTooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibTooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibASTMatchers.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibASTMatchers.html</a></li>
</ul>
<p>静态检查的一些库以及使用方法</p>
<ul>
<li><a href="https://github.com/DeveloperLx/FauxPas_document_translation/blob/master/README.md?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">FauxPas_document_translation/README.md at master · DeveloperLx/FauxPas_document_translation · GitHub</a></li>
</ul>
<h1 id="CodeGen-生成-IR-代码"><a href="#CodeGen-生成-IR-代码" class="headerlink" title="CodeGen 生成 IR 代码"></a>CodeGen 生成 IR 代码</h1><p>将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。</p>
<p>这个过程中还会跟 runtime 桥接。</p>
<ul>
<li>各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。</li>
<li>Non-Fragile ABI 合成 OBJC<em>IVAR</em>$_ 偏移值常量。</li>
<li>ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。</li>
<li>strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。</li>
<li>@synthesize 的处理。</li>
<li>生成 block_layout 数据结构</li>
<li><strong>block 和 </strong>weak</li>
<li>_block_invoke</li>
<li>ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。</li>
</ul>
<p>不管编译的语言时 Objective-C 还是 Swift 也不管对应机器是什么，亦或是即时编译，LLVM 里唯一不变的是中间语言 LLVM IR。那么我们就来看看如何玩 LLVM IR。</p>
<h2 id="IR-结构"><a href="#IR-结构" class="headerlink" title="IR 结构"></a>IR 结构</h2><p>下面是刚才生成的 main.ll 中间代码文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">; ModuleID = ‘main.c’</div><div class="line">source_filename = “main.c”</div><div class="line">target datalayout = “e-m:o-i64:64-f80:128-n8:16:32:64-S128”</div><div class="line">target triple = “x86_64-apple-macosx10.12.0”</div><div class="line"></div><div class="line">@.str = private unnamed_addr constant [16 x i8] c”Please input a:\00”, align 1</div><div class="line">@.str.1 = private unnamed_addr constant [3 x i8] c”%d\00”, align 1</div><div class="line">@.str.2 = private unnamed_addr constant [16 x i8] c”Please input b:\00”, align 1</div><div class="line">@.str.3 = private unnamed_addr constant [32 x i8] c”a is:%d,b is :%d,count equal:%d\00”, align 1</div><div class="line"></div><div class="line">; Function Attrs: nounwind ssp uwtable</div><div class="line">define i32 @main() #0 &#123;</div><div class="line">  %1 = alloca i32, align 4</div><div class="line">  %2 = alloca i32, align 4</div><div class="line">  %3 = bitcast i32* %1 to i8*</div><div class="line">  call void @llvm.lifetime.start(i64 4, i8* %3) #3</div><div class="line">  %4 = bitcast i32* %2 to i8*</div><div class="line">  call void @llvm.lifetime.start(i64 4, i8* %4) #3</div><div class="line">  %5 = tail call i32 (i8*, …) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i64 0, i64 0))</div><div class="line">  %6 = call i32 (i8*, …) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %1)</div><div class="line">  %7 = call i32 (i8*, …) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i64 0, i64 0))</div><div class="line">  %8 = call i32 (i8*, …) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %2)</div><div class="line">  %9 = load i32, i32* %1, align 4, !tbaa !2</div><div class="line">  %10 = load i32, i32* %2, align 4, !tbaa !2</div><div class="line">  %11 = add nsw i32 %10, %9</div><div class="line">  %12 = call i32 (i8*, …) @printf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3, i64 0, i64 0), i32 %9, i32 %10, i32 %11)</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* %4) #3</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* %3) #3</div><div class="line">  ret i32 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">; Function Attrs: argmemonly nounwind</div><div class="line">declare void @llvm.lifetime.start(i64, i8* nocapture) #1</div><div class="line"></div><div class="line">; Function Attrs: nounwind</div><div class="line">declare i32 @printf(i8* nocapture readonly, …) #2</div><div class="line"></div><div class="line">; Function Attrs: nounwind</div><div class="line">declare i32 @scanf(i8* nocapture readonly, …) #2</div><div class="line"></div><div class="line">; Function Attrs: argmemonly nounwind</div><div class="line">declare void @llvm.lifetime.end(i64, i8* nocapture) #1</div><div class="line"></div><div class="line">attributes #0 = &#123; nounwind ssp uwtable “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” &#125;</div><div class="line">attributes #1 = &#123; argmemonly nounwind &#125;</div><div class="line">attributes #2 = &#123; nounwind “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” &#125;</div><div class="line">attributes #3 = &#123; nounwind &#125;</div><div class="line"></div><div class="line">!llvm.module.flags = !&#123;!0&#125;</div><div class="line">!llvm.ident = !&#123;!1&#125;</div><div class="line"></div><div class="line">!0 = !&#123;i32 1, !”PIC Level”, i32 2&#125;</div><div class="line">!1 = !&#123;!”Apple LLVM version 8.0.0 (clang-800.0.42.1)”&#125;</div><div class="line">!2 = !&#123;!3, !3, i64 0&#125;</div><div class="line">!3 = !&#123;!”int”, !4, i64 0&#125;</div><div class="line">!4 = !&#123;!”omnipotent char”, !5, i64 0&#125;</div><div class="line">!5 = !&#123;!”Simple C/C++ TBAA”&#125;</div></pre></td></tr></table></figure></p>
<p>LLVM IR 有三种表示格式，第一种是 bitcode 这样的存储格式，以 .bc 做后缀，第二种是可读的以 .ll，第三种是用于开发时操作 LLVM IR 的内存格式。</p>
<p>一个编译的单元即一个文件在 IR 里就是一个 Module，Module 里有 Global Variable 和 Function，在 Function里有 Basic Block，Basic Block 里有 指令 Instructions。<br>‘</p>
<p>通过下面的 IR 结构图能够更好的理解 IR 的整体结构。</p>
<p><img src="/uploads/deeply-analyse-llvm/08.png" alt=""></p>
<p>图中可以看出最大的是 Module，里面包含多个 Function，每个 Function 包含多个 BasicBlock，BasicBlock 里含有 Instruction，代码非常清晰，这样如果想开发一个新语言只需要完成语法解析后通过 LLVM 提供的丰富接口在内存中生成 IR 就可以直接运行在各个不同的平台。</p>
<p>IR 语言满足静态单赋值，可以很好的降低数据流分析和控制流分析的复杂度。及只能在定义时赋值，后面不能更改。但是这样就没法写程序了，输入输出都没法弄，所以函数式编程才会有类似 Monad 这样机制的原因。</p>
<h2 id="LLVM-IR-优化"><a href="#LLVM-IR-优化" class="headerlink" title="LLVM IR 优化"></a>LLVM IR 优化</h2><p>使用 O2，O3 这样的优化会调用对应的 Pass 来进行处理，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。可以通过 llvm-opt 调用 LLVM 优化相关的库。</p>
<p>可能直接这么说不太直观，我们可以更改下原 c 代码举个小例子看看这些 Pass 会做哪些优化。当我们加上<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</div><div class="line">    i++;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的 IR 代码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">%call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 1)</div><div class="line">%call4.1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 2)</div><div class="line">%call4.2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 3)</div><div class="line">%call4.3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 4)</div><div class="line">%call4.4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 5)</div><div class="line">%call4.5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 6)</div><div class="line">%call4.6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 7)</div><div class="line">%call4.7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 8)</div><div class="line">%call4.8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 9)</div><div class="line">%call4.9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 10)</div></pre></td></tr></table></figure></p>
<p>可以看出来这个 while 在 IR 中就是重复的打印了10次，那要是我把10改成100是不是会变成打印100次呢？</p>
<p>我们改成100后，再次生成 IR 可以看到 IR 变成了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  br label %while.body</div><div class="line"></div><div class="line">while.body:                                       ; preds = %while.body, %entry</div><div class="line">  %i.010 = phi i32 [ 0, %entry ], [ %inc, %while.body ]</div><div class="line">  %inc = add nuw nsw i32 %i.010, 1</div><div class="line">  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 %inc)</div><div class="line">  %exitcond = icmp eq i32 %inc, 100</div><div class="line">  br i1 %exitcond, label %while.end, label %while.body</div><div class="line"></div><div class="line">while.end:                                        ; preds = %while.body</div><div class="line">  %2 = load i32, i32* %a, align 4, !tbaa !2</div><div class="line">  %3 = load i32, i32* %b, align 4, !tbaa !2</div><div class="line">  %add = add nsw i32 %3, %2</div><div class="line">  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3, i64 0, i64 0), i32 %add)</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* nonnull %1) #3</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* nonnull %0) #3</div><div class="line">  ret i32 0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里对不同条件生成的不同都是 Pass 优化器做的事情。解读上面这段 IR 需要先了解下 IR 语法关键字，如下：</p>
<ul>
<li>@ - 代表全局变量</li>
<li>% - 代表局部变量</li>
<li>alloca - 指令在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存。</li>
<li>i32：- i 是几这个整数就会占几位，i32就是32位4字节</li>
<li>align - 对齐，比如一个 int,一个 char 和一个 int。单个 int 占4个字节，为了对齐只占一个字节的 char需要向4对齐占用4字节空间。</li>
<li>Load - 读出，store 写入</li>
<li>icmp - 两个整数值比较，返回布尔值</li>
<li>br - 选择分支，根据 cond 来转向 label，不根据条件跳转的话类似 goto</li>
<li>indirectbr - 根据条件间接跳转到一个 label，而这个 label 一般是在一个数组里，所以跳转目标是可变的，由运行时决定的</li>
<li>label - 代码标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">br label %while.body</div></pre></td></tr></table></figure>
<p>如上面表述，br  会选择跳向 while.body 定义的这个标签。这个标签里可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%exitcond = icmp eq i32 %inc, 100</div><div class="line">  br i1 %exitcond, label %while.end, label %while.body</div></pre></td></tr></table></figure></p>
<p>这段，icmp 会比较当前的 %inc 和定义的临界值 100，根据返回的布尔值来决定 br 跳转到那个代码标签，真就跳转到 while.end 标签，否就在进入 while.body 标签。这就是 while 的逻辑。通过br 跳转和 label 这种标签的概念使得 IR 语言能够成为更低级兼容性更高更方便转向更低级语言的语言。</p>
<h2 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h2><p>LLVM IR 是 SSA 形式的，维护双向 def-use 信息，use-def 是通过普通指针实现信息维护，def-use 是通过内存跳表和链表来实现的，便于 forward dataflow analysis 和 backward dataflow analysis。可以通过 ADCE 这个 Pass 来了解下 backward dataflow，这个pass 的源文件在 lib/Transforms/Scalar/ADCE.cpp 中，ADCE 实现了 Aggressive Dead Code Elimination Pass。这个 Pass 乐观地假设所有 instructions 都是 Dead 直到证明是否定的，允许它消除其他 DCE Pass 的 Dead 计算 catch，特别是涉及循环计算。其它 DCE 相关的 Pass 可以查看同级目录下的 BDCE.cpp 和 DCE.cpp，目录下其它的 Pass 都是和数据流相关的分析包含了各种分析算法和思路。</p>
<p>那么看看加法这个操作的相关的 IR 代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%2 = load i32, i32* %a, align 4, !tbaa !2</div><div class="line">%3 = load i32, i32* %b, align 4, !tbaa !2</div><div class="line">%add = add nsw i32 %3, %2</div></pre></td></tr></table></figure></p>
<p>加法对应的指令是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BinaryOperator::CreateAdd(Value *V1, Value *V2, <span class="keyword">const</span> Twine &amp;Name)</div></pre></td></tr></table></figure></p>
<p>两个输入 V1 和 V2 的 def-use 是如何的呢，看看如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">class Value &#123;</div><div class="line">  void addUse(Use &amp;U) &#123; U.addToList(&amp;UseList); &#125;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Use &#123;</div><div class="line">  Value *Val;</div><div class="line">  Use *Next;</div><div class="line">  PointerIntPair&lt;Use **, 2, PrevPtrTag&gt; Prev;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void Use::set(Value *V) &#123;</div><div class="line">  if (Val) removeFromList();</div><div class="line">  Val = V;</div><div class="line">  if (V) V-&gt;addUse(*this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Value *Use::operator=(Value *RHS) &#123;</div><div class="line">  set(RHS);</div><div class="line">  return RHS;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class User : public Value &#123;</div><div class="line">  template &lt;int Idx, typename U&gt; static Use &amp;OpFrom(const U *that) &#123;</div><div class="line">    return Idx &lt; 0</div><div class="line">      ? OperandTraits&lt;U&gt;::op_end(const_cast&lt;U*&gt;(that))[Idx]</div><div class="line">      : OperandTraits&lt;U&gt;::op_begin(const_cast&lt;U*&gt;(that))[Idx];</div><div class="line">  &#125;</div><div class="line">  template &lt;int Idx&gt; Use &amp;Op() &#123;</div><div class="line">    return OpFrom&lt;Idx&gt;(this);</div><div class="line">  &#125;</div><div class="line">  template &lt;int Idx&gt; const Use &amp;Op() const &#123;</div><div class="line">    return OpFrom&lt;Idx&gt;(this);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Instruction : public User,</div><div class="line">                    public ilist_node_with_parent&lt;Instruction, BasicBlock&gt; &#123;</div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class BinaryOperator : public Instruction &#123;</div><div class="line">  /// Construct a binary instruction, given the opcode and the two</div><div class="line">  /// operands.  Optionally (if InstBefore is specified) insert the instruction</div><div class="line">  /// into a BasicBlock right before the specified instruction.  The specified</div><div class="line">  /// Instruction is allowed to be a dereferenced end iterator.</div><div class="line">  ///</div><div class="line">  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,</div><div class="line">                                const Twine &amp;Name = Twine(),</div><div class="line">                                Instruction *InsertBefore = nullptr);</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">BinaryOperator::BinaryOperator(BinaryOps iType, Value *S1, Value *S2,</div><div class="line">                               Type *Ty, const Twine &amp;Name,</div><div class="line">                               Instruction *InsertBefore)</div><div class="line">  : Instruction(Ty, iType,</div><div class="line">                OperandTraits&lt;BinaryOperator&gt;::op_begin(this),</div><div class="line">                OperandTraits&lt;BinaryOperator&gt;::operands(this),</div><div class="line">                InsertBefore) &#123;</div><div class="line">  Op&lt;0&gt;() = S1;</div><div class="line">  Op&lt;1&gt;() = S2;</div><div class="line">  init(iType);</div><div class="line">  setName(Name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">BinaryOperator *BinaryOperator::Create(BinaryOps Op, Value *S1, Value *S2,</div><div class="line">                                       const Twine &amp;Name,</div><div class="line">                                       Instruction *InsertBefore) &#123;</div><div class="line">  assert(S1-&gt;getType() == S2-&gt;getType() &amp;&amp;</div><div class="line">         "Cannot create binary operator with two operands of differing type!");</div><div class="line">  return new BinaryOperator(Op, S1, S2, S1-&gt;getType(), Name, InsertBefore);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码里可以看出是使用了 Use 对象来把 use 和 def 联系起来的。</p>
<p>LLVM IR 通过 mem2reg 这个 Pass 来把局部变量成 SSA 形式。这个 Pass 的代码在 lib/Transforms/Utils/Mem2Reg.cpp 里。LLVM通过 mem2reg Pass 能够识别 alloca 模式，将其设置 SSA value。这时就不在需要 alloca，load和store了。mem2reg 是对 PromoteMemToReg 函数调用的一个简单包装，真正的算法实现是在 PromoteMemToReg 函数里，这个函数在 lib/Transforms/Utils/PromoteMemoryToRegister.cpp 这个文件里。</p>
<p>这个算法会使 alloca 这个仅仅作为 load 和 stores 的用途的指令使用迭代 dominator 边界转换成 PHI 节点，然后通过使用深度优先函数排序重写 loads 和 stores。这种算法叫做 iterated dominance frontier算法，具体实现方法可以参看 PromoteMemToReg 函数的实现。</p>
<p>当然把多个字节码 .bc 合成一个文件，链接时还会优化，IR 结构在优化后会有变化，这样还能够在变化后的 IR 的结构上再进行更多的优化。</p>
<p>这里可以进行 lli 解释执行 LLVM IR。</p>
<p>llc 编译器是专门编译 LLVM IR 的编译器用来生成汇编文件。</p>
<p>调用系统汇编器比如 GNU 的 as 来编译生成 .o Object 文件，接下来就是用链接器链接相关库和 .o 文件一起生成可执行的 .out 或者 exe 文件了。</p>
<p>llvm-mc 还可以直接生成 object 文件。</p>
<h1 id="Clang-CFE"><a href="#Clang-CFE" class="headerlink" title="Clang CFE"></a>Clang CFE</h1><p>动手玩肯定不能少了 Clang 的前端组件及库，熟悉这些库以后就能够自己动手用这些库编写自己的程序了。下面我就对这些库做些介绍，然后再着重说说 libclang 库，以及如何用它来写工具。</p>
<ul>
<li>LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。</li>
<li>The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。</li>
<li>The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。</li>
<li>Precompiled Headers - Clang 支持预编译 headers 的两个实现。</li>
<li>The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。</li>
<li>The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。</li>
<li>The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。</li>
<li>The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。</li>
</ul>
<h2 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h2><p>libclang 会让你觉得 clang 不仅仅只是一个伟大的编译器。下面从解析源码来说下</p>
<p>先写个 libclang 的程序来解析源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">    CXIndex Index = clang_createIndex(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    CXTranslationUnit TU = clang_parseTranslationUnit(Index, <span class="number">0</span>,</div><div class="line">                                                      argv, argc, <span class="number">0</span>, <span class="number">0</span>, CXTranslationUnit_None); <span class="keyword">for</span> (<span class="keyword">unsigned</span> I = <span class="number">0</span>, N = clang_getNumDiagnostics(TU); I != N; ++I) &#123;</div><div class="line">        CXDiagnostic Diag = clang_getDiagnostic(TU, I);</div><div class="line">        CXString String = clang_formatDiagnostic(Diag,clang_defaultDiagnosticDisplayOptions());</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, clang_getCString(String));</div><div class="line">        clang_disposeString(String);</div><div class="line">    &#125;</div><div class="line">    clang_disposeTranslationUnit(TU);</div><div class="line">    clang_disposeIndex(Index);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再写个有问题的 c 程序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span> <span class="comment">/**/</span> &#125;;<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">union</span> List *L)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure></p>
<p>运行了语法检查后会出现提示信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">list.c:2:9: error: use of <span class="string">'List'</span> with tag <span class="built_in">type</span> that does not match</div><div class="line">      previous declaration</div><div class="line">int sum(union List *Node) &#123;</div><div class="line">^~~~~</div><div class="line">struct</div><div class="line">list.c:1:8: note: previous use is here</div><div class="line">struct List &#123;</div><div class="line">^</div></pre></td></tr></table></figure></p>
<p>下面我们看看诊断过程，显示几个核心诊断方法诊断出问题</p>
<ul>
<li>enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic Diag);</li>
<li>CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic Diag);</li>
<li>CXString clang_getDiagnosticSpelling(CXDiagnostic Diag);</li>
</ul>
<p>接着进行高亮显示，最后提供两个提示修复的方法</p>
<ul>
<li>unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diag);</li>
<li>CXString clang_getDiagnosticFixIt(CXDiagnostic Diag, unsigned FixIt,<br>CXSourceRange *ReplacementRange);</li>
</ul>
<p>我们先遍历语法树的节点。源 c 程序如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> Data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">Next</span>;</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(struct List *Node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (; Node; Node = Node-&gt;Next)</div><div class="line">        result = result + Node-&gt;Data;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先找出所有的声明，比如 List，Data，Next，sum，Node 以及 result 等。再找出引用，比如 struct List *Next 里的 List。还有声明和表达式，比如 int result = 0; 还有 for 语句等。还有宏定义和实例化等。</p>
<p>CXCursor 会统一 AST 的节点，规范包含的信息</p>
<ul>
<li>代码所在位置和长度</li>
<li>名字和符号解析</li>
<li>类型</li>
<li>子节点</li>
</ul>
<p>举个 CXCursor 分析例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> Data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">Next</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>CXCursor 的处理过程如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Top-level cursor C</span></div><div class="line">clang_getCursorKind(C) == CXCursor_StructDecl</div><div class="line">clang_getCursorSpelling(C) == <span class="string">"List"</span> <span class="comment">//获取名字字符串</span></div><div class="line">clang_getCursorLocation(C) <span class="comment">//位置</span></div><div class="line">clang_getCursorExtent(C) <span class="comment">//长度</span></div><div class="line">clang_visitChildren(C, ...); <span class="comment">//访问子节点</span></div><div class="line"></div><div class="line"><span class="comment">//Reference cursor R</span></div><div class="line">clang_getCursorKind(R) == CXCursor_TypeRef </div><div class="line">clang_getCursorSpelling(R) == <span class="string">"List"</span></div><div class="line">clang_getCursorLocation(R)</div><div class="line">clang_getCursorExtent(R)</div><div class="line">clang_getCursorReferenced(R) == C <span class="comment">//指向C</span></div></pre></td></tr></table></figure></p>
<h1 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h1><p>动手玩的话，特别是想要使用这些工具链之前最好先了解我们和 LLVM 交互的实现。那么这部分就介绍下 LLVM 里的 Driver。</p>
<p>Driver 是 Clang 面对用户的接口，用来解析 Option 设置，判断决定调用的工具链，最终完成整个编译过程。</p>
<p>相关源代码在这里：clang/tools/driver/driver.cpp</p>
<p>整个 Driver 源码的入口函数就是 driver.cpp 里的 main() 函数。从这里可以作为入口看看整个  driver 是如何工作的，这样更利于我们以后轻松动手驾驭 LLVM。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc_, <span class="keyword">const</span> <span class="keyword">char</span> **argv_)</span> </span>&#123;</div><div class="line">  llvm::sys::PrintStackTraceOnErrorSignal(argv_[<span class="number">0</span>]);</div><div class="line">  llvm::<span class="function">PrettyStackTraceProgram <span class="title">X</span><span class="params">(argc_, argv_)</span></span>;</div><div class="line">  llvm::llvm_shutdown_obj Y; <span class="comment">// Call llvm_shutdown() on exit.</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (llvm::sys::Process::FixupStandardFileDescriptors())</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">  SmallVector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="number">256</span>&gt; argv;</div><div class="line">  llvm::SpecificBumpPtrAllocator&lt;<span class="keyword">char</span>&gt; ArgAllocator;</div><div class="line">  <span class="built_in">std</span>::error_code EC = llvm::sys::Process::GetArgumentVector(</div><div class="line">      argv, llvm::makeArrayRef(argv_, argc_), ArgAllocator);</div><div class="line">  <span class="keyword">if</span> (EC) &#123;</div><div class="line">    llvm::errs() &lt;&lt; <span class="string">"error: couldn't get arguments: "</span> &lt;&lt; EC.message() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  llvm::InitializeAllTargets();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> ProgName = argv[<span class="number">0</span>];</div><div class="line">  <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; TargetAndMode =</div><div class="line">      ToolChain::getTargetAndModeFromProgramName(ProgName);</div><div class="line"></div><div class="line">  llvm::BumpPtrAllocator A;</div><div class="line">  llvm::<span class="function">StringSaver <span class="title">Saver</span><span class="params">(A)</span></span>;</div><div class="line">	</div><div class="line">	<span class="comment">//省略</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// If we have multiple failing commands, we return the result of the first</span></div><div class="line">  <span class="comment">// failing command.</span></div><div class="line">  <span class="keyword">return</span> Res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Driver-的工作流程图"><a href="#Driver-的工作流程图" class="headerlink" title="Driver 的工作流程图"></a>Driver 的工作流程图</h2><p>在 driver.cpp 的 main 函数里有 Driver 的初始化。我们来看看和 driver 相关的代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">  Driver TheDriver(Path, llvm::sys::getDefaultTargetTriple(), Diags);</div><div class="line">  SetInstallDir(argv, TheDriver, CanonicalPrefixes);</div><div class="line"></div><div class="line">  insertTargetAndModeArgs(TargetAndMode.first, TargetAndMode.second, argv,</div><div class="line">                          SavedStrings);</div><div class="line"></div><div class="line">  SetBackdoorDriverOutputsFromEnvVars(TheDriver);</div><div class="line"></div><div class="line">  std::unique_ptr&lt;Compilation&gt; C(TheDriver.BuildCompilation(argv));</div><div class="line">  int Res = 0;</div><div class="line">  SmallVector&lt;std::pair&lt;int, const Command *&gt;, 4&gt; FailingCommands;</div><div class="line">  if (C.get())</div><div class="line">    Res = TheDriver.ExecuteCompilation(*C, FailingCommands);</div><div class="line"></div><div class="line">  // Force a crash to test the diagnostics.</div><div class="line">  if (::getenv("FORCE_CLANG_DIAGNOSTICS_CRASH")) &#123;</div><div class="line">    Diags.Report(diag::err_drv_force_crash) &lt;&lt; "FORCE_CLANG_DIAGNOSTICS_CRASH";</div><div class="line"></div><div class="line">    // Pretend that every command failed.</div><div class="line">    FailingCommands.clear();</div><div class="line">    for (const auto &amp;J : C-&gt;getJobs())</div><div class="line">      if (const Command *C = dyn_cast&lt;Command&gt;(&amp;J))</div><div class="line">        FailingCommands.push_back(std::make_pair(-1, C));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  for (const auto &amp;P : FailingCommands) &#123;</div><div class="line">    int CommandRes = P.first;</div><div class="line">    const Command *FailingCommand = P.second;</div><div class="line">    if (!Res)</div><div class="line">      Res = CommandRes;</div><div class="line"></div><div class="line">    // If result status is &lt; 0, then the driver command signalled an error.</div><div class="line">    // If result status is 70, then the driver command reported a fatal error.</div><div class="line">    // On Windows, abort will return an exit code of 3.  In these cases,</div><div class="line">    // generate additional diagnostic information if possible.</div><div class="line">    bool DiagnoseCrash = CommandRes &lt; 0 || CommandRes == 70;</div><div class="line">#ifdef LLVM_ON_WIN32</div><div class="line">    DiagnoseCrash |= CommandRes == 3;</div><div class="line">#endif</div><div class="line">    if (DiagnoseCrash) &#123;</div><div class="line">      TheDriver.generateCompilationDiagnostics(*C, *FailingCommand);</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到初始化 Driver 后 driver 会调用 BuildCompilation 生成 Compilation。Compilation 字面意思是合集的意思，通过 driver.cpp 的 include 可以看到<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Driver/Compilation.h"</span></span></div></pre></td></tr></table></figure></p>
<p>根据此路径可以细看下 Compilation 这个为了 driver 设置的一组任务的类。通过这个类我们提取里面这个阶段比较关键的几个信息出来<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compilation</span> &#123;</span></div><div class="line">	<span class="comment">/// The original (untranslated) input argument list.</span></div><div class="line">  llvm::opt::InputArgList *Args;</div><div class="line"></div><div class="line">  <span class="comment">/// The driver translated arguments. Note that toolchains may perform their</span></div><div class="line">  <span class="comment">/// own argument translation.</span></div><div class="line">  llvm::opt::DerivedArgList *TranslatedArgs;</div><div class="line">  <span class="comment">/// The driver we were created by.</span></div><div class="line">  <span class="keyword">const</span> Driver &amp;TheDriver;</div><div class="line"></div><div class="line">  <span class="comment">/// The default tool chain.</span></div><div class="line">  <span class="keyword">const</span> ToolChain &amp;DefaultToolChain;</div><div class="line"> ...</div><div class="line">  <span class="comment">/// The list of actions.  This is maintained and modified by consumers, via</span></div><div class="line">  <span class="comment">/// getActions().</span></div><div class="line">  ActionList Actions;</div><div class="line"></div><div class="line">  <span class="comment">/// The root list of jobs.</span></div><div class="line">  JobList Jobs;</div><div class="line">	...</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	...</div><div class="line">  <span class="function"><span class="keyword">const</span> Driver &amp;<span class="title">getDriver</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> TheDriver; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">const</span> ToolChain &amp;<span class="title">getDefaultToolChain</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DefaultToolChain; &#125;</div><div class="line">	...</div><div class="line">  <span class="function">ActionList &amp;<span class="title">getActions</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Actions; &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> ActionList &amp;<span class="title">getActions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Actions; &#125;</div><div class="line">	...</div><div class="line">  <span class="function">JobList &amp;<span class="title">getJobs</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Jobs; &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> JobList &amp;<span class="title">getJobs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Jobs; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Command&gt; C)</span> </span>&#123; Jobs.addJob(<span class="built_in">std</span>::move(C)); &#125;</div><div class="line">	...</div><div class="line">  <span class="comment">/// ExecuteCommand - Execute an actual command.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param FailingCommand - For non-zero results, this will be set to the</span></div><div class="line">  <span class="comment">/// Command which failed, if any.</span></div><div class="line">  <span class="comment">/// \return The result code of the subprocess.</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command &amp;C, <span class="keyword">const</span> Command *&amp;FailingCommand)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/// ExecuteJob - Execute a single job.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param FailingCommands - For non-zero results, this will be a vector of</span></div><div class="line">  <span class="comment">/// failing commands and their associated result code.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ExecuteJobs</span><span class="params">(</span></span></div><div class="line">      <span class="keyword">const</span> JobList &amp;Jobs,</div><div class="line">      SmallVectorImpl&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">const</span> Command *&gt;&gt; &amp;FailingCommands) <span class="keyword">const</span>;</div><div class="line">	...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过这些关键定义再结合 BuildCompilation 函数的实现可以看出这个 Driver 的流程是按照 ArgList - Actions - Jobs 来的，完整的图如下：</p>
<p><img src="/uploads/deeply-analyse-llvm/04.png" alt=""></p>
<h2 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h2><p>看完完整的 Driver 流程后，我们就先从 Parse 开始说起。</p>
<p>Parse 是解析选项，对应的代码在 ParseArgStrings 这个函数里。</p>
<p>下面通过执行一个试试，比如 clang -### main.c -ITheOptionWeAdd</p>
<p><img src="/uploads/deeply-analyse-llvm/05.png" alt=""></p>
<p>这里的 -I 是 Clang 支持的，在 Clang 里是 Option 类，Clang 会对这些 Option 专门的进行解析，使用一种 DSL 语言将其转成 .tb 文件后使用 table-gen 转成 C++ 语言和其它代码一起进行编译。</p>
<p>Driver 层会解析我们传入的 -I Option 参数。</p>
<p>-x 后加个 c 表示是对 c 语言进行编译，Clang Driver 通过文件的后缀 .c 来自动加上这个 参数的。如果是 c++ 语言，仅仅通过在 -x 后添加 cpp 编译还是会出错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x c++ main.cpp</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/deeply-analyse-llvm/06.png" alt=""></p>
<p>通过报错信息可以看出一些链接错误</p>
<p>因为需要链接 C++ 标准库，所以加上参数 -lc++ 就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x c++ -lc++ main.cpp</div></pre></td></tr></table></figure></p>
<p>那么 clang++ 和 clang 命令的区别就在于会加载 C++ 库，其实 clang++ 最终还是会调用 Clang，那么手动指定加载库就好了何必还要多个 clang++ 命令呢，这主要是为了能够在这个命令里去加载更多的库，除了标准库以外，还有些非 C++ 标准库，辅助库等等。这样只要是 C++ 的程序用 clang++ 够了。</p>
<p>只有加上 -cc1 这个 option 才能进入到 Clang driver 比如 emit-obj 这个 option 就需要先加上 -cc1。</p>
<p>这点可以通过  driver.cpp 源码来看，在 main()  函数里可以看到在做了些多平台的兼容处理后就开始进行对入参判断第一个是不是 -cc1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (MarkEOLs &amp;&amp; argv.size() &gt; <span class="number">1</span> &amp;&amp; StringRef(argv[<span class="number">1</span>]).startswith(<span class="string">"-cc1"</span>))</div><div class="line">    MarkEOLs = <span class="literal">false</span>;</div><div class="line">  llvm::cl::ExpandResponseFiles(Saver, Tokenizer, argv, MarkEOLs);</div><div class="line"></div><div class="line">  <span class="comment">// 处理 -cc1 集成工具</span></div><div class="line">  <span class="keyword">auto</span> FirstArg = <span class="built_in">std</span>::find_if(argv.begin() + <span class="number">1</span>, argv.end(),</div><div class="line">                               [](<span class="keyword">const</span> <span class="keyword">char</span> *A) &#123; <span class="keyword">return</span> A != <span class="literal">nullptr</span>; &#125;);</div><div class="line">  <span class="keyword">if</span> (FirstArg != argv.end() &amp;&amp; StringRef(*FirstArg).startswith(<span class="string">"-cc1"</span>)) &#123;</div><div class="line">    <span class="comment">// 如果 -cc1 来自 response file, 移除 EOL sentinels</span></div><div class="line">    <span class="keyword">if</span> (MarkEOLs) &#123;</div><div class="line">      <span class="keyword">auto</span> newEnd = <span class="built_in">std</span>::remove(argv.begin(), argv.end(), <span class="literal">nullptr</span>);</div><div class="line">      argv.resize(newEnd - argv.begin());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ExecuteCC1Tool(argv, argv[<span class="number">1</span>] + <span class="number">4</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如果是 -cc1 的话会调用 ExecuteCC1Tool 这个函数，先看看这个函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ExecuteCC1Tool</span><span class="params">(ArrayRef&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; argv, StringRef Tool)</span> </span>&#123;</div><div class="line">  <span class="keyword">void</span> *GetExecutablePathVP = (<span class="keyword">void</span> *)(<span class="keyword">intptr_t</span>) GetExecutablePath;</div><div class="line">  <span class="keyword">if</span> (Tool == <span class="string">""</span>)</div><div class="line">    <span class="keyword">return</span> cc1_main(argv.slice(<span class="number">2</span>), argv[<span class="number">0</span>], GetExecutablePathVP);</div><div class="line">  <span class="keyword">if</span> (Tool == <span class="string">"as"</span>)</div><div class="line">    <span class="keyword">return</span> cc1as_main(argv.slice(<span class="number">2</span>), argv[<span class="number">0</span>], GetExecutablePathVP);</div><div class="line"></div><div class="line">  <span class="comment">// 拒绝未知工具</span></div><div class="line">  llvm::errs() &lt;&lt; <span class="string">"error: unknown integrated tool '"</span> &lt;&lt; Tool &lt;&lt; <span class="string">"'\n"</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的执行会执行 cc1-main 或者 cc1as_main 。这两个函数分别在 driver.cpp 同级目录里的 cc1_main.cpp 和 cc1as_main.cpp 中。</p>
<p>下面看看有哪些解析 Args 的方法</p>
<ul>
<li>ParseAnalyzerArgs - 解析出静态分析器 option</li>
<li>ParseMigratorArgs - 解析 Migrator option</li>
<li>ParseDependencyOutputArgs - 解析依赖输出 option</li>
<li>ParseCommentArgs - 解析注释 option</li>
<li>ParseFileSystemArgs - 解析文件系统 option</li>
<li>ParseFrontendArgs - 解析前端 option</li>
<li>ParseTargetArgs - 解析目标  option</li>
<li>ParseCodeGenArgs - 解析 CodeGen 相关的 option</li>
<li>ParseHeaderSearchArgs - 解析 HeaderSearch 对象相关初始化相关的 option</li>
<li>parseSanitizerKinds - 解析 Sanitizer Kinds</li>
<li>ParsePreprocessorArgs - 解析预处理的 option</li>
<li>ParsePreprocessorOutputArgs - 解析预处理输出的 option</li>
</ul>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>Pipeline 这里可以添加 -ccc-print-phases 看到进入 Pipeline 以后的事情。</p>
<p>这些如 -ccc-print-phases 这样的 option 在编译时会生成.inc 这样的 C++ TableGen 文件。在 Options.td 可以看到全部的 option 定义。</p>
<p>在 Clang 的 Pipeline 中很多实际行为都有对应的 Action，比如 preprocessor 时提供文件的 InputAction 和用于绑定机器架构的 BindArchAction。</p>
<p>使用 clang main.c -arch i386 -arch x86_64 -o main 然后 file main 能够看到这时 BindArchAction 这个 Action 起到了作用，编译链接了两次同时创建了一个库既能够支持32位也能够支持64位用 lipo 打包。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// BuildActions - Construct the list of actions to perform for the</span></div><div class="line">  <span class="comment">/// given arguments, which are only done for a single architecture.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param C - The compilation that is being built.</span></div><div class="line">  <span class="comment">/// \param Args - The input arguments.</span></div><div class="line">  <span class="comment">/// \param Actions - The list to store the resulting actions onto.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">BuildActions</span><span class="params">(Compilation &amp;C, llvm::opt::DerivedArgList &amp;Args,</span></span></div><div class="line">                    <span class="keyword">const</span> InputList &amp;Inputs, ActionList &amp;Actions) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="comment">/// BuildUniversalActions - Construct the list of actions to perform</span></div><div class="line">  <span class="comment">/// for the given arguments, which may require a universal build.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param C - The compilation that is being built.</span></div><div class="line">  <span class="comment">/// \param TC - The default host tool chain.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">BuildUniversalActions</span><span class="params">(Compilation &amp;C, <span class="keyword">const</span> ToolChain &amp;TC,</span></span></div><div class="line">                             <span class="keyword">const</span> InputList &amp;BAInputs) <span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<p>上面两个方法中 BuildUniversalActions 最后也会走 BuildActions。BuildActions 了，进入这个方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Driver::BuildActions(Compilation &amp;C, DerivedArgList &amp;Args,</div><div class="line">                          <span class="keyword">const</span> InputList &amp;Inputs, ActionList &amp;Actions) <span class="keyword">const</span> &#123;</div><div class="line">  llvm::<span class="function">PrettyStackTraceString <span class="title">CrashInfo</span><span class="params">(<span class="string">"Building compilation actions"</span>)</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!SuppressMissingInputWarning &amp;&amp; Inputs.empty()) &#123;</div><div class="line">    Diag(clang::diag::err_drv_no_input_files);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Arg *FinalPhaseArg;</div><div class="line">  phases::ID FinalPhase = getFinalPhase(Args, &amp;FinalPhaseArg);</div></pre></td></tr></table></figure></p>
<p>接着跟 getFinalPhase 这个方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// -&#123;E,EP,P,M,MM&#125; only run the preprocessor.</span></div><div class="line">  <span class="keyword">if</span> (CCCIsCPP() || (PhaseArg = DAL.getLastArg(options::OPT_E)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_EP)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT_M, options::OPT_MM)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_P))) &#123;</div><div class="line">    FinalPhase = phases::Preprocess;</div><div class="line"></div><div class="line">    <span class="comment">// -&#123;fsyntax-only,-analyze,emit-ast&#125; only run up to the compiler.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_fsyntax_only)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_module_file_info)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_verify_pch)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_objc)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_legacy_objc)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT__migrate)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT__analyze,</div><div class="line">                                        options::OPT__analyze_auto)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_emit_ast))) &#123;</div><div class="line">    FinalPhase = phases::Compile;</div><div class="line"></div><div class="line">    <span class="comment">// -S only runs up to the backend.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_S))) &#123;</div><div class="line">    FinalPhase = phases::Backend;</div><div class="line"></div><div class="line">    <span class="comment">// -c compilation only runs up to the assembler.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_c))) &#123;</div><div class="line">    FinalPhase = phases::Assemble;</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise do everything.</span></div><div class="line">  &#125; <span class="keyword">else</span></div><div class="line">    FinalPhase = phases::Link;</div></pre></td></tr></table></figure></p>
<p>看完这段代码就会发现其实每次的 option 都会完整的走一遍从预处理，静态分析，backend 再到汇编的过程。</p>
<p>下面列下一些编译器的前端 Action，大家可以一个个用着玩。</p>
<ul>
<li>InitOnlyAction - 只做前端初始化，编译器 option 是 -init-only</li>
<li>PreprocessOnlyAction - 只做预处理，不输出，编译器的 option 是 -Eonly</li>
<li>PrintPreprocessedAction - 做预处理，子选项还包括-P、-C、-dM、-dD 具体可以查看PreprocessorOutputOptions 这个类，编译器 option 是 -E</li>
<li>RewriteIncludesAction - 预处理</li>
<li>DumpTokensAction - 打印token，option 是 -dump-tokens</li>
<li>DumpRawTokensAction - 输出原始tokens，包括空格符，option 是 -dump-raw-tokens</li>
<li>RewriteMacrosAction - 处理并扩展宏定义，对应的 option 是 -rewrite-macros</li>
<li>HTMLPrintAction - 生成高亮的代码网页，对应的 option 是 -emit-html</li>
<li>DeclContextPrintAction - 打印声明，option 对应的是 -print-decl-contexts</li>
<li>ASTDeclListAction - 打印 AST 节点，option 是 -ast-list</li>
<li>ASTDumpAction - 打印 AST 详细信息，对应 option 是 -ast-dump</li>
<li>ASTViewAction - 生成 AST dot 文件，能够通过 Graphviz 来查看图形语法树。 option 是 -ast-view</li>
<li>AnalysisAction - 运行静态分析引擎，option 是 -analyze</li>
<li>EmitLLVMAction - 生成可读的 IR 中间语言文件，对应的 option 是 -emit-llvm</li>
<li>EmitBCAction - 生成 IR Bitcode 文件，option 是 -emit-llvm-bc</li>
<li>MigrateSourceAction - 代码迁移，option 是 -migrate</li>
</ul>
<h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>Bind 主要是与工具链 ToolChain 交互<br>根据创建的那些 Action，在 Action 执行时 Bind 来提供使用哪些工具，比如生成汇编时是使用内嵌的还是 GNU 的，还是其它的呢，这个就是由 Bind 来决定的，具体使用的工具有各个架构，平台，系统的 ToolChain 来决定。</p>
<p>通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果</p>
<p>可以看到编译选择的是 clang，链接选择的是 darwin::Linker，但是在链接时前没有汇编器的过程，这个就是 Bind 起了作用，它会根据不同的平台来决定选择什么工具，因为是在 Mac 系统里 Bind 就会决定使用 integrated-as 这个内置汇编器。那么如何在不用内置汇编器呢。可以使用 -fno-integrated-as 这个 option。</p>
<h2 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h2><p>Translate 就是把相关的参数对应到不同平台上不同的工具。</p>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>从创建 Jobs 的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// BuildJobsForAction - Construct the jobs to perform for the action \p A and</span></div><div class="line">  <span class="comment">/// return an InputInfo for the result of running \p A.  Will only construct</span></div><div class="line">  <span class="comment">/// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once.</span></div><div class="line">  <span class="function">InputInfo</span></div><div class="line">  <span class="title">BuildJobsForAction</span><span class="params">(Compilation &amp;C, <span class="keyword">const</span> Action *A, <span class="keyword">const</span> ToolChain *TC,</span></div><div class="line">                     StringRef BoundArch, <span class="keyword">bool</span> AtTopLevel, <span class="keyword">bool</span> MultipleArchs,</div><div class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *LinkingOutput,</div><div class="line">                     <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Action *, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;, InputInfo&gt;</div><div class="line">                         &amp;CachedResults,</div><div class="line">                     Action::OffloadKind TargetDeviceOffloadKind) <span class="keyword">const</span>;</div></pre></td></tr></table></figure></p>
<p>可以看出 Jobs 需要前面的 Compilation，Action，ToolChain 等，那么 Jobs 就是将前面获取的信息进行组合分组给后面的 Execute 做万全准备。</p>
<h2 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h2><p>在 driver.cpp 的 main 函数里的 ExecuteCompilation 方法里可以看到如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set up response file names for each command, if necessary</span></div><div class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Job : C.getJobs())</div><div class="line">   setUpResponseFiles(C, Job);</div><div class="line"></div><div class="line"> C.ExecuteJobs(C.getJobs(), FailingCommands);</div></pre></td></tr></table></figure></p>
<p>能够看到 Jobs 准备好了后就要开始 Excute 他们。</p>
<p>Execute 就是执行整个的编译过程的 Jobs。过程执行的内容和耗时可以通过添加 -ftime-report 这个 option 来看到。</p>
<p><img src="/uploads/deeply-analyse-llvm/07.png" alt=""></p>
<h1 id="Clang-Attributes"><a href="#Clang-Attributes" class="headerlink" title="Clang Attributes"></a>Clang Attributes</h1><p>以 <strong>attribute</strong>(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法：</p>
<h2 id="attribute-format-NSString-F-A-格式化字符串"><a href="#attribute-format-NSString-F-A-格式化字符串" class="headerlink" title="attribute((format(NSString, F, A))) 格式化字符串"></a><strong>attribute</strong>((format(<strong>NSString</strong>, F, A))) 格式化字符串</h2><p>可以查看 NSLog 的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_EXPORT void NSLog(NSString *format, …) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;</div><div class="line"></div><div class="line">// Marks APIs which format strings by taking a format string and optional varargs as arguments</div><div class="line">#if !defined(NS_FORMAT_FUNCTION)</div><div class="line">    #if (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED)</div><div class="line">	#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</div><div class="line">    #else</div><div class="line">	#define NS_FORMAT_FUNCTION(F,A)</div><div class="line">    #endif</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<h2 id="attribute-deprecated-s-版本弃用提示"><a href="#attribute-deprecated-s-版本弃用提示" class="headerlink" title="attribute((deprecated(s))) 版本弃用提示"></a><strong>attribute</strong>((deprecated(s))) 版本弃用提示</h2><p>在编译过程中能够提示开发者该方法或者属性已经被弃用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)preMethod:( NSString *)string __attribute__((deprecated(“preMethod已经被弃用，请使用newMethod”)));</div><div class="line">- (void)deprecatedMethod DEPRECATED_ATTRIBUTE; //也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏</div></pre></td></tr></table></figure></p>
<h2 id="attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围"><a href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围" class="headerlink" title="attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围"></a><strong>attribute</strong>((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” <strong>VA_ARGS</strong>))) 指明使用版本范围</h2><p>os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=“iOS3到iOS7版本可用，iOS7不能用”)));</div></pre></td></tr></table></figure></p>
<h2 id="attribute-unavailable-…-方法不可用提示"><a href="#attribute-unavailable-…-方法不可用提示" class="headerlink" title="attribute((unavailable(…))) 方法不可用提示"></a><strong>attribute</strong>((unavailable(…))) 方法不可用提示</h2><p>这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。</p>
<h2 id="attribute-unused"><a href="#attribute-unused" class="headerlink" title="attribute((unused))"></a><strong>attribute</strong>((unused))</h2><p>没有被使用也不报警告</p>
<h2 id="attribute-warn-unused-result"><a href="#attribute-warn-unused-result" class="headerlink" title="attribute((warn_unused_result))"></a><strong>attribute</strong>((<strong>warn_unused_result</strong>))</h2><p>不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。</p>
<h2 id="attribute-availability-swift-unavailable-message-msg"><a href="#attribute-availability-swift-unavailable-message-msg" class="headerlink" title="attribute((availability(swift, unavailable, message=_msg)))"></a><strong>attribute</strong>((<strong>availability</strong>(swift, unavailable, message=_msg)))</h2><p>OC 的方法不能在 Swift 中使用。</p>
<h2 id="attribute-cleanup-…-作用域结束时自动执行一个指定方法"><a href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法" class="headerlink" title="attribute((cleanup(…))) 作用域结束时自动执行一个指定方法"></a><strong>attribute</strong>((cleanup(…))) 作用域结束时自动执行一个指定方法</h2><p>作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。</p>
<p>Reactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define onExit \</div><div class="line">    rac_keywordify \</div><div class="line">    __strong rac_cleanupBlock_t metamacro_concat(rac_exitBlock_, __LINE__) __attribute__((cleanup(rac_executeCleanupBlock), unused)) = ^</div><div class="line"></div><div class="line">static inline void rac_executeCleanupBlock (__strong rac_cleanupBlock_t *block) &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (property != NULL) &#123;</div><div class="line">		rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property);</div><div class="line">		if (attributes != NULL) &#123;</div><div class="line">			@onExit &#123;</div><div class="line">				free(attributes);</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			BOOL isObject = attributes-&gt;objectClass != nil || strstr(attributes-&gt;type, @encode(id)) == attributes-&gt;type;</div><div class="line">			BOOL isProtocol = attributes-&gt;objectClass == NSClassFromString(@“Protocol”);</div><div class="line">			BOOL isBlock = strcmp(attributes-&gt;type, @encode(void(^)())) == 0;</div><div class="line">			BOOL isWeak = attributes-&gt;weak;</div><div class="line"></div><div class="line">			shouldAddDeallocObserver = isObject &amp;&amp; isWeak &amp;&amp; !isBlock &amp;&amp; !isProtocol;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。</p>
<h2 id="attribute-overloadable-方法重载"><a href="#attribute-overloadable-方法重载" class="headerlink" title="attribute((overloadable)) 方法重载"></a><strong>attribute</strong>((overloadable)) 方法重载</h2><p>能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">__attribute__((overloadable)) void printArgument(int number)&#123;</div><div class="line">    NSLog(@“Add Int %i”, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) void printArgument(NSString *number)&#123;</div><div class="line">    NSLog(@“Add NSString %@“, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) void printArgument(NSNumber *number)&#123;</div><div class="line">    NSLog(@“Add NSNumber %@“, number);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="attribute-objc-designated-initializer-指定内部实现的初始化方法"><a href="#attribute-objc-designated-initializer-指定内部实现的初始化方法" class="headerlink" title="attribute((objc_designated_initializer)) 指定内部实现的初始化方法"></a><strong>attribute</strong>((objc_designated_initializer)) 指定内部实现的初始化方法</h2><ul>
<li>如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。</li>
<li>如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。</li>
</ul>
<h2 id="attribute-objc-subclassing-restricted-指定不能有子类"><a href="#attribute-objc-subclassing-restricted-指定不能有子类" class="headerlink" title="attribute((objc_subclassing_restricted)) 指定不能有子类"></a><strong>attribute</strong>((objc_subclassing_restricted)) 指定不能有子类</h2><p>相当于 Java 里的 final 关键字，如果有子类继承就会出错。</p>
<h2 id="attribute-objc-requires-super-子类继承必须调用-super"><a href="#attribute-objc-requires-super-子类继承必须调用-super" class="headerlink" title="attribute((objc_requires_super)) 子类继承必须调用 super"></a><strong>attribute</strong>((objc_requires_super)) 子类继承必须调用 super</h2><p>声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。</p>
<h2 id="attribute-const-重复调用相同数值参数优化返回"><a href="#attribute-const-重复调用相同数值参数优化返回" class="headerlink" title="attribute((const)) 重复调用相同数值参数优化返回"></a><strong>attribute</strong>((const)) 重复调用相同数值参数优化返回</h2><p>用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。</p>
<h2 id="attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><a href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY" class="headerlink" title="attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))"></a><strong>attribute</strong>((constructor(PRIORITY))) 和 <strong>attribute</strong>((destructor(PRIORITY)))</h2><p>PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。</p>
<p>通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。</p>
<h1 id="Clang-警告处理"><a href="#Clang-警告处理" class="headerlink" title="Clang 警告处理"></a>Clang 警告处理</h1><p>先看看这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored “-Wdeprecated-declarations”</div><div class="line">        sizeLabel = [self sizeWithFont:font constrainedToSize:size lineBreakMode:NSLineBreakByWordWrapping];</div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure></p>
<p>如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p>
<h1 id="使用-libclang-来进行语法分析"><a href="#使用-libclang-来进行语法分析" class="headerlink" title="使用 libclang 来进行语法分析"></a>使用 libclang 来进行语法分析</h1><p>使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。</p>
<p>使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js / ruby binding，还有 Objective-C的开源库 <a href="https://github.com/macmade/ClangKit" target="_blank" rel="external">GitHub - macmade/ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented.</a> 。</p>
<p>写个 python 脚本来调用 clang<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pip install clang</div><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># vim: set fileencoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> clang.cindex</div><div class="line"><span class="keyword">import</span> asciitree</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node_children</span><span class="params">(node)</span>:</span></div><div class="line">    <span class="keyword">return</span> (c <span class="keyword">for</span> c <span class="keyword">in</span> node.get_children() <span class="keyword">if</span> c.location.file == sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_node</span><span class="params">(node)</span>:</span></div><div class="line">    text = node.spelling <span class="keyword">or</span> node.displayname</div><div class="line">    kind = str(node.kind)[str(node.kind).index(‘.’)+<span class="number">1</span>:]</div><div class="line">    <span class="keyword">return</span> ‘&#123;&#125; &#123;&#125;’.format(kind, text)</div><div class="line"></div><div class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</div><div class="line">    print(“Usage: dump_ast.py [header file name]”)</div><div class="line">    sys.exit()</div><div class="line"></div><div class="line">clang.cindex.Config.set_library_file(‘/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib’)</div><div class="line">index = clang.cindex.Index.create()</div><div class="line">translation_unit = index.parse(sys.argv[<span class="number">1</span>], [‘-x’, ‘objective-c’])</div><div class="line"></div><div class="line"><span class="keyword">print</span> asciitree.draw_tree(translation_unit.cursor,</div><div class="line">                          <span class="keyword">lambda</span> n: list(n.get_children()),</div><div class="line">                          <span class="keyword">lambda</span> n: “%s (%s)” % (n.spelling <span class="keyword">or</span> n.displayname, str(n.kind).split(“.”)[<span class="number">1</span>]))</div></pre></td></tr></table></figure></p>
<p>基于语法树的分析还可以针对字符串做加密。</p>
<h1 id="LibTooling-对语法树完全的控制"><a href="#LibTooling-对语法树完全的控制" class="headerlink" title="LibTooling 对语法树完全的控制"></a>LibTooling 对语法树完全的控制</h1><p>因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。</p>
<ul>
<li>可以改变 clang 生成代码的方式。</li>
<li>增加更强的类型检查。</li>
<li>按照自己的定义进行代码的检查分析。</li>
<li>对源码做任意类型分析，甚至重写程序。</li>
<li>给 clang 添加一些自定义的分析，创建自己的重构器。</li>
<li>基于现有代码做出大量的修改。</li>
<li>基于工程生成相关图形或文档。</li>
<li>检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者  Swift 。</li>
</ul>
<p>官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： <a href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="external">Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation</a></p>
<p>按照说明编译完成后进入 LLVM 的目录 ~/llvm/tools/clang/tools/ 在这了可以创建自己的 clang 工具。这里有个范例： <a href="https://github.com/objcio/issue-6-compiler-tool" target="_blank" rel="external">GitHub - objcio/issue-6-compiler-tool: Example code for a standalone clang/llvm tool.</a> 可以直接 make 成一个二进制文件。</p>
<p>下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface Observer</div><div class="line">+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">VisitObjCMessageExpr</span><span class="params">(ObjCMessageExpr *E)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) &#123;</div><div class="line">    QualType ReceiverType = E-&gt;getClassReceiver();</div><div class="line">    Selector Sel = E-&gt;getSelector();</div><div class="line">    <span class="built_in">string</span> TypeName = ReceiverType.getAsString();</div><div class="line">    <span class="built_in">string</span> SelName = Sel.getAsString();</div><div class="line">    <span class="keyword">if</span> (TypeName == “Observer” &amp;&amp; SelName == “observerWithTarget:action:”) &#123;</div><div class="line">      Expr *Receiver = E-&gt;getArg(<span class="number">0</span>)-&gt;IgnoreParenCasts();</div><div class="line">      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(<span class="number">1</span>)-&gt;IgnoreParenCasts());</div><div class="line">      Selector Sel = SelExpr-&gt;getSelector();</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">const</span> ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) &#123;</div><div class="line">        ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl();</div><div class="line">        <span class="keyword">if</span> (! decl-&gt;lookupInstanceMethod(Sel)) &#123;</div><div class="line">          errs() &lt;&lt; “Warning: <span class="class"><span class="keyword">class</span> “ &lt;&lt; TypeName &lt;&lt; “ does not implement selector “ &lt;&lt; Sel.getAsString() &lt;&lt; “\n”;</span></div><div class="line">          SourceLocation Loc = E-&gt;getExprLoc();</div><div class="line">          PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc);</div><div class="line">          errs() &lt;&lt; “in “ &lt;&lt; PLoc.getFilename() &lt;&lt; “ &lt;“ &lt;&lt; PLoc.getLine() &lt;&lt; “:” &lt;&lt; PLoc.getColumn() &lt;&lt; “&gt;\n”;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Clang-Plugin"><a href="#Clang-Plugin" class="headerlink" title="Clang Plugin"></a>Clang Plugin</h1><p>通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm/tools/clang/tools</p>
<p>动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库  <a href="https://lmsgsendnilself.github.io/blog/2017/02/28/clangtojszi-yuan/" target="_blank" rel="external">clangtojs资源 - Lmsgsendnilself</a> ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： <a href="http://slides.com/sunnyxx/calling-conventions-in-cocoa#/" target="_blank" rel="external">Calling Conventions in Cocoa by sunnyxx</a> bang 也有篇文章： <a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="external">如何动态调用 C 函数 «  bang’s blog</a>  。</p>
<p>这三个方案作者都分别写了文章详细说明其实现方案。</p>
<ul>
<li><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">JSPatch实现原理详解 «  bang’s blog</a></li>
<li><a href="http://mp.weixin.qq.com/s/qRW_akbU3TSd0SxpF3iQmQ" target="_blank" rel="external">DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航</a></li>
<li><a href="http://www.jianshu.com/p/6c756ce76758" target="_blank" rel="external">OCS——史上最疯狂的iOS动态化方案 - 简书</a></li>
</ul>
<p>滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 <a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651112856&amp;idx=1&amp;sn=b2c74c62a10b4c9a4e7538d1ad7eb739" target="_blank" rel="external">《基于clang插件的一种iOS包大小瘦身方案》</a></p>
<p>那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。</p>
<ul>
<li>官方 clang 的插件： <a href="http://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="external">External Clang Examples</a></li>
<li>收集一些如何使用 clang 库的例子：<a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li>在 Xcode 中添加 clang 静态分析自定义 checks： <a href="http://clang-analyzer.llvm.org/xcode.html" target="_blank" rel="external">Running the analyzer within Xcode</a></li>
<li>将 LLVM C 的 API 用 swift 来包装： <a href="https://github.com/harlanhaskins/LLVMSwift" target="_blank" rel="external">GitHub - harlanhaskins/LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1</a></li>
</ul>
<h1 id="LLVM-Backend"><a href="#LLVM-Backend" class="headerlink" title="LLVM Backend"></a>LLVM Backend</h1><p>首先通过下图看看 LLVM Backend 在整个 LLVM 里所处的位置：<br><img src="/uploads/deeply-analyse-llvm/09.png" alt=""></p>
<p>接下来是整个 LLVM Backend 的流程图，后面会对每个过程详细说明</p>
<p><img src="/uploads/deeply-analyse-llvm/10.png" alt=""></p>
<h2 id="CodeGen-阶段"><a href="#CodeGen-阶段" class="headerlink" title="CodeGen 阶段"></a>CodeGen 阶段</h2><ul>
<li>Instruction Selection 指令选择：将IR转化成目标平台指令组成的定向非循环图 DAG（Directed Acyclic Graph）</li>
<li>Scheduling and Formation 调度与排序：读取 DAG，将 DAG 的指令排成 MachineInstr 的队列</li>
<li>SSA 优化：多个基于 SSA（Static Single Assignment） 的 Pass 组成。比如 modulo-scheduling 和 peephole optimization 都是在这个阶段完成的</li>
<li>Register allocation 寄存器分配：将 Virtual Register 映射到 Physical Register 或内存上<br>Prolog / Epilog 生成</li>
<li>确定所需堆栈大小：Machine Code </li>
<li>晚期优化：最后一次优化机会</li>
<li>Code Emission：输出代码，可以选择汇编或者二进制机器码。</li>
</ul>
<h2 id="SelectionDAG"><a href="#SelectionDAG" class="headerlink" title="SelectionDAG"></a>SelectionDAG</h2><ul>
<li>构建最初的 DAG：把 IR 里的 add 指令转成 SelectionDAG 的 add 节点</li>
<li>优化构建好的 DAG：把一些平台支持的 meta instructions 比如 Rotates，div / rem 指令识别出</li>
<li>Legalization SelectionDAG 类型：比如某些平台只有64位浮点和32位整数运算指令，那么就需要把所有 f32 都提升到 f64，i1/i8/i16 都提升到 i32，同时还要把 i64 拆分成两个 i32 来存储，操作符的合法化，比如 SDIV 在 x86 上回转成 SDIVREM。这个过程结果可以通过 llc -view-dag-combine2-dags sum.ll 看到</li>
<li>指令选择 instruction selector（ISel）：将平台无关的 DAG 通过 TableGen 读入 .tb 文件并且生成对应的模式匹配代码从而转成平台相关的 DAG</li>
<li>SelectionDAG Scheduling and Formation：因为 CPU 是没法执行 DAG，所以需要将指令从 DAG 中提取依据一定规则比如 minimal register pressure 或隐藏指令延迟重排成指令队列。（DAG -&gt; linear list（SSA form） -&gt; MachineInstr -&gt; MC Layer API MCInst MCStreamr -&gt; MCCodeEmitter -&gt; Binary Instr）</li>
</ul>
<p>下图是 llc -view-isel-dags 状态下的 DAG 图：</p>
<p><img src="/uploads/deeply-analyse-llvm/11.png" alt=""></p>
<p>查看 DAG 不同状态的说明如下：</p>
<ul>
<li>-view-dag-combine1-dags：可以显示没有被优化的 DAG</li>
<li>-view-legalize-dags：合法化之前的 DAG</li>
<li>-view-dag-cmobine2-dags：第二次优化前</li>
<li>-view-isel-dags：显示指令选择前的 DAG</li>
<li>-view-sched-dags：在 Scheduler 之前 ISel 之后</li>
<li>-view-sunit-dags：可以显示 Scheduler 的依赖图</li>
</ul>
<h2 id="Register-Allocation-寄存器分配"><a href="#Register-Allocation-寄存器分配" class="headerlink" title="Register Allocation 寄存器分配"></a>Register Allocation 寄存器分配</h2><h3 id="寄存器在-LLVM-中的表达"><a href="#寄存器在-LLVM-中的表达" class="headerlink" title="寄存器在 LLVM 中的表达"></a>寄存器在 LLVM 中的表达</h3><p>物理寄存器在 LLVM 里均有 1 - 1023 范围内的编号。在 GenRegisterNames.inc 里找到，比如 lib/Target/X86/X86GenRegisterInfo.inc</p>
<h3 id="虚拟寄存器到物理寄存器的映射"><a href="#虚拟寄存器到物理寄存器的映射" class="headerlink" title="虚拟寄存器到物理寄存器的映射"></a>虚拟寄存器到物理寄存器的映射</h3><p>直接映射使用 TargetRegisterInfo 和 MachineOperand 中的 API。间接映射的API用 VirtRegMap 以正确插入读写指令实现内存调度</p>
<h3 id="LLVM-自带的寄存器分配算法"><a href="#LLVM-自带的寄存器分配算法" class="headerlink" title="LLVM 自带的寄存器分配算法"></a>LLVM 自带的寄存器分配算法</h3><p>llc -regalloc=Greedy add.bc -o ln.s</p>
<ul>
<li>Fast - debug 默认，尽可能保存寄存器。</li>
<li>Basic - 增量分配</li>
<li>Greedy - LLVM 默认寄存器分配算法，对 Basic 算法变量生存期进行分裂进行高度优化</li>
<li>PBQP - 将寄存器分配描述成分区布尔二次规划</li>
</ul>
<h2 id="Code-Emission"><a href="#Code-Emission" class="headerlink" title="Code Emission"></a>Code Emission</h2><p>下图详细表达了整个 Code Emission 的过程<br><img src="/uploads/deeply-analyse-llvm/12.png" alt=""></p>
<h1 id="Swift-编译流"><a href="#Swift-编译流" class="headerlink" title="Swift 编译流"></a>Swift 编译流</h1><p>Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C/OC 进行交互。</p>
<p>下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(“hi!”)</div></pre></td></tr></table></figure></p>
<p>生成程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc toy.swift</div><div class="line">./toy</div></pre></td></tr></table></figure></p>
<p>生成检查 AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -dump-ast toy.swift</div></pre></td></tr></table></figure></p>
<p>可以还原之前函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-silgen toy.swift | xcrun swift-demangle</div></pre></td></tr></table></figure></p>
<p>llvm ir 和汇编的生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-ir toy.swift</div><div class="line">swiftc -emit-assembly toy.swift</div></pre></td></tr></table></figure></p>
<p>生成可执行的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk macosx swiftc toy.swift -o toy</div></pre></td></tr></table></figure></p>
<h1 id="编译后生成的二进制内容-Link-Map-File"><a href="#编译后生成的二进制内容-Link-Map-File" class="headerlink" title="编译后生成的二进制内容 Link Map File"></a>编译后生成的二进制内容 Link Map File</h1><p>在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容</p>
<h2 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h2><p>这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。</p>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><p>这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 <strong>TEXT 代码段和 </strong>DATA 数据段两种。</p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>Symbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。</p>
<h1 id="每次编译后生成的-dSYM-文件"><a href="#每次编译后生成的-dSYM-文件" class="headerlink" title="每次编译后生成的 dSYM 文件"></a>每次编译后生成的 dSYM 文件</h1><p>在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。</p>
<p>可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。</p>
<p>还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</div><div class="line">symbolicatecrash appName.crash appName.app &gt; appName.log</div></pre></td></tr></table></figure></p>
<h1 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h1><p>记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。</p>
<p>Mach-O 文件包含三个区域</p>
<ul>
<li>Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等</li>
<li>Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。</li>
<li>Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。</li>
</ul>
<h2 id="Mach-O-文件的解析"><a href="#Mach-O-文件的解析" class="headerlink" title="Mach-O 文件的解析"></a>Mach-O 文件的解析</h2><p>再通过一个例子来分析下：<br>这次用 xcrun 来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -v</div></pre></td></tr></table></figure></p>
<p>先创建一个test.c的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch test.c</div></pre></td></tr></table></figure></p>
<p>编辑里面的内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vi test.c</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hi there!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行，没有起名默认为 a.out<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang test.c</div><div class="line">./a.out</div></pre></td></tr></table></figure></p>
<p>a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -S -o - test.c | open -f</div></pre></td></tr></table></figure></p>
<p>输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.section	__TEXT,__text,regular,pure_instructions</div><div class="line">.macosx_version_min 10, 12</div><div class="line">.globl	_main</div><div class="line">.align	4, 0x90</div></pre></td></tr></table></figure></p>
<p>.section 指令指定接下来执行哪一个段。</p>
<p>.globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。</p>
<p>.align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。</p>
<p>看看接下来的 main 函数头部部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_main:                                  ## @main</div><div class="line">	.cfi_startproc</div><div class="line">## BB#0:</div><div class="line">	pushq	%rbp</div><div class="line">Ltmp0:</div><div class="line">	.cfi_def_cfa_offset 16</div><div class="line">Ltmp1:</div><div class="line">	.cfi_offset %rbp, -16</div><div class="line">	movq	%rsp, %rbp</div><div class="line">Ltmp2:</div><div class="line">	.cfi_def_cfa_register %rbp</div><div class="line">	subq	$32, %rsp</div></pre></td></tr></table></figure></p>
<p>_main 是函数开始的地址，二进制文件会有这个位置的引用。</p>
<p>.cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in / out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。</p>
<p>pushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。</p>
<p>.cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。</p>
<p>movq %rsp, %rbp 把局部变量放到栈上。</p>
<p>subq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。</p>
<p>再看看 printf()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">leaq	L_.str(%rip), %rax</div><div class="line">movl	$0, -4(%rbp)</div><div class="line">movl	%edi, -8(%rbp)</div><div class="line">movq	%rsi, -16(%rbp)</div><div class="line">movq	%rax, %rdi</div><div class="line">movb	$0, %al</div><div class="line">callq	_printf</div></pre></td></tr></table></figure></p>
<p>leap 会将 L<em>.str 这个指针加载到 rax 寄存器里。可以看看 L</em>.str 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div></pre></td></tr></table></figure></p>
<p>这个就是我们代码文件里定义的那个字符串。</p>
<p>这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。</p>
<p>当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。</p>
<p>printf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。</p>
<p>接下来看看返回和函数的结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xorl	%ecx, %ecx</div><div class="line">movl	%eax, -20(%rbp)         ## 4-byte Spill</div><div class="line">movl	%ecx, %eax</div><div class="line">addq	$32, %rsp</div><div class="line">popq	%rbp</div><div class="line">retq</div><div class="line">.cfi_endproc</div></pre></td></tr></table></figure></p>
<p>xorl    %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。</p>
<p>函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。</p>
<p>接下来是字符串输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	.section	__TEXT,__cstring,cstring_literals</div><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div><div class="line"></div><div class="line">.subsections_via_symbols</div></pre></td></tr></table></figure></p>
<p>同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。</p>
<p>接下来通过 size 工具来看看 a.out 里的 section。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun size -x -l -m a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</div><div class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</div><div class="line">	Section __text: 0x34 (addr 0x100000f50 offset 3920)</div><div class="line">	Section __stubs: 0x6 (addr 0x100000f84 offset 3972)</div><div class="line">	Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980)</div><div class="line">	Section __cstring: 0xa (addr 0x100000fa6 offset 4006)</div><div class="line">	Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016)</div><div class="line">	total 0xa6</div><div class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</div><div class="line">	Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</div><div class="line">	Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</div><div class="line">	total 0x18</div><div class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</div><div class="line">total 0x100003000</div></pre></td></tr></table></figure>
<p>可以看出有四个 segment 和多个section。</p>
<p>在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。</p>
<p>__PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。</p>
<p>__TEXT segment 包含被执行的代码以只读和可执行的方式映射。</p>
<ul>
<li>__text section 包含编译后的机器码。</li>
<li><strong>stubs 和 </strong>stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。</li>
<li>__cstring 可执行文件中的字符串。</li>
<li>__const 不可变的常量。</li>
</ul>
<p>__DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。</p>
<ul>
<li>__nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 </li>
<li>__la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。</li>
<li>__const 需要重定向的常量，例如 char * const c = “foo”; c指针指向可变的数据。</li>
<li>__bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。</li>
<li>__common 包含外部全局变量。例如在函数外定义 int i;</li>
<li>__dyld 是section占位符，用于动态链接器。</li>
</ul>
<p>更多 section 类型介绍可以查看苹果文档： <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html" target="_blank" rel="external">OS X Assembler Reference</a></p>
<p>接下来用 otool 查看下 section 里的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -s __TEXT __text a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">Contents of (__TEXT,__text) section</div><div class="line">0000000100000f50	55 48 89 e5 48 83 ec 20 48 8d 05 47 00 00 00 c7 </div><div class="line">0000000100000f60	45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 </div><div class="line">0000000100000f70	b0 00 e8 0d 00 00 00 31 c9 89 45 ec 89 c8 48 83 </div><div class="line">0000000100000f80	c4 20 5d c3</div></pre></td></tr></table></figure>
<p>这个返回的内容很难读，加个 - v  就可以查看反汇编代码了， -s <strong>TEXT </strong>text 有个缩写 -t<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -v -t a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">(__TEXT,__text) section</div><div class="line">_main:</div><div class="line">0000000100000f50	pushq	%rbp</div><div class="line">0000000100000f51	movq	%rsp, %rbp</div><div class="line">0000000100000f54	subq	$0x20, %rsp</div><div class="line">0000000100000f58	leaq	0x47(%rip), %rax</div><div class="line">0000000100000f5f	movl	$0x0, -0x4(%rbp)</div><div class="line">0000000100000f66	movl	%edi, -0x8(%rbp)</div><div class="line">0000000100000f69	movq	%rsi, -0x10(%rbp)</div><div class="line">0000000100000f6d	movq	%rax, %rdi</div><div class="line">0000000100000f70	movb	$0x0, %al</div><div class="line">0000000100000f72	callq	0x100000f84</div><div class="line">0000000100000f77	xorl	%ecx, %ecx</div><div class="line">0000000100000f79	movl	%eax, -0x14(%rbp)</div><div class="line">0000000100000f7c	movl	%ecx, %eax</div><div class="line">0000000100000f7e	addq	$0x20, %rsp</div><div class="line">0000000100000f82	popq	%rbp</div><div class="line">0000000100000f83	retq</div></pre></td></tr></table></figure>
<p>看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。</p>
<p>现在来看看可执行文件。</p>
<p>通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -h a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Mach header</div><div class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</div><div class="line">MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    15       1200   NOUNDEFS DYLDLINK TWOLEVEL PIE</div></pre></td></tr></table></figure>
<p>mach_header 结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>      magic;</div><div class="line">  <span class="keyword">cpu_type_t</span>    cputype;</div><div class="line">  <span class="keyword">cpu_subtype_t</span> cpusubtype;</div><div class="line">  <span class="keyword">uint32_t</span>      filetype;</div><div class="line">  <span class="keyword">uint32_t</span>      ncmds;</div><div class="line">  <span class="keyword">uint32_t</span>      sizeofcmds;</div><div class="line">  <span class="keyword">uint32_t</span>      flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -l a.out | open -f</div></pre></td></tr></table></figure></p>
<p>加载命令结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>  cmd;</div><div class="line">  <span class="keyword">uint32_t</span>  cmdsize;</div><div class="line">  <span class="keyword">char</span>      segname[<span class="number">16</span>];</div><div class="line">  <span class="keyword">uint32_t</span>  vmaddr;</div><div class="line">  <span class="keyword">uint32_t</span>  vmsize;</div><div class="line">  <span class="keyword">uint32_t</span>  fileoff;</div><div class="line">  <span class="keyword">uint32_t</span>  filesize;</div><div class="line">  <span class="keyword">vm_prot_t</span> maxprot;</div><div class="line">  <span class="keyword">vm_prot_t</span> initprot;</div><div class="line">  <span class="keyword">uint32_t</span>  nsects;</div><div class="line">  <span class="keyword">uint32_t</span>  flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。</p>
<p>在加载命令里还是看看 <strong>TEXT </strong>text 的section的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Section</div><div class="line">  sectname __text</div><div class="line">   segname __TEXT</div><div class="line">      addr 0x0000000100000f50</div><div class="line">      size 0x0000000000000034</div><div class="line">    offset 3920</div><div class="line">     align 2^4 (16)</div><div class="line">    reloff 0</div><div class="line">    nreloc 0</div><div class="line">      type S_REGULAR</div><div class="line">attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS</div><div class="line"> reserved1 0</div><div class="line"> reserved2 0</div></pre></td></tr></table></figure></p>
<p>addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。</p>
<p>单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。<br>Foo.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Foo : NSObject</div><div class="line"></div><div class="line">- (void)say;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Foo.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import “Foo.h”</div><div class="line"></div><div class="line">@implementation Foo</div><div class="line"></div><div class="line">- (void)say</div><div class="line">&#123;</div><div class="line">    NSLog(@“hi there again!\n”);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>SayHi.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import “Foo.h”</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        Foo *foo = [[Foo alloc] init];</div><div class="line">        [foo say];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先编译多个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang -c Foo.m</div><div class="line">xcrun clang -c SayHi.m</div></pre></td></tr></table></figure></p>
<p>再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang SayHi.o Foo.o -Wl,`xcrun —show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</div></pre></td></tr></table></figure></p>
<h2 id="逆向-Mach-O-文件"><a href="#逆向-Mach-O-文件" class="headerlink" title="逆向 Mach-O 文件"></a>逆向 Mach-O 文件</h2><p>需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。</p>
<p>Mobilesubstrate 提供了三个模块来方便开发。</p>
<ul>
<li>MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。</li>
<li>MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook  放在这里就可以了。</li>
<li>Safe mode：类似安全模式，会禁用的改动。</li>
</ul>
<p>先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。</p>
<p>当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。</p>
<ul>
<li>这里有个实例，讲解如何通过逆向实现微信抢红包的插件： <a href="http://dev.qq.com/topic/5791da152168f2690e72daa4" target="_blank" rel="external">【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB</a></li>
<li>入门文章可以看看这篇： <a href="https://github.com/zhengmin1989/MyArticles/tree/master/iOS%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C" target="_blank" rel="external">MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub</a></li>
<li>玩出新花样： <a href="http://blog.imjun.net/2016/10/08/%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%9A%E6%8A%8A%E7%AC%AC%E4%B8%89%E6%96%B9-iOS-%E5%BA%94%E7%94%A8%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/" target="_blank" rel="external">黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog</a>，作者另一篇文章： <a href="http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog</a></li>
</ul>
<h1 id="dyld动态链接"><a href="#dyld动态链接" class="headerlink" title="dyld动态链接"></a>dyld动态链接</h1><p>生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。</p>
<p>用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。</p>
<p>符号表会规定它们的符号，使用 nm 工具看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm SayHi.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _OBJC_CLASS_$_Foo</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush</div><div class="line">                 (undefined) external _objc_msgSend</div><div class="line">0000000000000000 (__TEXT,__text) external _main</div></pre></td></tr></table></figure>
<ul>
<li>_OBJC<em>CLASS</em>$_Foo 表示 Foo 的 OC 符号。</li>
<li>(undefined) external 表示未实现非私有，如果是私有就是 non-external。</li>
<li>external _main 表示 main() 函数，处理 0 地址，将要到 <strong>TEXT,</strong>text section </li>
</ul>
<p>再看看 Foo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm Foo.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject</div><div class="line">                 (undefined) external ___CFConstantStringClassReference</div><div class="line">                 (undefined) external __objc_empty_cache</div><div class="line">0000000000000000 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo</div><div class="line">00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo</div><div class="line">00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo</div><div class="line">0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>因为 undefined 符号表示该文件类未实现的，所以在目标文件和  Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。</p>
<p>链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog (from Foundation)</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</div><div class="line">                 (undefined) external __objc_empty_cache (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</div><div class="line">                 (undefined) external _objc_msgSend (from libobjc)</div><div class="line">                 (undefined) external dyld_stub_binder (from libSystem)</div><div class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</div><div class="line">0000000100000e90 (__TEXT,__text) external _main</div><div class="line">0000000100000f10 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。</p>
<p>通过 otool 可以找到所需库在哪<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -L a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">	/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0)</div><div class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)</div><div class="line">	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0)</div><div class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</div></pre></td></tr></table></figure>
<p>libSystem 里有很多我们熟悉的lib</p>
<ul>
<li>libdispatch：GCD</li>
<li>libsystem_c：C语言库</li>
<li>libsystem_blocks：Block</li>
<li>libcommonCrypto：加密，比如md5</li>
</ul>
<p>dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。</p>
<p>打印什么库被加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(export DYLD_PRINT_LIBRARIES=; ./a.out )</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dyld: loaded: /Users/didi/Downloads/./a.out</div><div class="line">dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</div><div class="line">dyld: loaded: /usr/lib/libSystem.B.dylib</div><div class="line">dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation</div><div class="line">…</div></pre></td></tr></table></figure>
<p>数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。</p>
<p>动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external">Dynamic Linking On OS X</a></p>
<p>dyld 做了些什么事</p>
<ul>
<li>kernel 做启动程序初始准备，开始由dyld负责。</li>
<li>基于非常简单的原始栈为 kernel 设置进程来启动自身。</li>
<li>使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。</li>
<li>立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。</li>
<li>为可执行文件运行静态初始化。</li>
<li>设置参数到可执行文件的 main 函数并调用它。</li>
<li>在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 runtime 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime  会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 Class，按照继承层级依次调用  +load 方法。</li>
<li>在 mian 函数返回后运行 static terminator。</li>
<li>在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。</li>
</ul>
<p>查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="external">RetVal/objc-runtime: objc runtime 706</a> 来进行断点查看调用的 runtime 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  +[someclass load]</div><div class="line">1  call_class_loads()</div><div class="line">2  ::call_load_methods</div><div class="line">3  ::load_images(const char *path __unused, const struct mach_header *mh)</div><div class="line">4  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</div><div class="line">11 _dyld_start</div></pre></td></tr></table></figure>
<p>在  load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。</p>
<p>prepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。</p>
<p>最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。</p>
<p>如果想了解 Cocoa 的 Fundation 库可以通过 <a href="https://github.com/AaronYi/gnustep-base" target="_blank" rel="external">GNUStep</a> 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。</p>
<p>dyld 是开源的： <a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">GitHub - opensource-apple/dyld</a></p>
<p>还可以看看苹果的 WWDC 视频 <a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="external">WWDC 2016 Session 406</a> 里讲解对启动进行优化。</p>
<p>这篇文章也不错： <a href="https://www.codeproject.com/articles/187181/dynamic-linking-of-imported-functions-in-mach-o" target="_blank" rel="external">Dynamic Linking of Imported Functions in Mach-O - CodeProject</a></p>
<h1 id="LLVM-工具链"><a href="#LLVM-工具链" class="headerlink" title="LLVM 工具链"></a>LLVM 工具链</h1><h2 id="获取-LLVM"><a href="#获取-LLVM" class="headerlink" title="获取 LLVM"></a>获取 LLVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#先下载 LLVM</span></div><div class="line">svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</div><div class="line"></div><div class="line"><span class="comment">#在 LLVM 的 tools 目录下下载 Clang</span></div><div class="line"><span class="built_in">cd</span> llvm/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</div><div class="line"></div><div class="line"><span class="comment">#在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabi</span></div><div class="line"><span class="built_in">cd</span> ../projects</div><div class="line">svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi</div><div class="line"></div><div class="line"><span class="comment">#在 Clang 的 tools 下安装 extra 工具</span></div><div class="line"><span class="built_in">cd</span> ../tools/clang/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</div></pre></td></tr></table></figure>
<h2 id="编译-LLVM"><a href="#编译-LLVM" class="headerlink" title="编译 LLVM"></a>编译 LLVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">brew install gcc</div><div class="line">brew install cmake</div><div class="line">mkdir build</div><div class="line"><span class="built_in">cd</span> build</div><div class="line">cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLLVM_TARGETS_TO_BUILD=<span class="string">"AArch64;X86"</span> -G <span class="string">"Unix Makefiles"</span> ..</div><div class="line">make j8</div><div class="line"><span class="comment">#安装</span></div><div class="line">make install</div><div class="line"><span class="comment">#如果找不到标准库，Xcode 需要安装 xcode-select --install</span></div></pre></td></tr></table></figure>
<p><img src="/uploads/deeply-analyse-llvm/01.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#如果希望是 xcodeproject 方式 build 可以使用 -GXcode</span></div><div class="line">mkdir xcodeBuild</div><div class="line"><span class="built_in">cd</span> xcodeBuild</div><div class="line">cmake -GXcode /path/to/llvm/<span class="built_in">source</span></div></pre></td></tr></table></figure>
<p><img src="/uploads/deeply-analyse-llvm/02.png" alt=""></p>
<p>在 bin 下存放着工具链，有了这些工具链就能够完成源码编译了。</p>
<p><img src="/uploads/deeply-analyse-llvm/03.png" alt=""></p>
<h2 id="LLVM-源码工程目录介绍"><a href="#LLVM-源码工程目录介绍" class="headerlink" title="LLVM 源码工程目录介绍"></a>LLVM 源码工程目录介绍</h2><ul>
<li>llvm/examples/ - 使用 LLVM IR 和 JIT 的例子。</li>
<li>llvm/include/ - 导出的头文件。</li>
<li>llvm/lib/ - 主要源文件都在这里。</li>
<li>llvm/project/ - 创建自己基于 LLVM 的项目的目录。</li>
<li>llvm/test/ - 基于 LLVM 的回归测试，健全检察。</li>
<li>llvm/suite/ - 正确性，性能和基准测试套件。</li>
<li>llvm/tools/ - 基于 lib 构建的可以执行文件，用户通过这些程序进行交互，-help 可以查看各个工具详细使用。</li>
<li>llvm/utils/ - LLVM 源代码的实用工具，比如，查找 LLC 和 LLI 生成代码差异工具， Vim 或 Emacs 的语法高亮工具等。</li>
</ul>
<h2 id="lib-目录介绍"><a href="#lib-目录介绍" class="headerlink" title="lib 目录介绍"></a>lib 目录介绍</h2><ul>
<li>llvm/lib/IR/ - 核心类比如 Instruction 和 BasicBlock。</li>
<li>llvm/lib/AsmParser/ - 汇编语言解析器。</li>
<li>llvm/lib/Bitcode/ - 读取和写入字节码</li>
<li>llvm/lib/Analysis/ - 各种对程序的分析，比如 Call Graphs，Induction Variables，Natural Loop Identification 等等。</li>
<li>llvm/lib/Transforms/ - IR-to-IR 程序的变换。</li>
<li>llvm/lib/Target/ - 对像 X86 这样机器的描述。</li>
<li>llvm/lib/CodeGen/ - 主要是代码生成，指令选择器，指令调度和寄存器分配。</li>
<li>llvm/lib/ExecutionEngine/ - 在解释执行和JIT编译场景能够直接在运行时执行字节码的库。</li>
</ul>
<h2 id="工具链命令介绍"><a href="#工具链命令介绍" class="headerlink" title="工具链命令介绍"></a>工具链命令介绍</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>llvm-as - 汇编器，将 .ll 汇编成字节码。</li>
<li>llvm-dis - 反汇编器，将字节码编成可读的 .ll 文件。</li>
<li>opt - 字节码优化器。</li>
<li>llc - 静态编译器，将字节码编译成汇编代码。</li>
<li>lli - 直接执行 LLVM 字节码。</li>
<li>llvm-link - 字节码链接器，可以把多个字节码文件链接成一个。</li>
<li>llvm-ar - 字节码文件打包器。</li>
<li>llvm-lib - LLVM lib.exe 兼容库工具。</li>
<li>llvm-nm - 列出字节码和符号表。</li>
<li>llvm-config - 打印 LLVM 编译选项。</li>
<li>llvm-diff - 对两个进行比较。</li>
<li>llvm-cov - 输出 coverage infomation。</li>
<li>llvm-profdata - Profile 数据工具。</li>
<li>llvm-stress - 生成随机 .ll 文件。</li>
<li>llvm-symbolizer - 地址对应源码位置，定位错误。</li>
<li>llvm-dwarfdump - 打印 DWARF。</li>
</ul>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul>
<li>bugpoint - 自动测试案例工具</li>
<li>llvm-extract - 从一个 LLVM 的模块里提取一个函数。</li>
<li>llvm-bcanalyzer - LLVM 字节码分析器。</li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul>
<li>FileCheck - 灵活的模式匹配文件验证器。</li>
<li>tblgen - C++ 代码生成器。</li>
<li>lit - LLVM 集成测试器。</li>
<li>llvm-build - LLVM 构建工程时需要的工具。</li>
<li>llvm-readobj - LLVM Object 结构查看器。</li>
</ul>
<h1 id="Swift-编译"><a href="#Swift-编译" class="headerlink" title="Swift 编译"></a>Swift 编译</h1><p>官网： <a href="https://github.com/apple/swift" target="_blank" rel="external">GitHub - apple/swift: The Swift Programming Language</a><br>swift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： <a href="https://swift.org/contributing/#contributing-code" target="_blank" rel="external">Swift.org - Contributing</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录</div><div class="line">brew install cmake ninja</div><div class="line">mkdir swiftsource</div><div class="line">cd swiftsource</div><div class="line"></div><div class="line">#clone 下 swift 源码</div><div class="line">git clone https://github.com/apple/swift.git</div><div class="line"></div><div class="line">#checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个</div><div class="line">./swift/utils/update-checkout —clone</div><div class="line"></div><div class="line">#查看文件夹</div><div class="line">du -h -d 1</div><div class="line"></div><div class="line">#build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#更新</div><div class="line">./swift/utils/update-checkout</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#切到指定tag和分支</div><div class="line">#tag</div><div class="line">./swift/utils/update-checkout —tag swift-3.0-RELEASE</div><div class="line">#特定分支</div><div class="line">./swift/utils/update-checkout —scheme swift-3.0-branch</div></pre></td></tr></table></figure>
<p>swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： <a href="https://swift.org/source-code/" target="_blank" rel="external">Swift.org - Source Code</a></p>
<h1 id="其它编译工具"><a href="#其它编译工具" class="headerlink" title="其它编译工具"></a>其它编译工具</h1><h2 id="js写的C-解释器JSCPP"><a href="#js写的C-解释器JSCPP" class="headerlink" title="js写的C++解释器JSCPP"></a>js写的C++解释器JSCPP</h2><p>适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：<a href="https://github.com/felixhao28/JSCPP" target="_blank" rel="external">GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript</a></p>
<h2 id="C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language"><a href="#C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language" class="headerlink" title="C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language"></a>C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language</h2><p>在 web 中有个 WebAssembly 是个标准，可以使得 web 运行 C/C++ 成为可能。当然还有其它的比如：<a href="http://c-smile.sourceforge.net/" target="_blank" rel="external">http://c-smile.sourceforge.net/</a></p>
<h1 id="资料网址"><a href="#资料网址" class="headerlink" title="资料网址"></a>资料网址</h1><ul>
<li><a href="http://llvm.org" target="_blank" rel="external">http://llvm.org</a></li>
<li><a href="http://clang.llvm.org/" target="_blank" rel="external">http://clang.llvm.org/</a></li>
<li><a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">http://www.aosabook.org/en/llvm.html</a></li>
<li><a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li><a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks" target="_blank" rel="external">Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow</a></li>
<li><a href="http://llvm.org/devmtg/" target="_blank" rel="external">LLVM Developers’ Metting</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="LLVM" scheme="http://ming1016.github.io/tags/LLVM/"/>
    
      <category term="Clang" scheme="http://ming1016.github.io/tags/Clang/"/>
    
  </entry>
  
  <entry>
    <title>iOS预加载Web页面方案</title>
    <link href="http://ming1016.github.io/2016/11/22/how-to-preload-web-in-ios/"/>
    <id>http://ming1016.github.io/2016/11/22/how-to-preload-web-in-ios/</id>
    <published>2016-11-22T13:55:35.000Z</published>
    <updated>2017-05-27T06:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以先下载Demo看看效果，Github地址：&lt; <a href="https://github.com/ming1016/STMURLCache" target="_blank" rel="external">GitHub - ming1016/STMURLCache: iOS预加载Web页面方案</a> &gt;<br>可以预加载多个网址，然后在离线状态去显示那几个网址，看看是不是都完全缓存下来了。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在需要开启预加载的地方创建<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.sCache = [STMURLCache create:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.whiteListsHost(whiteLists).whiteUserAgent(<span class="string">@"starming"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>这里是所有可设置项目，默认设置可以查看 model 的 get 方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) memoryCapacity;   <span class="comment">//内存容量</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) diskCapacity;     <span class="comment">//本地存储容量</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) cacheTime;        <span class="comment">//缓存时间</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) subDirectory;     <span class="comment">//子目录</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">BOOL</span>)) isDownloadMode;         <span class="comment">//是否启动下载模式</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSArray</span> *)) whiteListsHost;    <span class="comment">//域名白名单</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) whiteUserAgent;   <span class="comment">//WebView的user-agent白名单</span></div><div class="line"></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) addHostWhiteList;        <span class="comment">//添加一个域名白名单</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) addRequestUrlWhiteList;  <span class="comment">//添加请求白名单</span></div><div class="line"></div><div class="line"><span class="comment">//NSURLProtocol相关设置</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">BOOL</span>)) isUsingURLProtocol; <span class="comment">//是否使用NSURLProtocol，默认使用NSURLCache</span></div></pre></td></tr></table></figure></p>
<p>也可以随时更新这些设置项<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.sCache update:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.isDownloadMode(<span class="literal">YES</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>预加载名单可以按照整个 web 页面请求进行预加载<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.sCache preLoadByWebViewWithUrls:@[<span class="string">@"http://www.v2ex.com"</span>,<span class="string">@"http://www.github.com"</span>];</div></pre></td></tr></table></figure></p>
<p>如果需要按照单个资源列表进行预加载可以使用 <em>preLoadByRequestWithUrls</em> 这个方法。</p>
<h2 id="白名单设置"><a href="#白名单设置" class="headerlink" title="白名单设置"></a>白名单设置</h2><p>对于只希望缓存特定域名或者地址的可以通过白名单进行设置，可以在创建时进行设置或者更新时设置。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *whiteListStr = <span class="string">@"www.starming.com|www.github.com|www.v2ex.com|www.baidu.com"</span>;</div><div class="line"><span class="built_in">NSMutableArray</span> *whiteLists = [<span class="built_in">NSMutableArray</span> arrayWithArray:[whiteListStr componentsSeparatedByString:<span class="string">@"|"</span>]];</div><div class="line"><span class="keyword">self</span>.sCache = [STMURLCache create:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.whiteListsHost(whiteLists).whiteUserAgent(<span class="string">@"starming"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>这里的 <em>whiteUserAgent</em> 的设置会设置 webview 的 UserAgent，这样能够让webview以外的网络请求被过滤掉。</p>
<h2 id="基本加载缓存实现原理"><a href="#基本加载缓存实现原理" class="headerlink" title="基本加载缓存实现原理"></a>基本加载缓存实现原理</h2><p>创建 <em>STMURLCache</em> 后设置 <em>NSURLCache</em> 的 <em>URLCache</em> ，在 <em>cachedResponseForRequest</em> 方法中获取 <em>NSURLRequest</em> 判断白名单，检验是否有与之对应的 Cache ，有就使用本地数据返回 <em>NSCachedURLResponse</em> ，没有就通过网络获取数据数据缓存。 <em>STMURLCache</em> 对象释放时将 <em>NSURLCache</em> 设置为不缓存，表示这次预加载完成不需要再缓存。当缓存空间超出设置大小会将其清空。</p>
<p>使用 <em>NSURLProtocol</em> 这种原理基本类似。</p>
<h2 id="白名单实现原理"><a href="#白名单实现原理" class="headerlink" title="白名单实现原理"></a>白名单实现原理</h2><p>创建域名列表设置项 <em>whiteListsHost</em> 和 <em>userAgent</em> 设置项，在创建和更新时对其进行设置。在网络请求开始通过设置项进行过滤。具体实现如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对于域名白名单的过滤</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.whiteListsHost.count &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">id</span> isExist = [<span class="keyword">self</span>.mk.cModel.whiteListsHost objectForKey:[<span class="keyword">self</span> hostFromRequest:request]];</div><div class="line">    <span class="keyword">if</span> (!isExist) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//User-Agent来过滤</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.whiteUserAgent.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">NSString</span> *uAgent = [request.allHTTPHeaderFields objectForKey:<span class="string">@"User-Agent"</span>];</div><div class="line">    <span class="keyword">if</span> (uAgent) &#123;</div><div class="line">        <span class="keyword">if</span> (![uAgent hasSuffix:<span class="keyword">self</span>.mk.cModel.whiteUserAgent]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="具体缓存实现"><a href="#具体缓存实现" class="headerlink" title="具体缓存实现"></a>具体缓存实现</h2><p>缓存的实现有两种，一种是 <em>NSURLCache</em> 另一种是 <em>NSURLProtocol</em> ， <em>STMURLCache</em> 同时支持了这两种，通过 <em>STMURLCacheModel</em> 里的 <em>isUsingURLProtocol</em> 设置项来选择使用哪个。</p>
<h3 id="NSURLCache的实现"><a href="#NSURLCache的实现" class="headerlink" title="NSURLCache的实现"></a>NSURLCache的实现</h3><p>没有缓存的 request 会对其进行请求将获取数据按照hash地址存两份于本地，一份是数据，一份记录时间和类型，时间记录可以用于判断失效时间。对于判断是否有缓存可以根据请求地址对应的文件进行判断。具体实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSCachedURLResponse</span> *)localCacheResponeWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    __block <span class="built_in">NSCachedURLResponse</span> *cachedResponse = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span> filePathFromRequest:request isInfo:<span class="literal">NO</span>];</div><div class="line">    <span class="built_in">NSString</span> *otherInfoPath = [<span class="keyword">self</span> filePathFromRequest:request isInfo:<span class="literal">YES</span>];</div><div class="line">    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</div><div class="line">    <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="keyword">if</span> ([fm fileExistsAtPath:filePath]) &#123;</div><div class="line">        <span class="comment">//有缓存文件的情况</span></div><div class="line">        <span class="built_in">BOOL</span> expire = <span class="literal">false</span>;</div><div class="line">        <span class="built_in">NSDictionary</span> *otherInfo = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:otherInfoPath];</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cacheTime &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSInteger</span> createTime = [[otherInfo objectForKey:<span class="string">@"time"</span>] integerValue];</div><div class="line">            <span class="keyword">if</span> (createTime + <span class="keyword">self</span>.cacheTime &lt; [date timeIntervalSince1970]) &#123;</div><div class="line">                expire = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (expire == <span class="literal">false</span>) &#123;</div><div class="line">            <span class="comment">//从缓存里读取数据</span></div><div class="line">            <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</div><div class="line">            <span class="built_in">NSURLResponse</span> *response = [[<span class="built_in">NSURLResponse</span> alloc] initWithURL:request.URL MIMEType:[otherInfo objectForKey:<span class="string">@"MIMEType"</span>] expectedContentLength:data.length textEncodingName:[otherInfo objectForKey:<span class="string">@"textEncodingName"</span>]];</div><div class="line">            <span class="built_in">NSCachedURLResponse</span> *cachedResponse = [[<span class="built_in">NSCachedURLResponse</span> alloc] initWithResponse:response data:data];</div><div class="line">            <span class="keyword">return</span> cachedResponse;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//cache失效了</span></div><div class="line">            [fm removeItemAtPath:filePath error:<span class="literal">nil</span>];      <span class="comment">//清除缓存data</span></div><div class="line">            [fm removeItemAtPath:otherInfoPath error:<span class="literal">nil</span>]; <span class="comment">//清除缓存其它信息</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//从网络读取</span></div><div class="line">        <span class="keyword">self</span>.isSavedOnDisk = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">id</span> isExist = [<span class="keyword">self</span>.responseDic objectForKey:request.URL.absoluteString];</div><div class="line">        <span class="keyword">if</span> (isExist == <span class="literal">nil</span>) &#123;</div><div class="line">            [<span class="keyword">self</span>.responseDic setValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">TRUE</span>] forKey:request.URL.absoluteString];</div><div class="line">            <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</div><div class="line">            <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">                <span class="keyword">if</span> (error) &#123;</div><div class="line">                    cachedResponse = <span class="literal">nil</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">NSDictionary</span> *dic = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%f"</span>,[date timeIntervalSince1970]],<span class="string">@"time"</span>,response.MIMEType,<span class="string">@"MIMEType"</span>,response.textEncodingName,<span class="string">@"textEncodingName"</span>, <span class="literal">nil</span>];</div><div class="line">                    <span class="built_in">BOOL</span> resultO = [dic writeToFile:otherInfoPath atomically:<span class="literal">YES</span>];</div><div class="line">                    <span class="built_in">BOOL</span> result = [data writeToFile:filePath atomically:<span class="literal">YES</span>];</div><div class="line">                    <span class="keyword">if</span> (resultO == <span class="literal">NO</span> || result == <span class="literal">NO</span>) &#123;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    &#125;</div><div class="line">                    cachedResponse = [[<span class="built_in">NSCachedURLResponse</span> alloc] initWithResponse:response data:data];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            [task resume];</div><div class="line">            <span class="keyword">return</span> cachedResponse;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="NSURLProtocol的实现"><a href="#NSURLProtocol的实现" class="headerlink" title="NSURLProtocol的实现"></a>NSURLProtocol的实现</h3><p>在设置配置项和更新配置项时需要创建一个 <em>STMURLCacheModel</em> 的单例来进行设置和更新配置项给 NSURLProtocol 的实现来使用。通过 isUsingURLProtocol 设置项区分， NSURLProtocol 是通过registerClass方式将protocol实现的进行注册。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (STMURLCache *)configWithMk &#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.mk.cModel.isSavedOnDisk = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.isUsingURLProtocol) &#123;</div><div class="line">        STMURLCacheModel *sModel = [STMURLCacheModel shareInstance];</div><div class="line">        sModel.cacheTime = <span class="keyword">self</span>.mk.cModel.cacheTime;</div><div class="line">        sModel.diskCapacity = <span class="keyword">self</span>.mk.cModel.diskCapacity;</div><div class="line">        sModel.diskPath = <span class="keyword">self</span>.mk.cModel.diskPath;</div><div class="line">        sModel.cacheFolder = <span class="keyword">self</span>.mk.cModel.cacheFolder;</div><div class="line">        sModel.subDirectory = <span class="keyword">self</span>.mk.cModel.subDirectory;</div><div class="line">        sModel.whiteUserAgent = <span class="keyword">self</span>.mk.cModel.whiteUserAgent;</div><div class="line">        sModel.whiteListsHost = <span class="keyword">self</span>.mk.cModel.whiteListsHost;</div><div class="line">        [<span class="built_in">NSURLProtocol</span> registerClass:[STMURLProtocol <span class="keyword">class</span>]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="built_in">NSURLCache</span> setSharedURLCache:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关闭时两者也是不同的，通过设置项进行区分<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.isUsingURLProtocol) &#123;</div><div class="line">        [<span class="built_in">NSURLProtocol</span> unregisterClass:[STMURLProtocol <span class="keyword">class</span>]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSURLCache</span> *c = [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">0</span> diskCapacity:<span class="number">0</span> diskPath:<span class="literal">nil</span>];</div><div class="line">        [<span class="built_in">NSURLCache</span> setSharedURLCache:c];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.mk.cModel checkCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>白名单处理还有读取缓存和前者都类似，但是在缓存Data时 <em>NSURLCached</em> 的方案里是通过发起一次新的请求来获取数据，而 <em>NSURLProtocol</em> 在 <em>NSURLConnection</em> 的 Delegate 里可以获取到，少了一次网络的请求，这里需要注意的是在 - (void) connection:(NSURLConnection <em>)connection didReceiveData:(NSData </em>)data 每次从这个回调里获取的数据不是完整的，要在 - (void) connectionDidFinishLoading:(NSURLConnection *)connection 这个会调里将分段数据拼接成完整的数据保存下来。具体完整的代码实现可以看 STMURLProtocol 里的代码实现。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过 <em>map</em> 网络请求可以缓存请求，也可以 <em>mock</em> 接口请求进行测试。</p>
<p>完整代码：&lt; <a href="https://github.com/ming1016/STMURLCache" target="_blank" rel="external">GitHub - ming1016/STMURLCache: iOS预加载Web页面方案</a> &gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以先下载Demo看看效果，Github地址：&amp;lt; &lt;a href=&quot;https://github.com/ming1016/STMURLCache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub - ming1016/STMURLCach
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="UIWebView" scheme="http://ming1016.github.io/tags/UIWebView/"/>
    
      <category term="NSURLProtocol" scheme="http://ming1016.github.io/tags/NSURLProtocol/"/>
    
  </entry>
  
  <entry>
    <title>使用Swift3开发了个macOS的程序可以检测出objc项目中无用方法，然后一键全部清理</title>
    <link href="http://ming1016.github.io/2016/11/17/use-swift3-build-macos-program-to-clear-unuse-method/"/>
    <id>http://ming1016.github.io/2016/11/17/use-swift3-build-macos-program-to-clear-unuse-method/</id>
    <published>2016-11-17T13:51:58.000Z</published>
    <updated>2017-05-27T06:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>当项目越来越大，引入第三方库越来越多，上架的APP体积也会越来越大，对于用户来说体验必定是不好的。在清理资源，编译选项优化，清理无用类等完成后，能够做而且效果会比较明显的就只有清理无用函数了。现有一种方案是根据Linkmap文件取到objc的所有类方法和实例方法。再用工具逆向可执行文件里引用到的方法名，求个差集列出无用方法。这个方案有些比较麻烦的地方，因为检索出的无用方法没法确定能够直接删除，还需要挨个检索人工判断是否可以删除，这样每次要清理时都需要这样人工排查一遍是非常耗时耗力的。</p>
<p>这样就只有模拟编译过程对代码进行深入分析才能够找出确定能够删除的方法。具体效果可以先试试看，程序代码在：<a href="https://github.com/ming1016/SMCheckProject" target="_blank" rel="external">https://github.com/ming1016/SMCheckProject</a> 选择工程目录后程序就开始检索无用方法然后将其注释掉。</p>
<h2 id="设置结构体-😚"><a href="#设置结构体-😚" class="headerlink" title="设置结构体 😚"></a>设置结构体 😚</h2><p>首先确定结构，类似先把 <em>OC</em> 文件根据语法画出整体结构。先看看 <em>OC Runtime</em> 里是如何设计的结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span>  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*类*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span>  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">long</span> version;</div><div class="line">    <span class="keyword">long</span> info;</div><div class="line">    <span class="keyword">long</span> instance_size;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*成员变量列表*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> ivar_count               </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                    </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> <span class="title">ivar_list</span>[1]</span></div><div class="line">&#125;      </div><div class="line"></div><div class="line">/*成员变量结构体*/</div><div class="line"><span class="title">struct</span> <span class="title">objc_ivar</span> &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name</div><div class="line">    <span class="keyword">char</span> *ivar_type</div><div class="line">    <span class="keyword">int</span> ivar_offset</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space      </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;    </div><div class="line"></div><div class="line"><span class="comment">/*方法列表*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> &#123;</span>  </div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">obsolete</span>;</span></div><div class="line">    <span class="keyword">int</span> method_count;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*方法结构体*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> &#123;</span>  </div><div class="line">    SEL method_name;</div><div class="line">    <span class="keyword">char</span> *method_types;    <span class="comment">/* a string representing argument/return types */</span></div><div class="line">    IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>一个 class 只有少量函数会被调用，为了减少较大的遍历所以创建一个 <em>objc_cache</em> ，在找到一个方法后将 <em>method_name</em> 作为 key，将 <em>method_imp</em> 做值，再次发起时就可以直接在 cache 里找。</p>
<p>使用 swift 创建类似的结构体，做些修改<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">//文件</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="type">FileType</span>.<span class="type">FileH</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> content = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> methods = [<span class="type">Method</span>]() <span class="comment">//所有方法</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> imports = [<span class="type">Import</span>]() <span class="comment">//引入类</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//引入</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Import</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> fileName = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对象</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> superObject = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> properties = [<span class="type">Property</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> methods = [<span class="type">Method</span>]()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//成员变量</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Property</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> classMethodTf = <span class="literal">false</span> <span class="comment">//+ or -</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnType = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnTypePointTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnTypeBlockTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> params = [<span class="type">MethodParam</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> usedMethod = [<span class="type">Method</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> filePath = <span class="string">""</span> <span class="comment">//定义方法的文件路径，方便修改文件使用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> pnameId = <span class="string">""</span>  <span class="comment">//唯一标识，便于快速比较</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParam</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> typePointTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> iName = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">//todo:更多类型</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="number">0</span> <span class="comment">//0是值类型 1是指针</span></div><div class="line">&#125;</div><div class="line">```swift</div><div class="line"></div><div class="line">## 开始语法解析 😈</div><div class="line">首先遍历目录下所有的文件。</div><div class="line">```swift</div><div class="line"><span class="keyword">let</span> fileFolderPath = <span class="keyword">self</span>.selectFolder()</div><div class="line"><span class="keyword">let</span> fileFolderStringPath = fileFolderPath.replacingOccurrences(of: <span class="string">"file://"</span>, with: <span class="string">""</span>)</div><div class="line"><span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span>;</div><div class="line"><span class="comment">//深度遍历</span></div><div class="line"><span class="keyword">let</span> enumeratorAtPath = fileManager.enumerator(atPath: fileFolderStringPath)</div><div class="line"><span class="comment">//过滤文件后缀</span></div><div class="line"><span class="keyword">let</span> filterPath = <span class="type">NSArray</span>(array: (enumeratorAtPath?.allObjects)!).pathsMatchingExtensions([<span class="string">"h"</span>,<span class="string">"m"</span>])</div></pre></td></tr></table></figure></p>
<p>然后将注释排除在分析之外，这样做能够有效避免无用的解析。</p>
<p>分析是否需要按照行来切割，在 <em>@interface</em> ， <em>@end</em> 和 <em>@ implementation</em> ， <em>@end</em> 里面不需要换行，按照;符号，外部需要按行来。所以两种切割都需要。</p>
<p>先定义语法标识符<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sb</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> add = <span class="string">"+"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> minus = <span class="string">"-"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> rBktL = <span class="string">"("</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> rBktR = <span class="string">")"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> asterisk = <span class="string">"*"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> colon = <span class="string">":"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> semicolon = <span class="string">";"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> divide = <span class="string">"/"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> agBktL = <span class="string">"&lt;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> agBktR = <span class="string">"&gt;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> quotM = <span class="string">"\""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> pSign = <span class="string">"#"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> braceL = <span class="string">"&#123;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> braceR = <span class="string">"&#125;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> bktL = <span class="string">"["</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> bktR = <span class="string">"]"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> qM = <span class="string">"?"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> upArrow = <span class="string">"^"</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> inteface = <span class="string">"@interface"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> implementation = <span class="string">"@implementation"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> end = <span class="string">"@end"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> selector = <span class="string">"@selector"</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> space = <span class="string">" "</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> newLine = <span class="string">"\n"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就要开始根据标记符号来进行切割分组了，使用 <em>Scanner</em> ，具体方式如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据代码文件解析出一个根据标记符切分的数组</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createOCTokens</span>(<span class="title">conent</span>:<span class="title">String</span>) -&gt; [<span class="title">String</span>] </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = conent</div><div class="line"></div><div class="line">    str = <span class="keyword">self</span>.dislodgeAnnotaion(content: str)</div><div class="line"></div><div class="line">    <span class="comment">//开始扫描切割</span></div><div class="line">    <span class="keyword">let</span> scanner = <span class="type">Scanner</span>(string: str)</div><div class="line">    <span class="keyword">var</span> tokens = [<span class="type">String</span>]()</div><div class="line">    <span class="comment">//Todo:待处理符号,.</span></div><div class="line">    <span class="keyword">let</span> operaters = [<span class="type">Sb</span>.add,<span class="type">Sb</span>.minus,<span class="type">Sb</span>.rBktL,<span class="type">Sb</span>.rBktR,<span class="type">Sb</span>.asterisk,<span class="type">Sb</span>.colon,<span class="type">Sb</span>.semicolon,<span class="type">Sb</span>.divide,<span class="type">Sb</span>.agBktL,<span class="type">Sb</span>.agBktR,<span class="type">Sb</span>.quotM,<span class="type">Sb</span>.pSign,<span class="type">Sb</span>.braceL,<span class="type">Sb</span>.braceR,<span class="type">Sb</span>.bktL,<span class="type">Sb</span>.bktR,<span class="type">Sb</span>.qM]</div><div class="line">    <span class="keyword">var</span> operatersString = <span class="string">""</span></div><div class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> operaters &#123;</div><div class="line">        operatersString = operatersString.appending(op)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> <span class="keyword">set</span> = <span class="type">CharacterSet</span>()</div><div class="line">    <span class="keyword">set</span>.insert(charactersIn: operatersString)</div><div class="line">    <span class="keyword">set</span>.formUnion(<span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> !scanner.isAtEnd &#123;</div><div class="line">        <span class="keyword">for</span> operater <span class="keyword">in</span> operaters &#123;</div><div class="line">            <span class="keyword">if</span> (scanner.scanString(operater, into: <span class="literal">nil</span>)) &#123;</div><div class="line">                tokens.append(operater)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> result:<span class="type">NSString</span>?</div><div class="line">        result = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span> scanner.scanUpToCharacters(from: <span class="keyword">set</span>, into: &amp;result) &#123;</div><div class="line">            tokens.append(result <span class="keyword">as</span>! <span class="type">String</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    tokens = tokens.<span class="built_in">filter</span> &#123;</div><div class="line">        $<span class="number">0</span> != <span class="type">Sb</span>.space</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tokens;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行解析的方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据代码文件解析出一个根据行切分的数组</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createOCLines</span>(<span class="title">content</span>:<span class="title">String</span>) -&gt; [<span class="title">String</span>] </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = content</div><div class="line">    str = <span class="keyword">self</span>.dislodgeAnnotaion(content: str)</div><div class="line">    <span class="keyword">let</span> strArr = str.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">    <span class="keyword">return</span> strArr</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="根据结构将定义的方法取出-🤖"><a href="#根据结构将定义的方法取出-🤖" class="headerlink" title="根据结构将定义的方法取出 🤖"></a>根据结构将定义的方法取出 🤖</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithMemoryCapacity:(<span class="built_in">NSUInteger</span>)memoryCapacity diskCapacity:(<span class="built_in">NSUInteger</span>)diskCapacity diskPath:(<span class="built_in">NSString</span> *)path cacheTime:(<span class="built_in">NSInteger</span>)cacheTime subDirectory:(<span class="built_in">NSString</span>*)subDirectory;</div></pre></td></tr></table></figure>
<p>这里按照语法规则顺序取出即可，将方法名，返回类型，参数名，参数类型记录。这里需要注意 <em>Block</em> 类型的参数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (STMPartMaker *(^)(STMPartColorType))colorTypeIs;</div></pre></td></tr></table></figure></p>
<p>这种类型中还带有括号的语法的解析，这里用到的方法是对括号进行计数，左括号加一右括号减一的方式取得完整方法。</p>
<p>获得这些数据后就可以开始检索定义的方法了。我写了一个类专门用来获得所有定义的方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">parsingWithArray</span>(<span class="title">arr</span>:<span class="title">Array</span>&lt;<span class="title">String</span>&gt;) -&gt; <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> mtd = <span class="type">Method</span>()</div><div class="line">    <span class="keyword">var</span> returnTypeTf = <span class="literal">false</span> <span class="comment">//是否取得返回类型</span></div><div class="line">    <span class="keyword">var</span> parsingTf = <span class="literal">false</span> <span class="comment">//解析中</span></div><div class="line">    <span class="keyword">var</span> bracketCount = <span class="number">0</span> <span class="comment">//括弧计数</span></div><div class="line">    <span class="keyword">var</span> step = <span class="number">0</span> <span class="comment">//1获取参数名，2获取参数类型，3获取iName</span></div><div class="line">    <span class="keyword">var</span> types = [<span class="type">String</span>]()</div><div class="line">    <span class="keyword">var</span> methodParam = <span class="type">MethodParam</span>()</div><div class="line">    <span class="comment">//print("\(arr)")</span></div><div class="line">    <span class="keyword">for</span> <span class="keyword">var</span> tk <span class="keyword">in</span> arr &#123;</div><div class="line">        tk = tk.replacingOccurrences(of: <span class="type">Sb</span>.newLine, with: <span class="string">""</span>)</div><div class="line">        <span class="keyword">if</span> (tk == <span class="type">Sb</span>.semicolon || tk == <span class="type">Sb</span>.braceL) &amp;&amp; step != <span class="number">1</span> &#123;</div><div class="line">            <span class="keyword">var</span> shouldAdd = <span class="literal">false</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> mtd.params.<span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</div><div class="line">                <span class="comment">//处理这种- (void)initWithC:(type)m m2:(type2)i, ... NS_REQUIRES_NIL_TERMINATION;入参为多参数情况</span></div><div class="line">                <span class="keyword">if</span> methodParam.type.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">                    shouldAdd = <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                shouldAdd = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> shouldAdd &#123;</div><div class="line">                mtd.params.append(methodParam)</div><div class="line">                mtd.pnameId = mtd.pnameId.appending(<span class="string">"<span class="subst">\(methodParam.name)</span>:"</span>)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktL &#123;</div><div class="line">            bracketCount += <span class="number">1</span></div><div class="line">            parsingTf = <span class="literal">true</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktR &#123;</div><div class="line">            bracketCount -= <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> bracketCount == <span class="number">0</span> &#123;</div><div class="line">                <span class="keyword">var</span> typeString = <span class="string">""</span></div><div class="line">                <span class="keyword">for</span> typeTk <span class="keyword">in</span> types &#123;</div><div class="line">                    typeString = typeString.appending(typeTk)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> !returnTypeTf &#123;</div><div class="line">                    <span class="comment">//完成获取返回</span></div><div class="line">                    mtd.returnType = typeString</div><div class="line">                    step = <span class="number">1</span></div><div class="line">                    returnTypeTf = <span class="literal">true</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> step == <span class="number">2</span> &#123;</div><div class="line">                        methodParam.type = typeString</div><div class="line">                        step = <span class="number">3</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//括弧结束后的重置工作</span></div><div class="line">                parsingTf = <span class="literal">false</span></div><div class="line">                types = []</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> parsingTf &#123;</div><div class="line">            types.append(tk)</div><div class="line">            <span class="comment">//todo:返回block类型会使用.设置值的方式，目前获取用过方法方式没有.这种的解析，暂时作为</span></div><div class="line">            <span class="keyword">if</span> tk == <span class="type">Sb</span>.upArrow &#123;</div><div class="line">                mtd.returnTypeBlockTf = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">            step = <span class="number">2</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> step == <span class="number">1</span> &#123;</div><div class="line">            <span class="keyword">if</span> tk == <span class="string">"initWithCoordinate"</span> &#123;</div><div class="line">                <span class="comment">//</span></div><div class="line">            &#125;</div><div class="line">            methodParam.name = tk</div><div class="line">            step = <span class="number">0</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> step == <span class="number">3</span> &#123;</div><div class="line">            methodParam.iName = tk</div><div class="line">            step = <span class="number">1</span></div><div class="line">            mtd.params.append(methodParam)</div><div class="line">            mtd.pnameId = mtd.pnameId.appending(<span class="string">"<span class="subst">\(methodParam.name)</span>:"</span>)</div><div class="line">            methodParam = <span class="type">MethodParam</span>()</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk != <span class="type">Sb</span>.minus &amp;&amp; tk != <span class="type">Sb</span>.add &#123;</div><div class="line">            methodParam.name = tk</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;<span class="comment">//遍历</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> mtd</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法大概的思路就是根据标记符设置不同的状态，然后将获取的信息放入定义的结构中。</p>
<h2 id="使用过的方法的解析-😱"><a href="#使用过的方法的解析-😱" class="headerlink" title="使用过的方法的解析 😱"></a>使用过的方法的解析 😱</h2><p>进行使用过的方法解析前需要处理的事情</p>
<ul>
<li>@“…” 里面的数据，因为这里面是允许我们定义的标识符出现的。</li>
<li>递归出文件中 import 所有的类，根据对类的使用可以清除无用的 import</li>
<li>继承链的获取。</li>
<li>解析获取实例化了的成员变量列表。在解析时需要依赖列表里的成员变量名和变量的类进行方法的完整获取。</li>
</ul>
<p>简单的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[view update:status animation:<span class="literal">YES</span>];</div></pre></td></tr></table></figure></p>
<p>从左到右按照 : 符号获取</p>
<p>方法嵌套调用，下面这种情况如何解析出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[[[[[SMNetManager shareInstance] fetchAllFeedWithModelArray:<span class="keyword">self</span>.feeds] map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSUInteger</span> index = [value integerValue];</div><div class="line">    <span class="keyword">self</span>.feeds[index] = [SMNetManager shareInstance].feeds[index];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.feeds[index];</div><div class="line">&#125;] doCompleted:^&#123;</div><div class="line">    <span class="comment">//抓完所有的feeds</span></div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"fetch complete"</span>);</div><div class="line">    <span class="comment">//完成置为默认状态</span></div><div class="line">    <span class="keyword">self</span>.tbHeaderLabel.text = <span class="string">@""</span>;</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>;</div><div class="line">    [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">NO</span>;</div><div class="line">    <span class="comment">//下拉刷新关闭</span></div><div class="line">    [<span class="keyword">self</span>.tableView.mj_header endRefreshing];</div><div class="line">    <span class="comment">//更新列表</span></div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    <span class="comment">//检查是否需要增加源</span></div><div class="line">    <span class="keyword">if</span> ([SMFeedStore defaultFeeds].count &gt; <span class="keyword">self</span>.feeds.count) &#123;</div><div class="line">        <span class="keyword">self</span>.feeds = [SMFeedStore defaultFeeds];</div><div class="line">        [<span class="keyword">self</span> fetchAllFeeds];</div><div class="line">    &#125;</div><div class="line">&#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(SMFeedModel *feedModel) &#123;</div><div class="line">    <span class="comment">//抓完一个</span></div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.tbHeaderView;</div><div class="line">    <span class="comment">//显示抓取状态</span></div><div class="line">    <span class="keyword">self</span>.fetchingCount += <span class="number">1</span>;</div><div class="line">    <span class="keyword">self</span>.tbHeaderLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"正在获取%@...(%lu/%lu)"</span>,feedModel.title,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.fetchingCount,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.feeds.count];</div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>一开始会想到使用递归，以前我做 <em>STMAssembleView</em> 时就是使用的递归，这样时间复杂度就会是 O(nlogn) ，这次我换了个思路，将复杂度降低到了 n ，思路大概是 创建一个字典，键值就是深度，从左到右深度的增加根据 <em>[</em> 符号，减少根据 <em>]</em> 符号，值会在 <em>[</em> 时创建一个 <em>Method</em> 结构体，根据]来完成结构体，将其添加到 <em>methods</em> 数组中 。</p>
<p>具体实现如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">parsing</span>(<span class="title">contentArr</span>:<span class="title">Array</span>&lt;<span class="title">String</span>&gt;, <span class="title">inMethod</span>:<span class="title">Method</span>) -&gt; <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> mtdIn = inMethod</div><div class="line">    <span class="comment">//处理用过的方法</span></div><div class="line">    <span class="comment">//todo:还要过滤@""这种情况</span></div><div class="line">    <span class="keyword">var</span> psBrcStep = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> uMtdDic = [<span class="type">Int</span>:<span class="type">Method</span>]()</div><div class="line">    <span class="keyword">var</span> preTk = <span class="string">""</span></div><div class="line">    <span class="comment">//处理?:这种条件判断简写方式</span></div><div class="line">    <span class="keyword">var</span> psCdtTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> psCdtStep = <span class="number">0</span></div><div class="line">    <span class="comment">//判断selector</span></div><div class="line">    <span class="keyword">var</span> psSelectorTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> preSelectorTk = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> selectorMtd = <span class="type">Method</span>()</div><div class="line">    <span class="keyword">var</span> selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line"></div><div class="line">    uMtdDic[psBrcStep] = <span class="type">Method</span>() <span class="comment">//初始时就实例化一个method，避免在define里定义只定义]符号</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="keyword">var</span> tk <span class="keyword">in</span> contentArr &#123;</div><div class="line">        <span class="comment">//selector处理</span></div><div class="line">        <span class="keyword">if</span> psSelectorTf &#123;</div><div class="line">            <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">                selectorMtdPar.name = preSelectorTk</div><div class="line">                selectorMtd.params.append(selectorMtdPar)</div><div class="line">                selectorMtd.pnameId += <span class="string">"<span class="subst">\(selectorMtdPar.name)</span>:"</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktR &#123;</div><div class="line">                mtdIn.usedMethod.append(selectorMtd)</div><div class="line">                psSelectorTf = <span class="literal">false</span></div><div class="line">                selectorMtd = <span class="type">Method</span>()</div><div class="line">                selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                preSelectorTk = tk</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> tk == <span class="type">Sb</span>.selector &#123;</div><div class="line">            psSelectorTf = <span class="literal">true</span></div><div class="line">            selectorMtd = <span class="type">Method</span>()</div><div class="line">            selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//通常处理</span></div><div class="line">        <span class="keyword">if</span> tk == <span class="type">Sb</span>.bktL &#123;</div><div class="line">            <span class="keyword">if</span> psCdtTf &#123;</div><div class="line">                psCdtStep += <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">            psBrcStep += <span class="number">1</span></div><div class="line">            uMtdDic[psBrcStep] = <span class="type">Method</span>()</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.bktR &#123;</div><div class="line">            <span class="keyword">if</span> psCdtTf &#123;</div><div class="line">                psCdtStep -= <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (uMtdDic[psBrcStep]?.params.<span class="built_in">count</span>)! &gt; <span class="number">0</span> &#123;</div><div class="line">                mtdIn.usedMethod.append(uMtdDic[psBrcStep]!)</div><div class="line">            &#125;</div><div class="line">            psBrcStep -= <span class="number">1</span></div><div class="line">            <span class="comment">//[]不配对的容错处理</span></div><div class="line">            <span class="keyword">if</span> psBrcStep &lt; <span class="number">0</span> &#123;</div><div class="line">                psBrcStep = <span class="number">0</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">            <span class="comment">//条件简写情况处理</span></div><div class="line">            <span class="keyword">if</span> psCdtTf &amp;&amp; psCdtStep == <span class="number">0</span> &#123;</div><div class="line">                psCdtTf = <span class="literal">false</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//dictionary情况处理@"key":@"value"</span></div><div class="line">            <span class="keyword">if</span> preTk == <span class="type">Sb</span>.quotM || preTk == <span class="string">"respondsToSelector"</span> &#123;</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> prm = <span class="type">MethodParam</span>()</div><div class="line">            prm.name = preTk</div><div class="line">            <span class="keyword">if</span> prm.name != <span class="string">""</span> &#123;</div><div class="line">                uMtdDic[psBrcStep]?.params.append(prm)</div><div class="line">                uMtdDic[psBrcStep]?.pnameId = (uMtdDic[psBrcStep]?.pnameId.appending(<span class="string">"<span class="subst">\(prm.name)</span>:"</span>))!</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.qM &#123;</div><div class="line">            psCdtTf = <span class="literal">true</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tk = tk.replacingOccurrences(of: <span class="type">Sb</span>.newLine, with: <span class="string">""</span>)</div><div class="line">            preTk = tk</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> mtdIn</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在设置 <em>Method</em> 结构体时将参数名拼接起来成为 <em>Method</em> 的识别符用于后面处理时的快速比对。</p>
<p>解析使用过的方法时有几个问题需要注意下<br>1.在方法内使用的方法，会有 <em>respondsToSelector</em> ， <em>@selector</em> 还有条件简写语法的情况需要单独处理下。<br>2.在 <em>#define</em> 里定义使用了方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define CLASS_VALUE(x)    [NSValue valueWithNonretainedObject:(x)]</span></div></pre></td></tr></table></figure></p>
<h2 id="找出无用方法-😄"><a href="#找出无用方法-😄" class="headerlink" title="找出无用方法 😄"></a>找出无用方法 😄</h2><p>获取到所有使用方法后进行去重，和定义方法进行匹对求出差集，即全部未使用的方法。</p>
<h2 id="去除无用方法-😎"><a href="#去除无用方法-😎" class="headerlink" title="去除无用方法 😎"></a>去除无用方法 😎</h2><p>比对后获得无用方法后就要开始注释掉他们了。遍历未使用的方法，根据先前 <em>Method</em> 结构体中定义了方法所在文件路径，根据文件集结构和File的结构体，可以避免 IO ，直接获取方法对应的文件内容和路径。<br>对文件内容进行行切割，逐行检测方法名和参数，匹对时开始对行加上注释， h 文件已;符号为结束， m 文件会对大括号进行计数，逐行注释。实现的方法具体如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除指定的一组方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">delete</span>(<span class="title">methods</span>:[<span class="title">Method</span>]) </span>&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"无用方法"</span>)</div><div class="line">    <span class="keyword">for</span> aMethod <span class="keyword">in</span> methods &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(File.desDefineMethodParams(paramArr: aMethod.params)</span>)"</span>)</div><div class="line"></div><div class="line">        <span class="comment">//开始删除</span></div><div class="line">        <span class="comment">//continue</span></div><div class="line">        <span class="keyword">var</span> hContent = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mContent = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mFilePath = aMethod.filePath</div><div class="line">        <span class="keyword">if</span> aMethod.filePath.hasSuffix(<span class="string">".h"</span>) &#123;</div><div class="line">            hContent = <span class="keyword">try</span>! <span class="type">String</span>(contentsOf: <span class="type">URL</span>(string:aMethod.filePath)!, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">            <span class="comment">//todo:因为先处理了h文件的情况</span></div><div class="line">            mFilePath = aMethod.filePath.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"h"</span>)) <span class="comment">//去除头尾字符集</span></div><div class="line">            mFilePath = mFilePath.appending(<span class="string">"m"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> mFilePath.hasSuffix(<span class="string">".m"</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                mContent = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: <span class="type">URL</span>(string:mFilePath)!, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">            &#125; <span class="keyword">catch</span> &#123;</div><div class="line">                mContent = <span class="string">""</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> hContentArr = hContent.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">        <span class="keyword">let</span> mContentArr = mContent.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">        <span class="comment">//print(mContentArr)</span></div><div class="line">        <span class="comment">//----------------h文件------------------</span></div><div class="line">        <span class="keyword">var</span> psHMtdTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">var</span> hMtds = [<span class="type">String</span>]()</div><div class="line">        <span class="keyword">var</span> hMtdStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> hMtdAnnoStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> hContentCleaned = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> hOneLine <span class="keyword">in</span> hContentArr &#123;</div><div class="line">            <span class="keyword">var</span> line = hOneLine.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasPrefix(<span class="type">Sb</span>.minus) || line.hasPrefix(<span class="type">Sb</span>.add) &#123;</div><div class="line">                psHMtdTf = <span class="literal">true</span></div><div class="line">                hMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                hMtdStr = hMtdStr.appending(hOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                hMtdAnnoStr += <span class="string">"//-----由SMCheckProject工具删除-----\n//"</span></div><div class="line">                hMtdAnnoStr += hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                line = <span class="keyword">self</span>.dislodgeAnnotaionInOneLine(content: line)</div><div class="line">                line = line.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> psHMtdTf &#123;</div><div class="line">                hMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                hMtdStr = hMtdStr.appending(hOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                hMtdAnnoStr += <span class="string">"//"</span> + hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                line = <span class="keyword">self</span>.dislodgeAnnotaionInOneLine(content: line)</div><div class="line">                line = line.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                hContentCleaned += hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasSuffix(<span class="type">Sb</span>.semicolon) &amp;&amp; psHMtdTf&#123;</div><div class="line">                psHMtdTf = <span class="literal">false</span></div><div class="line"></div><div class="line">                <span class="keyword">let</span> methodPnameId = <span class="type">ParsingMethod</span>.parsingWithArray(arr: hMtds).pnameId</div><div class="line">                <span class="keyword">if</span> aMethod.pnameId == methodPnameId &#123;</div><div class="line">                    hContentCleaned += hMtdAnnoStr</div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    hContentCleaned += hMtdStr</div><div class="line">                &#125;</div><div class="line">                hMtdAnnoStr = <span class="string">""</span></div><div class="line">                hMtdStr = <span class="string">""</span></div><div class="line">                hMtds = []</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//删除无用函数</span></div><div class="line">        <span class="keyword">try</span>! hContentCleaned.write(to: <span class="type">URL</span>(string:aMethod.filePath)!, atomically: <span class="literal">false</span>, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line"></div><div class="line">        <span class="comment">//----------------m文件----------------</span></div><div class="line">        <span class="keyword">var</span> mDeletingTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">var</span> mBraceCount = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> mContentCleaned = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtdStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtdAnnoStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtds = [<span class="type">String</span>]()</div><div class="line">        <span class="keyword">var</span> psMMtdTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">for</span> mOneLine <span class="keyword">in</span> mContentArr &#123;</div><div class="line">            <span class="keyword">let</span> line = mOneLine.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> mDeletingTf &#123;</div><div class="line">                <span class="keyword">let</span> lTokens = <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                mMtdAnnoStr += <span class="string">"//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                <span class="keyword">for</span> tk <span class="keyword">in</span> lTokens &#123;</div><div class="line">                    <span class="keyword">if</span> tk == <span class="type">Sb</span>.braceL &#123;</div><div class="line">                        mBraceCount += <span class="number">1</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> tk == <span class="type">Sb</span>.braceR &#123;</div><div class="line">                        mBraceCount -= <span class="number">1</span></div><div class="line">                        <span class="keyword">if</span> mBraceCount == <span class="number">0</span> &#123;</div><div class="line">                            mContentCleaned = mContentCleaned.appending(mMtdAnnoStr)</div><div class="line">                            mMtdAnnoStr = <span class="string">""</span></div><div class="line">                            mDeletingTf = <span class="literal">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasPrefix(<span class="type">Sb</span>.minus) || line.hasPrefix(<span class="type">Sb</span>.add) &#123;</div><div class="line">                psMMtdTf = <span class="literal">true</span></div><div class="line">                mMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                mMtdStr = mMtdStr.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                mMtdAnnoStr += <span class="string">"//-----由SMCheckProject工具删除-----\n//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> psMMtdTf &#123;</div><div class="line">                mMtdStr = mMtdStr.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                mMtdAnnoStr += <span class="string">"//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                mMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mContentCleaned = mContentCleaned.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasSuffix(<span class="type">Sb</span>.braceL) &amp;&amp; psMMtdTf &#123;</div><div class="line">                psMMtdTf = <span class="literal">false</span></div><div class="line">                <span class="keyword">let</span> methodPnameId = <span class="type">ParsingMethod</span>.parsingWithArray(arr: mMtds).pnameId</div><div class="line">                <span class="keyword">if</span> aMethod.pnameId == methodPnameId &#123;</div><div class="line">                    mDeletingTf = <span class="literal">true</span></div><div class="line">                    mBraceCount += <span class="number">1</span></div><div class="line">                    mContentCleaned = mContentCleaned.appending(mMtdAnnoStr)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    mContentCleaned = mContentCleaned.appending(mMtdStr)</div><div class="line">                &#125;</div><div class="line">                mMtdStr = <span class="string">""</span></div><div class="line">                mMtdAnnoStr = <span class="string">""</span></div><div class="line">                mMtds = []</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="comment">//m文件</span></div><div class="line"></div><div class="line">        <span class="comment">//删除无用函数</span></div><div class="line">        <span class="keyword">if</span> mContent.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">try</span>! mContentCleaned.write(to: <span class="type">URL</span>(string:mFilePath)!, atomically: <span class="literal">false</span>, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整代码在：<a href="https://github.com/ming1016/SMCheckProject" target="_blank" rel="external">https://github.com/ming1016/SMCheckProject</a> 这里。</p>
<h2 id="后记-🦁"><a href="#后记-🦁" class="headerlink" title="后记 🦁"></a>后记 🦁</h2><p>有了这样的结构数据就可以模拟更多人工检测的方式来检测项目。</p>
<p>通过获取的方法结合获取类里面定义的局部变量和全局变量，在解析过程中模拟引用的计数来分析循环引用等等类似这样的检测。<br>通过获取的类的完整结构还能够将其转成JavaScriptCore能解析的js语法文件等等。</p>
<h2 id="对于APP瘦身的一些想法-👽"><a href="#对于APP瘦身的一些想法-👽" class="headerlink" title="对于APP瘦身的一些想法 👽"></a>对于APP瘦身的一些想法 👽</h2><p>瘦身应该从平时开发时就需要注意。除了功能和组件上的复用外还需要对堆栈逻辑进行封装以达到代码压缩的效果。</p>
<p>比如使用ReactiveCocoa和RxSwift这样的函数响应式编程库提供的方法和编程模式进行</p>
<p>对于UI的视图逻辑可以使用一套统一逻辑压缩代码使用DSL来简化写法等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当项目越来越大，引入第三方库越来越多，上架的APP体积也会越来越大，对于用户来说体验必定是不好的。在清理资源，编译选项优化，清理无用类等完成后，能够做而且效果会比较明显的就只有清理无用函数了。现有一种方案是根据Linkmap文件取到objc的所有类方法和实例方法。再用工具逆
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="macOS" scheme="http://ming1016.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>15，16年iPad上使用Procreate画的</title>
    <link href="http://ming1016.github.io/2016/09/20/draw-with-procreate-in-ipad-during-15-to-16/"/>
    <id>http://ming1016.github.io/2016/09/20/draw-with-procreate-in-ipad-during-15-to-16/</id>
    <published>2016-09-20T13:34:41.000Z</published>
    <updated>2017-05-27T14:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/1.png" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/2.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/3.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/4.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/5.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/6.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/7.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/8.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/9.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/10.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/11.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/12.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/13.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/draw-with-procreate-in-ipad-during-15-to-16/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-with-procreate-in-ipad-during-15
    
    </summary>
    
      <category term="我的画" scheme="http://ming1016.github.io/categories/%E6%88%91%E7%9A%84%E7%94%BB/"/>
    
    
      <category term="画" scheme="http://ming1016.github.io/tags/%E7%94%BB/"/>
    
      <category term="权利的游戏" scheme="http://ming1016.github.io/tags/%E6%9D%83%E5%88%A9%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    
      <category term="iPad" scheme="http://ming1016.github.io/tags/iPad/"/>
    
      <category term="Procreate" scheme="http://ming1016.github.io/tags/Procreate/"/>
    
  </entry>
  
  <entry>
    <title>使用ReactiveCocoa开发RSS阅读器</title>
    <link href="http://ming1016.github.io/2016/09/02/develop-rss-reader/"/>
    <id>http://ming1016.github.io/2016/09/02/develop-rss-reader/</id>
    <published>2016-09-02T13:47:59.000Z</published>
    <updated>2017-05-27T04:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前已经完成的功能有对RSS的解析和Atom解析，RSS内容本地数据库存储和读取，抓取中状态进度展示，标记阅读状态，标记全部已读等。这些功能里我对一些异步操作产生的数据采用了ReactiveCocoa来对数据流向进行了控制，下面我来说下如何运用RAC来进行的开发。</p>
<h1 id="初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新"><a href="#初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新" class="headerlink" title="初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新"></a>初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新</h1><p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot1.png?raw=true" alt="截图"></p>
<p>这里会用到RAC这个宏可以方便的来进行键值和信号的绑定，RACObserve这个宏方便的进行键值变化的监听处理。具体实现代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line"><span class="comment">//首页列表数据赋值，过滤无效数据</span></div><div class="line">RAC(<span class="keyword">self</span>, feeds) = [[[SMDB shareInstance] selectAllFeeds] filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSMutableArray</span> *feedsArray) &#123;</div><div class="line">    <span class="keyword">if</span> (feedsArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">//监听列表数据变化进行列表更新</span></div><div class="line">[RACObserve(<span class="keyword">self</span>, feeds) subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">//本地读取首页订阅源数据</span></div><div class="line">- (RACSignal *)selectAllFeeds &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        FMDatabase *db = [FMDatabase databaseWithPath:<span class="keyword">self</span>.feedDBPath];</div><div class="line">        <span class="keyword">if</span> ([db open]) &#123;</div><div class="line">            FMResultSet *rs = [db executeQuery:<span class="string">@"select * from feeds"</span>];</div><div class="line">            <span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line">            <span class="built_in">NSMutableArray</span> *feedsArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">                SMFeedModel *feedModel = [[SMFeedModel alloc] init];</div><div class="line">                feedModel.fid = [rs intForColumn:<span class="string">@"fid"</span>];</div><div class="line">                feedModel.title = [rs stringForColumn:<span class="string">@"title"</span>];</div><div class="line">                feedModel.link = [rs stringForColumn:<span class="string">@"link"</span>];</div><div class="line">                feedModel.des = [rs stringForColumn:<span class="string">@"des"</span>];</div><div class="line">                feedModel.copyright = [rs stringForColumn:<span class="string">@"copyright"</span>];</div><div class="line">                feedModel.generator = [rs stringForColumn:<span class="string">@"generator"</span>];</div><div class="line">                feedModel.imageUrl = [rs stringForColumn:<span class="string">@"imageurl"</span>];</div><div class="line">                feedModel.feedUrl = [rs stringForColumn:<span class="string">@"feedurl"</span>];</div><div class="line">                feedModel.unReadCount = [rs intForColumn:<span class="string">@"unread"</span>];</div><div class="line">                [feedsArray addObject:feedModel];</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            [subscriber sendNext:feedsArray];</div><div class="line">            [subscriber sendCompleted];</div><div class="line">            [db close];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示"><a href="#通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示" class="headerlink" title="通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示"></a>通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示</h1><p>这里的异步操作比较多，而且为了尽快取得数据采用的是并行队列，需要准确的获取到每个源完成的状态，包括解析的完成，本地存储完成，全部获取完成等数据完成情况。具体使用RAC方式的代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取所有feeds以及完成处理</span></div><div class="line">- (<span class="keyword">void</span>)fetchAllFeeds &#123;</div><div class="line">    [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.tbHeaderView;</div><div class="line">    <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>; <span class="comment">//统计抓取数量</span></div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    [[[[[[SMNetManager shareInstance] fetchAllFeedWithModelArray:<span class="keyword">self</span>.feeds] map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="built_in">NSUInteger</span> index = [value integerValue];</div><div class="line">        <span class="keyword">self</span>.feeds[index] = [SMNetManager shareInstance].feeds[index];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.feeds[index];</div><div class="line">    &#125;] doCompleted:^&#123;</div><div class="line">        <span class="comment">//抓完所有的feeds</span></div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fetch complete"</span>);</div><div class="line">        <span class="comment">//完成置为默认状态</span></div><div class="line">        <span class="keyword">self</span>.tbHeaderLabel.text = <span class="string">@""</span>;</div><div class="line">        <span class="keyword">self</span>.tableView.tableHeaderView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">        <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>;</div><div class="line">        [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">NO</span>;</div><div class="line">    &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(SMFeedModel *feedModel) &#123;</div><div class="line">        <span class="comment">//抓完一个</span></div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="comment">//显示抓取状态</span></div><div class="line">        <span class="keyword">self</span>.fetchingCount += <span class="number">1</span>;</div><div class="line">        <span class="keyword">self</span>.tbHeaderLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"正在获取%@...(%lu/%lu)"</span>,feedModel.title,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.fetchingCount,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.feeds.count];</div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"><span class="comment">//网络获取以及解析本地存储</span></div><div class="line">- (RACSignal *)fetchAllFeedWithModelArray:(<span class="built_in">NSMutableArray</span> *)modelArray &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="comment">//创建并行队列</span></div><div class="line">        <span class="built_in">dispatch_queue_t</span> fetchFeedQueue = dispatch_queue_create(<span class="string">"com.starming.fetchfeed.fetchfeed"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">        dispatch_group_t group = dispatch_group_create();</div><div class="line">        <span class="keyword">self</span>.feeds = modelArray;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; modelArray.count; i++) &#123;</div><div class="line">            dispatch_group_enter(group);</div><div class="line">            SMFeedModel *feedModel = modelArray[i];</div><div class="line">            <span class="built_in">dispatch_async</span>(fetchFeedQueue, ^&#123;</div><div class="line">                [<span class="keyword">self</span> GET:feedModel.feedUrl parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">                    <span class="comment">//解析feed</span></div><div class="line">                    <span class="keyword">self</span>.feeds[i] = [<span class="keyword">self</span>.feedStore updateFeedModelWithData:responseObject preModel:feedModel];</div><div class="line">                    <span class="comment">//入库存储</span></div><div class="line">                    SMDB *db = [[SMDB alloc] init];</div><div class="line">                    [[db insertWithFeedModel:<span class="keyword">self</span>.feeds[i]] subscribeNext:^(<span class="built_in">NSNumber</span> *x) &#123;</div><div class="line">                        SMFeedModel *model = (SMFeedModel *)<span class="keyword">self</span>.feeds[i];</div><div class="line">                        model.fid = [x integerValue];</div><div class="line">                        <span class="comment">//插入本地数据库成功后开始sendNext</span></div><div class="line">                        [subscriber sendNext:@(i)];</div><div class="line">                        <span class="comment">//通知单个完成</span></div><div class="line">                        dispatch_group_leave(group);</div><div class="line">                    &#125;];</div><div class="line"></div><div class="line">                &#125; failure:^(<span class="built_in">NSURLSessionTask</span> *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                    dispatch_group_leave(group);</div><div class="line">                &#125;];</div><div class="line"></div><div class="line">            &#125;);<span class="comment">//end dispatch async</span></div><div class="line"></div><div class="line">        &#125;<span class="comment">//end for</span></div><div class="line">        <span class="comment">//全完成后执行事件</span></div><div class="line">        dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">            [subscriber sendCompleted];</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="读取RSS列表，异步读取，主线程更新"><a href="#读取RSS列表，异步读取，主线程更新" class="headerlink" title="读取RSS列表，异步读取，主线程更新"></a>读取RSS列表，异步读取，主线程更新</h1><p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot2.png?raw=true" alt="截图"></p>
<p>这里通过RAC能够很方便的进行主线程操作UI，非主线程操作数据这样的操作，具体实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取列表数据以及对应的操作</span></div><div class="line">- (<span class="keyword">void</span>)selectFeedItems &#123;</div><div class="line">    RACScheduler *scheduler = [RACScheduler schedulerWithPriority:RACSchedulerPriorityHigh];</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    [[[[[SMDB shareInstance] selectFeedItemsWithPage:<span class="keyword">self</span>.page fid:<span class="keyword">self</span>.feedModel.fid]</div><div class="line">       subscribeOn:scheduler]</div><div class="line">      deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">     subscribeNext:^(<span class="built_in">NSMutableArray</span> *x) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.listData.count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//进入时加载</span></div><div class="line">            [<span class="keyword">self</span>.listData addObjectsFromArray:x];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//加载更多</span></div><div class="line">            <span class="keyword">self</span>.listData = x;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//刷新</span></div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">        <span class="comment">//处理无数据的显示</span></div><div class="line">        [<span class="keyword">self</span>.tableView.mj_footer endRefreshingWithNoMoreData];</div><div class="line">    &#125; completed:^&#123;</div><div class="line">        <span class="comment">//加载完成后的处理</span></div><div class="line">        [<span class="keyword">self</span>.tableView.mj_footer endRefreshing];</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.page += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//数据库获取信号</span></div><div class="line">- (RACSignal *)selectFeedItemsWithPage:(<span class="built_in">NSUInteger</span>)page fid:(<span class="built_in">NSUInteger</span>)fid &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        FMDatabase *db = [FMDatabase databaseWithPath:<span class="keyword">self</span>.feedDBPath];</div><div class="line">        <span class="keyword">if</span> ([db open]) &#123;</div><div class="line">            <span class="comment">//分页获取</span></div><div class="line">            FMResultSet *rs = [db executeQuery:<span class="string">@"select * from feeditem where fid = ? and isread = ? order by iid desc limit ?, 20"</span>,@(fid), @(<span class="number">0</span>), @(page * <span class="number">20</span>)];</div><div class="line">            <span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line">            <span class="built_in">NSMutableArray</span> *feedItemsArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="comment">//设置返回Array里的Model</span></div><div class="line">            <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">                SMFeedItemModel *itemModel = [[SMFeedItemModel alloc] init];</div><div class="line">                itemModel.iid = [rs intForColumn:<span class="string">@"iid"</span>];</div><div class="line">                itemModel.fid = [rs intForColumn:<span class="string">@"fid"</span>];</div><div class="line">                itemModel.link = [rs stringForColumn:<span class="string">@"link"</span>];</div><div class="line">                itemModel.title = [rs stringForColumn:<span class="string">@"title"</span>];</div><div class="line">                itemModel.author = [rs stringForColumn:<span class="string">@"author"</span>];</div><div class="line">                itemModel.category = [rs stringForColumn:<span class="string">@"category"</span>];</div><div class="line">                itemModel.pubDate = [rs stringForColumn:<span class="string">@"pubDate"</span>];</div><div class="line">                itemModel.des = [rs stringForColumn:<span class="string">@"des"</span>];</div><div class="line">                itemModel.isRead = [rs intForColumn:<span class="string">@"isread"</span>];</div><div class="line">                [feedItemsArray addObject:itemModel];</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                [subscriber sendNext:feedItemsArray];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//获取出错处理</span></div><div class="line">                [subscriber sendError:<span class="literal">nil</span>];</div><div class="line">            &#125;</div><div class="line">            [subscriber sendCompleted];</div><div class="line">            [db close];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot3.png?raw=true" alt="截图"></p>
<p>完整代码可以在这里看:<a href="https://github.com/ming1016/GCDFetchFeed" target="_blank" rel="external">https://github.com/ming1016/GCDFetchFeed</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前已经完成的功能有对RSS的解析和Atom解析，RSS内容本地数据库存储和读取，抓取中状态进度展示，标记阅读状态，标记全部已读等。这些功能里我对一些异步操作产生的数据采用了ReactiveCocoa来对数据流向进行了控制，下面我来说下如何运用RAC来进行的开发。&lt;/p&gt;

    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="RSSReader" scheme="http://ming1016.github.io/tags/RSSReader/"/>
    
  </entry>
  
  <entry>
    <title>iOS函数响应式编程以及ReactiveCocoa的使用</title>
    <link href="http://ming1016.github.io/2016/08/09/how-to-use-reactivecocoa/"/>
    <id>http://ming1016.github.io/2016/08/09/how-to-use-reactivecocoa/</id>
    <published>2016-08-09T13:44:10.000Z</published>
    <updated>2017-05-27T06:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅</p>
<h1 id="声明式编程泛型Declarative-programming"><a href="#声明式编程泛型Declarative-programming" class="headerlink" title="声明式编程泛型Declarative programming"></a>声明式编程泛型Declarative programming</h1><p>函数反应式编程是声明式编程的子编程范式之一</p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>需要满足两个条件</p>
<ul>
<li>一个或者多个函数作为输入。</li>
<li>有且仅有一个函数输出。</li>
</ul>
<p>objectivec里使用block作为函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">NSNumber</span> *number, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,number);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h2 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> * mappedArray = [array rx_mapWithBlock:^<span class="keyword">id</span>(<span class="keyword">id</span> each)&#123;</div><div class="line">    <span class="keyword">return</span> @(pow([each integerValue],<span class="number">2</span>));</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="过滤filter"><a href="#过滤filter" class="headerlink" title="过滤filter"></a>过滤filter</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *filteredArray = [array rx_filterWithBlock:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> each)&#123;</div><div class="line">    <span class="keyword">return</span> ([each integerValue] % <span class="number">2</span> == <span class="number">0</span>);</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<h2 id="折叠fold"><a href="#折叠fold" class="headerlink" title="折叠fold"></a>折叠fold</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[array rx_mapWithBlock:^<span class="keyword">id</span> (<span class="keyword">id</span> each)&#123;</div><div class="line">        <span class="keyword">return</span> [each stringValue];</div><div class="line">    &#125;] rx_foldInitialValue:<span class="string">@""</span> block:^<span class="keyword">id</span> (<span class="keyword">id</span> memo , <span class="keyword">id</span> each)&#123;</div><div class="line">        <span class="keyword">return</span> [memo stringByAppendingString:each];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>用函数生成另一个函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGenerator</span><span class="params">(lastnameCondition: String)</span></span> -&gt; (<span class="type">Staff</span>) -&gt; (<span class="type">Bool</span>) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;staff <span class="keyword">in</span></div><div class="line">        <span class="keyword">return</span> staff.lastname == lastnameCondition</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> filterWang = filterGenerator(<span class="string">"Wang"</span>)</div><div class="line"><span class="keyword">let</span> filterHu = filterGenerator(<span class="string">"Hu"</span>)</div><div class="line"></div><div class="line">staffs.<span class="built_in">filter</span>(filterHu)</div></pre></td></tr></table></figure></p>
<h1 id="RAC中使用高阶函数"><a href="#RAC中使用高阶函数" class="headerlink" title="RAC中使用高阶函数"></a>RAC中使用高阶函数</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[ @<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span> ];</div><div class="line">RACSequence * stream = [array rac_sequence];</div><div class="line"><span class="comment">//RACSequence是一个RACStream的子类。</span></div><div class="line">[stream map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">    <span class="keyword">return</span> @(pow([value integerValue], <span class="number">2</span>));</div><div class="line">&#125;];</div><div class="line"><span class="comment">//RACSequence有一个方法返回数组:array</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[stream array]);</div><div class="line"></div><div class="line"><span class="comment">//避免污染变量的作用域</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[[array rac_sequence] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> @(pow([value integerValue], <span class="number">2</span>));</div><div class="line">                &#125;] array]);</div></pre></td></tr></table></figure>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[array rac_sequence] filter:^<span class="built_in">BOOL</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                        <span class="keyword">return</span> [value integerValue] % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">                    &#125;] array]);</div></pre></td></tr></table></figure>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[[array rac_sequence] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> [value stringValue];</div><div class="line">                &#125;] foldLeftWithStart:<span class="string">@""</span> reduce:^<span class="keyword">id</span> (<span class="keyword">id</span> accumulator, <span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> [accumulator stringByAppendingString:value];</div><div class="line">            &#125;]);</div></pre></td></tr></table></figure>
<h2 id="绑定键值"><a href="#绑定键值" class="headerlink" title="绑定键值"></a>绑定键值</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RACSignal * validEmailSignal = [<span class="keyword">self</span>.textField.rac_textSignal map:^<span class="keyword">id</span> (<span class="built_in">NSString</span> *value)&#123;</div><div class="line">    <span class="keyword">return</span> @([value rangeOfString:<span class="string">@"@"</span>].location != <span class="built_in">NSNotFound</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RAC(<span class="keyword">self</span>.button, enabled) = validEmailSignal;</div><div class="line"></div><div class="line">RAC(<span class="keyword">self</span>.textField, textColor) = [validEmailSignal map: ^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">    <span class="keyword">if</span>([value boolValue])&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> greenColor];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> redColor];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><img src="https://github.com/ming1016/study/blob/master/pic/CombinePipeline.png?raw=true" alt="绑定键值图示"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>比较好的一个完整的RAC实践的例子：<a href="https://github.com/ashfurrow/FunctionalReactivePixels" target="_blank" rel="external">https://github.com/ashfurrow/FunctionalReactivePixels</a></p>
<h3 id="网络请求生成对应model"><a href="#网络请求生成对应model" class="headerlink" title="网络请求生成对应model"></a>网络请求生成对应model</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">+ (RACSignal *)importPhotos&#123;</div><div class="line">    RACReplaySubject * subject = [RACReplaySubject subject];</div><div class="line">    <span class="built_in">NSURLRequest</span> * request = [<span class="keyword">self</span> popularURLRequest];</div><div class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request</div><div class="line">                                    queue:[<span class="built_in">NSOperationQueue</span> mainQueue]</div><div class="line">                        completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError)&#123;</div><div class="line">                            <span class="keyword">if</span> (data) &#123;</div><div class="line">                                <span class="keyword">id</span> results = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">                                [subject sendNext:[[[results[<span class="string">@"photos"</span>] rac_sequence] map:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *photoDictionary)&#123;</div><div class="line">                                    FRPPhotoModel * model = [FRPPhotoModel new];</div><div class="line"></div><div class="line">                                    [<span class="keyword">self</span> configurePhotoModel:model withDictionary:photoDictionary];</div><div class="line">                                    [<span class="keyword">self</span> downloadThumbnailForPhotoModel:model];</div><div class="line"></div><div class="line">                                    <span class="keyword">return</span> model;</div><div class="line">                                &#125;] array]];</div><div class="line"></div><div class="line">                                [subject sendCompleted];</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span>&#123;</div><div class="line">                                [subject sendError:connectionError];</div><div class="line">                            &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> subject;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="过滤相同大小的图片，取出他们的url，返回第一个"><a href="#过滤相同大小的图片，取出他们的url，返回第一个" class="headerlink" title="过滤相同大小的图片，取出他们的url，返回第一个"></a>过滤相同大小的图片，取出他们的url，返回第一个</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSString</span> *)urlForImageSize:(<span class="built_in">NSInteger</span>)size inDictionary:(<span class="built_in">NSArray</span> *)array&#123;</div><div class="line">    <span class="keyword">return</span> [[[[[array rac_sequence] filter:^ <span class="built_in">BOOL</span> (<span class="built_in">NSDictionary</span> * value)&#123;</div><div class="line">        <span class="keyword">return</span> [value[<span class="string">@"size"</span>] integerValue] == size;</div><div class="line">    &#125;] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">        <span class="keyword">return</span> value[<span class="string">@"url"</span>];</div><div class="line">    &#125;] array] firstObject];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径"><a href="#观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径" class="headerlink" title="观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径"></a>观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setPhotoModel:(FRPPhotoModel *)photoModel&#123;</div><div class="line">    <span class="keyword">self</span>.subscription = [[[RACObserver(photoModel, thumbnailData)</div><div class="line">        filter:^ <span class="built_in">BOOL</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">            <span class="keyword">return</span> value != <span class="literal">nil</span>;</div><div class="line">        &#125;] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithData:value];</div><div class="line">        &#125;] setKeyPath:@keypath(<span class="keyword">self</span>.imageView, image) onObject:<span class="keyword">self</span>.imageView];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="UITableViewCell复用时需要取消cell上各个组件的订阅"><a href="#UITableViewCell复用时需要取消cell上各个组件的订阅" class="headerlink" title="UITableViewCell复用时需要取消cell上各个组件的订阅"></a>UITableViewCell复用时需要取消cell上各个组件的订阅</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForReuse &#123;</div><div class="line">    [<span class="keyword">super</span> prepareForReuse];</div><div class="line">    [<span class="keyword">self</span>.subscription dispose], <span class="keyword">self</span>.subscription = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Delegate的使用"><a href="#Delegate的使用" class="headerlink" title="Delegate的使用"></a>Delegate的使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意：你必须retain这个delegate对象，否则他们将会被释放，你将会得到一个EXC_BAD_ACCESS异常。添加下列私有属性到画廊视图控制器：</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> collectionViewDelegate;</div><div class="line"></div><div class="line"><span class="comment">//同时你也需要导入RACDelegateProxy.h，因为他不是ReactiveCocoa的核心部分，不包含在ReactiveCocoa.h中。</span></div><div class="line">RACDelegateProxy *viewControllerDelegate = [[RACDelegateProxy alloc]</div><div class="line">                                    initWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">FRPFullSizePhotoViewControllerDelegate</span>)];</span></div><div class="line"></div><div class="line">[[viewControllerDelegate rac_signalForSelector:<span class="keyword">@selector</span>(userDidScroll:toPhotoAtIndex:)     fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">FRPFullSizePhotoViewControllerDelegate</span>)]</span></div><div class="line">        subscribeNext:^(RACTuple *value)&#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            [<span class="keyword">self</span>.collectionView</div><div class="line">                scrollToItemAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForItem:[value.second integerValue] inSection:<span class="number">0</span>]</div><div class="line">                atScrollPosition:<span class="built_in">UICollectionViewScrollPositionCenteredVertically</span></div><div class="line">                animated:<span class="literal">NO</span>];</div><div class="line">        &#125;];</div><div class="line"></div><div class="line"><span class="keyword">self</span>.collectionViewDelegate = [[RACDelegateProxy alloc] initWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UICollectionViewDelegate</span>)];</span></div><div class="line"></div><div class="line">[[<span class="keyword">self</span>.collectionViewDelegate rac_signalForSelector:<span class="keyword">@selector</span>(collectionView:didSelectItemAtIndexPath:)]</div><div class="line">        subscribeNext:^(RACTuple *arguments) &#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            FRPFullSizePhotoViewController *viewController = [[FRPFullSizePhotoViewController alloc] initWithPhotoModels:<span class="keyword">self</span>.photosArray currentPhotoIndex:[(<span class="built_in">NSIndexPath</span> *)arguments.second item]];</div><div class="line">            viewController.delegate = (<span class="keyword">id</span>&lt;FRPFullSizePhotoViewControllerDelegate&gt;)viewControllerDelegate;</div><div class="line"></div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:viewController animated:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">        &#125;];</div></pre></td></tr></table></figure>
<h3 id="处理异常，完成执行刷新操作，异常打印日志，执行对应方法"><a href="#处理异常，完成执行刷新操作，异常打印日志，执行对应方法" class="headerlink" title="处理异常，完成执行刷新操作，异常打印日志，执行对应方法"></a>处理异常，完成执行刷新操作，异常打印日志，执行对应方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RAC(<span class="keyword">self</span>, photosArray) = [[[[FRPPhotoImporter importPhotos]</div><div class="line">        doCompleted:^&#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            [<span class="keyword">self</span>.collectionView reloadData];</div><div class="line">        &#125;] logError] catchTo:[RACSignal empty]];</div></pre></td></tr></table></figure>
<h3 id="网络请求处理数据，获取数据返回主线程"><a href="#网络请求处理数据，获取数据返回主线程" class="headerlink" title="网络请求处理数据，获取数据返回主线程"></a>网络请求处理数据，获取数据返回主线程</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+ (RACSignal *)importPhotos &#123;</div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="keyword">self</span> popularURLRequest];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[[[[[<span class="built_in">NSURLConnection</span> rac_sendAsynchronousRequest:request]</div><div class="line">                reduceEach:^<span class="keyword">id</span>(<span class="built_in">NSURLResponse</span> *response , <span class="built_in">NSData</span> *data)&#123;</div><div class="line">                    <span class="comment">//注意：我们可以用下面的reduceEach:替代使用RACTuple的第一个map:，以便提供编译时检查。</span></div><div class="line">                    <span class="keyword">return</span> data;</div><div class="line">                &#125;]</div><div class="line">                deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">                map:^<span class="keyword">id</span> (<span class="built_in">NSData</span> *data) &#123;</div><div class="line">                    <span class="keyword">id</span> results = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</div><div class="line">                    <span class="keyword">return</span> [[[results[<span class="string">@"photo"</span>] rac_sequence]</div><div class="line">                        map:^<span class="keyword">id</span> (<span class="built_in">NSDictionary</span> *photoDictionary) &#123;</div><div class="line">                            FRPPhotoModel *model = [FRPPhotoModel new];</div><div class="line">                            [<span class="keyword">self</span> configurePhotoModel:model withDictionary:photoDictionary];</div><div class="line">                            [<span class="keyword">self</span> downloadThumbnailForPhotoModel:model];</div><div class="line">                            <span class="keyword">return</span> model;</div><div class="line">                        &#125;] array];</div><div class="line">                &#125;] publish] autoconnect];</div><div class="line">    <span class="comment">//信号链条最末端的信号操作publish. publish返回一个RACMulitcastConnection,当信号连接上时，他将订阅该接收信号。autoconnect为我们做的是：当它返回的信号被订阅，连接到 该(订阅背后的)信号（underly signal）。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="信号的信号Signal-of-signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext-块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。"><a href="#信号的信号Signal-of-signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext-块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。" class="headerlink" title="信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。"></a>信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">//x</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）"><a href="#不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）" class="headerlink" title="不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）"></a>不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)requestAccessToTwitterSignal</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 定义一个错误，如果用户拒绝访问则发送</span></div><div class="line">    <span class="built_in">NSError</span> *accessError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 创建并返回信号</span></div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 请求访问twitter</span></div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        [<span class="keyword">self</span>.accountStore requestAccessToAccountsWithType:<span class="keyword">self</span>.twitterAccountType</div><div class="line">                                                   options:<span class="literal">nil</span></div><div class="line">                                                completion:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                                                    <span class="comment">// 处理响应</span></div><div class="line">                                                    <span class="keyword">if</span> (!granted)</div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendError:accessError];</div><div class="line">                                                    &#125;</div><div class="line">                                                    <span class="keyword">else</span></div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendNext:<span class="literal">nil</span>];</div><div class="line">                                                        [subscriber sendCompleted];</div><div class="line">                                                    &#125;</div><div class="line">                                                &#125;];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//throttle可以避免连续输入造成的不必要的请求，then会忽略前一个信号的值，底层的实现是先过滤之前信号发的值，再使用concat连接then返回的信号。</span></div><div class="line">[[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line">      then:^RACSignal *&#123;</div><div class="line">          @strongify(<span class="keyword">self</span>)</div><div class="line">          <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line">      &#125;]</div><div class="line">     filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">         @strongify(<span class="keyword">self</span>)</div><div class="line">         <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line">     &#125;]</div><div class="line">    throttle:<span class="number">0.5</span>]</div><div class="line">   flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">       @strongify(<span class="keyword">self</span>)</div><div class="line">       <span class="comment">//flattenMap来将每个next事件映射到一个新的被订阅的信号</span></div><div class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line">   &#125;]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="built_in">NSDictionary</span> *jsonSearchResult) &#123;</div><div class="line">     <span class="built_in">NSArray</span> *statuses = jsonSearchResult[<span class="string">@"statuses"</span>];</div><div class="line">     <span class="built_in">NSArray</span> *tweets = [statuses linq_select:^<span class="keyword">id</span>(<span class="keyword">id</span> tweet) &#123;</div><div class="line">         <span class="keyword">return</span> [RWTweet tweetWithStatus:tweet];</div><div class="line">     &#125;];</div><div class="line">     [<span class="keyword">self</span>.resultsViewController displayTweets:tweets];</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div><div class="line"> - (RACSignal *)signalForSearchWithText:(<span class="built_in">NSString</span> *)text &#123;</div><div class="line">    <span class="comment">// 1 - define the errors</span></div><div class="line">    <span class="built_in">NSError</span> *noAccountsError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain</div><div class="line">                                                   code:RWTwitterInstantErrorNoTwitterAccounts</div><div class="line">                                               userInfo:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSError</span> *invalidResponseError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain</div><div class="line">                                                        code:RWTwitterInstantErrorInvalidResponse</div><div class="line">                                                        userInfo:<span class="literal">nil</span>];</div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span> subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        SLRequest *request = [<span class="keyword">self</span> requestforTwitterSearchWithText:text];</div><div class="line">        <span class="built_in">NSArray</span> *twitterAccounts = [<span class="keyword">self</span>.accountStore accountsWithAccountType:<span class="keyword">self</span>.twitterAccountType];         <span class="keyword">if</span> (twitterAccounts.count == <span class="number">0</span>) &#123;</div><div class="line">            [subscriber sendError:noAccountsError];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [request setAccount:[twitterAccounts lastObject]];</div><div class="line">        [request performRequestWithHandler: ^(<span class="built_in">NSData</span> *responseData,</div><div class="line">                <span class="built_in">NSHTTPURLResponse</span> *urlResponse, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">            <span class="keyword">if</span> (urlResponse.statusCode == <span class="number">200</span>) &#123;</div><div class="line">                <span class="built_in">NSDictionary</span> *timelineData = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:responseData</div><div class="line">                                                options:<span class="built_in">NSJSONReadingAllowFragments</span></div><div class="line">                                                  error:<span class="literal">nil</span>];</div><div class="line">                [subscriber sendNext:timelineData];</div><div class="line">                [subscriber sendCompleted];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [subscriber sendError:invalidResponseError];</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/ming1016/study/blob/master/pic/CompletePipeline.png?raw=true" alt="不同信号顺序链接"></p>
<h3 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-(RACSignal *)signalForLoadingImage:(<span class="built_in">NSString</span> *)imageUrl &#123;</div><div class="line"></div><div class="line">    RACScheduler *scheduler = [RACScheduler</div><div class="line">                               schedulerWithPriority:RACSchedulerPriorityBackground];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:imageUrl]];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        [subscriber sendNext:image];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;] subscribeOn:scheduler];</div><div class="line">&#125;</div><div class="line"></div><div class="line">cell.twitterAvatarView.image = <span class="literal">nil</span>;</div><div class="line">[[[<span class="keyword">self</span> signalForLoadingImage:tweet.profileImageUrl]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">  subscribeNext:^(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">   cell.twitterAvatarView.image = image;</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<h3 id="观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用"><a href="#观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用" class="headerlink" title="观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用"></a>观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[[RACSignal merge: @[RACObserve(<span class="keyword">self</span>.viewModel,  tweets),</div><div class="line">                     RACObserve(<span class="keyword">self</span>.viewModel,  allTweetsLoaded)]]</div><div class="line">    bufferWithTime: <span class="number">0</span> onScheduler: [RACScheduler mainThreadScheduler]]</div><div class="line">    subscribeNext: ^(<span class="keyword">id</span> value) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125;];</div><div class="line"><span class="comment">//bufferWithTime设置为0是为了避免同一时刻两个值被同时设置新值产生了table进行了两次reloadData</span></div></pre></td></tr></table></figure>
<h3 id="封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。"><a href="#封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。" class="headerlink" title="封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。"></a>封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[tableView rac_signalForSelector:<span class="keyword">@selector</span>(layoutSubviews)]subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    [<span class="keyword">self</span> doSomethingBeforeTableViewLayoutSubviews];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等"><a href="#使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等" class="headerlink" title="使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等"></a>使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等</h3><p>Demo的github地址：<a href="https://github.com/olegam/RACCommandExample" target="_blank" rel="external">https://github.com/olegam/RACCommandExample</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindWithViewModel &#123;</div><div class="line">  RAC(<span class="keyword">self</span>.viewModel, email) =<span class="keyword">self</span>.emailTextField.rac_textSignal;</div><div class="line">  <span class="keyword">self</span>.subscribeButton.rac_command = <span class="keyword">self</span>.viewModel.subscribeCommand;</div><div class="line">  RAC(<span class="keyword">self</span>.statusLabel, text) =RACObserve(<span class="keyword">self</span>.viewModel, statusMessage);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubscribeViewModel</span> :<span class="title">NSObject</span></span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)RACCommand *subscribeCommand;  <span class="comment">// writeto this property</span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *email;  <span class="comment">// read from this property</span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *statusMessage;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"SubscribeViewModel.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"AFHTTPRequestOperationManager+RACSupport.h"</span></span></div><div class="line"><span class="meta">#import<span class="meta-string">"NSString+EmailAdditions.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kSubscribeURL =<span class="string">@"http://reactivetest.apiary.io/subscribers"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubscribeViewModel</span> ()</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSignal*emailValidSignal;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubscribeViewModel</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">       <span class="keyword">self</span>= [<span class="keyword">super</span> init];</div><div class="line">       <span class="keyword">if</span>(<span class="keyword">self</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> mapSubscribeCommandStateToStatusMessage];</div><div class="line">       &#125;</div><div class="line">       returnself;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)mapSubscribeCommandStateToStatusMessage &#123;</div><div class="line">       RACSignal *startedMessageSource = [<span class="keyword">self</span>.subscribeCommand.executionSignals map:^<span class="keyword">id</span>(RACSignal *subscribeSignal) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Sending request..."</span>, <span class="literal">nil</span>);</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RACSignal *completedMessageSource = [<span class="keyword">self</span>.subscribeCommand.executionSignals flattenMap:^RACStream *(RACSignal *subscribeSignal) &#123;</div><div class="line">              <span class="keyword">return</span>[[[subscribeSignal materialize] filter:^<span class="built_in">BOOL</span>(RACEvent *event) &#123;</div><div class="line">                     <span class="keyword">return</span> event.eventType == RACEventTypeCompleted;</div><div class="line">              &#125;] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">                     <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Thanks"</span>, <span class="literal">nil</span>);</div><div class="line">              &#125;];</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RACSignal*failedMessageSource = [[<span class="keyword">self</span>.subscribeCommand.errors subscribeOn:[RACSchedulermainThreadScheduler]] map:^<span class="keyword">id</span>(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Error :("</span>, <span class="literal">nil</span>);</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RAC(<span class="keyword">self</span>,statusMessage) = [RACSignal merge:@[startedMessageSource, completedMessageSource, failedMessageSource]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (RACCommand *)subscribeCommand &#123;</div><div class="line">       <span class="keyword">if</span>(!_subscribeCommand) &#123;</div><div class="line">              @weakify(<span class="keyword">self</span>);</div><div class="line">              _subscribeCommand = [[RACCommand alloc] initWithEnabled:<span class="keyword">self</span>.emailValidSignal signalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line">                     @strongify(<span class="keyword">self</span>);</div><div class="line">                     <span class="keyword">return</span> [SubscribeViewModel postEmail:<span class="keyword">self</span>.email];</div><div class="line">              &#125;];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> _subscribeCommand;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (RACSignal *)postEmail:(<span class="built_in">NSString</span> *)email&#123;</div><div class="line">       AFHTTPRequestOperationManager*manager = [AFHTTPRequestOperationManager manager];</div><div class="line">       manager.requestSerializer= [AFJSONRequestSerializer new];</div><div class="line">       <span class="built_in">NSDictionary</span>*body = @&#123;<span class="string">@"email"</span>: email ?: <span class="string">@""</span>&#125;;</div><div class="line">       <span class="keyword">return</span> [[[manager rac_POST:kSubscribeURL parameters:body] logError] replayLazily];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (RACSignal *)emailValidSignal &#123;</div><div class="line">       <span class="keyword">if</span>(!_emailValidSignal) &#123;</div><div class="line">              _emailValidSignal= [RACObserve(<span class="keyword">self</span>, email) map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *email) &#123;</div><div class="line">                     <span class="keyword">return</span>@([email isValidEmail]);</div><div class="line">              &#125;];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> _emailValidSignal;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="替换Delegate，直接使用RACSubject"><a href="#替换Delegate，直接使用RACSubject" class="headerlink" title="替换Delegate，直接使用RACSubject"></a>替换Delegate，直接使用RACSubject</h3><h1 id="RAC内存管理"><a href="#RAC内存管理" class="headerlink" title="RAC内存管理"></a>RAC内存管理</h1><p>RAC会维护一个全局的信号集合，一个或多于一个订阅者就可用，所有订阅者都被移除了，信号就被释放了。</p>
<h1 id="RAC需要注意的内存问题"><a href="#RAC需要注意的内存问题" class="headerlink" title="RAC需要注意的内存问题"></a>RAC需要注意的内存问题</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123; <span class="comment">//1</span></div><div class="line">        MTModel *model = [[MTModel alloc] init]; <span class="comment">// MTModel有一个名为的title的属性</span></div><div class="line">        [subscriber sendNext:model];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.flattenMapSignal = [signal flattenMap:^RACStream *(MTModel *model) &#123; <span class="comment">//2</span></div><div class="line">        <span class="keyword">return</span> RACObserve(model, title);</div><div class="line">    &#125;];</div><div class="line">    [<span class="keyword">self</span>.flattenMapSignal subscribeNext:^(<span class="keyword">id</span> x) &#123; <span class="comment">//3</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"subscribeNext - %@"</span>, x);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的RACObserve会引起引用不释放的问题，通过RACObserve的定义来看看，里面会对self进行持有。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define RACObserve(TARGET, KEYPATH) \</span></div><div class="line">    (&#123; \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic push"</span>) \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic ignored \"-Wreceiver-is-weak\""</span>) \</div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">id</span> target_ = (TARGET); \</div><div class="line">        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:<span class="keyword">self</span>]; \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic pop"</span>) \</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p>对subject进行map这样的操作，这时就需要sendCompleted<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    RACSubject *subject = [RACSubject subject];</div><div class="line">    [subject.rac_willDeallocSignal subscribeCompleted:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"subject dealloc"</span>);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [[subject map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">        <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</div><div class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"next = %@"</span>, x);</div><div class="line">    &#125;];</div><div class="line">    [subject sendNext:@<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是为什么signal进行map操作，不sendCompleted而不会内存泄漏呢。因为调到bind的比如map、filter、merge、combineLatest、flattenMap等操作如果是RACSubject这样会持有订阅者的信号会产生内存泄漏需要sendCompleted。可以先看看bind的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * -bind: should:</div><div class="line">     *</div><div class="line">     * 1. Subscribe to the original signal of values.</div><div class="line">     * 2. Any time the original signal sends a value, transform it using the binding block.</div><div class="line">     * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they're received.</div><div class="line">     * 4. If the binding block asks the bind to terminate, complete the _original_ signal.</div><div class="line">     * 5. When _all_ signals complete, send completed to the subscriber.</div><div class="line">     *</div><div class="line">     * If any signal sends an error at any point, send that to the subscriber.</div><div class="line">     */</div><div class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        RACStreamBindBlock bindingBlock = block();</div><div class="line">        <span class="built_in">NSMutableArray</span> *signals = [<span class="built_in">NSMutableArray</span> arrayWithObject:<span class="keyword">self</span>];</div><div class="line">        <span class="comment">// 此处省略了80行代码</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>didSubscribe的开头，就创建了一个数组signals，并且持有了self，也就是源信号，也就是订阅者持有了信号，如果是Subject那么这种信号又会持有订阅者，这样就形成了循环引用。</p>
<p>下面看看sendCompleted如何修复的内存泄漏<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^completeSignal)(RACSignal *, RACDisposable *) = ^(RACSignal *signal, RACDisposable *finishedDisposable) &#123;</div><div class="line">    <span class="built_in">BOOL</span> removeDisposable = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">@synchronized</span> (signals) &#123;</div><div class="line">        [signals removeObject:signal]; <span class="comment">//1</span></div><div class="line">        <span class="keyword">if</span> (signals.count == <span class="number">0</span>) &#123;</div><div class="line">            [subscriber sendCompleted]; <span class="comment">//2</span></div><div class="line">            [compoundDisposable dispose]; <span class="comment">//3</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            removeDisposable = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (removeDisposable) [compoundDisposable removeDisposable:finishedDisposable]; <span class="comment">//4</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从signals这个数组中移除传入的signal，也就是让订阅的signal不会持有subject这种信号。</p>
<p>还有replay这样的操作，因为这个方法返回的是一个RACReplaySubject<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    [subscriber sendNext:@<span class="number">1</span>];</div><div class="line">    [subscriber sendCompleted]; <span class="comment">// 保证源信号发送完成</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *replaySignal = [signal replay]; <span class="comment">// 这里返回的其实是一个RACReplaySubject</span></div><div class="line"></div><div class="line">[[replaySignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">    <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscribeNext - %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h1 id="热信号冷信号"><a href="#热信号冷信号" class="headerlink" title="热信号冷信号"></a>热信号冷信号</h1><ul>
<li>热信号是主动的，不订阅也能够按时发送。冷信号是被动的，只有订阅才会发送。</li>
<li>热信号可以有多个订阅者。冷信号只能够一对一，有不同订阅者，消息会从新完整发送。</li>
</ul>
<h1 id="RAC的API手册"><a href="#RAC的API手册" class="headerlink" title="RAC的API手册"></a>RAC的API手册</h1><h2 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h2><h3 id="RACSiganl-信号类。"><a href="#RACSiganl-信号类。" class="headerlink" title="RACSiganl 信号类。"></a>RACSiganl 信号类。</h3><ul>
<li>RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法；</li>
<li>RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法；</li>
<li>RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；</li>
<li>RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法；</li>
<li>RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。</li>
</ul>
<h3 id="RACSubscriber-订阅者"><a href="#RACSubscriber-订阅者" class="headerlink" title="RACSubscriber 订阅者"></a>RACSubscriber 订阅者</h3><h3 id="RACDisposable-用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。"><a href="#RACDisposable-用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。" class="headerlink" title="RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。"></a>RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</h3><ul>
<li>RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来；</li>
<li>RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察；</li>
<li>RACCompoundDisposable ：它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象</li>
<li>RACScopedDisposable ：当它被 dealloc 的时候调用本身的 -dispose 方法。</li>
</ul>
<h3 id="RACSubject-信号提供者，自己可以充当信号，又能发送信号。订阅后发送"><a href="#RACSubject-信号提供者，自己可以充当信号，又能发送信号。订阅后发送" class="headerlink" title="RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送"></a>RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送</h3><ul>
<li>RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能；</li>
<li>RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值；</li>
<li>RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。可以先发送后订阅</li>
</ul>
<h3 id="RACTuple-元组类-类似NSArray-用来包装值"><a href="#RACTuple-元组类-类似NSArray-用来包装值" class="headerlink" title="RACTuple 元组类,类似NSArray,用来包装值."></a>RACTuple 元组类,类似NSArray,用来包装值.</h3><h3 id="RACSequence-RAC中的集合类"><a href="#RACSequence-RAC中的集合类" class="headerlink" title="RACSequence RAC中的集合类"></a>RACSequence RAC中的集合类</h3><h3 id="RACCommand-RAC中用于处理事件的类，可以把事件如何处理-事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。"><a href="#RACCommand-RAC中用于处理事件的类，可以把事件如何处理-事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。" class="headerlink" title="RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。"></a>RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</h3><h3 id="RACMulticastConnection-用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。"><a href="#RACMulticastConnection-用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。" class="headerlink" title="RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。"></a>RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</h3><h3 id="RACScheduler-RAC中的队列，用GCD封装的。"><a href="#RACScheduler-RAC中的队列，用GCD封装的。" class="headerlink" title="RACScheduler RAC中的队列，用GCD封装的。"></a>RACScheduler RAC中的队列，用GCD封装的。</h3><ul>
<li>RACImmediateScheduler ：立即执行调度的任务，这是唯一一个支持同步执行的调度器；</li>
<li>RACQueueScheduler ：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务；</li>
<li>RACTargetQueueScheduler ：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务；</li>
<li>RACSubscriptionScheduler ：一个只用来调度订阅的调度器。</li>
</ul>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><ul>
<li>rac_signalForSelector : 代替代理</li>
<li>rac_valuesAndChangesForKeyPath: KVO</li>
<li>rac_signalForControlEvents:监听事件</li>
<li>rac_addObserverForName 代替通知</li>
<li>rac_textSignal：监听文本框文字改变</li>
<li>rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
</ul>
<h2 id="常见宏"><a href="#常见宏" class="headerlink" title="常见宏"></a>常见宏</h2><ul>
<li>RAC(TARGET, [KEYPATH, [NIL_VALUE]])：用于给某个对象的某个属性绑定</li>
<li>RACObserve(self, name) ：监听某个对象的某个属性,返回的是信号。</li>
<li>@weakify(Obj)和@strongify(Obj)</li>
<li>RACTuplePack ：把数据包装成RACTuple（元组类）</li>
<li>RACTupleUnpack：把RACTuple（元组类）解包成对应的数据</li>
<li>RACChannelTo 用于双向绑定的一个终端</li>
</ul>
<h2 id="常用操作方法"><a href="#常用操作方法" class="headerlink" title="常用操作方法"></a>常用操作方法</h2><ul>
<li>flattenMap map 用于把源信号内容映射成新的内容。</li>
<li>concat 组合 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号</li>
<li>then 用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</li>
<li>merge 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用</li>
<li>zipWith 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。</li>
<li>combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</li>
<li>reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值</li>
<li>filter:过滤信号，使用它可以获取满足条件的信号.</li>
<li>ignore:忽略完某些值的信号.</li>
<li>distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</li>
<li>take:从开始一共取N次的信号</li>
<li>takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.</li>
<li>takeUntil:(RACSignal *):获取信号直到某个信号执行完成</li>
<li>skip:(NSUInteger):跳过几个信号,不接受。</li>
<li>switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</li>
<li>doNext: 执行Next之前，会先执行这个Block</li>
<li>doCompleted: 执行sendCompleted之前，会先执行这个Block</li>
<li>timeout：超时，可以让一个信号在一定的时间后，自动报错。</li>
<li>interval 定时：每隔一段时间发出信号</li>
<li>delay 延迟发送next。</li>
<li>retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</li>
<li>replay重放：当一个信号被多次订阅,反复播放内容</li>
<li>throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</li>
</ul>
<h2 id="UI-Category（常用汇总）"><a href="#UI-Category（常用汇总）" class="headerlink" title="UI - Category（常用汇总）"></a>UI - Category（常用汇总）</h2><h3 id="rac-prepareForReuseSignal：-需要复用时用"><a href="#rac-prepareForReuseSignal：-需要复用时用" class="headerlink" title="rac_prepareForReuseSignal： 需要复用时用"></a>rac_prepareForReuseSignal： 需要复用时用</h3><ul>
<li>相关UI: MKAnnotationView、UICollectionReusableView、UITableViewCell、UITableViewHeaderFooterView</li>
</ul>
<h3 id="rac-buttonClickedSignal：点击事件触发信号"><a href="#rac-buttonClickedSignal：点击事件触发信号" class="headerlink" title="rac_buttonClickedSignal：点击事件触发信号"></a>rac_buttonClickedSignal：点击事件触发信号</h3><ul>
<li>相关UI：UIActionSheet、UIAlertView</li>
</ul>
<h3 id="rac-command：button类、刷新类相关命令替换"><a href="#rac-command：button类、刷新类相关命令替换" class="headerlink" title="rac_command：button类、刷新类相关命令替换"></a>rac_command：button类、刷新类相关命令替换</h3><ul>
<li>相关UI：UIBarButtonItem、UIButton、UIRefreshControl</li>
</ul>
<h3 id="rac-signalForControlEvents-control-event-触发"><a href="#rac-signalForControlEvents-control-event-触发" class="headerlink" title="rac_signalForControlEvents: control event 触发"></a>rac_signalForControlEvents: control event 触发</h3><ul>
<li>相关UI：UIControl</li>
</ul>
<h3 id="rac-gestureSignal-UIGestureRecognizer-事件处理信号"><a href="#rac-gestureSignal-UIGestureRecognizer-事件处理信号" class="headerlink" title="rac_gestureSignal UIGestureRecognizer 事件处理信号"></a>rac_gestureSignal UIGestureRecognizer 事件处理信号</h3><ul>
<li>相关UI：UIGestureRecognizer</li>
</ul>
<h3 id="rac-imageSelectedSignal-选择图片的信号"><a href="#rac-imageSelectedSignal-选择图片的信号" class="headerlink" title="rac_imageSelectedSignal 选择图片的信号"></a>rac_imageSelectedSignal 选择图片的信号</h3><ul>
<li>相关UI：UIImagePickerController</li>
</ul>
<h3 id="rac-textSignal"><a href="#rac-textSignal" class="headerlink" title="rac_textSignal"></a>rac_textSignal</h3><ul>
<li>相关UI：UITextField、UITextView</li>
</ul>
<h3 id="可实现双向绑定的相关API"><a href="#可实现双向绑定的相关API" class="headerlink" title="可实现双向绑定的相关API"></a>可实现双向绑定的相关API</h3><ul>
<li>rac_channelForControlEvents: key: nilValue:</li>
<li>相关UI：UIControl类</li>
<li>rac_newDateChannelWithNilValue:</li>
<li>相关UI：UIDatePicker</li>
<li>rac_newSelectedSegmentIndexChannelWithNilValue:</li>
<li>相关UI：UISegmentedControl</li>
<li>rac_newValueChannelWithNilValue:</li>
<li>相关UI：UISlider、UIStepper</li>
<li>rac_newOnChannel</li>
<li>相关UI：UISwitch</li>
<li>rac_newTextChannel</li>
<li>相关UI：UITextField</li>
</ul>
<h2 id="Foundation-Category-（常用汇总）"><a href="#Foundation-Category-（常用汇总）" class="headerlink" title="Foundation - Category （常用汇总）"></a>Foundation - Category （常用汇总）</h2><h3 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h3><ul>
<li>rac_readContentsOfURL: options: scheduler: 比oc多出线程设置</li>
</ul>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><ul>
<li>rac_sequence</li>
<li>rac_keySequence key 集合</li>
<li>rac_valueSequence value 集合</li>
</ul>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><ul>
<li>rac_sequence 信号集合</li>
</ul>
<h3 id="NSFileHandle"><a href="#NSFileHandle" class="headerlink" title="NSFileHandle"></a>NSFileHandle</h3><ul>
<li>rac_readInBackground 后台线程读取</li>
</ul>
<h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><ul>
<li>rac_setArgument: atIndex: 设置参数</li>
<li>rac_argumentAtIndex 取某个参数</li>
<li>rac_returnValue 所关联方法的返回值</li>
</ul>
<h3 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h3><ul>
<li>rac_addObserverForName: object:注册通知</li>
</ul>
<h3 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h3><ul>
<li>rac_willDeallocSignal 对象销毁时发动的信号</li>
<li>rac_description debug用</li>
<li>rac_observeKeyPath: options: observer: block:监听某个事件</li>
<li>rac_liftSelector: withSignals: 全部信号都next在执行</li>
<li>rac_signalForSelector: 代替某个方法</li>
<li>rac_signalForSelector:(SEL)selector fromProtocol:代替代理</li>
</ul>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><ul>
<li>rac_keyPathComponents 获取一个路径所有的部分</li>
<li>rac_keyPathByDeletingLastKeyPathComponent 删除路径最后一部分</li>
<li>rac_keyPathByDeletingFirstKeyPathComponent 删除路径第一部分</li>
<li>rac_readContentsOfURL: usedEncoding: scheduler: 比之OC多线程调用</li>
<li>rac_sequence</li>
</ul>
<h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><ul>
<li>rac_sendAsynchronousRequest 发起异步请求</li>
</ul>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><ul>
<li>rac_channelTerminalForKey 用于双向绑定，此乃一</li>
</ul>
<h3 id="NSEnumerator"><a href="#NSEnumerator" class="headerlink" title="NSEnumerator"></a>NSEnumerator</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSIndexSet"><a href="#NSIndexSet" class="headerlink" title="NSIndexSet"></a>NSIndexSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSOrderedSet"><a href="#NSOrderedSet" class="headerlink" title="NSOrderedSet"></a>NSOrderedSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h1 id="RAC图片版的API手册"><a href="#RAC图片版的API手册" class="headerlink" title="RAC图片版的API手册"></a>RAC图片版的API手册</h1><h2 id="ReactiveCocoa-objectivec"><a href="#ReactiveCocoa-objectivec" class="headerlink" title="ReactiveCocoa objectivec"></a>ReactiveCocoa objectivec</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/ReactiveCocoaOC.png?raw=true" alt="ReactiveCocoaobjectivec"></p>
<h2 id="ReactiveCocoa-Swift"><a href="#ReactiveCocoa-Swift" class="headerlink" title="ReactiveCocoa Swift"></a>ReactiveCocoa Swift</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/ReactiveCocoaSwift.png?raw=true" alt="ReactiveCocoaSwift"></p>
<h2 id="RXSwift"><a href="#RXSwift" class="headerlink" title="RXSwift"></a>RXSwift</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/RXSwift.png?raw=true" alt="RXSwift"></p>
<h1 id="本文参考整理自"><a href="#本文参考整理自" class="headerlink" title="本文参考整理自"></a>本文参考整理自</h1><ul>
<li>ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2 <a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1</a></li>
<li>ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2 <a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2</a></li>
<li>iOS的函数响应型编程 <a href="https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details" target="_blank" rel="external">https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details</a></li>
<li>ReactiveCocoa Essentials: Understanding and Using RACCommand <a href="http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/" target="_blank" rel="external">http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/</a></li>
<li>iOS ReactiveCocoa 最全常用API整理（可做为手册查询）<a href="http://www.cocoachina.com/ios/20160729/17236.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20160729/17236.html</a></li>
<li>ReactiveCocoa和RXSwift速查表 <a href="http://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/" target="_blank" rel="external">http://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/</a></li>
<li>ReactiveCocoa中潜在的内存泄漏及解决方案<a href="http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅&lt;/p&gt;
&lt;h1 id=&quot;声明式编程泛型Declarative-programming&quot;&gt;&lt;a href=&quot;#声明式编程泛型Declarative-programming&quot;
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://ming1016.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>制作一个类似苹果VFL(Visual Format Language)的格式化语言来描述类似UIStackView那种布局思路，并解析生成页面</title>
    <link href="http://ming1016.github.io/2016/07/21/assembleview/"/>
    <id>http://ming1016.github.io/2016/07/21/assembleview/</id>
    <published>2016-07-21T13:38:01.000Z</published>
    <updated>2017-05-26T13:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中总是希望页面上各处的文字，颜色，字体大小甚至各个视图控件布局都能够在发版之后能够修改以弥补一些前期考虑不周，或者根据统计数据能够随时进行调整，当然是各个版本都能够统一变化。看到这样的要求后，第一反应是这样的页面只能改成H5，或者尝试使用React Native来应对这种要求。</p>
<p>既然UIStackView已经提供了一种既先进又简洁的布局思路，为何不通过制作一个类似VFL这样的DSL语言来处理布局。这样不就能够通过下发一串DSL字符串的方式来进行内容样式甚至布局的更换，不用跟版，还能使多版本统一。同时在端内直接用这样的DSL语言来写界面不光能够减少代码量易于维护，还能够很直观方便的看出整个界面布局结构。</p>
<h1 id="AssembleView（组装视图）和PartView（零件视图）"><a href="#AssembleView（组装视图）和PartView（零件视图）" class="headerlink" title="AssembleView（组装视图）和PartView（零件视图）"></a>AssembleView（组装视图）和PartView（零件视图）</h1><p>在设计格式化语言之前需要对布局做个统一思想进行管理，在看了WWDC里关于UIStackView的介绍后感觉任何复杂的布局都能够通过这样一种组合排布再组合排布的思路特别适合用格式化语言来描述。于是我想出两个视图概念。</p>
<p>一个是AssembleView组合视图，专门用于对其PartView子视图进行排列，比如说是水平排列还是垂直排列，PartView是按照居中对齐还是居左等对齐方式，各个PartView之间间隔是多少。</p>
<p>PartView决定自己视图类型，内容，无固定大小的可以设置大小，同时AssembleView可以作为PartView被加入另一个AssembleView里进行排列，这样各种设计图都可以在初期通过拆解分成不同的AssembleView和PartView进行组合套组合布局出来。</p>
<h1 id="格式化语言"><a href="#格式化语言" class="headerlink" title="格式化语言"></a>格式化语言</h1><p>接下来是如何通过格式化语言来描述AssembleView和PartView。“{}”符号里包含的是AssembleView的设置，“[]”符号里是PartView的设置，“()”里是他们的属性设置，“&lt;&gt;”可以将对象带入到设置里。下面举几个例子说明下。完整Demo放到了Github上：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">https://github.com/ming1016/STMAssembleView</a></p>
<h2 id="三个星星水平对齐居中排列"><a href="#三个星星水平对齐居中排列" class="headerlink" title="三个星星水平对齐居中排列"></a>三个星星水平对齐居中排列</h2><p>h表示水平排列horizontal，c表示居中center，“[]”PartView会根据顺序依次添加排列，imageName属性能够指定本地图片<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/center.png?raw=true" alt="三个星星水平对齐居中排列"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    hc(padding:30)</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView里套作为PartView的AssembleView的复杂情况"><a href="#AssembleView里套作为PartView的AssembleView的复杂情况" class="headerlink" title="AssembleView里套作为PartView的AssembleView的复杂情况"></a>AssembleView里套作为PartView的AssembleView的复杂情况</h2><p>color可以指定文字颜色，font指定文字大小<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/mid.png?raw=true" alt="AssembleView里套作为PartView的AssembleView的复杂情况"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    ht(padding:10)</div><div class="line">    [avatarImageView(imageName:avatar)]</div><div class="line">    [</div><div class="line">        &#123;</div><div class="line">            vl(padding:10)</div><div class="line">            [(text:戴铭,color:AAA0A3)]</div><div class="line">            [(text:Starming站长,color:E3DEE0,font:13)]</div><div class="line">            [(text:喜欢画画编程和写小说,color:E3DEE0,font:13)]</div><div class="line">        &#125;</div><div class="line">        (width:210,backColor:FAF8F9,backPaddingHorizontal:10,backPaddingVertical:10,radius:8)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="给PartView设置背景色和按钮"><a href="#给PartView设置背景色和按钮" class="headerlink" title="给PartView设置背景色和按钮"></a>给PartView设置背景色和按钮</h2><p>设置背景色使用backColor，背景距离设置的PartView的内容间距通过backPaddingHorizontal属性设置水平间距，backPaddingVertical设置垂直间距，“&lt;&gt;”符号带入的button通过button属性设置。<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/followBt.png?raw=true" alt="给PartView设置背景色和按钮"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        hc(padding:4)</div><div class="line">        [(imageName:starmingicon,width:14,height:10)]</div><div class="line">        [(text:关注,font:16,color:FFFFFF)]</div><div class="line">    &#125;</div><div class="line">    (height:36,backColor:AAA0A3,radius:8,backBorderWidth:1,backBorderColor:E3DEE0,backPaddingHorizontal:80,backPaddingVertical:10,button:&lt;clickBt&gt;)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView设置忽略约束的方法"><a href="#AssembleView设置忽略约束的方法" class="headerlink" title="AssembleView设置忽略约束的方法"></a>AssembleView设置忽略约束的方法</h2><p>水平排列时，通过ignoreAlignment属性设置忽略left约束，如果是垂直排列设置top忽略。<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/des.png?raw=true" alt="AssembleView设置忽略约束的方法"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    hc(padding:5)</div><div class="line">    [(text:STMAssembleView演示,color:E3DEE0,font:13)]</div><div class="line">    [(imageName:starmingicon,width:14,height:10,ignoreAlignment:left)]</div><div class="line">    [(text:Starming星光社,color:E3DEE0,font:13)]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="将前面的视图组合成一个AssembleView"><a href="#将前面的视图组合成一个AssembleView" class="headerlink" title="将前面的视图组合成一个AssembleView"></a>将前面的视图组合成一个AssembleView</h2><p><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/as.png?raw=true" alt="将前面的视图组合成一个AssembleView"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ASS(@&quot;&#123;</div><div class="line">    vc(padding:20)</div><div class="line">    [%@(height:90)]</div><div class="line">    [%@(height:36,backColor:AAA0A3,radius:8,backBorderWidth:1,backBorderColor:E3DEE0,backPaddingHorizontal:80,backPaddingVertical:10,button:&lt;clickBt&gt;)]</div><div class="line">    [%@(height:25)]</div><div class="line">    [%@(ignoreAlignment:top,isFill:1,height:16)]</div><div class="line">&#125;&quot;,midStr,followBtStr,centerStr,desStr)</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView的属性"><a href="#AssembleView的属性" class="headerlink" title="AssembleView的属性"></a>AssembleView的属性</h2><ul>
<li>当在“{}”里面第一个字母是v表示垂直排列vertical，是h表示水平排列horizontal</li>
<li>第二个字母是c表示所有PartView居中对齐center，l表示居左对齐left，r表示居右对齐right，t表示居上对齐top，b表示居下对齐bottom。</li>
<li>padding：默认各个PartView的间距。</li>
</ul>
<h2 id="PartView的属性"><a href="#PartView的属性" class="headerlink" title="PartView的属性"></a>PartView的属性</h2><p>如果不希望通过属性生成视图，可以通过在[后直接填入带入对象对应的key，然后再在()里设置属性。</p>
<h3 id="PartView布局相关属性"><a href="#PartView布局相关属性" class="headerlink" title="PartView布局相关属性"></a>PartView布局相关属性</h3><ul>
<li>width：UILabel和UIImage这样有固定大小的可以不用设置，会按照固定大小的来。</li>
<li>height：有固定大小的可以不用设置。</li>
<li>isFill：垂直排列时会将宽设置为父AssembleView的宽，水平排列时会将高设置为父AssembleView的高。</li>
<li>padding：设置后会忽略父AssembleView里设置的padding，达到自定义间距的效果。</li>
<li>partAlignment：可以自定义对齐方向，设置后会忽略父AssembleView里设置的对齐。值可填center，left，right，top，bottom。</li>
<li>ignoreAlignment：设置忽略的约束方向，在父AssembleView不需要由子PartView决定大小的情况下，可以通过打断某个方向约束来实现拆开排列的效果。值可填center，left，right，top，bottom。</li>
</ul>
<h3 id="PartView权重相关属性"><a href="#PartView权重相关属性" class="headerlink" title="PartView权重相关属性"></a>PartView权重相关属性</h3><ul>
<li>crp：Compression Resistance Priority的设置，根据权重由低到高值可以设置为fit，low，high，required。对应的UILayoutPriority的分别是UILayoutPriorityFittingSizeLevel，UILayoutPriorityDefaultLow，UILayoutPriorityDefaultHigh，UILayoutPriorityRequired。</li>
<li>minWidth：对应NSLayoutRelationGreaterThanOrEqual，设置一个最小的宽</li>
<li>maxWidth：对应NSLayoutRelationLessThanOrEqual，设置一个最大的宽</li>
</ul>
<h3 id="PartView视图控件相关设置"><a href="#PartView视图控件相关设置" class="headerlink" title="PartView视图控件相关设置"></a>PartView视图控件相关设置</h3><p>通过以下属性即可生成对应的UILabel，UIImageView或者UIButton等控件视图，而不用特别指出需要生成哪种控件视图</p>
<ul>
<li>text：设置文字内容</li>
<li>font：设置字体，可以带入一个UIFont，也可以直接设置一个字体大小，解析时会判断类型。</li>
<li>color：设置颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>imageName：设置本地图片，值是本地图片名称。</li>
<li>image：带入一个UIImage。</li>
<li>imageUrl：设置一个网络图片的url地址，ps:目前需要通过&lt;&gt;来带入一个字符串。</li>
</ul>
<h3 id="PartView的通用设置"><a href="#PartView的通用设置" class="headerlink" title="PartView的通用设置"></a>PartView的通用设置</h3><p>可以为PartView创建一个底部视图，并设置其样式。也可以添加一个UIButton设置UIControlStateHighlighted时的样式。</p>
<ul>
<li>backColor：设置底部视图的颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>backPaddingHorizontal：设置当前PartView视图距离底部视图top和bottom的间距。</li>
<li>backPaddingVertical：设置当前PartView视图距离底部视图left和right的间距。</li>
<li>backBorderColor：设置底部视图边框的颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>backBorderWidth：设置底部视图边框宽。</li>
<li>radius：设置底部视图的圆角半径。</li>
<li>button：带入一个button。</li>
<li>buttonHighlightColor：设置button在UIControlStateHighlighted时的颜色，默认是透明度0.05的黑色。</li>
</ul>
<h1 id="解析格式化语言"><a href="#解析格式化语言" class="headerlink" title="解析格式化语言"></a>解析格式化语言</h1><p>解析过程的第一步采用扫描scanner程序将字符串按照分析符号表将字符流序列收集到有意义的单元中。</p>
<p>第二步将这些单元逐个归类到对应的类别中。比如解析到“()”里内容时就将其归类到对应的AssembleView的属性或者PartView的属性类别中。在归类过程中会出现PartView是AssembleView，这个Assemble里面又有这样作为PartView的AssembleView这样层层套的情况，所以需要采用类似引用计数方式保证在最后一个“}”符号结束时能将整个Assemble递归进行解析。</p>
<p>第三步将各个类别集合转换成对应原生代码从而生成对应的视图布局。</p>
<p>具体实现可以查看STMAssembleView.m文件。Github地址：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">https://github.com/ming1016/STMAssembleView</a></p>
<h1 id="如何生成页面"><a href="#如何生成页面" class="headerlink" title="如何生成页面"></a>如何生成页面</h1><p>生成页面需要实现格式化语言对应的原生代码，所有PartView的属性都会存放在STMPartMaker里，包括带入的自定义视图还有用于生成视图控件的属性等。PartView属性设置完成后会在STMPartView这个类中先决定对应的视图控件，并将STMPartMaker里的属性都设置上。实现代码可以查看STMPartView.m里的- (STMPartView *)buildPartView方法。</p>
<p>接下来STMAssembleView会在buildAssembleView时进行布局，具体实现代码可以查看STMAssembleView.m里的- (STMAssembleView *)buildAssembleView方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中总是希望页面上各处的文字，颜色，字体大小甚至各个视图控件布局都能够在发版之后能够修改以弥补一些前期考虑不周，或者根据统计数据能够随时进行调整，当然是各个版本都能够统一变化。看到这样的要求后，第一反应是这样的页面只能改成H5，或者尝试使用React Native来应对
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="AssembleView" scheme="http://ming1016.github.io/tags/AssembleView/"/>
    
  </entry>
  
  <entry>
    <title>从 ReactiveCocoa 中能学到什么？不用此库也能学以致用</title>
    <link href="http://ming1016.github.io/2016/05/30/what-learn-from-reactivecocoa/"/>
    <id>http://ming1016.github.io/2016/05/30/what-learn-from-reactivecocoa/</id>
    <published>2016-05-30T13:32:02.000Z</published>
    <updated>2017-05-27T06:14:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>从知道ReactiveCocoa开始就发现对这个库有不同的声音，上次参加<t>技术沙龙时唐巧对在项目中已全面使用FRP的代码家提出为什么这种编程模型出现了这么长时间怎么像ReactiveCocoa这种完全按FRP编写的库没能够流行起来这个问题。对这个问题的回答一般都是门槛高，解决方法就是培训和通过熟悉以前的代码来快速入门。其实在我学习的过程中也发现确实会有这个问题，不过就算是有这样那样问题使得ReactiveCocoa这样的库没法大面积使用起来，也不能错失学习这种编程思想的机会。</t></p>
<p>如果不用这样的库，能不能将这种库的编程思想融入项目中，发挥出其优势呢？答案是肯定的。</p>
<p>FRP全称Function Reactive Programming，从名称就能够看出来这个模型关键就是Function Programming和Reactive Programming的结合。那么就先从函数式编程说起。说函数式编程前先聊聊链式编程，先看看一个开源Alert控件的头文件里定义的接口方法的写法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *  自定义样式的alertView</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="keyword">instancetype</span>)showAlertWithTitle:(<span class="built_in">NSString</span> *)title</div><div class="line">                           message:(<span class="built_in">NSString</span> *)message</div><div class="line">                        completion:(PXAlertViewCompletionBlock)completion</div><div class="line">                       cancelTitle:(<span class="built_in">NSString</span> *)cancelTitle</div><div class="line">                       otherTitles:(<span class="built_in">NSString</span> *)otherTitles, ... <span class="built_in">NS_REQUIRES_NIL_TERMINATION</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * @param otherTitles Must be a NSArray containing type NSString, or set to nil for no otherTitles.</div><div class="line"> */</div><div class="line">+ (<span class="keyword">instancetype</span>)showAlertWithTitle:(<span class="built_in">NSString</span> *)title</div><div class="line">                       contentView:(<span class="built_in">UIView</span> *)view</div><div class="line">                       secondTitle:(<span class="built_in">NSString</span> *)secondTitle</div><div class="line">                           message:(<span class="built_in">NSString</span> *)message</div><div class="line">                       cancelTitle:(<span class="built_in">NSString</span> *)cancelTitle</div><div class="line">                       otherTitles:(<span class="built_in">NSArray</span> *)otherTitles</div><div class="line">                          btnStyle:(<span class="built_in">BOOL</span>)btnStyle</div><div class="line">                        completion:(PXAlertViewCompletionBlock)completion;</div></pre></td></tr></table></figure>
<p>库里还有更多这样的组合，这么写是没有什么问题，无非是为了更方便组合使用而啰嗦了点，但是如果现在要添加一个AttributeString，那么所有组合接口都需要修改，每次调用接口方法如果不需要用Attribuite的地方还要去设置nil，这样会很不易于扩展。下面举个上报日志接口的例子。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMLogger</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">//初始化</span></div><div class="line">+ (SMLogger *)create;</div><div class="line"><span class="comment">//可选设置</span></div><div class="line">- (SMLogger *)object:(<span class="keyword">id</span>)obj;                        <span class="comment">//object对象记录</span></div><div class="line">- (SMLogger *)message:(<span class="built_in">NSString</span> *)msg;               <span class="comment">//描述</span></div><div class="line">- (SMLogger *)classify:(SMProjectClassify)classify;  <span class="comment">//分类</span></div><div class="line">- (SMLogger *)level:(SMLoggerLevel)level;            <span class="comment">//级别</span></div><div class="line"></div><div class="line"><span class="comment">//最后需要执行这个方法进行保存，什么都不设置也会记录文件名，函数名，行数等信息</span></div><div class="line">- (<span class="keyword">void</span>)save;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//宏</span></div><div class="line">FOUNDATION_EXPORT <span class="keyword">void</span> SMLoggerDebugFunc(DCProjectClassify classify, DCLoggerLevel level, <span class="built_in">NSString</span> *format, ...) <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">3</span>,<span class="number">4</span>);</div><div class="line"><span class="comment">//debug方式打印日志，不会上报</span></div><div class="line"><span class="meta">#define SMLoggerDebug(frmt, ...) \</span></div><div class="line"><span class="keyword">do</span> &#123; SMLoggerDebugFunc(SMProjectClassifyNormal,DCLoggerLevelDebug,frmt, <span class="meta">##__VA_ARGS__);&#125; while(0)</span></div><div class="line"><span class="comment">//简单的上报日志</span></div><div class="line"><span class="meta">#define SMLoggerSimple(frmt, ...) \</span></div><div class="line"><span class="keyword">do</span> &#123; SMLoggerDebugFunc(SMProjectClassifyNormal,SMLoggerLevelDebug,frmt, <span class="meta">##__VA_ARGS__);&#125; while(0)</span></div><div class="line"><span class="comment">//自定义classify和level的日志，可上报</span></div><div class="line"><span class="meta">#define SMLoggerCustom(classify,level,frmt, ...) \</span></div><div class="line"><span class="keyword">do</span> &#123; SMLoggerDebugFunc(classify,level,frmt, <span class="meta">##__VA_ARGS__);&#125; while(0)</span></div></pre></td></tr></table></figure>
<p>从这个头文件可以看出，对接口所需的参数不用将各种组合一一定义，只需要按照需要组合即可，而且做这个日志接口时发现后续维护过程中会增加越来越多的功能和需要更多的input数据。比如每条日志添加应用生命周期唯一编号，产品线每次切换唯一编号这样需要在特定场景需要添加的input支持。采用这种方式会更加易于扩展。写的时候会是[[[[DCLogger create] message:@”此处必改”] classify:DCProjectClassifyTradeHome] save]; 这样，对于不是特定场所较通用的场景可以使用宏来定义，内部实现还是按照前者的来实现，看起来是[DCLogger loggerWithMessage:@”此处必改”];，这样就能够同时满足常用场景和特殊场景的调用需求。</p>
<p>有了链式编程这种易于扩展方式的编程方式再来构造函数式编程，函数编程主要思路就是用有输入输出的函数作为参数将运算过程尽量写成一系列嵌套的函数调用，下面我构造一个需求来看看函数式编程的例子。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, SMStudentGender) &#123;</div><div class="line">    SMStudentGenderMale,</div><div class="line">    SMStudentGenderFemale</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">BOOL</span>(^SatisfyActionBlock)(<span class="built_in">NSUInteger</span> credit);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMStudent</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SMCreditSubject *creditSubject;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isSatisfyCredit;</div><div class="line"></div><div class="line">+ (SMStudent *)create;</div><div class="line">- (SMStudent *)name:(<span class="built_in">NSString</span> *)name;</div><div class="line">- (SMStudent *)gender:(SMStudentGender)gender;</div><div class="line">- (SMStudent *)studentNumber:(<span class="built_in">NSUInteger</span>)number;</div><div class="line"></div><div class="line"><span class="comment">//积分相关</span></div><div class="line">- (SMStudent *)sendCredit:(<span class="built_in">NSUInteger</span>(^)(<span class="built_in">NSUInteger</span> credit))updateCreditBlock;</div><div class="line">- (SMStudent *)filterIsASatisfyCredit:(SatisfyActionBlock)satisfyBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个例子中，sendCredit的block函数参数会处理当前的积分这个数据然后返回给SMStudent记录下来，filterIsASatisfyCredit的block函数参数会处理是否达到合格的积分判断返回是或否的BOOL值给SMStudent记录下来。实现代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//present</span></div><div class="line"><span class="keyword">self</span>.student = [[[[[SMStudent create]</div><div class="line">                   name:<span class="string">@"ming"</span>]</div><div class="line">                  gender:SMStudentGenderMale]</div><div class="line">                 studentNumber:<span class="number">345</span>]</div><div class="line">                filterIsASatisfyCredit:^<span class="built_in">BOOL</span>(<span class="built_in">NSUInteger</span> credit)&#123;</div><div class="line">                    <span class="keyword">if</span> (credit &gt;= <span class="number">70</span>) &#123;</div><div class="line">                        <span class="keyword">self</span>.isSatisfyLabel.text = <span class="string">@"合格"</span>;</div><div class="line">                        <span class="keyword">self</span>.isSatisfyLabel.textColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">                        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">self</span>.isSatisfyLabel.text = <span class="string">@"不合格"</span>;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;];</div><div class="line"></div><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[<span class="keyword">self</span>.testButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.student sendCredit:^<span class="built_in">NSUInteger</span>(<span class="built_in">NSUInteger</span> credit) &#123;</div><div class="line">        credit += <span class="number">5</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current credit %lu"</span>,credit);</div><div class="line">        [<span class="keyword">self</span>.student.creditSubject sendNext:credit];</div><div class="line">        <span class="keyword">return</span> credit;</div><div class="line">    &#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.student.creditSubject subscribeNext:^(<span class="built_in">NSUInteger</span> credit) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅的credit处理积分%lu"</span>,credit);</div><div class="line">    <span class="keyword">self</span>.currentCreditLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%lu"</span>,credit];</div><div class="line">    <span class="keyword">if</span> (credit &lt; <span class="number">30</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.currentCreditLabel.textColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(credit &lt; <span class="number">70</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.currentCreditLabel.textColor = [<span class="built_in">UIColor</span> purpleColor];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.currentCreditLabel.textColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.student.creditSubject subscribeNext:^(<span class="built_in">NSUInteger</span> credit) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅的credit处理积分%lu"</span>,credit);</div><div class="line">    <span class="keyword">if</span> (!(credit &gt; <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">self</span>.currentCreditLabel.text = <span class="string">@"0"</span>;</div><div class="line">        <span class="keyword">self</span>.isSatisfyLabel.text = <span class="string">@"未设置"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>每次按钮点击都会增加5个积分，达到70个积分就算合格了。上面的例子里可以看到一个对每次积分变化有不同的观察者处理的操作代码，这里并没有使用ReactiveCocoa里的信号，而是自己实现了一个特定的积分的类似信号的对象，方法名也用的是一样的。实现这个对象也是用的函数式编程方式。下面我的具体的实现代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMCreditSubject</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SubscribeNextActionBlock)(<span class="built_in">NSUInteger</span> credit);</div><div class="line"></div><div class="line">+ (SMCreditSubject *)create;</div><div class="line"></div><div class="line">- (SMCreditSubject *)sendNext:(<span class="built_in">NSUInteger</span>)credit;</div><div class="line">- (SMCreditSubject *)subscribeNext:(SubscribeNextActionBlock)block;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SMCreditSubject</span>()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> credit;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SubscribeNextActionBlock subscribeNextBlock;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *blockArray;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SMCreditSubject</span></span></div><div class="line"></div><div class="line">+ (SMCreditSubject *)create &#123;</div><div class="line">    SMCreditSubject *subject = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="keyword">return</span> subject;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (SMCreditSubject *)sendNext:(<span class="built_in">NSUInteger</span>)credit &#123;</div><div class="line">    <span class="keyword">self</span>.credit = credit;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.blockArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (SubscribeNextActionBlock block <span class="keyword">in</span> <span class="keyword">self</span>.blockArray) &#123;</div><div class="line">            block(<span class="keyword">self</span>.credit);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (SMCreditSubject *)subscribeNext:(SubscribeNextActionBlock)block &#123;</div><div class="line">    <span class="keyword">if</span> (block) &#123;</div><div class="line">        block(<span class="keyword">self</span>.credit);</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.blockArray addObject:block];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Getter</span></div><div class="line">- (<span class="built_in">NSMutableArray</span> *)blockArray &#123;</div><div class="line">    <span class="keyword">if</span> (!_blockArray) &#123;</div><div class="line">        _blockArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _blockArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Demo地址：<a href="https://github.com/ming1016/RACStudy" target="_blank" rel="external">https://github.com/ming1016/RACStudy</a></p>
<p>主要思路就是subscribeNext时将参数block的实现输入添加到一个数组中，sendNext时记录输入的积分，同时遍历那个记录subscribeNext的block的数组使那些block再按照新积分再实现一次输入，达到更新积分通知多个subscriber来实现新值的效果。</p>
<p>除了block还可以将每次sendNext的积分放入一个数组记录每次的积分变化，在RAC中的Signal就是这样处理的，如下图，这样新加入的subscirber能够读取到积分变化历史记录。</p>
<p>所以不用ReactiveCocoa库也能够按照函数式编程方式改造现有项目达到同样的效果。</p>
<p>上面的例子也能够看出FRP的另一个响应式编程的特性。说响应式编程之前可以先看看我之前关于解耦的那篇文章里的Demo<a href="https://github.com/ming1016/DecoupleDemo" target="_blank" rel="external">https://github.com/ming1016/DecoupleDemo</a>，里面使用了Model作为连接视图，请求存储和控制器之间的纽带，通过KVO使它们能够通过Model的属性来相互监听来避免它们之间的相互依赖达到解耦的效果。</p>
<p>像上面的例子那样其实也能够达到同样的效果，创建一个Model然后通过各个Subject来贯穿视图层和数据层进行send值和多subscribe值的处理。</p>
<p>了解了这种编程模型，再去了解下ReactiveCocoa使用的三种设计模式就能够更容易的将它学以致用了，下面配上这三种贯穿ReactiveCocoa的设计模式，看这些图里的方法名是不是很眼熟。</p>
<p>ReactiveCocoa里面还有很多可以学习的地方，比如宏的运用，可以看看sunnyxx的那篇《Reactive Cocoa Tutorial [1] = 神奇的Macros》<a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/03/06/rac_1_macros/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从知道ReactiveCocoa开始就发现对这个库有不同的声音，上次参加&lt;t&gt;技术沙龙时唐巧对在项目中已全面使用FRP的代码家提出为什么这种编程模型出现了这么长时间怎么像ReactiveCocoa这种完全按FRP编写的库没能够流行起来这个问题。对这个问题的回答一般都是门槛高
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://ming1016.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>竭尽全力的去解耦的一次实践，封装一个TableView和一些功能组合的控件</title>
    <link href="http://ming1016.github.io/2016/05/23/try-to-decouple-with-demo/"/>
    <id>http://ming1016.github.io/2016/05/23/try-to-decouple-with-demo/</id>
    <published>2016-05-23T13:24:25.000Z</published>
    <updated>2017-05-27T06:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以先看看这个Demo：<a href="https://github.com/ming1016/DecoupleDemo" target="_blank" rel="external">https://github.com/ming1016/DecoupleDemo</a>。从这个Demo里可以看到Controller和View还有Store的头文件里没有任何Delegate，Block回调，只有初始化和更新ViewModel的方法。所有这些控件，请求，ViewController和视图之间的联系都是通过ViewModel来进行的，而viewModel也不进行任何逻辑处理，只是简单的起到描述和默认值设置的作用。ViewController也被减轻的小得不能再小了，只需要初始化视图和Store即可。这也是我的一次尝试，看看如何利用KVO能够做到最大限度的解耦，和最大限度的减少代码和接口。</p>
<p>可以先看看以前代码最臃肿的地方在使用了新的思路后会变成怎么样，首先是ViewController<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [<span class="keyword">self</span> addKVO];</div><div class="line">    [<span class="keyword">self</span> buildConstraints];</div><div class="line">    <span class="keyword">self</span>.tbStore = [[TestTableStore alloc] initWithViewModel:<span class="keyword">self</span>.tbView.viewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到里面仅仅做了添加KVO，布局控件和初始化Store的工作。</p>
<p>封装的TableView作为一个通用控件是不会去设置管理不同的Cell的，可以看看不用Delegate和Block是如何处理的。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="keyword">self</span>.viewModel.tableViewIdentifier = smTableViewIdentifier;</div><div class="line">    <span class="keyword">self</span>.viewModel.tableView = tableView;</div><div class="line">    <span class="keyword">self</span>.viewModel.cellIndexPath = indexPath;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.viewModel.cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我觉得这样应该很简化了。当触发到UITableView这个配置Cell的回调时，通过对ViewModel的键值的监听就能够在任何地方对Cell进行配置了，而不用通过繁琐的Delegate和Block来层层回调了。</p>
<p>除了这里外，其它地方也用同样的方法进行了处理，比如说对新出现消息提示点击使其消失只需要设置ViewModel里的isHideHintView的值的处理，还有对请求不同状态显示不同引导页，只要是以前需要通过接口和回调的全部干掉，用ViewModel去控制，下面可以看看我写的ViewModel中，我将KVO分成了View Side和Data Side，前者主要是响应视图方面的逻辑变化，后者Data Side是响应不同的动作来产生对数据不同的处理，其它就都是些关于样式和数据配置相关的了。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="comment">//           KVO View Side</span></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isHideGuideView;             <span class="comment">//是否显示guide view</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isHideHintView;              <span class="comment">//是否显示hint view</span></div><div class="line"><span class="comment">//下拉刷新上拉加载更多</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SMTableRequestStatus requestStatus; <span class="comment">//刷新状态</span></div><div class="line"><span class="comment">//TableView Delegate</span></div><div class="line"><span class="comment">//通用</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITableView</span> *tableView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *tableViewIdentifier;</div><div class="line"><span class="comment">//Cell</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *cellIndexPath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITableViewCell</span> *cell;</div><div class="line"><span class="comment">//CellHeight</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *cellHeightIndexPath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;</div><div class="line"></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="comment">//          KVO Data Side</span></div><div class="line"><span class="comment">//---------------------------</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SMTableRefreshingStatus dataSourceRefreshingStatus; <span class="comment">//请求状态</span></div></pre></td></tr></table></figure></p>
<p>纵观整个项目，头文件都很干净，唯一有方法需要参数的也就是ViewModel。这种完全面向对象思路的编程方式在需求经常变更的情况下优势就会慢慢显露出来，对吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以先看看这个Demo：&lt;a href=&quot;https://github.com/ming1016/DecoupleDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ming1016/DecoupleDemo&lt;/a
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Pattern" scheme="http://ming1016.github.io/tags/Pattern/"/>
    
  </entry>
  
  <entry>
    <title>十中</title>
    <link href="http://ming1016.github.io/2016/04/04/tenth-middle-school/"/>
    <id>http://ming1016.github.io/2016/04/04/tenth-middle-school/</id>
    <published>2016-04-04T08:08:08.000Z</published>
    <updated>2017-05-27T13:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一话"><a href="#第一话" class="headerlink" title="第一话"></a>第一话</h1><p>决赛进入了加时赛，凌召一记凌空射门，球入网，十中获得联赛冠军。凌召站在获奖台时当着所有人的面对着喇叭说，“丁晓炎，谢谢你的加油，让我有一直努力的毅力，因为我是好喜欢，好喜欢你”。这时他看到台下丁晓炎正被另一个男生搂着，他们带着冷冷的笑看着自己。就在这时凌召从梦中惊醒过来。</p>
<p>是因为要小学同学的聚会的原因吧，聚会前一天会梦到丁晓炎。二十年以来第一次聚会，聚会还没有结束凌召就匆匆离席了，他为什么会早走呢？他的同学们都不知道，原来他听说丁晓炎同学成了一个作家，而这天她却没有来，于是凌召直奔图书大厦找她写的书去了。</p>
<p>来到图书大厦，他检索到丁晓炎写的几本书，其中有一本是她的短篇集，封面是个黄色的表，凌召还记得这个表是他小学时送给她的那个。打开目录他发现有篇名叫《凌召的表》，这不是自己的名字么，文字将他的回忆一页一页的翻了起来。</p>
<p>那时，凌召还在十中读初中，他的小学的同学们几乎都对口了另一所中学，一中。</p>
<p>“你小学是哪个班的？”凌召的同桌秦珊问道。</p>
<p>“我以前不是你们学校的，我小学同学都去一中了。”凌召回答。</p>
<p>“那你觉得现在我们班上哪些女生漂亮，这样吧，来个排名从五到一，你说说看。”</p>
<p>凌召看了看秦珊，她，瓜子脸，肤色较黑，虽然不是自己喜欢的类型，但是他知道秦珊是希望自己说她漂亮的。</p>
<p>“恩，第五嘛，我觉得是古文蔚，我唯一在十中的小学女同学，第四是于佳吧，看起来蛮文静的，第三是周冰…”</p>
<p>秦珊带着焦虑的眼神看着凌召，虽然她觉得自己好看，但是也自知算不上班花级别，担心自己凌召说完五人也不会提自己。</p>
<p>“第二，让我好好想想，好难分高下。恩，就蒋美龄吧。”凌召说着看到秦珊渴望又带着焦虑的眼神，心中窃喜。</p>
<p>“不是吧，我觉得蒋美龄是班上最好看的。”</p>
<p>“不要急嘛，当当当，当当当。第一就是秦珊。”</p>
<p>秦珊噗的一声，随手推了凌召一下，黑黑的脸上泛起一丝红晕，看来是满足了，还有点不好意思，开心却又假装生气的说：“去去，是因为我问的你，你才把我排第一吧。”话虽这么说，心里却等着凌召否认。</p>
<p>凌召摇了摇头，其实他本来就对这个班上的女同学不熟悉，提到的这些人也是平时男生常常讨论的人，当然里面没有秦珊，但是凌召不希望秦珊失望。他也不是很关心这个班上的女孩子，因为他喜欢的女孩不在这个学校里。</p>
<p>“你想听听我给男生排名是什么样的吗？”</p>
<p>凌召点了点头。</p>
<p>“我觉得你马马虎虎，也算是帅，排第五吧。”</p>
<p>这时，班主任带着一位同学走近教室。</p>
<p>“同学们，我介绍一位同学，他名叫李文龙，转校到我们十中，他特长是足球，以前小学曾代表学校比赛得过奖。希望他以后也能够带领十中校队获得好成绩，来，大家一起鼓掌欢迎他。”</p>
<p>李文龙挎着单肩书包，在掌声中穿过，旁边不断有人低声窃语，感叹着好帅。</p>
<p>“你进不了前五了。你看他这双大眼睛，高高鼻梁，还有这360度无死角的脸型，迷死人了，秒杀你们，踢足球的男孩就是帅气，第一，第二，第三，第四，第五都是他了。”秦珊对凌召说，眼睛里泛出无数的心心。</p>
<p>自从凌召担任了小组长后，就一直不顺利，这不，收个作业还被同组同学找茬。</p>
<p>“韩霍，交作业了，就差你了。”凌召拿着那堆收好的作业来到韩霍的座位旁。</p>
<p>“没写。”韩霍坐在桌上，一只手搭在翘在桌上的腿，一只手依着桌角，瞟了一眼凌召后就跟李文龙接着聊天。韩霍是个典型的外面玩的那种孩子，常常到其它学校去抢钱，到街机厅抢币，坐在最后，成天和他的哥们一起。李文龙来后也总是跟他们在一起。所谓好兔不吃窝边草，只要惹他们，也不怎么欺负班上同学。</p>
<p>“没写我给你一本，你可以抄完再交。”凌召从收的作业本里抽出一本递给韩霍。</p>
<p>韩霍一把打掉凌召手中的作业本，说：“老子不想写，也懒得抄，怎么着。滚一边去！”</p>
<p>凌召心想着以前有次作业忘记做了，当时那叫一个着急啊，这时有位同学将自己作业递给自己说给他抄，这是要担着被老师发现的危险的，还好凌召机智的将几个题答案故意写错避过一劫，但心里却是非常的感激这位同学的，然而韩霍不但不感谢自己，还这样对自己，只觉得委屈生气，一脸怒气看着韩霍。</p>
<p>啪的一声，韩霍一个大巴掌打了过来。凌召被打得后退了一步，手捂着脸，韩霍手浮着还未收回，说：“看什么看。”</p>
<p>凌召哪里受得了这气，抬起脚朝韩霍踢去。韩霍毕竟打的架多，侧个身闪过，同时一手抓住凌召的脚，用力一拉，凌召一屁股倒在地上，头撞到一旁桌脚上。接着韩霍一脚踢向凌召腰部，旁边的韩霍的那帮人准备过来一起动手。</p>
<p>这时韩霍的肩膀被轻轻拍了一下。“哥们，不想抄，我来帮你抄。来来，但是，抄完别忘记给我买包烟。”李文龙在背后笑着看着韩霍。韩霍看是李文龙，于是跟旁边打算过来帮手的人使了个眼色让他们不要过来。凌召捂着腰站起来正要冲过去时被李文龙一手搂住肩膀拉着转了个身，小声地说：“别跟他一般见识，他是什么层次的人你又不是不知道。”</p>
<p>凌召侧脸抬头看着李文龙俊朗的脸上那双有着长长睫毛有神的大眼睛正自信的看着自己，心中的怒气也就消散了。李文龙看了看凌召的脸，怒容已散，说了句：“对吧。”</p>
<p>“要不你加入足球部，跟我一起玩玩足球怎么样，听说你喜欢弹钢琴，看你这弱身板，不练练体力怎么能够弹得带劲。”李文龙对凌召提出邀请。</p>
<p>“真是隔行如隔山，弹钢琴才不是你想的那样呢，不过踢足球，挺不错的，我答应你。”凌召想起秦珊说踢足球的男孩有魅力，然后又看了看李文龙，还真以为踢上足球就能够像李文龙那样，真是笑死人了。不过凌召有些纳闷的是李文龙怎么知道自己喜欢弹钢琴，班上应该还没有人知道这事呢。</p>
<p>自从在他加入足球部后，情况确实有了些变化，但一定不是凌召想的那样。</p>
<p>训练时，凌召被秦珊称为班级第一美的蒋美龄拿着一封信来到凌召跟前低着头递给了他。凌召奇怪的接过信，问了句：“这时什么？”</p>
<p>“情书。”说着脸开始红了。</p>
<p>凌召仔细打量起了，蒋美龄果然是个美人胚子，白白嫩嫩的皮肤，标致的五官，确实看起来比班上其他女生要好看些。但凌召还惦记着小学那个喜欢的女孩，不好意思又很果断的回绝道：“那个，要不我们做朋友吧。”</p>
<p>蒋美龄脸色一下子就变了，一脸的害羞荡然无存，大声说：“这个不是给你的，是让你帮我给李文龙的，你好好看看上面的字吧。臭美”说完就走了。凌召仔细看了看信封上的字，一脸尴尬。拿着情书回到训练球场，想着自己是不是也该给自己喜欢的那个女孩丁晓炎也写封情书表达下自己的思念。这个时候，他觉得附近好像有双眼睛一直看着自己，余光中感觉像是丁晓炎，但扭头看去却都是还是那些李文龙的粉丝女们，细想下丁晓炎现在在一中了，怎么会出现在十中。觉得自己要不就是太想她了，要不就是天气太热训练过头中暑了。他还没有回过神，砰的一下，一球打在了脸上。</p>
<p>“干嘛呢，快练球”李文龙厉声叫道。凌召很奇怪一向遇事冷静的李文龙今儿怎么突然发起火来。看李文龙的表情也是奇怪，李文龙发现凌召愣着看自己，勉强的故装轻松却无法按耐着生气。</p>
<p>“不要这样生气嘛，你看看这是什么，班花给你的情书耶！”凌召走向李文龙。李文龙接过情书都没有打开就揉成一团扔到一边。</p>
<p>“凌召，把注意力放到训练上，你没有足球的基础，这段时间我看你练得不错，已经给校队教练提名让你入校队了，应该问题不大。不过以你现在的实力还只能够作替补，加把油，十中十来年都没拿过奖呢，争取这次联赛时能够上场，给咱们十中拿个大奖杯回来。”</p>
<p>“能进校队了，真的！替补也行啊！”凌召开心的不行。</p>
<p>“恩，好好干。”李文龙拍了拍凌召的肩膀就继续自己的训练了。</p>
<p>慢慢接近联赛，凌召在李文龙的指导下进行了异常艰苦的训练。</p>
<p>进入淘汰赛，李文龙把一班的队员集合在一起，对大家说：“你们三个和我都是一班的，下场比赛，纪崇飞还是踢边锋，韩霍后卫，你要注意我教你的那些小动作，关键时候一定要用，我们队守门员水平偏下，后卫非常关键。我来担任前锋，落后的分就交给我补回来，凌召这次你还是在场外学习，这次对手很强劲，他们的主力小学也跟我对过手，这场比赛将会是场异常艰苦的作战，大家都记住了吧！”</p>
<p>李文龙伸出手掌，四人将手叠在一起。“这次也要赢！有信心吗？”李文龙大声叫道。</p>
<p>“有！”四人齐声喊道。</p>
<p>四人散开时，韩霍故意撞了下凌召，凌召想着李文龙说的大人不记小人过，也就没有和韩霍计较，哪知韩霍来了句：“听见没，多学着点。”说完神气的走在了凌召前面，凌召想着就来气，打到淘汰赛之前一直坐冷板凳，一直憋着，这次和一中比赛，主场还在一中，他喜欢的丁晓炎一定会来看这场比赛，如果被她发现自己一直坐冷板凳多没有面子，现在还被韩霍这么一嘲笑，准备反嘴道你个连作业都不会写的货有什么资格说我，但是转眼看旁边的李文龙对自己使了个眼色，这气也就忍了下来。上次凌召就问过李文龙怎么把韩霍这货给弄进校队，李文龙说校队欢迎所有球踢得好的，同时他提醒凌召不要和韩霍起冲突，不然教练会把他们都赶出校队。</p>
<p>比赛那天，凌召特意跑到观众席上找以前的小学同学。凌召环顾了一圈都没发现丁晓炎，反而是其他以前小学的同学们围了过来问他在十中的情况。</p>
<p>回到球场边板凳上，没有见到喜爱的人一脸无精打采。比赛过程也是乏味的很，淘汰赛阶段双方都会非常小心的进攻，而加强防守，而且两支球队教练都采用了防守反击策略，导致在没有进球的情况下，比赛看着让人犯困。</p>
<p>到了临近结束前，双方为了避免进入疲劳的加时赛都开始转守为攻，急于夺分的一中前锋一脚铲伤了十中的右后卫，这时十中教练将凌召换上场。凌召一脸兴奋，想着最后关键时刻李文龙一定会力挽狂澜，如果这次能胜了一中一定会在一中的校刊上留下一笔，说不定丁晓炎也能够看到呢。拍了下场受伤后卫的手，凌召一路开心的小跑到场上。一站到位，凌召就发现李文龙正一脸焦虑的看着自己，一旁还有韩霍那种不屑异常轻视，仿佛等着自己出丑的目光。放眼朝观众席看去，所有目光都集中到了自己身上，还伴随着一片主场特有的阵阵嘘声。这让本就毫无赛场经验的凌召开始紧张起来了，李文龙还没来得及给他鼓气，对手的进攻就来了。</p>
<p>一中前锋也看出了凌召是个十足的新手，就带着球冲向凌召防守的这边。一个简单的虚晃就过了凌召。凌召怎可罢休，紧紧的贴身在对手身边把他往边路挤。对手想往里过时，他就侧个身背挡着裁判视线手伸出去拽对手衣裤。李文龙教他的小动作他也算是活学活用了。临近球门却没有机会，一中这位前锋只得后脚跟一磕将球传给右侧前来接应的队友。</p>
<p>一心担心着凌召的李文龙也不顾自己体力，急忙回防，发现对手传球的意识，大呼一声：“断球！”</p>
<p>凌召下意识侧身伏下左脚一伸将球给断了下来。</p>
<p>抢下球的凌召瞬间就被对方两名球员给贴身夹住了。这下凌召给慌了，看着前面路线被堵死，他只得转身寻找接球人，这时韩霍给他示意了下，凌召急忙大脚将球踢了过去。</p>
<p>嗖的一声，球进来！但是是自家球门。原来韩霍示意凌召传他球后，故意装作不知情的跑开了，这样球直接进入自家球门死角。凌召呆呆的站在那里，这次真是会上一中校刊头条了，如此的耻辱，让他有种想钻进地下去的冲动。</p>
<p>离结束还有不到两分钟，一中又有了一次进攻的机会，凌召还茫然的站在那里。又一球入网。自此，十中已无缘奖杯。凌召感觉自己也没脸呆在十中校队了。</p>
<p>赛后在更衣室，队友一个个叹着气离开，韩霍捂着嘴冷笑着看了凌召一眼，很满足的离开了。这时更衣室就只剩下李文龙和凌召了。</p>
<p>“别灰心！”李文龙坐到凌召身边。</p>
<p>“是韩霍，是他…”本来就强忍着委屈的凌召听到李文龙的安慰，忍不住想说出委屈，看着眼泪都快要流出来的凌召，李文龙一把将他搂住，说：“别说了，我知道是韩霍故意漏球的。我都看到了。本来呢，对你上场我也是反对的，主要就是担心你和韩霍的配合，当然还有你的上场经验。教练让你上次，我刚才想通了，这场比赛教练他估计是觉得没有胜算了，为了将来球队着想才让你上场积累下大赛经验。一中毕竟也是名校，也是最近这几届的冠军队。教练他也看出了你的潜力，争取明年你能够有大的进步让我们扳倒一中吧。”</p>
<p>看李文龙严肃而自信的看着自己，凌召咽下一口水，连连点头。</p>
<h1 id="第二话"><a href="#第二话" class="headerlink" title="第二话"></a>第二话</h1><p>虽然自己上了十中的耻辱柱，但校园的生活还是要继续嘛。这是个阳光极好的一天，难得的万里无云，同学们嬉笑着到音乐教室上课，你也知道音乐课正是大家放松的时候，没有枯燥的公式，单调的英文字母，难读还要背的文言文，让人发困与自己无关的那些古代牛人，难以下笔，下笔又画得无法欣赏的画，有的只是动听的节奏，美妙的音符。</p>
<p>不过今儿这节课音乐老师却问哪位同学们上来表演。“哪位同学愿意自告奋勇上台给大家弹上一曲？”老师问道。这一问弄得大家都默默低下头，一阵沉寂，以往那种轻松的气氛变得紧张起来，大家都担心着老师会点到自己。</p>
<p>“我来吧！”以为女同学站了起来，走到钢琴前。老师鼓起掌以示鼓励，同时摆了下头示意大家来一起鼓掌。这位女同学坐上钢琴椅，微微卷起衣袖，坐正了身子，十指缓慢的放在琴键上方。</p>
<p>等着大家掌声结束，琴声随即响起，同学们都感叹这位同学的专业。凌召小时候也学了六年多的钢琴，此刻也自叹不如。</p>
<p>“以前都没注意过这女孩，你知道她叫什么名字吗？”凌召问身边的叶正。</p>
<p>“于佳啊，我不是跟你说过，这班上也就她我看得上眼了，又漂亮又有气质。你都没放心上啊，真不知道你成天都想啥呢。”叶正说。叶正是凌召在十中最要好的朋友，也是小学跟他一起到十中那极少的同学中的一个。叶正也凌召的爱好也差不多，都喜欢音乐，而且他一直在学，直到现在还请着老师教呢。</p>
<p>叶正这一问凌召在想啥和于佳美妙的琴声一下子把凌召的思绪带回到了他怀念的小学时光里，让他想起了小学时和丁晓炎同桌的时光，还有那次课上不知道是幻觉还是真实的画面。把凌召上次比赛的烦恼羞辱一点点的破碎掉，转成无比的愉悦，随着琴声娴熟的转向高潮，凌召兴奋的也站了起来，走向台上。</p>
<p>于佳抬眼看着凌召，只见凌召寻着一旁的吉它，将它抱起，跟着于佳的节奏弹了起来。于佳微笑着继续弹着，时不时的瞟眼看凌召。凌召却也是十分享受着这段曲子竟也是陶醉起来。叶正也注意到于佳的眼神，忍不住也走向他们，坐在架子鼓上随着他们的节奏敲打起来，这画面可把音乐老师乐坏了。</p>
<p>下课后老师讲他们三人留下，希望他们都能够加入音乐部。</p>
<p>“我可能不行”凌召为难的说。</p>
<p>于佳看了看凌召，说凌召不加入她也不想加入了。叶正看这情况，想着难得有机会和于佳一起，于是说：“凌召是担心参加两个部时间顾不上吧。”凌召点了点头。</p>
<p>“没事，这不，联赛也结束了，好好放松下，下个赛季开始再退出也不迟嘛。”叶正眼光闪烁着一股自以为聪明劲儿满怀着期待的看着凌召。凌召思量了下，回想了刚才弹琴时的感觉，今儿才发现原来音乐不光能够表演炫技，还能够勾起对丁晓炎的思念和回忆。再看看自己好朋友叶正那双渴望的眼神，于是答应了加入音乐部。</p>
<p>叶正握手收腰耶的一声，于佳也露出了笑容。就这样这三个人开始了他们的校园音乐生活。在音乐部里他们形影不离，音乐部没有活动时他们就一起去街机厅玩游戏，一起去台球厅打台球，在江滩上一起弹吉它。</p>
<p>说到梦想谁没有呢，特别是在凌召他们这样的年龄。三人坐在江滩沙子上，刚弹完凌召写的一个曲子，三人相互望了一下，表示了下对自己和队友的肯定，随后三人一起望着夜空。</p>
<p>“听说对着星星许愿会灵验哦。”叶正说。</p>
<p>“笨蛋，是流星啦！”于佳说：“星星天天都能看到，哪会那么容易让你实现。”</p>
<p>“也是啊。”叶正摸着头，怪不好意思。</p>
<p>于佳看了看凌召，凌召静静坐在那里看着星星发呆。于佳接着对叶正说：“你学学人家凌召，别没话找话说。”</p>
<p>凌召笑了笑，看着于佳和叶正说：“难得叶正有这兴致，要不，我们一起对着这条江河许个愿吧，让它能够带着我们的愿望流向浩瀚大海，征服我们的未来。”</p>
<p>于佳听凌召这么一说，抿嘴直点头，然后用手轻轻的拽了两下叶正的袖子，示意他不要说傻话。</p>
<p>“对，对，来吧，一，二，三，一起许愿吧。”叶正傻傻的点着头望了望于佳又望了望凌召。三人闭眼低头双手紧握开始许愿。凌召此刻正迫不及待的想对大江说他希望自己长大能够成为一个有名的音乐人，大街小巷都能听到他创作的音乐，还有，他希望能够和丁晓炎在一起。</p>
<p>“我许完了，凌召你的愿望是什么？”于佳许完愿望急忙的问凌召。</p>
<p>“不是说许的愿望说出来就不灵了吗？”凌召回道。</p>
<p>“那是对流星许愿才有这规矩。这流向浩瀚大海的心愿才没有那么小气呢！”于佳咧着嘴笑着说。</p>
<p>“那你先说。”凌召说。</p>
<p>于佳瘪着嘴说：“说就说，我呀！希望以后能够像现在一样和你凌召一起玩音乐，组乐队，做出最棒的音乐。”</p>
<p>“喂，还有我。”叶正急忙补充道：“是我们三个人的乐队，我的愿望也是这个。凌召，你的呢？”</p>
<p>“恩，我的嘛。”凌召犹豫了会，接着说：“其实，也是这样的，好期待以后的我们呢。”凌召竖起大拇指，说道：“给未来的我们和现在的我们赞一个。”</p>
<p>于佳和叶正也竖起大拇指，三人拇指并在一起，月光洒在他们脸上，让他们在黑暗的夜里也光芒起来。</p>
<p>加入音乐部后凌召练足球的时间也少了不少，而且有一点让凌召很不爽的是自他加入音乐部后，音乐部里那些女同学们总是从他那里打探李文龙的事情，比如说李文龙喜欢什么类型女孩子，喜欢什么颜色，星座啊，什么时候会到球场练球什么的。看来不是说只要踢球的男孩就会受欢迎，还需要球技高人长的帅才行啊，凌召不断的感叹到，这个看脸的时代。这不，情人节到了，凌召打开在音乐部的存包柜，发现里面堆满了信，随便拿出几封都是要转交给李文龙的。凌召想着这不用打开也知道里面写的都是些肉麻的话。</p>
<p>来到足球部，凌召从书包中掏出一打信用力往更衣室正在换衣服的李文龙身旁桌上一砸。</p>
<p>“好开心吧，这批来自音乐部的情书够你看一阵了吧。”凌召说。</p>
<p>“你有打火机吗？”李文龙问。</p>
<p>“我又不抽烟，干嘛？”凌召反问。</p>
<p>“帮我烧了呗。”李文龙看起来一副淡定自若对这事习以为常的态度说道。</p>
<p>“多可惜啊！你看看这一封封爱意满满的信，谁不知道音乐部都是美女啊，就没你喜欢的？”凌召左手拿一封右手拿一封，不断摇着头以示可惜。</p>
<p>“美女？你是指那个天天跟你一起的于佳么？”李文龙坏笑着说。</p>
<p>“哦！对哦，让我找找，看看美女会用什么深情意浓的文字来写情书。”凌召顺着李文龙的玩笑一边说着，一边在那堆信中找署名是于佳的信。李文龙换好衣服坐在凳子上，歪着脑袋以一种不屑的神情帮着凌召找。</p>
<p>“这里！”李文龙翻到了，笑着大声说。裁开看着信时不时看了看凌召，看完后对凌召说：“这个是给你的。”</p>
<p>凌召接过信，心里有种说不出的感觉。</p>
<p>“看来你们修成正果了。不简单，美女的情书哦。”李文龙看起来是那么幸福，好像是自己修成正果那般的甜蜜笑着对凌召说。</p>
<p>凌召拿着信回到家。坐在自己的书桌前，慢慢读着信。首先是不敢相信自己也能够收到情书，同时也担心是于佳在跟自己开玩笑。认真看完信里的每个字，他能够感觉到于佳对自己的真情实意。</p>
<p>凌召一头倒在床上，双手举着那封情书，信结尾说如果凌召对她也有意明天放学后在江滩那见面。</p>
<p>次日，课间，叶正把凌召拉到走廊一角。</p>
<p>“这个，能帮我把这封信交给于佳吗？”叶正拽着凌召的袖子，神神秘秘的将一封信塞到凌召手中。</p>
<p>“情书？怎么不直接给她？”凌召问。</p>
<p>“我看她蛮听你的，你给我多说几句好话呗。靠你了。”叶正再次用那满怀期待的眼神望着凌召。凌召其实早就发现叶正的小心思了，点了点头，将信装到了口袋中。</p>
<p>放学后，叶正背着书包经过凌召轻轻撞了下凌召，给他使了个眼色提醒他不要忘记给于佳送情书。</p>
<p>凌召低着头小步慢走来到江滩。远处看到于佳正坐在沙堆高处，双手托着面额面对着江水。凌召走上沙堆来到于佳身边，于佳转头看见凌召，开心的双手将他抱住。</p>
<p>时间就像停止了一样，于佳紧紧的抱着凌召，嘴角凑到他耳边。</p>
<p>“我们就像这样一直在一起吧。”于佳慢慢闭上眼睛，享受着属于自己的这一刻的满足。</p>
<p>凌召轻轻拿开于佳的手，说：“对不起。”</p>
<p>“对不起？你不是来了吗？”于佳吃惊的看着凌召。</p>
<p>凌召扭开书包扣，取出叶正那封信给了于佳，说道：“我是来给叶正送这封信的。叶正挺棒的，琴弹的比我好，又很喜欢你，你应该能感觉到吧。我们还是最佳拍档对吧。我们许的愿…”</p>
<p>“我就问你，你喜欢我吗？”于佳没等凌召说完认真的看着他说。</p>
<p>“我…”凌召不忍回答。停顿许久，于佳一直目不转睛的看着他。</p>
<p>“不用回答了，你走吧。”于佳转过头背对着凌召说。低下头，双肩有些颤抖，带着些许嘶哑声说：“你不是说过许的愿望说出来就不灵了么，看来是真的。”</p>
<p>回到家中，凌召将自己房间的门锁住，背靠内门，心里埋怨自己，他也没想到于佳会那样将自己抱住，那一刻他心也酥了，有种也想将她抱住的冲动。但那时他眼前出现了丁晓炎的幻觉。凌召来到书桌旁的钢琴边，掀开琴布，琴盖打开，坐下，翻到他和于佳叶正一起创作的曲子那页，弹了起来。此刻他的心情是极好的，谁不喜欢被人爱呢，但也带着些愧疚。随着曲子的进行，又将凌召带回了小学时光，好一个多愁善感之人，他是更享受音乐带他进入另一个世界的感觉。晚上，凌召不断想着丁晓炎，到了很晚才入睡，睡梦中，他进到他家旁边那家书店，忽然发现了丁晓炎正从书店里出来，她没有发现自己，他们擦肩而过。</p>
<p>梦有时真的很奇怪，日有所思，夜有所梦是没错，但夜有所梦，日有所见竟也会发生，而当这事出现时会让你有充满希望和那种命中注定的那种幸福感。</p>
<p>凌召来到音乐部发现叶正已退出了，看来于佳已经拒绝他了。于佳还没退出音乐部，但也没有再像以前对凌召热情。音乐部训练结束，凌召走出门，发现韩霍正在门口，回头发现于佳正笑着走向韩霍。</p>
<p>韩霍和于佳小学就是同学，只是为什么会是韩霍，凌召心里很难受，这个他最讨厌的人。他急步走了一段，回头看了看，于佳正牵着韩霍的手看着自己，缓缓的将头靠向韩霍。</p>
<p>于佳跟谁和自己又有什么关系呢，凌召不断跟自己讲着。想着于佳刚刚看自己的眼神，心里感觉那一定是她想气自己才这么做的吧，想必应该是这样吧。凌召心里七上八下的，久久无法平复，其实想想也不能怨人家于佳，是自己先伤了对方的心，当时她心里也一定很难过。</p>
<p>想着想着，凌召一脚已踏进家附近那家书店，昨晚梦中画面忽的浮现在面前，他也不知怎么就来到这，可能是本能的期待着梦中那画面能够出现，所谓的梦想成真也不过如此。但却是真的成了真。凌召选择了一本刚出的七龙珠，贝吉塔时隔一年后来到地球本。到柜台时发现身边正站着那个日里梦里都想着的丁晓炎。</p>
<p>可能是两人很久没见了，多了好些生疏。丁晓炎也发现了凌召，说道：“凌召，你也来买书了。”</p>
<p>凌召正准备说丁晓炎的名字，忽然发现这个他心中默念过千遍万遍的名字，此刻竟无法说出口，急忙中简单了回了句：“是的。”说完低下头，脸上开始泛起红。这是他们上初中以来第一次碰面，而且这次偶遇的画面和昨晚梦中的画面是如此的相似。</p>
<p>丁晓炎看凌召一句简单的回答就一直低着头，也没有再说些什么，其实这时的凌召的心里已翻江倒海，正为这个梦有所见欢喜不已。凌召拿起书时胳膊一不小心靠到丁晓炎的胳膊，她没有本能的挪开。此刻，他心跳急剧加速，脸红烫到了鼻头。脚开始发软了，只得用右手使劲撑着柜台面。</p>
<p>“我结完帐了，先走一步。再见。”丁晓炎看着还低着头的凌召说。</p>
<p>凌召挥了挥手，没好意思抬头让丁晓炎瞧见自己烤熟的脸蛋。这时多么不容易的一次能够看看自己朝思暮想的丁晓炎的机会，当凌召想到这点时，将头抬起，发现丁晓炎早已走远。</p>
<p>有时缘分就是这么奇妙，虽有祸不单行一说，但也有福不单行发生。凌召又再次见到了丁晓炎。凌召走到教学楼总会经过一片绿植园，穿过后走几步就能够到了。在他刚走出那片绿植时惊讶发现李文龙正在和丁晓炎聊着什么，丁晓炎发现凌召后就急匆匆的走了，连跟李文龙道别和跟自己打招呼都没有。凌召正纳闷她怎么会认识李文龙，发现李文龙直站在那发呆，看起来悲伤极了。</p>
<p>“李文龙，你怎么认识丁晓炎？她来十中干什么？”凌召走到李文龙身边将手搭在他肩上问道。</p>
<p>李文龙将凌召的手从自己肩上拿下，转过身背对着凌召慢慢走向教学楼。</p>
<p>后来凌召也没有再问李文龙这个事情，李文龙也没有跟凌召提过丁晓炎的事。</p>
<h1 id="第三话"><a href="#第三话" class="headerlink" title="第三话"></a>第三话</h1><p>随着第二次市足球联赛的逼近，凌召将更多时间花到了足球部上。李文龙为了让凌召能够发挥出最大潜力，每天都陪他练球到很晚。当然再晚也会有李文龙的女粉在场边守候。</p>
<p>“你看，秦珊啊，蒋美龄啊这些美女们每天都这么辛苦的陪着我，怪不好意思的。”凌召说完用手捂着脸假装一副怪不好意思的样子。</p>
<p>“哧！”李文龙刚喝到嘴里的那口水差点喷了出来。“又不是陪你，你有什么不好意思的。好好练球，别成天想这些乱七八糟的，你没有经验，实战又少，自己摸索时间等不起，这段时间我陪你练习，是不是感觉进步了很多。”</p>
<p>“那是，李文龙亲自带那还会不成。”凌召双手叉腰神气的说。</p>
<p>“少来，今天时间差不多了，走了。”李文龙用力拍了下凌召的背。</p>
<p>出球场，换好衣服，走出场馆。走在通过十中大门的树荫大道上，李文龙挎着书包，一手扶着自行车，一手托着球把玩着，凌召双手推着自行车，女粉大队们也陆陆续续的骑着车走了。天已黑，路边的灯亮了起来。凌召看了看神情自若的李文龙。</p>
<p>“那个…”凌召打算试着问下丁晓炎的事情。</p>
<p>李文龙似乎已察觉到似的，将球放进车前框子里，左脚一蹬右脚一抬骑上自行车对凌召说：“时间不早了，我们都快点回家休息吧，明天继续练。十中必胜！”说完握拳做出加油的动作，凌召也做了个同样的动作，看着李文龙骑走。</p>
<p>快到家门时发现一个高大的身影出现在面前。</p>
<p>“凌召，好久不见了。”黑影显然认识自己。</p>
<p>凌召透过昏暗的灯光看去。</p>
<p>“陈天丸？”凌召激动的叫道。陈天丸是凌召小学时非常要好的朋友，凌召经常去他家玩游戏机，什么魂斗罗，马里奥，松鼠大战，绿色兵团的。凌召仔细打量了下，说：“一年多，个子长了这么多，样子也凶悍了不少，差点认不出了。”</p>
<p>“走，我们玩去。介绍几个朋友你认识下，以后外面有人欺负，就报我们的名字，保证没人敢动你。”陈天丸大拇指往外一翘。凌召急着将自行车停在楼下，跟着陈天丸。</p>
<p>“陈天丸，你现在是外面玩的了，你在一中几班呢？还有哪些小学同学分在你们班？”凌召急着问了一堆。</p>
<p>“哈哈，凌召，还惦记着丁晓炎呢，这么含蓄干嘛！直接问我不就得了。还挺巧，丁晓炎现在跟我一个班，情书不好意思送就让我代你给她。”</p>
<p>凌召脸刷的一下就红了，没想到自个小心思这么容易就被看穿了，但心里却是十分的欢喜，想着终于有了一个能够将他和丁晓炎连在一起的人了。</p>
<p>来到街机厅，陈天丸将凌召介绍给他的两个朋友，江曰日和程三石。程三石瞧了瞧凌召，对陈天丸说：“你兄弟看起来这么斯文秀气，三好学生吧，哈哈。”说着左右望了望江曰日和陈天丸，哈哈大笑起来。</p>
<p>“别小看他，人家是十中足球校队的，来，凌召，把那个小家伙的游戏币给抢了。别让程三石小瞧了。”陈天丸将手搭在凌召肩上指着一个刚买完币的小孩对凌召说。</p>
<p>凌召这会儿还在为那事兴奋着呢，他伸手将陈天丸的手扶下，接着走到老板那买了一个游戏币，程三石和江曰日双目相望捂着嘴咯咯笑了起来。凌召拿着那枚币走到里面对那小孩说：“把我们的币交换下怎么样？”说着讲手掌张开，小孩看了看凌召手中那个币，又看了看凌召，凌召正凶横的俯视着他，身后还有三个黄色头发的大个子盯着自己，吓得赶紧将手中那堆币给力凌召，叫上自己的伙伴跑出街机厅，刚出门就回头大叫：“你们给我等着，有本事就别走。”</p>
<p>“凌召，真看不出来，你刚才那样还真像那么回事。”陈天丸松了口气说道。</p>
<p>江曰日给程三石使了个眼色。接着他们来到一个录像厅附近的一家台球室，一路上边说边笑那个小屁孩跑了还不忘放个屁。</p>
<p>“来一局，看今天我怎么灭你。”程三石抽出一个长杆擦着防滑粉对江曰日说道。</p>
<p>凌召自进入台球室就发现了于佳和韩霍还有韩霍小跟班们在里侧球桌那。整个台球室充满了烟味，于佳也拿着烟在那儿抽。凌召气冲冲的看着于佳，于佳也看着他。</p>
<p>陈天丸看到此状问：“那伙人认识你？”</p>
<p>凌召没心思答，走到于佳前面将她手中的烟一把夺了过来，往地上一扔，用脚踩灭。气呼呼的说：“你知不知道这样会影响你的嗓子吗？你以后还想不想唱歌了。这段时间看你都不怎么去音乐部，你成天都在干嘛？”</p>
<p>于佳将口中那口烟吐到凌召的脸上，说：“干你什么事，好心先生，你不也没怎么去吗。”</p>
<p>凌召正要解释，韩霍走了过来，一把揪住凌召衣领，凶狠狠的看着他，将他往外一推，力气真够大，凌召背撞到柱子上，韩霍跨步冲上去，于佳用手抓住韩霍的衣服，摇头一副心疼的样子，韩霍不顾于佳，将她手一甩，冲到凌召面前就是一拳，说道：“今儿没有李文龙，看我怎么好好教训你。”</p>
<p>接着有是一拳，凌召不是对手，捂着头，韩霍就用膝盖磕凌召头。</p>
<p>砰的一声，韩霍摸了摸头，手上全是血，对面程三石拿着球杆，另一只手做出一个漏空的动作。</p>
<p>“哟，刚才球去哪了，是不是撞到那条狗了，咦，怎么没听到狗叫呢。”程三石一本正经的说着。</p>
<p>“操，敢打老子。”韩霍怒气满面。</p>
<p>“喔，是这条，我还以为是条哑巴狗呢。”程三石左右看看江曰日和陈天丸，捂嘴笑着说。</p>
<p>韩霍气得血流的更急了，他捡起地上击中他的那个球要扔回去。趁他弯下腰时，程三石他们三人就冲到韩霍旁边拿着球杆往他身上打。韩霍那群人冲了过来帮忙。</p>
<p>不一会，韩霍和那伙人就扛不住了，跑到台球室门口，韩霍指着程三石说：“臭小子，有种，敢告诉我你在哪个学校，叫什么名字吗？”</p>
<p>“这有什么，想找我还不容易，记住我叫程三石就行，到哪都能找到我。”程三石舔了舔溅到嘴边的血说道。</p>
<p>“三石？小黄毛？”韩霍这个外面玩的当然知道了，这片地方的老大就是大黄毛，他弟弟就是人称小黄毛的程三石。</p>
<p>“难怪，小黄毛果然能打。”说完就准备走。</p>
<p>“喂，你的名字呢？哪个学校的？真不懂礼貌。”程三石说。</p>
<p>韩霍呆了一下，赶紧拉着小弟们跑了。</p>
<p>“切，一群不懂事的小屁孩。”程三石说着拉起地上的凌召。</p>
<p>“他是怕你再找他。”凌召捂着疼痛的肚子说。</p>
<p>“我知道，你跟他们很认识？一个班的吧，以后他要是再找你麻烦，直接找我，看我怎么教训这群兔崽子。”</p>
<p>由于李文龙的特训，凌召进步飞快，现在已成为首发。足球联赛开始后，十中已经连下几城。</p>
<p>训练时，陈天丸找到凌召。</p>
<p>“怎么了？”凌召看陈天丸慌慌张张的。</p>
<p>“你们足球队那个李文龙又跟程三石杠上了，说是要弄死他。”</p>
<p>“李文龙怎么跟你们一中的人扯上关系了。”凌召好奇的问道。</p>
<p>“怎么，看你跟他挺熟的，难道他没跟你提过他以前是一中的吗？李文龙年以前跟我们一个班，有次程三石正在教训一个不听话的同学时，李文龙过来管这闲事，动起手来，结果两个人都被学校开除了，转到十中，再后来的事你就知道了。”陈天丸说。</p>
<p>还真是李文龙的风格，凌召想起收作业和韩霍起冲突李文龙过来解围的那次。</p>
<p>陈天丸接着说：“最近不知怎么的李文龙跟丁晓炎好上了，经常跑到我们一中找丁晓炎，有次程三石来找我，正好碰到了李文龙和丁晓炎在一起，我跟程三石说过你小学时就挺喜欢丁晓炎，结果他看到这幕，新仇旧恨一气上来，跟李文龙干了起来。李文龙天天练球这身手也比以前强多了，结果把程三石打得很惨，今儿他准备过来好好教训下李文龙。”</p>
<p>凌召听到李文龙和丁晓炎好上了这事着实吃了一惊。想起那次在十中碰到他们在一起聊天，又想到他们时常在一中碰面的画面，心里升起一阵妒忌，可能太在意丁晓炎了，对李文龙有种特别的反感，有种想冲回球场跟他干一场的冲动。</p>
<p>凌召低头沉思了会说：“你让程三石他们等会，我会把训练时间拖的晚点，那时没人后，你们想怎么弄他就怎么弄他。”</p>
<p>回到球场，凌召拼命的往球门射球，心中那股妒气难消。到了很晚天都黑了，其他队员和粉丝们都离开球场，李文龙发现凌召一点走的意思都没有。问道：“凌召，今天怎么这么主动训练，平时这么晚你都吵着要回的。”</p>
<p>凌召看着李文龙，忽然浮现出丁晓炎依偎在李文龙身上笑着看自己的画面。</p>
<p>“压力太大，想多练练。”凌召心里发虚，不敢抬头看李文龙。</p>
<p>“没事，放松些，还有我呢。”李文龙笑着说，用脚挑起球到空中，凌空一脚强力旋转球，擦着球门左边侧栏应声入网。</p>
<p>这球好棒，凌召心里不断感叹道，只觉得自己和李文龙比起来还差得好远。以前只有崇拜，现在却有多了种要比较带来的自卑感。</p>
<p>“我去小卖部买点喝的，等会回来再跟你请教这球怎么练。”</p>
<p>凌召说完慢慢走出球馆大门，刚走出门口，程三石早已等在那，带着一群人，其中有个个子高高块头较大黄头发的人，凌召想那一定是程三石的哥哥大黄毛。他们从凌召身边走过，凌召站在原地不动，余光看见程三石对着他竖起大拇指，大黄毛从衣服里掏出一把大砍刀。刀在月光下一闪，霎那间凌召想到血腥的画面，脑袋一下子清醒过来，想起李文龙一直也没有做错什么事，他又不知道自己喜欢丁晓炎，而且他比自己优秀那么多，丁晓炎喜欢他也很正常啊，只要丁晓炎开心，自己还有什么好气的呢。李文龙心又那么好，帮过自己，还这么用心教自己，鼓励自己。 先前陈天丸说程三石要弄死李文龙，现在看这状况是真有可能了，即使没弄死也得残废吧。先到这里，凌召转身准备冲进球场，转而一想，程三石那么多人，自己单枪匹马冲进去不但救不了李文龙，自己也得打个半死，于是急忙跑到学校门口传达室让他们叫警察过来。</p>
<p>警察赶到时，李文龙已满身是血，看到警察终于坚持不住晕倒在地。</p>
<p>次日放学，凌召来到李文龙病床边，在床头放下自己用省出来的零花钱买的水果，坐在床边的椅子上看着睡着的李文龙。虽然受了重伤，脸上也是青一块紫一块的，依然无法盖住他的俊气。凌召眼角一股酸意，眼泪完全没法控制住流了一脸，他用力的抽搐着，眼泪越流越多，模糊了整个视线。模糊的眼睛看见一只手伸了过来，凌召本能的将眼闭上，这只手将眼边泪水擦干。凌召睁开眼，看见李文龙已醒，笑着看着自己，手上正流着自己的眼泪。</p>
<p>李文龙对凌召说：“你哭什么，都是些皮肉伤，过几天就好了。”</p>
<p>李文龙看凌召又开始哭了，接着说：“还哭，我听护士说昨晚你一直床边哭，一夜了，上学才走。昨晚是你叫的警察吧？”</p>
<p>凌召点了点头。</p>
<p>“这我就要怪你了，完全没必要嘛，在多等一会，我就能将他们都放倒。还好那会你出去了，不然要拖我后腿了。”李文龙假装着生气的说道。</p>
<p>李文龙看凌召一直不说话，头躺了下来，看着天花板叹了口气说：“你这是干什么来的，又不和我说话。下午学校来人通知我被退学了，看来我又要转学了，不知道这次还有没有学校愿意再要我了，你也不说点开心的话逗我开心开心。”</p>
<p>“怎么会这样，那以后我们的足球怎么办，没有你，十中怎么踢？”凌召听到这着急的说。</p>
<p>“我也不想这样，不过也没有办法，以后十中就靠你了，你要相信自己，你现在缺的就是自信了。等我到了其它学校，我们还是有机会在一个赛场上踢球的，我期待着下个赛季的到来。你可不能因为我不在而放弃训练啊！”</p>
<p>凌召含着泪不断点着头，心里充满了对李文龙的愧疚。在凌召准备回去走到病房门口时，李文龙语气严肃的叫住了凌召。</p>
<p>“这一年你要好好练球，下次赛场上你要用全力和我比，如果你输了，我们就再也不是好兄弟了。同意？”</p>
<p>凌召没有转身，背对着李文龙点了下头就离开了，其实这也是凌召所期待的，对！与其对李文龙羡慕嫉妒恨，不如堂堂正正在赛场上去赢来的光荣。</p>
<p>十中缺少了李文龙犹如猛龙少了龙头一般不堪一击，很快就被淘汰了。凌召也开始了准备下一届联赛的训练，有了和李文龙的约定，即使李文龙不在身边监督他也比以往更加刻苦了。</p>
<p>临近圣诞，也是同学们之间相互赠送圣诞卡片的时候。凌召没有丝毫放松自己的训练，走出球场，回家路上经过那家书店，发现从小就和丁晓炎总在一起的姚婷正站在书店门口。</p>
<p>“这不是姚婷吗？在等人吗？”凌召走上前问道。</p>
<p>“凌召！”姚婷发现凌召站在身旁自己要抬着头看，她用手从自己头上横划着比划了下，说：“长这么高了，小学时都看出来呢，看着好像也帅了好多。我是在等丁晓炎。”</p>
<p>凌召一听到丁晓炎的名字，心开始扑动一阵急跳，他往书店看去，看见丁晓炎还在里面找书。</p>
<p>“你们常到这里买书吗？”凌召问道。</p>
<p>“也不是，偶尔吧，我都是跟丁晓炎来的。这么久没见你，你怎么都不来一中找我们这些老同学玩呢，把我们都忘了吧！”姚婷撅着嘴说。</p>
<p>“怎么会，天天都想你们呢。这不圣诞节快到了，等我给你们这些老同学寄贺卡啊。”凌召说。</p>
<p>“姚婷，我买好了。”丁晓炎走出书店对姚婷说。</p>
<p>凌召转头看见丁晓炎，脸忽然又热起来，他只好又低下头。</p>
<p>“丁晓炎，你看，凌召这两年变化挺大的吧，是不是比以前帅多了？”姚婷笑着对丁晓炎说。</p>
<p>“我看还是跟以前一样啊。”丁晓炎看起来没有姚婷那样激动，很平淡的看着姚婷。</p>
<p>对嘛，凌召想着就算自己再怎么变也没法跟李文龙比，想必在丁晓炎心里只有李文龙，其他人她定是瞧不上。越想，凌召越难受，一个人的不开心往往都是来自比较吧。</p>
<p> 回到家，凌召对着镜子，想着丁晓炎的淡淡的表情和她的话，还有镜子前浮现的李文龙帅气而阳光的笑容，心中只觉得自卑到了极致。</p>
<p>凌召从柜子中翻出小学时自己的照片，对着镜中的自己看了又看，虽然没有质的变化，但五官却是更正了，脸颊更加消瘦，轮廓更清晰了，回想姚婷的话，觉得跟以前的自己比就好了。想到这。他回到自己的书桌前，从抽屉里拿出一堆准备好的贺卡。将笔蘸了蘸墨水，他第一个想写给的人当然就是丁晓炎了。</p>
<p>他写道：“丁晓炎：不知道你是否会回想起小学时我们同桌的快乐时光，自从我被调到后面座位，就没有一刻不想你，想和你再在一起，我知道你现在喜欢的是李文龙，他也是我的好兄弟，是个很棒的男孩，我的目标，我真的为你感到高兴。圣诞到了，祝你在新的一年能够同样开开心心的！”</p>
<p>写完所有人的贺卡，凌召来到陈天丸家，托他将这些贺卡送给以前小学同学们。第二天，陈天丸将贺卡一一送给同学们时发现少了几张，估计是书包没拉紧路上弄丢了，于是他将缺的那几个贺卡自己补上，随便写了几句祝福话。在丢失的这几张卡片里包括了丁晓炎那张。就这样凌召对丁晓炎的这份表白和祝福在丁晓炎的世界里错失了。</p>
<p>丁晓炎给凌召回了一张贺卡。</p>
<p>贺卡中这样写着：“凌召：谢谢你的卡片，圣诞快乐，彩虹桥的另一端十分精彩，但需要努力才能够踏过去，祝愿你新的一年球技大增，获得冠军，我会为你加油的！”凌召看着丁晓炎对自己的这份鼓励，心中充满了力量，将卡片好好收起，双手握拳，心里默念着这次一定要得冠军。</p>
<h1 id="第四话"><a href="#第四话" class="headerlink" title="第四话"></a>第四话</h1><p>足球毕竟是团体运动，这次联赛也是凌召初中生活最后一次了，十中没有李文龙进入淘汰赛都非常困难，可凌召也顾不了这么多了，他现在只有全力提高自己的体力和球技，他把训练时间延得更长了，休息时就看意甲，研究战术和队友们的话题也是十句九句不离足球。</p>
<p>到了赛季，十中开局虽然胜了两局，但是都非常的吃力。第三场面对的对手是上届第四名的四十七中，因为接受了被十中开除的天才足球少年李文龙，这次他们的目标是冠军。</p>
<p>比赛前，十中更衣室，凌召将大家聚到一起说：“大家心里肯定都明白，这场比赛我们想赢几乎不可能，但我这几天仔细的看了他们的球员资料和比赛录像，具体情况我先不说，大家只要按我的计划来，还是有机会能够胜的。”</p>
<p>队友们都用好奇而怀疑的目光看着凌召，只有教练点了点头说：“凌召，这次我是真没招了，如果你有那么一丁点把握就去试试，我支持你。”</p>
<p>“那好，这次按541进行防守，上半场我不上场，只守不攻。下半场采用防守反击，我会全力将比分扳回来。”</p>
<p>队员们和教练都惊诧的看着凌召，多么冒险的一招棋啊。但凌召却表现得异常冷静而自信。</p>
<p>“好，大家就按凌召的办法来，加油，十中必胜！”教练大声给队员们鼓气。</p>
<p>比赛一开始，四十七中的攻击就在李文龙的带领下如狂风暴雨般倾盆而下，虽说是全场防守，但在这样有组织又激烈的撞击下也没能守得住。上半场以0比7大比分落后，这样的比分，无论是观众还是在十中队员甚至是对凌召有信心的教练看来都是没有什么扳回的机会了。韩霍气冲冲来到凌召面前大声吼道：“看你干的好事，十中的脸都让你丢尽了。”</p>
<p>哪知凌召却轻松的回答道：“丢脸的是你吧，我又没在场上。”</p>
<p>韩霍咬着牙，眼睛直瞪着凌召说：“好小子，有你的，乘机报复我是吧，等会下半场看你怎么收拾这局面。”说完转身做了个操的手势。</p>
<p>“喂，韩霍，有本事跟我比比吗？”凌召说。</p>
<p>“比什么？”</p>
<p>“比下半场是你丢球少还是我进球多，怎么样。”凌召笑着说。</p>
<p>“比就比，输了，就等着被我揍吧。”韩霍用手指着凌召说。</p>
<p>“好，我输了，随你怎么打，我绝不还手。”</p>
<p>下半场，四十七中为了保存实力，换下了两名主力，李文龙继续在场上。开球时，凌召望着李文龙。</p>
<p>“终于等到这一刻了，看来你是宝都压到下半场了，让我们好好比比吧。”李文龙笑着对凌召说。</p>
<p>“恩，可不要放水啊，不然我们就不是好兄弟了。”凌召说。</p>
<p>“还当然。”</p>
<p>哨声响起，凌召犀利的带着球一连突破中场来到后场，后场队员一脚铲了过来，凌召将球挑起，跳过对手，一脚站地，另一脚凌空一个快速的大弯弧线球冲向四十七中大门左侧，球擦着球门侧栏应声入网。这一球一气呵成漂亮极了。李文龙也惊住了，这不是他最擅长的那招么，竟被凌召运用的这样娴熟。</p>
<p>接下来，李文龙进攻的机会越来越少，凌召控球时长越来越长，满场的跑，李文龙上半场踢得太疯，体力没法跟上凌召了。一旦李文龙接住球，凌召还会过来协助围堵，断下球就回传队友，自个拼命往前跑，接到长传就疯狂的攻击。在这样疯狂的战术下，居然扳回了比分，打成了8比8平，进入加时。</p>
<p>加时赛时，四十七中已没有了换人名额，而十中将体力充沛的三名队员换上场，这时四十七中被一口气追上这么多比分心理上的压力是数倍于十中的。原来这一切也都在凌召的预料之中。早在比赛前，凌召就仔细研究过四十七中，发现他们今年厉害的后卫都退役了，新生的没有补上，联赛以来一直以攻代守，所以他才想到不在上半场和他们硬拼，将赌注都压在了下半场。看来这战略是没错了，在加时赛时凌召依旧保持了下半场那股冲劲将四十七中打回了老家。</p>
<p>比赛结束后，李文龙走了过来，伸出手，凌召抓住他的手，李文龙红着双眼说：“你赢了，我不如你。”</p>
<p>凌召用力一拽将李文龙抱住，凌召对李文龙的感觉真是酸甜苦辣咸五味俱全。这一时竟无话可以说出来。对于李文龙与无巨细的教足球他感激不尽，对于丁晓炎的事情他醋意满满，对于退学的事情他追悔莫及。</p>
<p>这场与李文龙的对战立刻传遍各个中学，校刊上到处都是凌召球场上的照片和采访的照片。赛中凌召战术的安排，下半场精妙绝伦进攻表现让人印象深刻。</p>
<p>训练时，教练领着几位新同学来到大家中间，对大家说：“同学们，这三位今天要加入我们十中的校队，他们都是非常优秀的球员，这次我们有希望能够那个冠军回来了。”</p>
<p>其中一位长发飘飘走到凌召跟前说：“凌召，上场比赛够精彩的，多么又想象力的比赛啊！其他两位都是跟着我来的，都是经验丰富的好手。对了，我叫王亦，待会我就办入学手续，到你班上，以后多多指教，让我来帮你圆个冠军梦吧。”</p>
<p>王亦是个爱热闹的人，他组织班上同学到他家里开派对。他家在江边有座独楼。这次派对王亦发现凌召总是一副闷闷不乐的表情，在房顶烧烤时，王亦发现凌召已经回去了。他向身边的秦珊打听原因。</p>
<p>“你刚来不知道，凌召以前跟于佳好过一阵，现在于佳跟凌召死对头韩霍在一起，你说你把他们邀到一块，凌召不尴尬才怪。”秦珊说。</p>
<p>“喔，喔，这样，我算明白了，这好办，我再办个派对。”王亦笑着说。</p>
<p>他果然说到做到，打听到跟凌召关系好的同学后。没几天他又办了个，这次，他只请了一些跟凌召玩的好的到江滩边烧烤。他特意请了于佳而没请韩霍。一箱烧烤吃的差不多时，王亦给大伙使了个眼色，说：“走，走，大家帮我再搬下吃的来。”凌召和于佳准备起身时，王亦对他说：“你们就在这里等好了，让我们去搬就好了。”</p>
<p>一转眼，江滩就只剩凌召和于佳了。与刚才的喧嚣相比，此刻的安静有点让人窒息的感觉。远处江面传来一阵船鸣声，于佳站了起来。望着坐在地上一脸无所适从的凌召说道：“王亦是故意的，找这个机会让我单独和你在一起。”</p>
<p>“为什么这么说？”凌召抬头望着双手叉在背后一只脚抬起做出不稳姿态的于佳说。</p>
<p>“他找过我，跟我说，要我不要跟韩霍在一起，让我和你好。”</p>
<p>“什么？他怎么…”凌召惊慌的站起来。</p>
<p>“他一定是错以为你喜欢我，所以想帮你，但其实是你不要我。”于佳转过身望着远方那支鸣着笛缓缓开过来的船。凌召又低下头，于佳转头看着凌召，接着说：“我现在还喜欢你，但你不要担心，我只要把你放在心里就好。”于佳将右手放到胸口，眼眶开始湿润起来。</p>
<p>凌召望着于佳欲言又止。</p>
<p>“王亦说如果我跟你好的话，可以捧红我。”于佳说。</p>
<p>“王亦？他有这本事。”凌召奇怪的问。</p>
<p>“你不知道吧，他父亲是王朝集团董事长，王朝娱乐就是他们旗下的，那个SGirls组合就是王亦班上的，他给一手捧红的。”</p>
<p>“难怪他家房子这么大呢，但是我…”凌召为难的说不下去了。</p>
<p>“没事，你不用愧疚，我已经告诉王亦我们的事情了，他说只要以后不跟韩霍在一起就行，免得让你看着心里难受。我答应了，反正我跟韩霍一起也是因为你，一点不可惜，我会好好把握这次机会…”于佳一副强作开心的笑着说。还有一句她没有说出口：“等我成为万人迷时，我想那时你可能会喜欢我的。”</p>
<p>“我是真心祝你能够成功的，你的愿望马上就要实现了。”凌召从地上捡起一听可乐，哧的一声打开，举杯说道。</p>
<p>“可惜我的愿望不是这个啊。”于佳眼睛直直的看着凌召，好像有种支撑不住想要倒在他怀里的感觉。凌召是知道于佳想法的，双眼无法承受这种过浓的情意，有种无法呼吸的感觉。</p>
<p>凌召一口气将手中可乐喝完。将易拉罐捏扁用力抛向江面。呼出一口气，接着对于佳说：“我最近写了一个新曲子，要不要听听？”</p>
<p>于佳点了点头，凌召从书包中掏出一个口风琴吹了起来。</p>
<p>于佳坐在地上，头侧贴着交叉置于双膝的双手上，目不转睛的望着吹着口风琴的凌召，细细的欣赏他的曲子。</p>
<p>吹完曲子，凌召自信的笑着说：“怎么样，等你成为明星后，让我做你的御用作曲人没问题吧。”</p>
<p>于佳没有回答他，从他手中拿过口风琴，没有擦，直接放到嘴上吹了起来。吹的曲子就是许愿那次他们一起弹的那首。每次想凌召时于佳就会弹这首曲子，于佳娴熟的吹着这首曲子，因为她早已弹过了无数遍。双手握着凌召的口风琴，贴着琴口，仿佛感觉自己已抱着凌召，吻着他的唇。她知道这只是幻觉，泪水已忍不住流过面颊滴在了口风琴上。</p>
<p>王亦继承了他父亲那种聪明和气质，不光成绩名列年纪第一，对待同学也十分平易近人，一点架子都没有。对于凌召来说，在接下来比赛中，王亦无疑起到了巨大的作用，使得十中能够顺利进入到淘汰赛。</p>
<p>随着联赛到了淘汰阶段，凌召他们年纪也开始面临初三的毕业。学校为了保证升学率，专门开设了晚间提高班，将那些各个班级成绩一般但有希望能够进一步提高的同学集中到一个班上学习。凌召成绩一般所以也在这群人中，这样他就还需要多花些时间在这个提高班上。</p>
<p>放学后，凌召跟王亦分组进行了一场训练赛，吸引力很多的同学围观。很多非球迷都是因为想看王朝董事公子王亦而慕名而来的。王亦球场上一头长发飘飘，非常帅气，球技也不亚于李文龙，和他一块来的两名同学也是他精挑细选的，所以这次十中能够进入淘汰赛，王亦亦是功不可没。打完训练赛，凌召已是大汗淋漓，接着他还要赶着去参加提高补习。</p>
<p>凌召来到提高补习教室，坐了下来，身上的热气还没有散，他从书包里拿出本子不住的扇着。</p>
<p>“跑着来的吧。”凌召旁边一位女孩子问道。</p>
<p>“刚才踢球了，好热！”凌召一边扇着，一边转过头看那女孩。那女孩白白净净的，五官清秀端正，大大的眼睛正有神的瞧着额头发稍汗湿的凌召。</p>
<p>“我叫田晓宁，是你提高班的同桌。”田晓宁说。</p>
<p>“我叫凌召，看我这身汗，我先去冲下。”凌召用手提了提衣领口。</p>
<p>冲完，凌召感觉舒畅极了。课上，田晓宁问凌召：“你在班上排名第几？”</p>
<p>“三十多吧。”</p>
<p>“我也是，那你打算考哪个高中？”</p>
<p>“还是十中吧。”</p>
<p>“我打算上一中，不过可能考不上。”田晓宁看起来也没有怎么担心的样子说。</p>
<p>凌召听到一中就想起了丁晓炎来，想着她是不是也能考上一中高中呢，转而一想是不是自己也应该好好学习了，也争取考上一中高中呢，这样就能够常常见到她了。</p>
<p>“我也想考一中。”凌召说：“但是现在水平估计难，离中考也没有多长时间了，不知道还来不来得及。”</p>
<p>“所以才让我们来提高班嘛，努力努力还是有希望的。”田晓宁蛮自信的说着。</p>
<p>在课上，田晓宁埋着头在本子上涂着画，凌召觉得很诧异，刚不是说要上一中么，上课还这么不认真。</p>
<p>“田晓宁，不是想考一中吗，怎么不好好听课，在画什么呢？”凌召问田晓宁，凑过去看她在画什么。</p>
<p>田晓宁急忙趴在本子上，有些不好意思地说：“没画什么，我是要上一中，考不上也能上的。”</p>
<p>“是么，你家有关系么。”</p>
<p>“恩，我爸有办法。凌召，你高中毕业后有打算考哪个大学吗？”</p>
<p>“这个，还从没想过呢，先把中考搞定再说吧。你有打算考哪个大学吗？”</p>
<p>这时老师发现他们俩一直在讲话，就点田晓宁站起来回答问题，田晓宁站起来时一着急把那个本子弄到地上，凌召帮着将那本子捡起，已经站着的田晓宁焦急而尴尬的看着凌召捡起本子后惊讶的看着本子的表情。</p>
<p>田晓宁回答完问题，满脸通红的从正在仔细欣赏本子上画的凌召手中将本子拿了回来。</p>
<p>“真像，你很早就知道我了呢，前面都是我踢足球玩乐器的画，最后一张肖像画是刚才画的吧，跟照片一样样的，好厉害好专业。”凌召兴奋的说。</p>
<p>田晓宁合上本子低着头半天都没有啃声。</p>
<p>快下课时，田晓宁对凌召说：“下次提高课你带几张你的照片送给我好吗，我现在还画的不好，有照片毕业后还能够有个纪念。”</p>
<p>“好啊，没问题。”凌召站起来收拾书包打算走。</p>
<p>“还有，你问我大学想去哪，我是打算直接去美国读，我有亲戚在那。”田晓宁说。</p>
<p>“美国，这么好，我就没有办法了，我没有一个亲戚在国外。”凌召羡慕极了。</p>
<p>“我去了后就可以给你担保啊，这样你也能够过来了啊。”田晓宁一副感觉一切都是轻而易举似的表情说。</p>
<p>凌召看着田晓宁期待的眼神看着自己，他知道这只是随口说出的一句话，但心里却是十分开心着呢。</p>
<p>回家路上，他一路哼着小曲。</p>
<p>随着淘汰赛的进行，一切都看起来很顺利。摆在十中面前的最后一堵墙是连续获得数届冠军的一中。</p>
<p>广播体操结束后，凌召和王亦边走边聊着应对一中的战术，在上楼梯时，一个女孩大叫了一声凌召的名字，凌召和王亦朝上看去，原来是田晓宁，凌召也回了句：“田晓宁。”挥挥手跟她打了个招呼。</p>
<p>王亦凑到凌召耳边说：“怎么认识这么漂亮的女孩，回头介绍给我。”</p>
<p>凌召看了看王亦色迷迷的眼神，忽地想起叶正找他递给于佳情书的事情，结果是两边不讨好，叶正这个朋友也没得做了。于是凌召对王亦说：“我也不认识啊，就是一粉丝，想泡自己追去。”说完就快速朝前走去。</p>
<p>王亦赶紧追了去，拉下凌召的衣袖说：“喂！别那么小气，不像介绍就算了，也用不着这样嘛，名字都记住了还说不认识，不用担心，兄弟我不跟你抢，漂亮妹子多的是，有你这么好的哥们可不容易咯。”</p>
<p>凌召笑着用力朝王亦胸口推了一把，假装生气的说：“去，谁担心了，不要太自信了，好好准备下场比赛，我想赢，我最在乎的人也希望我能赢，现在只剩最后这一场了。”</p>
<p>王亦看着凌召一脸认真的表情，哈哈大笑说：“最在乎的人，哈哈，是刚才那个漂亮女孩吗？”接着假装一本正经拍了拍凌召的肩膀说：“这不，here I am，我来十中就是来助你一臂之力的，我来这就是因为你，你不知道吗，你不知道你那场和李文龙的比赛又多精彩，彻底的吸引了我。”</p>
<p>“少胡扯，谁不知道是你老爸在这边有个项目才把你带过来的，这些甜言蜜语的话跟姑娘说去。我看你最近练球越来越不刻苦了，一点都不像李文龙。”凌召非常认真的表情说道。</p>
<p>“像李文龙那样干嘛，还不是被你击败了。”王亦一脸不服的说。</p>
<p>“他只是在足球上，准确来说是那一场比赛输给了我，其它地方，我比不过。算了，总之一句，已经到了这一步，绝对不能输，ok？”</p>
<p>看着凌召真的认真起来，王亦在一旁不停地点着头。</p>
<h1 id="第五话"><a href="#第五话" class="headerlink" title="第五话"></a>第五话</h1><p>命运往往都不那么会顺着人意，对凌召是，对丁晓炎也是。</p>
<p>画面终于定在了凌召期待的决赛，这次主场是在一中，上半场王亦和凌召娴熟的配合通过防守反击在快结束时压哨率先取得一分。凌召开心的小跑到场边，看见田晓宁已经准备好毛巾和水正等着他，他接过水，田晓宁满脸笑容深情的望着凌召，凌召想着凭借这一分优势，下半场就能够很容易掌握主动权，胜算将非常大。他打算在胜利后在台上大声说出对丁晓炎鼓励的感激。拿着水正要喝时，忽地感觉有个眼神在另一边看着自己，他放下水杯，往那边看去，那个身影忽地消失在人群中，那身型和发型像极了丁晓炎。</p>
<p>这一定是自己想丁晓炎想得太多了产生的幻觉吧。凌召将水往脸上泼了去，想让自己清醒下。</p>
<p>下半场，十中在最后时刻因为韩霍的冲动红牌下场而陷入被动，最终没能够挡住一中猛烈的攻势。这样凌召因为败落而失去找丁晓炎的勇气。那以后凌召就再也没有见过丁晓炎了。</p>
<p>即使这么多年过去，小学同学聚会上她也没有出现。凌召翻着那篇丁晓炎的文章，文章是这样写的：“</p>
<p>那年，我四年级，转学到一所小学，周围都那么陌生，和我同桌的以为男孩成为了我在这儿的第一个朋友。他叫凌召，我们很谈得来。他送给我一只黄色的电子表，这是我收到的第一个男生的礼物。</p>
<p>快乐的时光总是短暂的，在凌召被调到后面做的那天，放学后，我站在他必经路边的一颗树旁等他。在他经过时我问他不跟我坐是不是不开心，他看起来有些伤心，看也没看我一眼就走了。</p>
<p>自那以后，我常常看见凌召和他的同桌们吵架。一次学校庆典上，凌召来了场钢琴独奏，随着琴声飘荡在我耳边，我发现我已经喜欢上了他。他送给我的那只黄色表我放在抽屉一打开就能够看见的地方，这样我每次打开抽屉就能够回想和他同桌的时光。小女孩的心思就是这样的简单，单纯着，虽然也知道自己对凌召来说只是一个普通的同桌过的人而已，但却也能够勇敢的不顾一切的去享受着这份纯纯的单恋。</p>
<p>我们那个年代没有手机，小学临近毕业那会，同学们都会让自己在乎的人在自己的本子上留下家庭住址联系方式，因为毕业后大家可能会分开去其它的学校。当我把本子给凌召时，他的那些朋友们都这跟着起哄，弄得凌召不好意思的脸都红了，为了让他不尴尬，我让他的那些朋友也都在本子上写了。</p>
<p>上课后，我一直在想为什么就我去找凌召时他的朋友们会起哄，其他女同学去时他们也没什么反应啊，想着想着趴在桌上回头抄凌召坐的方向看去，发现他也正在看着我，我有点惊慌，心跳加速，但视线一直没有离开他，他也没有离开我。我有点不相信，回过神，发现他已经趴在桌上睡着了。</p>
<p>上了初中，我们分在了不同的学校，但因为一个人，让我能再了解到凌召在十中的所有事。这个人算得上是万人迷吧，班上的女生都被他迷得神魂颠倒的，可不知怎么的他就是喜欢我，我都没怎么跟他说过话耶，就是这样，可能一种感觉能让你毫无缘由的喜欢上一个人。这个男孩叫李文龙，在他跟我表白后，我说我已经有喜欢的人了，李文龙看起来有点不服气非要问出那个人是谁。</p>
<p>后来他跟班上一位同学打架劝退后转到了十中凌召的班，虽然转校了，但是因为凌召，他也能够有足够的话题来找我说了，对于我来说我也能够知道更多凌召的事情了。听说凌召加入了足球部，我想这样我就能够在放学后去他们学校看他练球了。</p>
<p>但那次当我在球场边栅栏看时发现一个非常漂亮的女生正在将一封信递给凌召。看着那女孩子不好意思的样子，我想那一定是情书吧。这时发现球场上另一边李文龙正带着一种伤心的眼神看着我。一会凌召也朝我这边看来，我赶紧躲到一旁树后。</p>
<p>后来听说我们一中要跟一中比赛，我想凌召应该也会来参赛，于是我申请了球赛自愿者在场边捡球。这样就能够近距离看见凌召了。开赛前，我在场边做准备，发现凌召跑到观众席和以前小学同学们打着招呼，我有点后悔应该呆在观众席了。比赛时，凌召全神贯注的注视着球场，直到最后他才被换上场，没想到我捡到他唯一的一个球竟是他的乌龙球。那时我离他是那么近，但他双眼已无神，看起来难过极了。</p>
<p>我一直担心着他后来的状况，一直盼着李文龙来找我。但这次李文龙带来的消息是凌召跟班上一个玩音乐的女孩子好上了，我知道凌召是很喜欢音乐的，想着他们一起聊着他们喜爱的音乐幸福的画面，有种难于形容的妒忌涌上心头。</p>
<p>李文龙跟我说不信可以第二天放学后去江滩看看，因为那女孩子给凌召的情书里是约着去那相见的。等我到江滩时看见那女孩正抱着凌召，我心里真的好难受，原本还抱着的一丝侥幸变得绝望。</p>
<p>这样的心情我想会持续很久吧，晚上我无法入睡，枕头全被泪水浸湿。</p>
<p>放学后我好像被一中磁场带动了凌召家旁边的书店。因为这家书店离我家比较远，我很少来。我漫不经心的翻着书架上的书，但脑海里却满是那女孩抱着凌召的画面，想到当时的情景，凌召看起来并不是很开心，他当时没有抱着那女孩。会不会只是那女孩单方面的喜欢呢，想到这里我已拿到新出的伯爵千金来到收银台。有种磁场理论就是对一个事渴望意念足够强就会产生巨大的磁场将那事吸引到身边。这时一个高大的身影出现在我身边。我抬头发现正是我日夜思恋的凌召，他好像没发现我，我跟他打了个招呼，他只是简单的回了句，然后就一直低着头。因为我们已经好久没这样一起过，我不知道他现在对我是怎样的感觉，于是也没有再说什么，在这样的气氛下，凌召不小心的碰到我的手臂，我用余光看见他害羞的脸好红，我胳膊能够感觉到他的颤动，虽然我们没怎么说话，但此时我能感觉他还是小学那会的他，那是种熟悉而难忘的感觉，我好希望能够这样多待会儿，可是凌召好像有些紧张，让我觉得他对我和对其他女生还是不一样的。结完帐，我看凌召好像还没有回过神。</p>
<p>我没法不去想和凌召的这次偶遇，接下来的一天，我没法忍住，在中午先去了十中，希望能够再看看他。来到他的教学楼下，碰到了李文龙，他开始是惊喜的表情，后来可能想到我是来看凌召的才恢复了淡定的神情。他应该也没想到我会这么喜欢凌召，李文龙说给凌召写情书的女孩后来没有跟凌召在一起，看来我的感觉是对的。接着李文龙说他愿意帮我去问问凌召喜欢谁。说可能那个人有可能是我。</p>
<p>听到这，我忽地红起脸来，心中窃喜，口中却连连说不可能。但我又害怕如果那个人不是我，我可能会更加难受。因为太在意所以会害怕，我让李文龙不要问，即使问了也不要跟我说。李文龙不傻，很快看出了我的小心思，他知道我对结果是既期待又惧怕，但是这种事情如果不挑明怎么会有结果呢，我们都知道凌召不是那种主动的人，于是李文龙想了个办法。他说现在凌召球是越踢越好了，如果十中能够获得冠军，他就帮我问，如果凌召喜欢的人是我，他会祝福我们，如果不是，李文龙希望我能够接受他。我没有答应如果那个人不是我就接受李文龙这个条件，心里觉得有些对不起李文龙，我不希望李文龙成为备胎，那样对他不公平，我是真的把他当成很好的朋友，但也只能到这一步。李文龙神情有些恍惚，我想定是我的回答伤了他骄傲的心。</p>
<p>这时，我看见李文龙身后出现了凌召的身影，他不会听到了我和李文龙的对话吧。我一时不知该如何面对，于是匆匆的走开了。</p>
<p>接下来，我就一直期待着足球足球赛的进行和李文龙定期到一中来跟我描述和称赞凌召如何聪明。每每听到凌召的事情我都会很开心，李文龙说他喜欢看到我笑的样子，他也知道是因为他说了很多凌召的事使我能够感到愉悦。所以每次他都只说凌召的事情，其它的事情包括他自己的事情他都是只字不提。</p>
<p>人生总是会出现很多无法预料的事情，上次因为打架而跟李文龙一起退学的程三石和他又在一中碰到了，他们又打了起来。这次打架后，李文龙就一直没有再到一中来。</p>
<p>这样我再无法知道凌召的消息，就算是守株待兔吧，我还是想像上次那样能够在那书店偶遇凌召。这次我要主动问他的近况，我暗暗的下着决心。</p>
<p>我和他还是有缘分的吧，一次我在书店里面挑书，跟我一起来的小学时就跟我要好的姚婷好像在书店门口和什么人说着话。我走出书店，发现是凌召，他还是跟上次一样，一见到我就低着头，姚婷说凌召比以前帅了，但我觉得他一直都很帅啊。</p>
<p>姚婷后来说凌召要给老同学们写贺卡，想着十中这最后一届足球联赛没有了李文龙，夺冠可能无法实现了，我也没法知道凌召心里那个她是不是我，想着每次碰见凌召那害羞的画面，我越发想确认了。于是我给凌召回卡里表达希望他能够夺冠的心情，我想如果凌召心中的那个她是我的话，他一定会全力以赴去夺冠的吧。我想当他获得冠军那天，我会鼓起勇气向他表白，就算没有夺冠，我也会，我不想错过我最喜欢的人。</p>
<p>接着的事情远比想象的好，从十中战胜李文龙带领的四十七中开始，校刊里不断出现凌召的身影，富家子弟王亦的加入让十中如虎添翼，战无不胜，一直冲到决赛和我们一中开始了最后的角逐。</p>
<p>决赛那天，空中飘满了气球彩条，赛前十中的王亦请来他们公司的当红明星过来表演助阵，从演出名单我能看到那位给凌召写情书的于佳的名字，现场我能看到于佳一边唱着歌跳舞，一边看着场边正在做准备运动的凌召，那种不一样的眼神，想想自己从小就很喜欢跳舞，也希望自己能够像于佳那样在观众面前表演展现自己。</p>
<p>比赛开始后，十中打得很不错，虽然我不懂足球，但从射门次数控球时间看来，明显能够感觉十中占据了优势，果不其然在中场结束前凌召一脚凌空射门将球打入。看着凌召兴奋的在场上奔跑着，我也忍不住欢呼起来。当然我能够感觉到边上同学看着我的异样眼神。我兴奋的拿着早已准备好的毛巾和水朝十中场地那边走去。</p>
<p>当我接近时，凌召正开心的带着一副帅气自信的笑容朝场边一位看起来秀美很有气质的女孩走去，那女孩微笑着用手中的毛巾擦着凌召额头的汗水，凌召的表情看起来幸福极了，他笑着从那女孩手中接过水，这时，我已感到脚有些发软，我急忙转过身朝人群中走去。此时，我觉得自己好傻，我这么一个平凡的女孩还天真的以为凌召会喜欢自己，想着他一直都在不断的努力着，琴弹的那么好，能够让和他一样优秀的于佳对他恋恋不忘，还通过自己的努力把自己不擅长的足球都踢得这么好，能够交上这么一个气质与美丽兼备的女朋友。</p>
<p>觉得天天想着的凌召离自己越来越远，有种以后就再也无法见到凌召的感觉，我坐在观众席上，用捧着的头发将头埋在里面不停的流着眼泪，比赛的结果对我来说已不重要。</p>
<p>那以后，我再也没有见过凌召，但对他的这段思念去一直住在我心里。”</p>
<p>看完这篇文章，凌召已按耐不住了，他已管不了那么多了，他一定要去见丁晓炎，不管她现在如何，也不管她是否还和以前一样喜欢自己。</p>
<p>通过出版社，凌召找到了丁晓炎的家。</p>
<p>打开门的是一个十来岁的男孩，凌召突然觉得自己是不是有些冒失。这么多年了，自己虽然没有结婚，但同龄人大多都该有这么大的孩子了。</p>
<p>“你是凌召叔叔吧。”那小孩问道。</p>
<p>凌召从发呆中回过神来。用惊讶的眼神看着那小孩。那男孩没等凌召回答继续说道：“来找我妈妈丁晓炎吧，她已经去世了，就在不久前。”</p>
<p>男孩看着凌召的眼睛，已经红了一片。</p>
<p>“我是丁晓炎的养子，我翻她的日记本知道了你。”男孩说完牵着凌召来到丁晓炎的房间，房间里书柜上堆满了书，书桌上还留着她未完成的作品草稿，相比结局丁晓炎一定会写得很圆满吧。凌召这么想着，眼前浮现出丁晓炎坐在书桌前写着小说的身影。他伸出手，那身影化成粉末飘散开去，在阳光的照耀下散发着亮光。</p>
<p>男孩拿出一个日记本递给凌召，刚翻开，他已控制不住满脸泪水如泉水不住从下颚流下来。那日记本里贴满了丁晓炎从校刊里剪下的凌召的照片，这么多年她一直精心的保存着。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一话&quot;&gt;&lt;a href=&quot;#第一话&quot; class=&quot;headerlink&quot; title=&quot;第一话&quot;&gt;&lt;/a&gt;第一话&lt;/h1&gt;&lt;p&gt;决赛进入了加时赛，凌召一记凌空射门，球入网，十中获得联赛冠军。凌召站在获奖台时当着所有人的面对着喇叭说，“丁晓炎，谢谢你的加油，让我
    
    </summary>
    
      <category term="我的小说" scheme="http://ming1016.github.io/categories/%E6%88%91%E7%9A%84%E5%B0%8F%E8%AF%B4/"/>
    
    
      <category term="小说" scheme="http://ming1016.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>细说 GCD（Grand Central Dispatch）如何用</title>
    <link href="http://ming1016.github.io/2016/01/13/how-to-use-gcd/"/>
    <id>http://ming1016.github.io/2016/01/13/how-to-use-gcd/</id>
    <published>2016-01-13T09:20:08.000Z</published>
    <updated>2017-05-27T06:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 <a href="https://github.com/ming1016/GCDDemo" target="_blank" rel="external">https://github.com/ming1016/GCDDemo</a> 对着文章试着来调demo体会更深哦，细细嚼消化好:)</p>
<h1 id="GCD（Grand-Central-Dispatch）-介绍"><a href="#GCD（Grand-Central-Dispatch）-介绍" class="headerlink" title="GCD（Grand Central Dispatch） 介绍"></a>GCD（Grand Central Dispatch） 介绍</h1><p>GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址<a href="http://libdispatch.macosforge.org" target="_blank" rel="external">http://libdispatch.macosforge.org</a>。GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。</p>
<h2 id="GCD概要"><a href="#GCD概要" class="headerlink" title="GCD概要"></a>GCD概要</h2><ul>
<li>和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。</li>
<li>公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O）</li>
<li>可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。</li>
<li>操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在主线程执行了</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>系统标准两个队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//全局队列，一个并行的队列</span></div><div class="line">dispatch_get_global_queue</div><div class="line"><span class="comment">//主队列，主线程中的唯一队列，一个串行队列</span></div><div class="line">dispatch_get_main_queue</div></pre></td></tr></table></figure>
<ul>
<li>自定义队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//串行队列</span></div><div class="line">dispatch_queue_create(<span class="string">"com.starming.serialqueue"</span>, DISPATCH_QUEUE_SERIAL)</div><div class="line"><span class="comment">//并行队列</span></div><div class="line">dispatch_queue_create(<span class="string">"com.starming.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT)</div></pre></td></tr></table></figure>
<ul>
<li>同步异步线程创建</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步线程</span></div><div class="line"><span class="built_in">dispatch_sync</span>(..., ^(block))</div><div class="line"><span class="comment">//异步线程</span></div><div class="line"><span class="built_in">dispatch_async</span>(..., ^(block))</div></pre></td></tr></table></figure>
<h1 id="队列（dispatch-queue）"><a href="#队列（dispatch-queue）" class="headerlink" title="队列（dispatch queue）"></a>队列（dispatch queue）</h1><ul>
<li>Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。</li>
<li>Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。</li>
<li>Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dipatch_queue_t queue;</div><div class="line">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<ul>
<li>user create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue</div><div class="line">queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<ul>
<li>自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dipatch_queue_attr_make_with_qos_class</span></div><div class="line">dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class="number">-1</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.qosqueue"</span>, attr);</div><div class="line"></div><div class="line"><span class="comment">//dispatch_set_target_queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.settargetqueue"</span>,<span class="literal">NULL</span>); <span class="comment">//需要设置优先级的queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>); <span class="comment">//参考优先级</span></div><div class="line">dispatch_set_target_queue(queue, referQueue); <span class="comment">//设置queue和referQueue的优先级一样</span></div></pre></td></tr></table></figure>
<ul>
<li>dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_queue_t</span> firstQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.firstqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_queue_t</span> secondQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.secondqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_set_target_queue(firstQueue, serialQueue);</div><div class="line">dispatch_set_target_queue(secondQueue, serialQueue);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(firstQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.</span>f];</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(secondQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(secondQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h2><p>队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init;</div><div class="line">&#123;</div><div class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">          <span class="built_in">NSString</span> *label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.isolation.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</div><div class="line">          <span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</div><div class="line"></div><div class="line">          label = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.work.%p"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>];</div><div class="line">          <span class="keyword">self</span>.workQueue = dispatch_queue_create([label UTF8String], <span class="number">0</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<p>示例：后台加载显示图片<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">     dispatch_async(dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INITIATED</span>.value), <span class="number">0</span>)) &#123; <span class="comment">// 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成，</span></div><div class="line">          <span class="keyword">let</span> overlayImage = <span class="keyword">self</span>.faceOverlayImageFromImage(<span class="keyword">self</span>.image)</div><div class="line">          dispatch_async(dispatch_get_main_queue()) &#123; <span class="comment">// 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。</span></div><div class="line">               <span class="keyword">self</span>.fadeInNewImage(overlayImage) <span class="comment">// 更新UI</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>何时使用何种队列类型</p>
<ul>
<li>主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。</li>
<li>并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。</li>
<li>自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。</li>
</ul>
<p>可以使用下面的方法简化QoS等级参数的写法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="type">GlobalMainQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_main_queue()</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUserInteractiveQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INTERACTIVE</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUserInitiatedQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INITIATED</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUtilityQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_UTILITY</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalBackgroundQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_BACKGROUND</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用起来就是这样，易读而且容易看出在使用哪个队列</span></div><div class="line">dispatch_async(<span class="type">GlobalUserInitiatedQueue</span>) &#123;</div><div class="line">     <span class="keyword">let</span> overlayImage = <span class="keyword">self</span>.faceOverlayImageFromImage(<span class="keyword">self</span>.image)</div><div class="line">     dispatch_async(<span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">self</span>.fadeInNewImage(overlayImage)</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-once用法"><a href="#dispatch-once用法" class="headerlink" title="dispatch_once用法"></a>dispatch_once用法</h2><p>dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIColor</span> *)boringColor;</div><div class="line">&#123;</div><div class="line">     <span class="keyword">static</span> <span class="built_in">UIColor</span> *color;</div><div class="line">     <span class="comment">//只运行一次</span></div><div class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">          color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.380</span>f green:<span class="number">0.376</span>f blue:<span class="number">0.376</span>f alpha:<span class="number">1.000</span>f];</div><div class="line">     &#125;);</div><div class="line">     <span class="keyword">return</span> color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h2><p>设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)processImage:(<span class="built_in">UIImage</span> *)image completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> success))handler;</div><div class="line">&#123;</div><div class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.isolationQueue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">          <span class="comment">// do actual processing here</span></div><div class="line">          <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.resultQueue, ^(<span class="keyword">void</span>)&#123;</div><div class="line">               handler(<span class="literal">YES</span>);</div><div class="line">          &#125;);</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码框架</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">     <span class="comment">// 耗时的操作</span></div><div class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">          <span class="comment">// 更新界面</span></div><div class="line">     &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//下载图片的示例</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">     <span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg"</span>];</div><div class="line">     <span class="built_in">NSData</span> * data = [[<span class="built_in">NSData</span> alloc]initWithContentsOfURL:url];</div><div class="line">     <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc]initWithData:data];</div><div class="line">     <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">               <span class="keyword">self</span>.imageView.image = image;</div><div class="line">          &#125;);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-after延后执行"><a href="#dispatch-after延后执行" class="headerlink" title="dispatch_after延后执行"></a>dispatch_after延后执行</h2><p>dispatch_after只是延时提交block，不是延时立刻执行。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)foo</div><div class="line">&#123;</div><div class="line">     <span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</div><div class="line">     dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">     dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">          [<span class="keyword">self</span> bar];</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showOrHideNavPrompt</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">let</span> delayInSeconds = <span class="number">1.0</span></div><div class="line">     <span class="keyword">let</span> popTime = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>,</div><div class="line">          <span class="type">Int64</span>(delayInSeconds * <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>))) <span class="comment">// 在这里声明推迟的时间</span></div><div class="line">     dispatch_after(popTime, <span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 等待delayInSeconds将闭包异步到主队列</span></div><div class="line">          <span class="keyword">let</span> <span class="built_in">count</span> = <span class="type">PhotoManager</span>.sharedManager.photos.<span class="built_in">count</span></div><div class="line">          <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">               <span class="keyword">self</span>.navigationItem.prompt = <span class="literal">nil</span></div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">self</span>.navigationItem.prompt = <span class="string">"Add photos with faces to Googlyify them!"</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子中的dispatch time的参数，可以先看看函数原型<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );</div></pre></td></tr></table></figure></p>
<p>第一个参数为DISPATCH_TIME_NOW表示当前。第二个参数的delta表示纳秒，一秒对应的纳秒为1000000000，系统提供了一些宏来简化<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒</span></div><div class="line"><span class="meta">#define USEC_PER_SEC 1000000ull    //每秒有多少毫秒</span></div><div class="line"><span class="meta">#define NSEC_PER_USEC 1000ull      //每毫秒有多少纳秒</span></div></pre></td></tr></table></figure></p>
<p>这样如果要表示一秒就可以这样写<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_time(DISPATCH_TIME_NOW, <span class="number">1000</span> * USEC_PER_SEC);</div><div class="line">dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * <span class="built_in">NSEC_PER_USEC</span>);</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁"><a href="#dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁" class="headerlink" title="dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁"></a>dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁</h2><p>Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建队列</span></div><div class="line"><span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="comment">//改变setter</span></div><div class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSUInteger</span>)count forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">     key = [key <span class="keyword">copy</span>];</div><div class="line">     <span class="comment">//确保所有barrier都是async异步的</span></div><div class="line">     dispatch_barrier_async(<span class="keyword">self</span>.isolationQueue, ^()&#123;</div><div class="line">          <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">               [<span class="keyword">self</span>.counts removeObjectForKey:key];</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">self</span>.counts[key] = @(count);</div><div class="line">          &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dispatchBarrierAsyncDemo &#123;</div><div class="line">    <span class="comment">//防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> dataQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.dataqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 1"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//等待前面的都完成，在执行barrier后面的</span></div><div class="line">    dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"write data 1"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 3"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 4"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swift示例<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> concurrentPhotoQueue = dispatch_queue_create(</div><div class="line"><span class="string">"com.raywenderlich.GooglyPuff.photoQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(photo: Photo)</span></span> &#123;</div><div class="line">     dispatch_barrier_async(concurrentPhotoQueue) &#123; <span class="comment">// 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。</span></div><div class="line">          <span class="keyword">self</span>._photos.append(photo) <span class="comment">// barrier能够保障不会和其他任务同时进行。</span></div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。</span></div><div class="line">               <span class="keyword">self</span>.postContentAddedNotification()</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。</span></div><div class="line"><span class="keyword">var</span> photos: [<span class="type">Photo</span>] &#123;</div><div class="line">     <span class="keyword">var</span> photosCopy: [<span class="type">Photo</span>]!</div><div class="line">     dispatch_sync(concurrentPhotoQueue) &#123; <span class="comment">// 同步调度到concurrentPhotoQueue队列执行读操作</span></div><div class="line">          photosCopy = <span class="keyword">self</span>._photos <span class="comment">// 保存</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> photosCopy</div><div class="line">&#125;</div><div class="line"><span class="comment">//这样读写问题都解决了。</span></div></pre></td></tr></table></figure></p>
<p>都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。</p>
<h2 id="dispatch-apply进行快速迭代"><a href="#dispatch-apply进行快速迭代" class="headerlink" title="dispatch_apply进行快速迭代"></a>dispatch_apply进行快速迭代</h2><p>类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (size_t y = <span class="number">0</span>; y &lt; height; ++y) &#123;</div><div class="line">     <span class="keyword">for</span> (size_t x = <span class="number">0</span>; x &lt; width; ++x) &#123;</div><div class="line">          <span class="comment">// Do something with x and y here</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//因为可以并行执行，所以使用dispatch_apply可以运行的更快</span></div><div class="line">- (<span class="keyword">void</span>)dispatchApplyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_apply(<span class="number">10</span>, concurrentQueue, ^(size_t i) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>,i);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The end"</span>); <span class="comment">//这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispatch_apply能避免线程爆炸，因为GCD会管理并发<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealWiththreadWithMaybeExplode:(<span class="built_in">BOOL</span>)explode &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="keyword">if</span> (explode) &#123;</div><div class="line">        <span class="comment">//有问题的情况，可能会死锁</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span> ; i++) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"wrong %d"</span>,i);</div><div class="line">                <span class="comment">//do something hard</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//会优化很多，能够利用GCD管理</span></div><div class="line">        dispatch_apply(<span class="number">999</span>, concurrentQueue, ^(size_t i)&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"correct %zu"</span>,i);</div><div class="line">            <span class="comment">//do something hard</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</div><div class="line">     <span class="keyword">let</span> addresses = [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line"></div><div class="line">     dispatch_apply(<span class="type">UInt</span>(addresses.<span class="built_in">count</span>), <span class="type">GlobalUserInitiatedQueue</span>) &#123;</div><div class="line">          i <span class="keyword">in</span></div><div class="line">          <span class="keyword">let</span> index = <span class="type">Int</span>(i)</div><div class="line">          <span class="keyword">let</span> address = addresses[index]</div><div class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">               image, error <span class="keyword">in</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                    storedError = error</div><div class="line">               &#125;</div><div class="line">               dispatch_group_leave(downloadGroup)</div><div class="line">          &#125;</div><div class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Block组合Dispatch-groups"><a href="#Block组合Dispatch-groups" class="headerlink" title="Block组合Dispatch_groups"></a>Block组合Dispatch_groups</h2><p>dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。</p>
<p>当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。</p>
<p>第一种使用dispatch_group_wait的swift的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     dispatch_async(<span class="type">GlobalUserInitiatedQueue</span>) &#123; <span class="comment">// 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞</span></div><div class="line">          <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">          <span class="keyword">var</span> downloadGroup = dispatch_group_create() <span class="comment">// 创建一个dispatch group</span></div><div class="line"></div><div class="line">          <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">               <span class="type">SuccessKidURLString</span>,</div><div class="line">               <span class="type">LotsOfFacesURLString</span>]</div><div class="line">          &#123;</div><div class="line">               <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">               dispatch_group_enter(downloadGroup) <span class="comment">// dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。</span></div><div class="line">               <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">                    image, error <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                         storedError = error</div><div class="line">                    &#125;</div><div class="line">                    dispatch_group_leave(downloadGroup) <span class="comment">// 保持和dispatch_group_enter配对。通知任务已经完成</span></div><div class="line">               &#125;</div><div class="line">               <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          dispatch_group_wait(downloadGroup, <span class="type">DISPATCH_TIME_FOREVER</span>) <span class="comment">// dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。</span></div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123; <span class="comment">// 执行闭包内容</span></div><div class="line">                    completion(error: storedError)</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>oc例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchGroupWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="comment">//在group中添加队列的block</span></div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"go on"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种使用dispatch_group_notify的swift的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="comment">// 不用加dispatch_async，因为没有阻塞主进程</span></div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</div><div class="line"></div><div class="line">     <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">               image, error <span class="keyword">in</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                    storedError = error</div><div class="line">               &#125;</div><div class="line">               dispatch_group_leave(downloadGroup)</div><div class="line">          &#125;</div><div class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。</span></div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>oc例子<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dispatch_group_notify</span></div><div class="line">- (<span class="keyword">void</span>)dispatchGroupNotifyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"can continue"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//dispatch_group_wait</span></div><div class="line">- (<span class="keyword">void</span>)dispatchGroupWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="comment">//在group中添加队列的block</span></div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"can continue"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如何对现有API使用dispatch_group_t<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。</span></div><div class="line">- (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</div><div class="line">          [<span class="keyword">self</span> performBlock:block];</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          dispatch_group_enter(group);</div><div class="line">          [<span class="keyword">self</span> performBlock:^()&#123;</div><div class="line">               block();</div><div class="line">               dispatch_group_leave(group);</div><div class="line">          &#125;];</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//NSURLConnection也可以这样做</span></div><div class="line">+ (<span class="keyword">void</span>)withGroup:(dispatch_group_t)group</div><div class="line">     sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">     queue:(<span class="built_in">NSOperationQueue</span> *)queue</div><div class="line">     completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (group == <span class="literal">NULL</span>) &#123;</div><div class="line">          [<span class="keyword">self</span> sendAsynchronousRequest:request</div><div class="line">               queue:queue</div><div class="line">               completionHandler:handler];</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          dispatch_group_enter(group);</div><div class="line">          [<span class="keyword">self</span> sendAsynchronousRequest:request</div><div class="line">                    queue:queue</div><div class="line">                    completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error)&#123;</div><div class="line">               handler(response, data, error);</div><div class="line">               dispatch_group_leave(group);</div><div class="line">          &#125;];</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意事项</p>
<ul>
<li>dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。</li>
<li>dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。</li>
<li>dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的</li>
</ul>
<h2 id="Dispatch-Block"><a href="#Dispatch-Block" class="headerlink" title="Dispatch Block"></a>Dispatch Block</h2><p>队列执行任务都是block的方式，</p>
<ul>
<li>创建block</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)createDispatchBlock &#123;</div><div class="line">    <span class="comment">//normal way</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.concurrentqueue"</span>,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_block_t block = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run block"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, block);</div><div class="line"></div><div class="line">    <span class="comment">//QOS way</span></div><div class="line">    dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(<span class="number">0</span>, QOS_CLASS_USER_INITIATED, <span class="number">-1</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run qos block"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, qosBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_wait：可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockWaitDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t block = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"star"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, block);</div><div class="line">    <span class="comment">//设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成</span></div><div class="line">    dispatch_block_wait(block, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ok, now can go on"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_notify：可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的block</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockNotifyDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block end"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, firstBlock);</div><div class="line">    dispatch_block_t secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"second block run"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//first block执行完才在serial queue中执行second block</span></div><div class="line">    dispatch_block_notify(firstBlock, serialQueue, secondBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_cancel：iOS8后GCD支持对dispatch block的取消</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatchBlockCancelDemo &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t firstBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"first block end"</span>);</div><div class="line">    &#125;);</div><div class="line">    dispatch_block_t secondBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"second block run"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, firstBlock);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, secondBlock);</div><div class="line">    <span class="comment">//取消secondBlock</span></div><div class="line">    dispatch_block_cancel(secondBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用dispatch-block-object（调度块）在任务执行前进行取消"><a href="#使用dispatch-block-object（调度块）在任务执行前进行取消" class="headerlink" title="使用dispatch block object（调度块）在任务执行前进行取消"></a>使用dispatch block object（调度块）在任务执行前进行取消</h2><p>dispatch block object可以为队列中的对象设置<br>示例，下载图片中途进行取消<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">let</span> downloadGroup = dispatch_group_create()</div><div class="line">     <span class="keyword">var</span> addresses = [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line">     addresses += addresses + addresses <span class="comment">// 扩展address数组，复制3份</span></div><div class="line">     <span class="keyword">var</span> blocks: [dispatch_block_t] = [] <span class="comment">// 一个保存block的数组</span></div><div class="line"></div><div class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; addresses.<span class="built_in">count</span> &#123;</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> block = dispatch_block_create(<span class="type">DISPATCH_BLOCK_INHERIT_QOS_CLASS</span>) &#123; <span class="comment">// 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS</span></div><div class="line">               <span class="keyword">let</span> index = <span class="type">Int</span>(i)</div><div class="line">               <span class="keyword">let</span> address = addresses[index]</div><div class="line">               <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">               <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">                    image, error <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                         storedError = error</div><div class="line">                    &#125;</div><div class="line">                    dispatch_group_leave(downloadGroup)</div><div class="line">               &#125;</div><div class="line">               <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">          &#125;</div><div class="line">          blocks.append(block)</div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>, block) <span class="comment">// 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">for</span> block <span class="keyword">in</span> blocks[<span class="number">3</span> ..&lt; blocks.<span class="built_in">count</span>] &#123;</div><div class="line">          <span class="keyword">let</span> cancel = arc4random_uniform(<span class="number">2</span>) <span class="comment">// 随机返回一个整数，会返回0或1</span></div><div class="line">          <span class="keyword">if</span> cancel == <span class="number">1</span> &#123;</div><div class="line">               dispatch_block_cancel(block) <span class="comment">// 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。</span></div><div class="line">               dispatch_group_leave(downloadGroup) <span class="comment">// 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-IO-文件操作"><a href="#Dispatch-IO-文件操作" class="headerlink" title="Dispatch IO 文件操作"></a>Dispatch IO 文件操作</h2><p>dispatch io读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文件这样会比单线程要快很多。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 0-99 bytes*/</span>&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 100-199 bytes*/</span>&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(queue,^&#123;<span class="comment">/*read 200-299 bytes*/</span>&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li>dispatch_io_create：创建dispatch io</li>
<li>dispatch_io_set_low_water：指定切割文件大小</li>
<li>dispatch_io_read：读取切割的文件然后合并。</li>
</ul>
<p>苹果系统日志API里用到了这个技术，可以在这里查看：<a href="https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c" target="_blank" rel="external">https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">pipe_q = dispatch_queue_create(<span class="string">"PipeQ"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//创建</span></div><div class="line">pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(<span class="keyword">int</span> err)&#123;</div><div class="line">    close(fd);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">*out_fd = fdpair[<span class="number">1</span>];</div><div class="line"><span class="comment">//设置切割大小</span></div><div class="line">dispatch_io_set_low_water(pipe_channel, SIZE_MAX);</div><div class="line"></div><div class="line">dispatch_io_read(pipe_channel, <span class="number">0</span>, SIZE_MAX, pipe_q, ^(<span class="keyword">bool</span> done, dispatch_data_t pipedata, <span class="keyword">int</span> err)&#123;</div><div class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        size_t len = dispatch_data_get_size(pipedata);</div><div class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//对每次切块数据的处理</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *bytes = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">char</span> *encoded;</div><div class="line">            uint32_t eval;</div><div class="line"></div><div class="line">            dispatch_data_t md = dispatch_data_create_map(pipedata, (<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;bytes, &amp;len);</div><div class="line">            encoded = asl_core_encode_buffer(bytes, len);</div><div class="line">            asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded);</div><div class="line">            free(encoded);</div><div class="line">            eval = _asl_evaluate_send(<span class="literal">NULL</span>, (aslmsg)aux, <span class="number">-1</span>);</div><div class="line">            _asl_send_message(<span class="literal">NULL</span>, eval, aux, <span class="literal">NULL</span>);</div><div class="line">            asl_msg_release(aux);</div><div class="line">            dispatch_release(md);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (done)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//semaphore +1使得不需要再等待继续执行下去。</span></div><div class="line">        dispatch_semaphore_signal(sem);</div><div class="line">        dispatch_release(pipe_channel);</div><div class="line">        dispatch_release(pipe_q);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Source-用GCD监视进程"><a href="#Dispatch-Source-用GCD监视进程" class="headerlink" title="Dispatch Source 用GCD监视进程"></a>Dispatch Source 用GCD监视进程</h2><p>Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:left">数据增加</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:left">数据OR</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:left">Mach端口发送</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:left">Mach端口接收</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</td>
<td style="text-align:left">内存情况</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:left">进程事件</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:left">读数据</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:left">信号</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:left">定时器</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:left">文件系统变化</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:left">文件写入</td>
</tr>
</tbody>
</table>
<p>方法</p>
<ul>
<li>dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。</li>
<li>dispatch_source_set_event_handler：设置事件处理handler</li>
<li>dispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。</li>
<li>dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSRunningApplication</span> *mail = [<span class="built_in">NSRunningApplication</span> runningApplicationsWithBundleIdentifier:<span class="string">@"com.apple.mail"</span>];</div><div class="line"><span class="keyword">if</span> (mail == <span class="literal">nil</span>) &#123;</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pid_t <span class="keyword">const</span> pid = mail.processIdentifier;</div><div class="line"><span class="keyword">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^()&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Mail quit."</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//在事件源传到你的事件处理前需要调用dispatch_resume()这个方法</span></div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure>
<p>监视文件夹内文件变化<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *directoryURL; <span class="comment">// assume this is set to a directory</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);</div><div class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">     <span class="keyword">char</span> buffer[<span class="number">80</span>];</div><div class="line">     strerror_r(errno, buffer, <span class="keyword">sizeof</span>(buffer));</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Unable to open \"%@\": %s (%d)"</span>, [directoryURL path], buffer, errno);</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,</div><div class="line">DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> data = dispatch_source_get_data(source);</div><div class="line">     <span class="keyword">if</span> (data &amp; DISPATCH_VNODE_WRITE) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"The directory changed."</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (data &amp; DISPATCH_VNODE_DELETE) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"The directory has been deleted."</span>);</div><div class="line">     &#125;</div><div class="line">&#125;);</div><div class="line">dispatch_source_set_cancel_handler(source, ^()&#123;</div><div class="line">     close(fd);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">self</span>.source = source;</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div><div class="line"><span class="comment">//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听</span></div></pre></td></tr></table></figure></p>
<p>NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,<span class="number">0</span>, <span class="number">0</span>, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Time flies."</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_time_t start</div><div class="line">dispatch_source_set_timer(source, DISPATCH_TIME_NOW, <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>,<span class="number">100</span>ull * <span class="built_in">NSEC_PER_MSEC</span>);</div><div class="line"><span class="keyword">self</span>.source = source;</div><div class="line">dispatch_resume(<span class="keyword">self</span>.source);</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Semaphore和的介绍"><a href="#Dispatch-Semaphore和的介绍" class="headerlink" title="Dispatch Semaphore和的介绍"></a>Dispatch Semaphore和的介绍</h2><p>另外一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dispatch semaphore</span></div><div class="line">- (<span class="keyword">void</span>)dispatchSemaphoreDemo &#123;</div><div class="line">    <span class="comment">//创建semaphore</span></div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"start"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"semaphore +1"</span>);</div><div class="line">        dispatch_semaphore_signal(semaphore); <span class="comment">//+1 semaphore</span></div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"continue"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>这里简单介绍下iOS中常用的各种锁和他们的性能。</p>
<ul>
<li>NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。</li>
<li>NSDistributedLock：分布锁，基于文件方式的锁机制，可以跨进程访问。</li>
<li>NSConditionLock：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。</li>
<li>OSSpinLock：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用pthread_mutex较好。</li>
<li>pthread_mutex_t：同步锁基于C语言，底层api性能高，使用方法和其它的类似。</li>
<li>@synchronized：更加简单。</li>
</ul>
<h2 id="dispatch-suspend和dispatch-resume挂起和恢复队列"><a href="#dispatch-suspend和dispatch-resume挂起和恢复队列" class="headerlink" title="dispatch_suspend和dispatch_resume挂起和恢复队列"></a>dispatch_suspend和dispatch_resume挂起和恢复队列</h2><p>dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。</p>
<h2 id="dispatch-set-context和dispatch-get-context"><a href="#dispatch-set-context和dispatch-get-context" class="headerlink" title="dispatch_set_context和dispatch_get_context"></a>dispatch_set_context和dispatch_get_context</h2><h2 id="GCD深入操作"><a href="#GCD深入操作" class="headerlink" title="GCD深入操作"></a>GCD深入操作</h2><ul>
<li>缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域</li>
<li>I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close</li>
<li>测试：使用dispatch_benchmark小工具</li>
<li>原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。</li>
</ul>
<h2 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h2><p>当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)deadLockCase1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="comment">//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="comment">//3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase3 &#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        <span class="comment">//串行队列里面同步一个串行队列就会死锁</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase4 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        <span class="comment">//将同步的串行队列放到另外一个线程就能够解决</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)deadLockCase5 &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">        <span class="comment">//回到主线程发现死循环后面就没法执行了</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">        &#125;);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line">    <span class="comment">//死循环</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="GCD实际使用"><a href="#GCD实际使用" class="headerlink" title="GCD实际使用"></a>GCD实际使用</h1><h2 id="FMDB如何使用dispatch-queue-set-specific和dispatch-get-specific来防止死锁"><a href="#FMDB如何使用dispatch-queue-set-specific和dispatch-get-specific来防止死锁" class="headerlink" title="FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁"></a>FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁</h2><p>作用类似objc_setAssociatedObject跟objc_getAssociatedObject<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;</div><div class="line"><span class="comment">//创建串行队列，所有数据库的操作都在这个队列里</span></div><div class="line">_queue = dispatch_queue_create([[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"fmdb.%@"</span>, <span class="keyword">self</span>] UTF8String], <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//标记队列</span></div><div class="line">dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">//检查是否是同一个队列来避免死锁的方法</span></div><div class="line">- (<span class="keyword">void</span>)inDatabase:(<span class="keyword">void</span> (^)(FMDatabase *db))block &#123;</div><div class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge <span class="keyword">id</span>)dispatch_get_specific(kDispatchQueueSpecificKey);</div><div class="line">    assert(currentSyncQueue != <span class="keyword">self</span> &amp;&amp; <span class="string">"inDatabase: was called reentrantly on the same queue, which would lead to a deadlock"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="iOS系统版本新特性"><a href="#iOS系统版本新特性" class="headerlink" title="iOS系统版本新特性"></a>iOS系统版本新特性</h1><h2 id="iOS8"><a href="#iOS8" class="headerlink" title="iOS8"></a>iOS8</h2><p>iOS8新加了一个功能叫Quality of Service(QoS)，里面提供了一下几个更容易理解的枚举名来使用user interactive，user initiated，utility和background。下面的表做了对比</p>
<table>
<thead>
<tr>
<th style="text-align:left">Global queue</th>
<th style="text-align:left">Corresponding QoS class</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Main thread</td>
<td style="text-align:left">NSQualityOfServiceUserInteractive</td>
<td style="text-align:left">UI相关，交互等</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_HIGH</td>
<td style="text-align:left">NSQualityOfServiceUserInitiated</td>
<td style="text-align:left">用户发起需要马上得到结果进行后续任务</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_DEFAULT</td>
<td style="text-align:left">NSQualityOfServiceDefault</td>
<td style="text-align:left">默认的不应该使用这个设置任务</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_LOW</td>
<td style="text-align:left">NSQualityOfServiceUtility</td>
<td style="text-align:left">花费时间稍多比如下载，需要几秒或几分钟的</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>
<td style="text-align:left">NSQualityOfServiceBackground</td>
<td style="text-align:left">不可见在后台的操作可能需要好几分钟甚至几小时的</td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h2><ul>
<li>Building Responsive and Efficient Apps with GCD：<a href="https://developer.apple.com/videos/play/wwdc2015-718/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-718/</a></li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li>官方文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="external">https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 &lt;a href=&quot;https://github.com/ming1016/GCDDemo&quot; target
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="GCD" scheme="http://ming1016.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Auto Layout，分析iOS各版本新增特性</title>
    <link href="http://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/"/>
    <id>http://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/</id>
    <published>2015-11-03T13:17:54.000Z</published>
    <updated>2017-05-27T02:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>先前写到的一篇Masonry心得文章里已经提到了很多AutoLayout相关的知识，这篇我会更加详细的对其知识要点进行分析和整理。</p>
<h1 id="来历"><a href="#来历" class="headerlink" title="来历"></a>来历</h1><p>一般大家都会认为Auto Layout这个东西是苹果自己搞出来的，其实不然，早在1997年Alan Borning, Kim Marriott, Peter Stuckey等人就发布了《Solving Linear Arithmetic Constraints for User Interface Applications》论文（论文地址：<a href="http://constraints.cs.washington.edu/solvers/uist97.html" target="_blank" rel="external">http://constraints.cs.washington.edu/solvers/uist97.html</a>）提出了在解决布局问题的Cassowary constraint-solving算法实现，并且将代码发布在他们搭建的Cassowary网站上<a href="http://constraints.cs.washington.edu/cassowary/" target="_blank" rel="external">http://constraints.cs.washington.edu/cassowary/</a>。后来更多开发者用各种语言来写Cassowary，比如说pybee用python写的<a href="https://github.com/pybee/cassowary" target="_blank" rel="external">https://github.com/pybee/cassowary</a>。自从它发布以来JavaScript，.NET，JAVA，Smalltall和C++都有相应的库。2011年苹果将这个算法运用到了自家的布局引擎中，美其名曰Auto Layout。</p>
<h2 id="Cassowary"><a href="#Cassowary" class="headerlink" title="Cassowary"></a>Cassowary</h2><p>Cassowary是个解析工具包，能够有效解析线性等式系统和线性不等式系统，用户的界面中总是会出现不等关系和相等关系，Cassowary开发了一种规则系统可以通过约束来描述视图间关系。约束就是规则，能够表示出一个视图相对于另一个视图的位置。</p>
<h1 id="Auto-Layout的生命周期"><a href="#Auto-Layout的生命周期" class="headerlink" title="Auto Layout的生命周期"></a>Auto Layout的生命周期</h1><p>进入下面主题前可以先介绍下加入Auto Layout的生命周期。在得到自己的layout之前Layout Engine会将Views，约束，Priorities（优先级），instrinsicContentSize（主要是UILabel,UIImageView等）通过计算转换成最终的效果。在Layout Engine里会有约束变化到Deferred Layout Pass再到应用Run Loop再回到约束变化这样的循环机制。</p>
<h2 id="约束变化"><a href="#约束变化" class="headerlink" title="约束变化"></a>约束变化</h2><p>触发约束变化包括</p>
<ul>
<li>Activating或Deactivating</li>
<li>设置constant或priority</li>
<li>添加和删除视图</li>
</ul>
<p>这个Engine遇到约束变化会重新计算layout，获取新值后会call它的superview.setNeedsLayout()</p>
<h2 id="Deferred-Layout-Pass"><a href="#Deferred-Layout-Pass" class="headerlink" title="Deferred Layout Pass"></a>Deferred Layout Pass</h2><p>在这个时候主要是做些容错处理，更新约束有些没有确定或者缺失布局声明的视图会在这里处理。接着从上而下调用layoutSubviews()来确定视图各个子视图的位置，这个过程实际上就是将subview的frame从layout engine里拷贝出来。这里要注意重写layoutSubviews()或者执行类似layoutIfNeeded这样可能会立刻唤起layoutSubviews()的方法，如果要这样做需要注意手动处理的这个地方自己的子视图布局的树状关系是否合理。</p>
<h2 id="生命周期中需要注意的事项"><a href="#生命周期中需要注意的事项" class="headerlink" title="生命周期中需要注意的事项"></a>生命周期中需要注意的事项</h2><ul>
<li>不要期望frame会立刻变化。</li>
<li>在重写layoutSubviews()时需要非常小心。</li>
</ul>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>Auto Layout你的视图层级里所有视图通过放置在它们里面的约束来动态计算的它们的大小和位置。一般控件需要四个约束决定位置大小，如果定义了intrinsicContentSize的比如UILabel只需要两个约束即可。</p>
<h2 id="约束方程式"><a href="#约束方程式" class="headerlink" title="约束方程式"></a>约束方程式</h2><p>view1.attribute1 = mutiplier * view2.attribute2 + constant</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redButton.left = <span class="number">1.0</span> * yellowLabel.right + <span class="number">10.0</span> <span class="comment">//红色按钮的左侧距离黄色label有10个point</span></div></pre></td></tr></table></figure>
<h2 id="使用API添加约束"><a href="#使用API添加约束" class="headerlink" title="使用API添加约束"></a>使用API添加约束</h2><p>使用NSLayoutConstraint类（最低支持iOS6）添加约束。NSLayoutConstraint官方参考：<a href="https://developer.apple.com/library/prerelease/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/index.html" target="_blank" rel="external">https://developer.apple.com/library/prerelease/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/index.html</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSLayoutContraint</span> constraintWithItem:view1</div><div class="line">                                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                               relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                                    toItem:view2</div><div class="line">                                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                                                multiplier:<span class="number">1.0</span></div><div class="line">                                                 constant:<span class="number">-5</span>]</div></pre></td></tr></table></figure></p>
<p>把约束用约束中两个view的共同父视图或者两视图中层次高视图的- (void)addConstraint:(NSLayoutConstraint *)constraint方法将约束添加进去。</p>
<h2 id="使用VFL语言添加约束"><a href="#使用VFL语言添加约束" class="headerlink" title="使用VFL语言添加约束"></a>使用VFL语言添加约束</h2><p>先举个简单的例子并排两个view添加约束<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[NSLayoutConstraint constraintWithVisualFormat:@“[view1]-[view2]"</div><div class="line">                                                                  options:0</div><div class="line">                                                                  metrics:nil</div><div class="line">                                                                     views:viewsDictionary;</div></pre></td></tr></table></figure></p>
<p>viewDictionary可以通过NSDictionaryOfVariableBindings方法得到</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">viewsDictionary = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1,view2);</div></pre></td></tr></table></figure>
<h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>可以给这个位掩码传入NSLayoutFormatAlignAllTop使它们顶部对齐，这个值的默认值是NSLayoutFormatDirectionLeadingToTrailing从左到右。可以使用NSLayoutFormatAlignAllTop | NSLayoutFormatAlignAllBottom 表示两个视图的顶部和底部约束相同。</p>
<h3 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h3><p>这个参数作用是替换VFL语句中对应的值<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> viewFrame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1, view2);</div><div class="line"><span class="built_in">NSDictionary</span> *metrics = @&#123;<span class="string">@"left"</span>: @(<span class="built_in">CGRectGetMinX</span>(viewFrame)),</div><div class="line">                                           <span class="string">@"top"</span>: @(<span class="built_in">CGRectGetMinY</span>(viewFrame)),</div><div class="line">                                        <span class="string">@"width"</span>: @(<span class="built_in">CGRectGetWidth</span>(viewFrame)),</div><div class="line">                                       <span class="string">@"height"</span>: @(<span class="built_in">CGRectGetHeight</span>(viewFrame))&#125;;</div><div class="line">[view1 addConstraints:[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-left-[view(&gt;=width)]"</span> options:<span class="number">0</span> metrics:metrics views:views]];</div></pre></td></tr></table></figure></p>
<p>使用NSDictionaryOfVariableBindings(…)快速创建<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *left = @<span class="number">50</span>;</div><div class="line"><span class="built_in">NSNumber</span> *top = @<span class="number">50</span>;</div><div class="line"><span class="built_in">NSNumber</span> *width = @<span class="number">100</span>;</div><div class="line"><span class="built_in">NSNumber</span> *height = @<span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1, view2);</div><div class="line"><span class="built_in">NSDictionary</span> *metrics = <span class="built_in">NSDictionaryOfVariableBindings</span>(left, top, width, height);</div><div class="line"></div><div class="line">[view1 addConstraints:[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-left-[view(&gt;=width)]"</span> options:<span class="number">0</span> metrics:metrics views:views]];</div></pre></td></tr></table></figure></p>
<h3 id="VFL几个基本例子"><a href="#VFL几个基本例子" class="headerlink" title="VFL几个基本例子"></a>VFL几个基本例子</h3><ul>
<li>[view1(50)]-10-[view2(100)] 表示view1宽50，view2宽100，间隔10</li>
<li>[view1(&gt;=50@750)] 表示view1宽度大于50，约束条件优先级为750（优先级越大优先执行该约束，最大1000）</li>
<li>V:[view1][view2(==view1)] 表示按照竖直排，上面是view1下面是一个和它一样大的view2</li>
<li>H:|-[view1]-[view2]-[view3(&gt;=20)]-| 表示按照水平排列，|表示父视图，各个视图之间按照默认宽度来排列</li>
</ul>
<h2 id="VFL介绍"><a href="#VFL介绍" class="headerlink" title="VFL介绍"></a>VFL介绍</h2><p>无论使用哪种方法创建约束都是NSLayoutConstraint类的成员，每个约束都会在一个Objective-C对象中存储y = mx + b规则，然后通过Auto Layout引擎来表达该规则，VFL也不例外。VFL由一个描述布局的文字字符串组成，文本会指出间隔，不等量和优先级。官方对其的介绍：Visual Format Language <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html</a></p>
<h2 id="VFL的语法"><a href="#VFL的语法" class="headerlink" title="VFL的语法"></a>VFL的语法</h2><ul>
<li>标准间隔：[button]-[textField]</li>
<li>宽约束：[button(&gt;=50)]</li>
<li>与父视图的关系：|-50-[purpleBox]-50-|</li>
<li>垂直布局：V:[topField]-10-[bottomField]</li>
<li>Flush Views：[maroonView][buleView]</li>
<li>权重：[button(100@20)]</li>
<li>等宽：[button(==button2)]</li>
<li>Multiple Predicates：[flexibleButton(&gt;=70,&lt;=100)]</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>创建这种字符串时需要注意一下几点：</p>
<ul>
<li>H:和V:每次都使用一个。</li>
<li>视图变量名出现在方括号中，例如[view]。</li>
<li>字符串中顺序是按照从顶到底，从左到右</li>
<li>视图间隔以数字常量出现，例如-10-。</li>
<li>|表示父视图</li>
</ul>
<h1 id="使用Auto-Layout时需要注意的点"><a href="#使用Auto-Layout时需要注意的点" class="headerlink" title="使用Auto Layout时需要注意的点"></a>使用Auto Layout时需要注意的点</h1><ul>
<li>注意禁用Autoresizing Masks。对于每个需要使用Auto Layout的视图需要调用setTranslatesAutoresizingMaskIntoConstraints:NO</li>
<li>VFL语句里不能包含空格和&gt;，&lt;这样的约束</li>
<li>布局原理是由外向里布局，最先屏幕尺寸，再一层一层往里决定各个元素大小。</li>
<li>删除视图时直接使用removeConstraint和removeConstraints时需要注意这样删除是没法删除视图不支持的约束导致view中还包含着那个约束（使用第三方库时需要特别注意下）。解决这个的办法就是添加约束时用一个局部变量保存下，删除时进行比较删掉和先前那个，还有个办法就是设置标记，constraint.identifier = @“What you want to call”。</li>
</ul>
<h1 id="布局约束规则"><a href="#布局约束规则" class="headerlink" title="布局约束规则"></a>布局约束规则</h1><p>表达布局约束的规则可以使用一些简单的数学术语，如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图位置</td>
<td style="text-align:left">NSLayoutAttributeLeft, NSLayoutAttributeRight, NSLayoutAttributeTop, NSLayoutAttributeBottom</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图前面后面</td>
<td style="text-align:left">NSLayoutAttributeLeading, NSLayoutAttributeTrailing</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图的宽度和高度</td>
<td style="text-align:left">NSLayoutAttributeWidth, NSLayoutAttributeHeight</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图中心</td>
<td style="text-align:left">NSLayoutAttributeCenterX, NSLayoutAttributeCenterY</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">视图的基线，在视图底部上方放置文字的地方</td>
<td style="text-align:left">NSLayoutAttributeBaseline</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">占位符，在与另一个约束的关系中没有用到某个属性时可以使用占位符</td>
<td style="text-align:left">NSLayoutAttributeNotAnAttribute</td>
</tr>
<tr>
<td style="text-align:left">关系</td>
<td style="text-align:left">允许将属性通过等式和不等式相互关联</td>
<td style="text-align:left">NSLayoutRelationLessThanOrEqual, NSLayoutRelationEqual, NSLayoutRelationGreaterThanOrEqual</td>
</tr>
<tr>
<td style="text-align:left">数学运算</td>
<td style="text-align:left">每个约束的乘数和相加性常数</td>
<td style="text-align:left">CGFloat值</td>
</tr>
</tbody>
</table>
<h1 id="约束层级"><a href="#约束层级" class="headerlink" title="约束层级"></a>约束层级</h1><p>约束引用两视图时，这两个视图需要属于同一个视图层次结构，对于引用两个视图的约束只有两个情况是允许的。第一种是一个视图是另一个视图的父视图，第二个情况是两个视图在一个窗口下有一个非nil的共同父视图。</p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>哪个约束优先级高会先满足其约束，系统内置优先级枚举值UILayoutPriority<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="built_in">UILayoutPriorityRequired</span> = <span class="number">1000</span>, <span class="comment">//默认的优先级，意味着默认约束一旦冲突就会crash</span></div><div class="line">    <span class="built_in">UILayoutPriorityDefaultHigh</span> = <span class="number">750</span>,</div><div class="line">    <span class="built_in">UILayoutPriorityDefaultLow</span> = <span class="number">250</span>,</div><div class="line">    <span class="built_in">UILayoutPriorityFittingSizeLevel</span> = <span class="number">50</span>,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> <span class="built_in">UILayoutPriority</span>;</div></pre></td></tr></table></figure></p>
<h1 id="IntrinsicContentSize-Compression-Resistance-Priority-Hugging-Priority"><a href="#IntrinsicContentSize-Compression-Resistance-Priority-Hugging-Priority" class="headerlink" title="IntrinsicContentSize / Compression Resistance Priority / Hugging Priority"></a>IntrinsicContentSize / Compression Resistance Priority / Hugging Priority</h1><p>具有instrinsic content size的控件，比如UILabel，UIButton，选择控件，进度条和分段等等，可以自己计算自己的大小，比如label设置text和font后大小是可以计算得到的。这时可以通过设置Hugging priority让这些控件不要大于某个设定的值,默认优先级为250。设置Content Compression Resistance就是让控件不要小于某个设定的值，默认优先级为750。加这些值可以当作是加了个额外的约束值来约束宽。</p>
<h1 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h1><p>updateConstraints -&gt; layoutSubViews -&gt; drawRect</p>
<h2 id="viewDidLayoutSubviews，-layoutSubviews"><a href="#viewDidLayoutSubviews，-layoutSubviews" class="headerlink" title="viewDidLayoutSubviews，-layoutSubviews"></a>viewDidLayoutSubviews，-layoutSubviews</h2><p>使用Auto Layout的view会在viewDidLayoutSubviews或－layoutSubview调用super转换成具有正确显示的frame值。</p>
<h2 id="View的改变会调用哪些方法"><a href="#View的改变会调用哪些方法" class="headerlink" title="View的改变会调用哪些方法"></a>View的改变会调用哪些方法</h2><ul>
<li>改变frame.origin不会掉用layoutSubviews</li>
<li>改变frame.size会使 superVIew的layoutSubviews调用</li>
<li>改变bounds.origin和bounds.size都会调用superView和自己view的layoutSubviews方法</li>
</ul>
<h1 id="Auto-Layout的Debug"><a href="#Auto-Layout的Debug" class="headerlink" title="Auto Layout的Debug"></a>Auto Layout的Debug</h1><p>Auto Layout以下几种情况会出错</p>
<ul>
<li>Unsatisfiable Layouts：约束冲突，同一时刻约束没法同时满足。系统发现时会先检测那些冲突的约束，然后会一直拆掉冲突的约束再检查布局直到找到合适的布局，最后日志会将冲突的约束和拆掉的约束打印在控制台上。</li>
<li>Ambiguous Layouts：约束有缺失，比如说位置或者大小没有全指定到。还有种情况就是两个冲突的约束的权重是一样的就会崩。</li>
<li>Logical Errors：布局中的逻辑错误。</li>
<li>不含视图项的约束不合法，每个约束至少需要引用一个视图，不然会崩。在删除视图时一定要注意。<h2 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h2></li>
<li>po [[UIWindow keyWindow] _autolayoutTrace]<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>参考官方文档：<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html</a></li>
</ul>
<h1 id="容易出问题的Bug-Case"><a href="#容易出问题的Bug-Case" class="headerlink" title="容易出问题的Bug Case"></a>容易出问题的Bug Case</h1><ul>
<li>无共同父视图的视图之间相互添加约束会有问题。</li>
<li>调用了setNeedsLayout后不能通过frame改变视图和控件</li>
<li>为了让在设置了setTranslatesAutoresizingMaskIntoConstraints:NO视图里更改的frame立刻生效而执行了没有标记立刻刷新的layoutIfNeeded的方式是不可取的。</li>
</ul>
<h1 id="实践中碰到的非必现低配置机器崩溃bug分析"><a href="#实践中碰到的非必现低配置机器崩溃bug分析" class="headerlink" title="实践中碰到的非必现低配置机器崩溃bug分析"></a>实践中碰到的非必现低配置机器崩溃bug分析</h1><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>一个视图缺少高宽约束，在设置完了约束后执行layoutIfNeeded，然后设置宽高，这种情况在低配机器上可能会出现崩问题。原因在于layoutIfNeeded需要有标记才会立刻调用layoutSubview得到宽高，不然是不会马上调用的。页面第一次显示是会自动标记上需要刷新这个标记的，所以第一次看显示都是看不出问题的，但页面再次调用layoutIfNeeded时是不会立刻执行layoutSubview的（但之前加上setNeedsLayout就会立刻执行），这时改变的宽高值会在上文生命周期中提到的Auto Layout Cycle中的Engine里的Deferred Layout Pass里执行layoutSubview，手动设置的layoutIfNeeded也会执行一遍layoutSubview，但是这个如果发生在Deferred Layout Pass之后就会出现崩的问题，因为当视图设置为setTranslatesAutoresizingMaskIntoConstraints:NO时会严格按照约束-&gt;Engine-&gt;显示这种流程，如在Deferred Layout Pass之前设置好是没有问题的，之后强制执行LayoutSubview会产生一个权重和先前一样的约束在类似动画block里更新布局让Engine执行导致Ambiguous Layouts这种权重相同冲突崩溃的情况发生。</p>
<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p>将多个有相互约束关系视图removeFromSuperView后更新布局在低配机器上出现崩的问题。这个原因主要是根据不含视图项的约束不合法这个原则来的，同时会抛出野指针的错误。在内存吃紧机器上，当应用占内存较多系统会抓住任何可以释放heap区内存的机会视图被移除后会立刻被清空，这时约束如果还没有被释就满足不含视图项的约束会崩的情况了。</p>
<h1 id="推荐Auto-Layout第三方库"><a href="#推荐Auto-Layout第三方库" class="headerlink" title="推荐Auto Layout第三方库"></a>推荐Auto Layout第三方库</h1><h2 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h2><p>Github地址：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">https://github.com/SnapKit/Masonry</a></p>
<h2 id="Cartography"><a href="#Cartography" class="headerlink" title="Cartography"></a>Cartography</h2><p>Github地址：<a href="https://github.com/robb/Cartography" target="_blank" rel="external">https://github.com/robb/Cartography</a></p>
<h1 id="Masonry-1"><a href="#Masonry-1" class="headerlink" title="Masonry"></a>Masonry</h1><p>可以参看我上篇文章《AutoLayout框架Masonry使用心得》:<a href="http://www.starming.com/index.php?v=index&amp;view=81" target="_blank" rel="external">http://www.starming.com/index.php?v=index&amp;view=81</a></p>
<h1 id="各版本iOS中AutoLayout的区别"><a href="#各版本iOS中AutoLayout的区别" class="headerlink" title="各版本iOS中AutoLayout的区别"></a>各版本iOS中AutoLayout的区别</h1><p>完整记录可以到官方网站进行核对和查找：What’s New in iOS <a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html</a></p>
<h2 id="iOS6"><a href="#iOS6" class="headerlink" title="iOS6"></a>iOS6</h2><p>苹果在这个版本引入Auto Layout，具备了所有核心功能。</p>
<h2 id="iOS7"><a href="#iOS7" class="headerlink" title="iOS7"></a>iOS7</h2><ul>
<li>NavigationBar,TabBar和ToolBar的translucent属性默认为YES，当前ViewController的高度是整个屏幕的高度，为了确保不被这些Bar覆盖可以在布局中使用topLayoutGuide和bottomLayoutGuide属性。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"V:[topLayoutGuide]-[view1]"</span> options:<span class="number">0</span> metrics:<span class="literal">nil</span> views:view2];</div></pre></td></tr></table></figure>
<h2 id="iOS8"><a href="#iOS8" class="headerlink" title="iOS8"></a>iOS8</h2><ul>
<li>Self Sizing Cells <a href="http://www.appcoda.com/self-sizing-cells/" target="_blank" rel="external">http://www.appcoda.com/self-sizing-cells/</a></li>
<li>UIViewController新增两个方法，用来处理UITraitEnvironment协议，UIKit里有UIScreen，UIViewController，UIView和UIPresentationController支持这个协议，当视图traitCollection改变时UIViewController时可以捕获到这个消息进行处理的。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setOverrideTraitCollection:(<span class="built_in">UITraitCollection</span> *)collection forChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="built_in">UITraitCollection</span> *)overrideTraitCollectionForChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure>
<ul>
<li>Size Class的出现UIViewController提供了一组新协议来支持UIContentContainer</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)systemLayoutFittingSizeDidChangeForChildContentContainer:(<span class="keyword">id</span> )container <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="built_in">CGSize</span>)sizeForChildContentContainer:(<span class="keyword">id</span> )container withParentContainerSize:(<span class="built_in">CGSize</span>)parentSize <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)willTransitionToTraitCollection:(<span class="built_in">UITraitCollection</span> *)newCollection withTransitionCoordinator:(<span class="keyword">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure>
<ul>
<li>UIView的Margin新增了3个API，NSLayoutMargins可以定义view之间的距离，这个只对Auto Layout有效，并且默认值为{8,8,8,8}。NSLayoutAttribute的枚举值也有相应的更新</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UIView的3个Margin相关API</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIEdgeInsets</span> layoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> preservesSuperviewLayoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line">- (<span class="keyword">void</span>)layoutMarginsDidChange <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">//NSLayoutAttribute的枚举值更新</span></div><div class="line"><span class="built_in">NSLayoutAttributeLeftMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeRightMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeTopMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeBottomMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeLeadingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeTrailingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeCenterXWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"><span class="built_in">NSLayoutAttributeCenterYWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div></pre></td></tr></table></figure>
<h2 id="iOS9"><a href="#iOS9" class="headerlink" title="iOS9"></a>iOS9</h2><h3 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h3><p>苹果一直希望能够让更多的人来用Auto Layout，除了弄出一个VFL现在又弄出一个不需要约束的方法，使用Stack view使大家使用Auto Layout时不用触碰到约束，官方口号是“Start with Stack View, use constraints as needed”。 更多细节可以查看官方介绍：UIKit Framework Reference  UIStackView Class Reference<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html</a></p>
<p>Stack Views ：<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html</a></p>
<p>Stack View提供了更加简便的自动布局方法比如Alignment的Fill，Leading，Center，Trailing。Distribution的Fill，Fill Equally，Fill Proportionally，Equal Spacing。</p>
<p>如果希望在iOS9之前的系统也能够使用Stack view可以用sunnyxx的FDStackView<a href="https://github.com/forkingdog/FDStackView" target="_blank" rel="external">https://github.com/forkingdog/FDStackView</a>，利用运行时替换元素的方法来支持iOS6+系统。</p>
<h3 id="NSLayoutAnchorAPI"><a href="#NSLayoutAnchorAPI" class="headerlink" title="NSLayoutAnchorAPI"></a>NSLayoutAnchorAPI</h3><p>新增这个API能够让约束的声明更加清晰，还能够通过静态类型检查确保约束的正常工作。具体可以查看官方文档<a href="https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLayoutConstraint</span> *constraint = [view1.leadingAnchor constraintEqualToAnchor:view2.topAnchor];</div></pre></td></tr></table></figure></p>
<h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul>
<li>Auto Layout Guide <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/index.html</a></li>
<li>UIScrollView And Autolayout <a href="https://developer.apple.com/library/ios/technotes/tn2154/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/technotes/tn2154/_index.html</a></li>
<li>IB中使用Auto Layout：Auto Layout Help <a href="https://developer.apple.com/library/ios/recipes/xcode_help-IB_auto_layout/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/recipes/xcode_help-IB_auto_layout/_index.html</a></li>
<li>What’s New in iOS <a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html</a></li>
</ul>
<h2 id="WWDC视频"><a href="#WWDC视频" class="headerlink" title="WWDC视频"></a>WWDC视频</h2><ul>
<li>WWDC 2012: Introduction to Auto Layout for iOS and OS X <a href="https://developer.apple.com/videos/wwdc/2012/?id=202" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=202</a></li>
<li>WWDC 2012: Introducing Collection Views <a href="https://developer.apple.com/videos/play/wwdc2012-205/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2012-205/</a></li>
<li>WWDC 2012: Advanced Collection Views and Building Custom Layouts <a href="https://developer.apple.com/videos/play/wwdc2012-219" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2012-219</a></li>
<li>WWDC 2012: Best Practices for Mastering Auto Layout <a href="https://developer.apple.com/videos/wwdc/2012/?id=228" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=228</a></li>
<li>WWDC 2012: Auto Layout by Example <a href="https://developer.apple.com/videos/wwdc/2012/?id=232" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2012/?id=232</a></li>
<li>WWDC 2013: Interface Builder Core Concepts <a href="https://developer.apple.com/videos/play/wwdc2013-405" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2013-405</a></li>
<li>WWDC 2013: Taking Control of Auto Layout in Xcode 5 <a href="https://developer.apple.com/videos/wwdc/2013/?id=406" target="_blank" rel="external">https://developer.apple.com/videos/wwdc/2013/?id=406</a></li>
<li>WWDC 2015: Mysteries of Auto Layout, Part 1 内容包含了Auto Layout更高封装stack view的介绍 <a href="https://developer.apple.com/videos/play/wwdc2015-218/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-218/</a></li>
<li>WWDC 2015: Mysteries of Auto Layout, Part 2 包含Auto Layout生命周期和调试Auto Layout的一些方法介绍<a href="https://developer.apple.com/videos/play/wwdc2015-219/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-219/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先前写到的一篇Masonry心得文章里已经提到了很多AutoLayout相关的知识，这篇我会更加详细的对其知识要点进行分析和整理。&lt;/p&gt;
&lt;h1 id=&quot;来历&quot;&gt;&lt;a href=&quot;#来历&quot; class=&quot;headerlink&quot; title=&quot;来历&quot;&gt;&lt;/a&gt;来历&lt;/h1&gt;
    
    </summary>
    
      <category term="开发" scheme="http://ming1016.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Autolayout" scheme="http://ming1016.github.io/tags/Autolayout/"/>
    
  </entry>
  
  <entry>
    <title>15年用iPad上的备忘录画的</title>
    <link href="http://ming1016.github.io/2015/11/02/draw-with-note-in-ipad-during-15/"/>
    <id>http://ming1016.github.io/2015/11/02/draw-with-note-in-ipad-during-15/</id>
    <published>2015-11-02T14:04:14.000Z</published>
    <updated>2017-05-27T14:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/draw-with-note-in-ipad-during-15/1.jpg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/2.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/3.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/4.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/5.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/6.jpg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/7.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/8.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/9.jpg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/10.jpg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/11.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/12.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/13.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/14.png" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/15.jpg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/16.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/17.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/18.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/19.jpg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/20.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/21.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/22.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/23.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/24.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/25.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/26.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/27.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/28.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/29.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/30.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/31.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/32.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/33.png" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/34.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/35.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/36.jpeg" alt=""><br><img src="/uploads/draw-with-note-in-ipad-during-15/37.jpeg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/draw-with-note-in-ipad-during-15/1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-with-note-in-ipad-during-15/2.jpeg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="我的画" scheme="http://ming1016.github.io/categories/%E6%88%91%E7%9A%84%E7%94%BB/"/>
    
    
      <category term="画" scheme="http://ming1016.github.io/tags/%E7%94%BB/"/>
    
      <category term="iPad" scheme="http://ming1016.github.io/tags/iPad/"/>
    
  </entry>
  
  <entry>
    <title>我用过的 macOS 应用</title>
    <link href="http://ming1016.github.io/2015/05/28/macos-app-i-used/"/>
    <id>http://ming1016.github.io/2015/05/28/macos-app-i-used/</id>
    <published>2015-05-28T01:25:27.000Z</published>
    <updated>2017-05-28T03:07:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写作笔记"><a href="#写作笔记" class="headerlink" title="写作笔记"></a>写作笔记</h1><h2 id="Bear"><a href="#Bear" class="headerlink" title="Bear"></a>Bear</h2><p>视觉效果最好，没有云存储，没有大纲</p>
<h2 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h2><p>有大纲</p>
<h2 id="Evernote"><a href="#Evernote" class="headerlink" title="Evernote"></a>Evernote</h2><p>有云存储，云同步，不过订阅才能够多于2台设备同步</p>
<h2 id="有道云笔记"><a href="#有道云笔记" class="headerlink" title="有道云笔记"></a>有道云笔记</h2><p>字体大小没法自定义</p>
<h2 id="Papers"><a href="#Papers" class="headerlink" title="Papers"></a>Papers</h2><p>pdf 整理</p>
<h2 id="有道词典"><a href="#有道词典" class="headerlink" title="有道词典"></a>有道词典</h2><p>翻译</p>
<h2 id="系统邮件"><a href="#系统邮件" class="headerlink" title="系统邮件"></a>系统邮件</h2><p>配合喵神 iOS 的 Mail Me 收集临时灵感和资料</p>
<h2 id="Reeder"><a href="#Reeder" class="headerlink" title="Reeder"></a>Reeder</h2><p>博客跟踪</p>
<h1 id="视觉"><a href="#视觉" class="headerlink" title="视觉"></a>视觉</h1><h2 id="keynote"><a href="#keynote" class="headerlink" title="keynote"></a>keynote</h2><p>整理演示</p>
<h2 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a>Photoshop</h2><p>编辑裁剪图片大小</p>
<h2 id="Pixave"><a href="#Pixave" class="headerlink" title="Pixave"></a>Pixave</h2><p>管理图片素材</p>
<h2 id="Sip"><a href="#Sip" class="headerlink" title="Sip"></a>Sip</h2><p>屏幕取色</p>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><h2 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h2><p>苹果程序</p>
<h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><p>js</p>
<h2 id="AppCode"><a href="#AppCode" class="headerlink" title="AppCode"></a>AppCode</h2><p>使用里面的检查功能，不过不够准确</p>
<h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><p>干净的编辑器</p>
<h2 id="Cornerstone"><a href="#Cornerstone" class="headerlink" title="Cornerstone"></a>Cornerstone</h2><p>svn</p>
<h2 id="Transmit"><a href="#Transmit" class="headerlink" title="Transmit"></a>Transmit</h2><p>ftp 上传</p>
<h2 id="iTerm"><a href="#iTerm" class="headerlink" title="iTerm"></a>iTerm</h2><p>终端</p>
<h2 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h2><p>手册查找</p>
<h2 id="Reaveal"><a href="#Reaveal" class="headerlink" title="Reaveal"></a>Reaveal</h2><p>调试视图</p>
<h2 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h2><p>Git 管理</p>
<h2 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h2><p>查看代码写的流程图 dot 格式</p>
<h1 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h1><h2 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h2><p>工作聊</p>
<h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><p>微信好友聊</p>
<h1 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h1><h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><p>听歌</p>
<h2 id="mpv"><a href="#mpv" class="headerlink" title="mpv"></a>mpv</h2><p>视频</p>
<h2 id="VLC"><a href="#VLC" class="headerlink" title="VLC"></a>VLC</h2><p>开源</p>
<h2 id="Thunder"><a href="#Thunder" class="headerlink" title="Thunder"></a>Thunder</h2><p>下载</p>
<h2 id="The-Unarchiver"><a href="#The-Unarchiver" class="headerlink" title="The Unarchiver"></a>The Unarchiver</h2><p>解压</p>
<h2 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h2><p>空间大</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写作笔记&quot;&gt;&lt;a href=&quot;#写作笔记&quot; class=&quot;headerlink&quot; title=&quot;写作笔记&quot;&gt;&lt;/a&gt;写作笔记&lt;/h1&gt;&lt;h2 id=&quot;Bear&quot;&gt;&lt;a href=&quot;#Bear&quot; class=&quot;headerlink&quot; title=&quot;Bear&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="应用" scheme="http://ming1016.github.io/categories/%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="macOS" scheme="http://ming1016.github.io/tags/macOS/"/>
    
      <category term="应用" scheme="http://ming1016.github.io/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>整理了画的权利的游戏里的角色，有龙女，小恶魔等等</title>
    <link href="http://ming1016.github.io/2015/04/02/draw-game-of-thrones-with-pencil-during-14/"/>
    <id>http://ming1016.github.io/2015/04/02/draw-game-of-thrones-with-pencil-during-14/</id>
    <published>2015-04-02T14:19:09.000Z</published>
    <updated>2017-05-27T14:24:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/1.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/2.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/3.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/4.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/5.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/6.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/7.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/8.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/9.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/10.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/11.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/12.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/13.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/14.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/15.jpg" alt=""><br><img src="/uploads/draw-game-of-thrones-with-pencil-during-14/16.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/draw-game-of-thrones-with-pencil-during-14/1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-game-of-thrones-with-pencil-durin
    
    </summary>
    
      <category term="我的画" scheme="http://ming1016.github.io/categories/%E6%88%91%E7%9A%84%E7%94%BB/"/>
    
    
      <category term="画" scheme="http://ming1016.github.io/tags/%E7%94%BB/"/>
    
      <category term="Pencil" scheme="http://ming1016.github.io/tags/Pencil/"/>
    
      <category term="权利的游戏" scheme="http://ming1016.github.io/tags/%E6%9D%83%E5%88%A9%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
</feed>
