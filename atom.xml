<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星光社 - 戴铭的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ming1016.github.io/"/>
  <updated>2018-04-02T11:17:52.790Z</updated>
  <id>http://ming1016.github.io/</id>
  
  <author>
    <name>戴铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 项目中涉及到 JSONDecoder，网络请求，泛型协议式编程的一些记录和想法</title>
    <link href="http://ming1016.github.io/2018/04/02/record-and-think-about-swift-project-jsondecoder-networking-and-pop/"/>
    <id>http://ming1016.github.io/2018/04/02/record-and-think-about-swift-project-jsondecoder-networking-and-pop/</id>
    <published>2018-04-02T11:12:28.000Z</published>
    <updated>2018-04-02T11:17:52.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目开发一直在使用 swift，因为 HTN 项目最近会有另外一位同事加入，所以打算对最近涉及到的一些技术和自己的一些想法做个记录，同时也能够方便同事熟悉代码。</p>
<h1 id="JSON-数据的处理"><a href="#JSON-数据的处理" class="headerlink" title="JSON 数据的处理"></a>JSON 数据的处理</h1><p>做项目只要是涉及到服务器端接口都没法避免和 JSON 数据打交道。对于来自网络的 JSON 结构化数据的处理，可以使用 JSONDecoder 这个苹果自己提供的字符串转模型类，这个类是在 Swift 4 的 Fundation 模块里提供的，可以在Swift 源码目录 swift/stdlib/public/SDK/Fundation/JSONEncoder.swift 看到苹果对这个类实现。</p>
<p>其它对 JSON 处理的库还有 SwiftyJSON <a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="external">GitHub - SwiftyJSON/SwiftyJSON: The better way to deal with JSON data in Swift</a></p>
<h2 id="使用-JSONDecoder"><a href="#使用-JSONDecoder" class="headerlink" title="使用 JSONDecoder"></a>使用 JSONDecoder</h2><p>下面苹果使用 JSONDecoder 的一个例子来看看如何使用 JSONDecoder<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct GroceryProduct: Codable &#123;</div><div class="line">    var name: String</div><div class="line">    var points: Int</div><div class="line">    var description: String?</div><div class="line">&#125;</div><div class="line"></div><div class="line">let json = """</div><div class="line">&#123;</div><div class="line">    "name": "Durian",</div><div class="line">    "points": 600,</div><div class="line">    "description": "A fruit with a distinctive scent."</div><div class="line">&#125;</div><div class="line">""".data(using: .utf8)!</div><div class="line"></div><div class="line">let decoder = JSONDecoder()</div><div class="line">let product = try decoder.decode(GroceryProduct.self, from: json)</div><div class="line"></div><div class="line">print(product.name) // Prints "Durian"</div></pre></td></tr></table></figure></p>
<p>这里要注意 GroceryProduct 结构体需要遵循 Codable，因为 JSONDecoder 的实例对象的 decode 方法需要遵循 Decodable 协议的结构体。Codable 是 Encodable 和 Decodable 两个协议的组合，写法如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Codable</span> = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></div></pre></td></tr></table></figure></p>
<p>当然 JSON 数据的结构不会都是这么简单，如果遇到嵌套情况如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let json = """</div><div class="line">&#123;</div><div class="line">    "name": "Durian",</div><div class="line">    "points": 600,</div><div class="line">    "ability": &#123;</div><div class="line">        "mathematics": "excellent",</div><div class="line">        "physics": "bad",</div><div class="line">        "chemistry": "fine"</div><div class="line">    &#125;,</div><div class="line">    "description": "A fruit with a distinctive scent."</div><div class="line">&#125;</div><div class="line">""".data(using: .utf8)!</div></pre></td></tr></table></figure></p>
<p>这时可以通过在 struct 里再套一个 struct 来做，修改过的 struct 如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> points: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> ability: <span class="type">Ability</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span>?</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Ability</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> mathematics: <span class="type">String</span></div><div class="line">        <span class="keyword">var</span> physics: <span class="type">String</span></div><div class="line">        <span class="keyword">var</span> chemistry: <span class="type">String</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里可以观察到 ability 里数学物理化学的评价都是那几个，无非是优良差，所以很适合用枚举表示，swift 的枚举对于字符串关联类型枚举也有很好的支持，只要声明关联值类型是 String 就行了，改后的代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> points: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> ability: <span class="type">Ability</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span>?</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Ability</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> mathematics: <span class="type">Appraise</span></div><div class="line">        <span class="keyword">var</span> physics: <span class="type">Appraise</span></div><div class="line">        <span class="keyword">var</span> chemistry: <span class="type">Appraise</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Appraise</span>: <span class="title">String</span>, <span class="title">Codable</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> excellent, fine, bad</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>API 返回的结果会有一个不可控的因素，是什么呢？那就是有的键值有时会返回有时不会返回，那么这个 struct 怎么兼容呢？</p>
<p>好在swift 原生就支持了 optional，只需要在属性后加个问号就行了。比如 points 有时会返回有时不会，那么就可以这么写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> points: <span class="type">Int</span>? <span class="comment">//可能会用不到</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CodingKey-协议"><a href="#CodingKey-协议" class="headerlink" title="CodingKey 协议"></a>CodingKey 协议</h2><p>接口还会有一些其它不可控因素，比如会产生出 snake case 的命名风格，要求风格统一固然是很好，但是现实环境总会有些不可抗拒的因素，比如不同团队，不同公司或者不同风格洁癖的 coder 之间。还好 JSONDecoder 已经做好了。下面我们看看如何用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let json = """</div><div class="line">&#123;</div><div class="line">    "nick_name": "Tom",</div><div class="line">    "points": 600,</div><div class="line">&#125;</div><div class="line">""".data(using: .utf8)!</div></pre></td></tr></table></figure></p>
<p>这里 nick_name 我们希望处理成 swift 的风格，那么我们可以使用一个遵循 CodingKey 协议的枚举来做映射。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> nickName: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> points: <span class="type">Int</span></div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span> : <span class="title">String</span>, <span class="title">CodingKey</span></span>&#123;</div><div class="line">        <span class="keyword">case</span> nickName = <span class="string">"nick_name"</span></div><div class="line">        <span class="keyword">case</span> points</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这个方法是个通用方法，不光能够处理 snake case 还能够起自己喜欢的命名，比如你喜欢简写，nick name 写成 nName，那么也可以用这个方法。Codable 协议默认的实现实际上已经能够 cover 掉现实环境的大部分问题了，如果有些自定义的东西要处理的话可以通过覆盖默认 Codable 的方式来做。关键点就是 encoder 的 container，通过获取 container 对象进行自定义操作。</p>
<h2 id="JSONDecoder-的-keyDecodingStrategy-属性"><a href="#JSONDecoder-的-keyDecodingStrategy-属性" class="headerlink" title="JSONDecoder 的 keyDecodingStrategy 属性"></a>JSONDecoder 的 keyDecodingStrategy 属性</h2><p>JSONDecoder 里还有专门的一个属性 keyDecodingStrategy，这个值是个布尔值，有个 case 是 convertFromSnakeCase，这样就会按照这个 strategy 来转换 snake case，这个是核心功能内置的，就不需要我们额外写代码处理了。上面加上的枚举 CodingKeys 也可以去掉了，只需要在 JSONDecoder 这个实例设置这个属性就行。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</div><div class="line">decoder.keyDecodingStrategy = .convertFromSnakeCase</div></pre></td></tr></table></figure></p>
<p>keyDecodingStrategy 这个属性是在 swift 4.1 加上的，所以这个版本之前的还是用 CodingKey 这个协议来处理吧。</p>
<p>那么苹果是如何通过这个 keyDecodingStrategy 属性的设置来做到的呢？</p>
<p>感谢苹果使用 Swift 写了 Swift 的核心功能，以后想要了解更多功能背后原理可以不用啃 C++ 了，一边学习原理还能一边学习苹果内部是如何使用 Swift 的，所谓一举两得。</p>
<p>实现这个功能代码就在上文提到的 Swift 源码目录 swift/stdlib/public/SDK/Fundation/ 下的 JSONEncoder.swift  文件，如果不想把源码下下来也可以在 GitHub 上在线看，地址：<a href="https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/JSONEncoder.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/JSONEncoder.swift</a></p>
<p>先看看这个属性的定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// The strategy to use for decoding keys. Defaults to `.useDefaultKeys`.</span></div><div class="line">open <span class="keyword">var</span> keyDecodingStrategy: <span class="type">KeyDecodingStrategy</span> = .useDefaultKeys</div></pre></td></tr></table></figure></p>
<p>这个属性是一个 keyDecodingStrategy 枚举，默认是 .userDefaultKeys。这个枚举是这样定义的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">KeyDecodingStrategy</span> </span>&#123;</div><div class="line">    <span class="comment">/// Use the keys specified by each type. This is the default strategy.</span></div><div class="line">    <span class="keyword">case</span> useDefaultKeys</div><div class="line">    </div><div class="line">    <span class="comment">/// Convert from "snake_case_keys" to "camelCaseKeys" before attempting to match a key with the one specified by each type.</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">/// The conversion to upper case uses `Locale.system`, also known as the ICU "root" locale. This means the result is consistent regardless of the current user's locale and language preferences.</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">/// Converting from snake case to camel case:</span></div><div class="line">    <span class="comment">/// 1. Capitalizes the word starting after each `_`</span></div><div class="line">    <span class="comment">/// 2. Removes all `_`</span></div><div class="line">    <span class="comment">/// 3. Preserves starting and ending `_` (as these are often used to indicate private variables or other metadata).</span></div><div class="line">    <span class="comment">/// For example, `one_two_three` becomes `oneTwoThree`. `_one_two_three_` becomes `_oneTwoThree_`.</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">/// - Note: Using a key decoding strategy has a nominal performance cost, as each string key has to be inspected for the `_` character.</span></div><div class="line">    <span class="keyword">case</span> convertFromSnakeCase</div><div class="line">    </div><div class="line">    <span class="comment">/// Provide a custom conversion from the key in the encoded JSON to the keys specified by the decoded types.</span></div><div class="line">    <span class="comment">/// The full path to the current decoding position is provided for context (in case you need to locate this key within the payload). The returned key is used in place of the last component in the coding path before decoding.</span></div><div class="line">    <span class="comment">/// If the result of the conversion is a duplicate key, then only one value will be present in the container for the type to decode from.</span></div><div class="line">    <span class="keyword">case</span> custom((<span class="number">_</span> codingPath: [<span class="type">CodingKey</span>]) -&gt; <span class="type">CodingKey</span>)</div><div class="line">    </div><div class="line">    fileprivate <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_convertFromSnakeCase</span><span class="params">(<span class="number">_</span> stringKey: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>case convertFromSnakeCase 就是我们使用的，注释部分描述了整个过程，首先会把 ‘<em>’ 符号后面的字母转成大写的，然后移除掉所有的 ‘</em>’ 符号，保留最前面和最后的 ‘_’ 符号。比如 <strong>nick<em>name</em> 就会转换成 </strong>nickName_ 而这些都是在枚举里定义的静态方法 _convertFromSnakeCase 里完成的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">fileprivate <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_convertFromSnakeCase</span><span class="params">(<span class="number">_</span> stringKey: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">guard</span> !stringKey.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> stringKey &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Find the first non-underscore character</span></div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> firstNonUnderscore = stringKey.index(<span class="keyword">where</span>: &#123; $<span class="number">0</span> != <span class="string">"_"</span> &#125;) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Reached the end without finding an _</span></div><div class="line">        <span class="keyword">return</span> stringKey</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Find the last non-underscore character</span></div><div class="line">    <span class="keyword">var</span> lastNonUnderscore = stringKey.index(before: stringKey.endIndex)</div><div class="line">    <span class="keyword">while</span> lastNonUnderscore &gt; firstNonUnderscore &amp;&amp; stringKey[lastNonUnderscore] == <span class="string">"_"</span> &#123;</div><div class="line">        stringKey.formIndex(before: &amp;lastNonUnderscore);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> keyRange = firstNonUnderscore...lastNonUnderscore</div><div class="line">    <span class="keyword">let</span> leadingUnderscoreRange = stringKey.startIndex..&lt;firstNonUnderscore</div><div class="line">    <span class="keyword">let</span> trailingUnderscoreRange = stringKey.index(after: lastNonUnderscore)..&lt;stringKey.endIndex</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> components = stringKey[keyRange].<span class="built_in">split</span>(separator: <span class="string">"_"</span>)</div><div class="line">    <span class="keyword">let</span> joinedString : <span class="type">String</span></div><div class="line">    <span class="keyword">if</span> components.<span class="built_in">count</span> == <span class="number">1</span> &#123;</div><div class="line">        <span class="comment">// No underscores in key, leave the word as is - maybe already camel cased</span></div><div class="line">        joinedString = <span class="type">String</span>(stringKey[keyRange])</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        joinedString = ([components[<span class="number">0</span>].lowercased()] + components[<span class="number">1</span>...].<span class="built_in">map</span> &#123; $<span class="number">0</span>.capitalized &#125;).joined()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Do a cheap isEmpty check before creating and appending potentially empty strings</span></div><div class="line">    <span class="keyword">let</span> result : <span class="type">String</span></div><div class="line">    <span class="keyword">if</span> (leadingUnderscoreRange.isEmpty &amp;&amp; trailingUnderscoreRange.isEmpty) &#123;</div><div class="line">        result = joinedString</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!leadingUnderscoreRange.isEmpty &amp;&amp; !trailingUnderscoreRange.isEmpty) &#123;</div><div class="line">        <span class="comment">// Both leading and trailing underscores</span></div><div class="line">        result = <span class="type">String</span>(stringKey[leadingUnderscoreRange]) + joinedString + <span class="type">String</span>(stringKey[trailingUnderscoreRange])</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!leadingUnderscoreRange.isEmpty) &#123;</div><div class="line">        <span class="comment">// Just leading</span></div><div class="line">        result = <span class="type">String</span>(stringKey[leadingUnderscoreRange]) + joinedString</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Just trailing</span></div><div class="line">        result = joinedString + <span class="type">String</span>(stringKey[trailingUnderscoreRange])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码处理的逻辑不算复杂，功能也不多，但是还是有很多值得学习的地方，首先可以看看是如何处理边界条件的。可以看到两个边界条件都是用 guard 语法来处理的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> !stringKey.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> stringKey &#125;</div><div class="line"></div><div class="line"><span class="comment">// Find the first non-underscore character</span></div><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> firstNonUnderscore = stringKey.index(<span class="keyword">where</span>: &#123; $<span class="number">0</span> != <span class="string">"_"</span> &#125;) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Reached the end without finding an _</span></div><div class="line">    <span class="keyword">return</span> stringKey</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个是判断空，第二个是通过 String 的 public func index(where predicate: (Character) throws -&gt; Bool) rethrows -&gt; String.Index?  这个函数来看字符串里是否包含了 ‘_’ 符号，如果没有包含就直接返回原 String 值。这个函数的参数就是一个自定义返回布尔值的 block，返回 true 即刻返回不再继续遍历了，可见苹果对于性能一点也不浪费。</p>
<p>然后这个返回的 index 值还有个作用就是可以得到 ‘<em>’ 符号在最前面后第一个非 ‘</em>’ 符号的字符。因为需求如此，不需要把最前面和最后面的 ‘<em>’ 转驼峰，但是前面和后面的 ‘</em>’ 符号个数又不一定，所以需要得到前面 ‘_’ 符号和后面的范围。</p>
<p>那么得到前面的范围后，后面的苹果是怎么做的呢？<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Find the last non-underscore character</span></div><div class="line"><span class="keyword">var</span> lastNonUnderscore = stringKey.index(before: stringKey.endIndex)</div><div class="line"><span class="keyword">while</span> lastNonUnderscore &gt; firstNonUnderscore &amp;&amp; stringKey[lastNonUnderscore] == <span class="string">"_"</span> &#123;</div><div class="line">    stringKey.formIndex(before: &amp;lastNonUnderscore);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里正好可以看到对 String 的 public func formIndex(before i: inout String.Index) 函数的应用，这里的参数定义为 inout 的作用是能够在函数里对这个参数不用通过返回的方式直接修改生效。这个函数的作用就是移动字符的 index，before 是往前移动，after 是往后移动。</p>
<p>上面的代码就是先找到整个字符串的最后的 index 然后开始从后往前找，找到不是 ‘_’ 符号时跳出这个 while，同时还要满足不超过 lastNonUnderscore 的范围。</p>
<p>在接下内容之前可以考虑这样一个问题，为什么在做前面的判断时为什么不用 public func formIndex(after i: inout String.Index) 这个方法，after 不是代表从开始往后移动遍历么，也可以达到找到第一个不是 ‘_’ 的字符就停止的效果。</p>
<p>苹果真是双枪老太婆，一击两发，既解决了边界问题又能解决一个需求，代码有了优化，代码量还减少了。其实面试过程中通常都会有些算法题的环节，很多人都以为只要有了解决思路或者写出简单的处理代码就可以了，我碰到了一些的面试人甚至用中文一条条写出思路以为就完事了。其实算法题的考察是分为两种的，一种是考智商的，就是解决办法很多或者解决办法很难，能够想到解法或者最优解是比较困难的，这样的题适合那些在面谈过程中能觉得实力和深度不错的人，通过这些题同时还能更多为判断面试人是否更具创造力，属于拔尖的考法。还有种是考严谨和实际项目能力的，这种更多是考察边界条件的处理，逻辑的严谨还有对代码优化的处理，这种题的解法和逻辑会比较简单。</p>
<p>_convertFromSnakeCase 这个枚举的静态函数会在创建 container 的时候调用，具体使用的函数是 _JSONKeyedDecodingContainer，在它的初始化方法里会判断  decoder.options.keyDecodingStrategy  这个枚举值，满足 convertFromSnakeCase 就会调用那个静态函数了。调用的时候还要注意一个处理就是转换成驼峰后的 key 可能会和已有命名重名，那么就需要选择进行一个选择，苹果的选择是第一个。实现方式如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.container = <span class="type">Dictionary</span>(container.<span class="built_in">map</span> &#123;</div><div class="line">    key, value <span class="keyword">in</span> (<span class="type">JSONDecoder</span>.<span class="type">KeyDecodingStrategy</span>._convertFromSnakeCase(key), value)</div><div class="line">&#125;, uniquingKeysWith: &#123; (first, <span class="number">_</span>) <span class="keyword">in</span> first &#125;)</div></pre></td></tr></table></figure></p>
<p>这里遇到一个 Dictionary 的初始化函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">S</span>&gt;(<span class="number">_</span> keysAndValues: <span class="type">S</span>, uniquingKeysWith combine: (<span class="type">Dictionary</span>.<span class="type">Value</span>, <span class="type">Dictionary</span>.<span class="type">Value</span>) <span class="keyword">throws</span> -&gt; <span class="type">Dictionary</span>.<span class="type">Value</span>) <span class="keyword">rethrows</span> <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Sequence</span>, <span class="type">S</span>.<span class="type">Element</span> == (<span class="type">Key</span>, <span class="type">Value</span>)</div></pre></td></tr></table></figure></p>
<p>这个函数就是专门用来处理上面的重复 key 的问题。如果要选择最后一个 key 的值用这个函数也会很容易。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pairsWithDuplicateKeys = [(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"a"</span>, <span class="number">3</span>), (<span class="string">"b"</span>, <span class="number">4</span>)]</div><div class="line"></div><div class="line"><span class="keyword">let</span> firstValues = <span class="type">Dictionary</span>(pairsWithDuplicateKeys,</div><div class="line">                             uniquingKeysWith: &#123; (first, <span class="number">_</span>) <span class="keyword">in</span> first &#125;)</div><div class="line"><span class="comment">// ["b": 2, "a": 1]</span></div><div class="line"><span class="keyword">let</span> lastValues = <span class="type">Dictionary</span>(pairsWithDuplicateKeys,</div><div class="line">                            uniquingKeysWith: &#123; (<span class="number">_</span>, last) <span class="keyword">in</span> last &#125;)</div><div class="line"><span class="comment">// ["b": 4, "a": 3]</span></div></pre></td></tr></table></figure></p>
<h2 id="枚举定义-block"><a href="#枚举定义-block" class="headerlink" title="枚举定义 block"></a>枚举定义 block</h2><p>KeyEncodingStrategy 还可以自定义 codingKey<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> custom((<span class="number">_</span> codingPath: [<span class="type">CodingKey</span>]) -&gt; <span class="type">CodingKey</span>)</div></pre></td></tr></table></figure></p>
<p>在 container 初始化时会调用这个 block 来进行 key 的转换，同样如果转换后出现重复 key 也会和 convertFromSnakeCase 一样选择第一个。这里可以看到 Swift 里的枚举还能够定义一个 block 方便自定义处理自己特定规则，这样就可以完全抛弃以前的那种覆盖 Codable 协议默认实现的方式了。</p>
<h2 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h2><p>上面提到了 public func formIndex(before i: inout Index) 这个函数，那么跟着这个函数在源码里看看它的实现，这个函数是在这个文件里实现的 <a href="https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/IndexSet.swift" target="_blank" rel="external">swift/IndexSet.swift at master · apple/swift · GitHub</a></p>
<p>找到这个方法时发现没有 inout 定义的同名函数也还在那里<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(before i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</div><div class="line">    <span class="keyword">if</span> i.value == i.extent.lowerBound &#123;</div><div class="line">        <span class="comment">// Move to the next range</span></div><div class="line">        <span class="keyword">if</span> i.rangeIndex == <span class="number">0</span> &#123;</div><div class="line">            <span class="comment">// We have no more to go</span></div><div class="line">            <span class="keyword">return</span> <span class="type">Index</span>(value: i.value, extent: i.extent, rangeIndex: i.rangeIndex, rangeCount: i.rangeCount)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> rangeIndex = i.rangeIndex - <span class="number">1</span></div><div class="line">            <span class="keyword">let</span> rangeCount = i.rangeCount</div><div class="line">            <span class="keyword">let</span> extent = _range(at: rangeIndex)</div><div class="line">            <span class="keyword">let</span> value = extent.upperBound - <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> <span class="type">Index</span>(value: value, extent: extent, rangeIndex: rangeIndex, rangeCount: rangeCount)</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Move to the previous value in this range</span></div><div class="line">        <span class="keyword">return</span> <span class="type">Index</span>(value: i.value - <span class="number">1</span>, extent: i.extent, rangeIndex: i.rangeIndex, rangeCount: i.rangeCount)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">formIndex</span><span class="params">(before i: <span class="keyword">inout</span> Index)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> i.value == i.extent.lowerBound &#123;</div><div class="line">        <span class="comment">// Move to the next range</span></div><div class="line">        <span class="keyword">if</span> i.rangeIndex == <span class="number">0</span> &#123;</div><div class="line">            <span class="comment">// We have no more to go</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            i.rangeIndex -= <span class="number">1</span></div><div class="line">            i.extent = _range(at: i.rangeIndex)</div><div class="line">            i.value = i.extent.upperBound - <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Move to the previous value in this range</span></div><div class="line">        i.value -= <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数的实现最直观的感受就是 inout 的少了三个 return。还有一个好处就是值类型参数 i 可以以引用方式传递，不需要 var 和 let 来修饰</p>
<p>当然 inout 还有一个好处在上面的函数里没有体现出来，那就是可以方便对多个值类型数据进行修改而不需要一一指明返回。</p>
<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><p>说到网络请求，在 Objective-C 世界里基本都是用的 AFNetworking <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">GitHub - AFNetworking/AFNetworking: A delightful networking framework for iOS, macOS, watchOS, and tvOS.</a> 在 Swift 里就是 Alamofire <a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">GitHub - Alamofire/Alamofire: Elegant HTTP Networking in Swift</a> 。我在 Swift 1.0 之前 beta 版本时就注意到 Alamofire 库里，那时还是 Mattt Thompson 一个人在写，文件也只有一个。如今功能已经多了很多，但代码量依然不算太大。我在做 HTN 项目时对于网络请求的需求不是那么大，但是也有，于是开始的时候就是简单的使用 URLSession 来实现了一下网路请求，就是想直接拉下接口下发的 JSON 数据。</p>
<p>开始结合着前面解析 JSON 的方法，我这么写了个网络请求：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WebJSON</span>:<span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name:<span class="type">String</span></div><div class="line">    <span class="keyword">var</span> node:<span class="type">String</span></div><div class="line">    <span class="keyword">var</span> version: <span class="type">Int</span>?</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> session = <span class="type">URLSession</span>.shared</div><div class="line"><span class="keyword">let</span> request:<span class="type">URLRequest</span> = <span class="type">NSURLRequest</span>.<span class="keyword">init</span>(url: <span class="type">URL</span>(string: <span class="string">"http://www.starming.com/api.php?get=testjson"</span>)!) <span class="keyword">as</span> <span class="type">URLRequest</span></div><div class="line"><span class="keyword">let</span> task = session.dataTask(with: request) &#123; (data, res, error) <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"解析 JSON 成功"</span>)</div><div class="line">            <span class="keyword">let</span> jsonModel = <span class="keyword">try</span> decoder.decode(<span class="type">WebJSON</span>.<span class="keyword">self</span>, from: data!)</div><div class="line">            <span class="built_in">print</span>(jsonModel)</div><div class="line">        &#125; <span class="keyword">catch</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"解析 JSON 失败"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么写是 ok 的，能够成功请求得到 JSON 数据然后转换成对应的结构数据。不过如果还有另外几处也要进行网络请求，拿这一坨代码不是要到处写了。那么先看看 Alamofire 干这个活是什么样子的？<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/get"</span>).responseData &#123; response <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = response.data &#123;</div><div class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"解析 JSON 成功"</span>)</div><div class="line">            <span class="keyword">let</span> jsonModel = <span class="keyword">try</span> decoder.decode(<span class="type">H5Editor</span>.<span class="keyword">self</span>, from: data)</div><div class="line">        &#125; <span class="keyword">catch</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"解析 JSON 失败"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Alamofire 有 responseJSON 的方法，不过解完是个字典，用的时候需要做很多容错判断很不方便，所以还是要使用 JSONDecoder 或者其它第三方库。不过 Alamofire 的写法已经做了一些简化，当然里面还实现了更多的功能，我待会再说，现在我的主要任务是简化调用。于是动手改改先前的实现，学习 Alamofire 的做法，首先创建一个类，然后简化掉 request 写法，再建个 block 方便请求完成后的数据返回处理，最后使用泛型支持不同 struct 的数据统一返回。写完后，我给这个网络类起个名字叫 SMNetWorking 这个类实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">SMNetWorking</span>&lt;<span class="title">T</span>:<span class="title">Codable</span>&gt; </span>&#123;</div><div class="line">    open <span class="keyword">let</span> session:<span class="type">URLSession</span></div><div class="line">    </div><div class="line">    <span class="keyword">typealias</span> <span class="type">CompletionJSONClosure</span> = (<span class="number">_</span> data:<span class="type">T</span>) -&gt; <span class="type">Void</span></div><div class="line">    <span class="keyword">var</span> completionJSONClosure:<span class="type">CompletionJSONClosure</span> =  &#123;<span class="number">_</span> <span class="keyword">in</span> &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">self</span>.session = <span class="type">URLSession</span>.shared</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//JSON的请求</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">requestJSON</span><span class="params">(<span class="number">_</span> url: SMURLNetWorking,</span></span></div><div class="line">                     doneClosure:@escaping CompletionJSONClosure</div><div class="line">                    ) &#123;</div><div class="line">        <span class="keyword">self</span>.completionJSONClosure = doneClosure</div><div class="line">        <span class="keyword">let</span> request:<span class="type">URLRequest</span> = <span class="type">NSURLRequest</span>.<span class="keyword">init</span>(url: url.asURL()) <span class="keyword">as</span> <span class="type">URLRequest</span></div><div class="line">        <span class="keyword">let</span> task = <span class="keyword">self</span>.session.dataTask(with: request) &#123; (data, res, error) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</div><div class="line">                <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="built_in">print</span>(<span class="string">"解析 JSON 成功"</span>)</div><div class="line">                    <span class="keyword">let</span> jsonModel = <span class="keyword">try</span> decoder.decode(<span class="type">T</span>.<span class="keyword">self</span>, from: data!)</div><div class="line">                    <span class="keyword">self</span>.completionJSONClosure(jsonModel)</div><div class="line">                &#125; <span class="keyword">catch</span> &#123;</div><div class="line">                    <span class="built_in">print</span>(<span class="string">"解析 JSON 失败"</span>)</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        task.resume()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*----------Protocol----------*/</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SMURLNetWorking</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*----------Extension---------*/</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">SMURLNetWorking</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string:<span class="keyword">self</span>) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">URL</span>(string:<span class="string">"http:www.starming.com"</span>)!</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> url</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样调用起来就简单得多了，看起来如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">SMNetWorking</span>&lt;<span class="type">WModel</span>&gt;().requestJSON(<span class="string">"https://httpbin.org/get"</span>) &#123; (jsonModel) <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(jsonModel)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这样写起来是简单多了，特别是请求不同的接口返回不同结构时，本地定义了很多的 model 结构体，那么请求时只需要指明不同的 model 类型，block 里就能够直接返回对应的值。</p>
<p>默认都按照 GET 方法请求，在实际项目中会用到其它比如 POST 等方法，Alamofire 的做法是这样的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// HTTP method definitions.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// See https://tools.ietf.org/html/rfc7231#section-4.3</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">HTTPMethod</span>: <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> options = <span class="string">"OPTIONS"</span></div><div class="line">    <span class="keyword">case</span> <span class="keyword">get</span>     = <span class="string">"GET"</span></div><div class="line">    <span class="keyword">case</span> head    = <span class="string">"HEAD"</span></div><div class="line">    <span class="keyword">case</span> post    = <span class="string">"POST"</span></div><div class="line">    <span class="keyword">case</span> put     = <span class="string">"PUT"</span></div><div class="line">    <span class="keyword">case</span> patch   = <span class="string">"PATCH"</span></div><div class="line">    <span class="keyword">case</span> delete  = <span class="string">"DELETE"</span></div><div class="line">    <span class="keyword">case</span> trace   = <span class="string">"TRACE"</span></div><div class="line">    <span class="keyword">case</span> connect = <span class="string">"CONNECT"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会先定义一个枚举，依据的标准也列在了注释里。使用起来是这样的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/get"</span>) <span class="comment">// method defaults to `.get`</span></div><div class="line"></div><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/post"</span>, method: .post)</div><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/put"</span>, method: .put)</div><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/delete"</span>, method: .delete)</div></pre></td></tr></table></figure></p>
<p>可以看出在 request 方法里有个可选参数，设置完会给 NSURLRequest 的 httpMethod 的这个可选属性附上设置的值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(url: <span class="type">URLConvertible</span>, method: <span class="type">HTTPMethod</span>, headers: <span class="type">HTTPHeaders</span>? = <span class="literal">nil</span>) <span class="keyword">throws</span> &#123;</div><div class="line">    <span class="keyword">let</span> url = <span class="keyword">try</span> url.asURL()</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(url: url)</div><div class="line">    </div><div class="line">    httpMethod = method.rawValue</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> headers = headers &#123;</div><div class="line">        <span class="keyword">for</span> (headerField, headerValue) <span class="keyword">in</span> headers &#123;</div><div class="line">            setValue(headerValue, forHTTPHeaderField: headerField)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么接下来我在 SMNetWorking 类里也加上这个功能，先定义一个枚举：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPMethod</span>: <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">GET</span>,<span class="type">OPTIONS</span>,<span class="type">HEAD</span>,<span class="type">POST</span>,<span class="type">PUT</span>,<span class="type">PATCH</span>,<span class="type">DELETE</span>,<span class="type">TRACE</span>,<span class="type">CONNECT</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>利用枚举的字符串协议特性，可以将枚举名直接转值的字符串，可以通过这种方式简化枚举定义。</p>
<p>翻下 NSURLRequest 提供的那些可选设置项还不少，如果把这些设置都做成一个个可配参数那么后期维护会非常麻烦。所以我打算使用链式来弄。先 fix HTTPMethod 这个。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链式方法</span></div><div class="line"><span class="comment">//HTTPMethod 的设置</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpMethod</span><span class="params">(<span class="number">_</span> md:HTTPMethod)</span></span> -&gt; <span class="type">SMNetWorking</span> &#123;</div><div class="line">    <span class="keyword">self</span>.op.httpMethod = md</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 op 是个结构体，专门用来存放这些可选项的值的。完整的代码可以在这里看到 <a href="https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/Core/HTNFundation/SMNetWorking.swift" target="_blank" rel="external">HTN/SMNetWorking.swift at master · ming1016/HTN · GitHub</a></p>
<p>使用起来也很方便：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">SMNetWorking</span>&lt;<span class="type">WModel</span>&gt;().method(.<span class="type">POST</span>).requestJSON(<span class="string">"https://httpbin.org/get"</span>)</div></pre></td></tr></table></figure></p>
<p>有了这样一个结构的设计后面扩展起来会非常方便，不过目前的功能是能够满足基本需求的，所以需要完善的比如对于 POST 请求需要的 HTTTP Body，还有 HTTP Headers 的自定义设置，Authentication 里的 HTTP Basic Authentication，Authentication with URLCredential 等，这些也可以先提供一个接口到外部去设置。所以可以先建个 block 把 URLRequest 提供出去由外围设置。</p>
<p>弄完后的使用效果如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">SMNetWorking</span>&lt;<span class="type">WModel</span>&gt;().method(.<span class="type">POST</span>).configRequest &#123; (request) <span class="keyword">in</span></div><div class="line">    <span class="comment">//设置 request</span></div><div class="line">&#125;.requestJSON(<span class="string">"https://httpbin.org/get"</span>)</div></pre></td></tr></table></figure></p>
<p>就刚才提到的请求参数来说，Alamofire 是定义了一个 ParameterEncoding 协议，协议里规定一个统一处理的方法 func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&gt; URLRequest 这样就可以对多种情况做一样的返回处理了。从遵循这个协议的结构体可以看到 URL，JSON 和 PropertyList 都遵循了，那么从实现这个协议的 encode 函数的实现里可以看到他们都是殊途同归到 request 的 httpBody 里。可以拿 URLEncoding 看看具体实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(<span class="number">_</span> urlRequest: URLRequestConvertible, with parameters: Parameters?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">URLRequest</span> &#123;</div><div class="line">    <span class="keyword">var</span> urlRequest = <span class="keyword">try</span> urlRequest.asURLRequest()</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> parameters = parameters <span class="keyword">else</span> &#123; <span class="keyword">return</span> urlRequest &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> method = <span class="type">HTTPMethod</span>(rawValue: urlRequest.httpMethod ?? <span class="string">"GET"</span>), encodesParametersInURL(with: method) &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = urlRequest.url <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">AFError</span>.parameterEncodingFailed(reason: .missingURL)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">var</span> urlComponents = <span class="type">URLComponents</span>(url: url, resolvingAgainstBaseURL: <span class="literal">false</span>), !parameters.isEmpty &#123;</div><div class="line">            <span class="keyword">let</span> percentEncodedQuery = (urlComponents.percentEncodedQuery.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="string">"&amp;"</span> &#125; ?? <span class="string">""</span>) + query(parameters)</div><div class="line">            urlComponents.percentEncodedQuery = percentEncodedQuery</div><div class="line">            urlRequest.url = urlComponents.url</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> urlRequest.value(forHTTPHeaderField: <span class="string">"Content-Type"</span>) == <span class="literal">nil</span> &#123;</div><div class="line">            urlRequest.setValue(<span class="string">"application/x-www-form-urlencoded; charset=utf-8"</span>, forHTTPHeaderField: <span class="string">"Content-Type"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> urlRequest</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="泛型协议式编程"><a href="#泛型协议式编程" class="headerlink" title="泛型协议式编程"></a>泛型协议式编程</h1><p>对于目前 HTN 项目来说，请求到了数据，将 JSON 解析生成了对应的 Struct，那么下一步就是要把这个结构化的数据生成不同平台的代码，比如首先是 Objective-C 代码，然后是 Swift 代码，再然后会有 Java 代码。为了能够更好的合并多语言里重复的东西，我打算将处理生成不同语言的实现遵循相同的协议，这样就可以更规范更减少重复的实现这样的功能了。最终的效果如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">SMNetWorking</span>&lt;<span class="type">H5Editor</span>&gt;().requestJSON(<span class="string">"https://httpbin.org/get"</span>) &#123; (jsonModel) <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> reStr = <span class="type">H5EditorToFrame</span>&lt;<span class="type">H5EditorObjc</span>&gt;(<span class="type">H5EditorObjc</span>()).convert(jsonModel)</div><div class="line">        <span class="built_in">print</span>(reStr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是转成 Swift 的话就把 H5EditorObjc 改成 H5EditorSwift 就好了，他们遵循的都是 HTNMultilingualismSpecification 协议，其它语言依此类推。如果遇到统一的实现，可以建个协议的扩展，然后用统一函数去实现就好了。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HTNMultilingualismSpecification</span> </span>&#123;</div><div class="line">    <span class="comment">//统一处理函数放这里</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种设计很类似类簇，比如我们熟悉的 NSString 就是这么设计的，根据初始化的不同，比如 initWith 什么的实例出来的对象是不同的，不过他们都遵循了相同的协议，所以我们在使用的时候没有感觉到差别。</p>
<p>HTNMultilingualismSpecification 这个协议里具体的定义在这里：<a href="https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/Core/HTNFundation/HTNMultilingualism.swift" target="_blank" rel="external">https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/Core/HTNFundation/HTNMultilingualism.swift</a></p>
<p>回头看看 JSONDecoder 也是使用协议泛型式编程的一个典范。先看看 decode 函数的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">decode</span>&lt;T : Decodable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>, from data: Data)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span></div></pre></td></tr></table></figure></p>
<p>入参 type 是遵循了统一的 Decodable 协议的，那么就可以按照统一的方法去做处理，在内部实现时实际上 JSONDecoder 会代理给 _JSONDecoder 来实现具体逻辑的。所以在 decode 里的具体实现值类型转换的 unbox 函数都是在 _JSONDecoder 的扩展里实现的。unbox 会处理数字，字符串，布尔值这些基础数据类型，如果有其它层级的结构体也会一层层解下去， _JSONDecoder 的 _JSONDecodingStorage 通过保存最终得到完整的结构体。可以通过下面的代码看出支持这个过程的结构是怎么设计的。首先是 _JSONDecoder 的属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// The decoder's storage.</span></div><div class="line">fileprivate <span class="keyword">var</span> storage: _JSONDecodingStorage</div><div class="line"></div><div class="line"><span class="comment">/// Options set on the top-level decoder.</span></div><div class="line">fileprivate <span class="keyword">let</span> options: <span class="type">JSONDecoder</span>._Options</div><div class="line"></div><div class="line"><span class="comment">/// The path to the current point in encoding.</span></div><div class="line">fileprivate(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> codingPath: [<span class="type">CodingKey</span>]</div><div class="line"></div><div class="line"><span class="comment">/// Contextual user-provided information for use during encoding.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> userInfo: [<span class="type">CodingUserInfoKey</span> : <span class="type">Any</span>] &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.options.userInfo</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是初始化<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Initializes `self` with the given top-level container and options.</span></div><div class="line">fileprivate <span class="keyword">init</span>(referencing container: <span class="type">Any</span>, at codingPath: [<span class="type">CodingKey</span>] = [], options: <span class="type">JSONDecoder</span>._Options) &#123;</div><div class="line">    <span class="keyword">self</span>.storage = _JSONDecodingStorage()</div><div class="line">    <span class="keyword">self</span>.storage.push(container: container)</div><div class="line">    <span class="keyword">self</span>.codingPath = codingPath</div><div class="line">    <span class="keyword">self</span>.options = options</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里可以看到 storage 在初始化时只 push 了顶层，push 的实现是：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fileprivate <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(container: Any)</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.containers.append(container)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>containers 在定义的时候是个 [Any] 数组，这样就允许 container 包含 container 也就是 struct 包含 struct 这样的结构。</p>
<h1 id="函数式思想编程"><a href="#函数式思想编程" class="headerlink" title="函数式思想编程"></a>函数式思想编程</h1><p>在处理映射成表达式是设置布局属性最复杂的地方，需要考虑兼顾到各种表达式情况的处理，这样救需要设计一个类似 SnapKit 那样可链式调用设置值的结构，我先设计了一个结构体用来存一些可变的信息<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PtEqual</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> leftId = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">left</span> = <span class="type">WgPt</span>.<span class="keyword">none</span></div><div class="line">    <span class="keyword">var</span> leftIdPrefix = <span class="string">""</span> <span class="comment">//左前缀</span></div><div class="line">    <span class="keyword">var</span> rightType = <span class="type">PtEqualRightType</span>.pt</div><div class="line">    <span class="keyword">var</span> rightId = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> rightIdPrefix = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">right</span> = <span class="type">WgPt</span>.<span class="keyword">none</span></div><div class="line">    <span class="keyword">var</span> rightFloat:<span class="type">Float</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> rightInt:<span class="type">Int</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> rightColor = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> rightText = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> rightString = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> rightSuffix = <span class="string">""</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> equalType = <span class="type">EqualType</span>.normal</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于这些结构的设置会在 PtEqualC 这个类里去处理，把每个结构体属性的设置做成各个函数返回类本身即可实现。效果如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.<span class="keyword">left</span>(.width).leftId(id).leftIdPrefix(<span class="string">"self."</span>).rightType(.float).rightFloat(fl.viewPt.padding.<span class="keyword">left</span> * <span class="number">2</span>).equalType(.decrease)</div></pre></td></tr></table></figure></p>
<p>不过每次设置完后需要累加到最后返回的字符串里，这样一个过程其实也可以封装一个简单函数，比如 add()。这个怎么做能够更通用呢？比如希望支持不同的累加方法等。</p>
<p>那么可以先设计一个累加的 block 属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">MutiClosure</span> = (<span class="number">_</span> pe: <span class="type">PtEqual</span>) -&gt; <span class="type">String</span></div><div class="line"><span class="keyword">var</span> accumulatorLineClosure:<span class="type">MutiClosure</span> = &#123;<span class="number">_</span> <span class="keyword">in</span> <span class="keyword">return</span> <span class="string">""</span>&#125;</div></pre></td></tr></table></figure></p>
<p>添加累加字符串和换行标示<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mutiEqualStr = <span class="string">""</span>         <span class="comment">//累加的字符串</span></div><div class="line"><span class="keyword">var</span> mutiEqualLineMark = <span class="string">"\n"</span>  <span class="comment">//换行标识</span></div></pre></td></tr></table></figure></p>
<p>写个函数去设置这个 block 返回是类自己用于链式<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//累计设置的 PtEqual 字符串</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">accumulatorLine</span><span class="params">(<span class="number">_</span> closure:@escaping MutiClosure)</span></span> -&gt; <span class="type">PtEqualC</span> &#123;</div><div class="line">    <span class="keyword">self</span>.accumulatorLineClosure = closure</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后添加一个函数专门用来使用的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行累加动作</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> filterBl &#123;</div><div class="line">        <span class="keyword">self</span>.mutiEqualStr += accumulatorLineClosure(<span class="keyword">self</span>.pe) + <span class="keyword">self</span>.mutiEqualLineMark</div><div class="line">    &#125;</div><div class="line">    <span class="number">_</span> = resetFilter()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看看用起来是什么效果：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="type">HTNMt</span>.<span class="type">PtEqualC</span>().accumulatorLine(&#123; (pe) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.ptEqualToStr(pe: pe)</div><div class="line">&#125;).<span class="built_in">filter</span>(&#123; () -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> vpt.isNormal</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    p.<span class="keyword">left</span>(.height).rightFloat(fl.viewPt.padding.top * <span class="number">2</span>).add()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>细心的同学会注意到这里多了两个东西，一个是 filter， 一个是 once，这两个函数里的 block 会把一些通用逻辑进行封装。filter 的设置会根据返回决定是否处理后面的 block 或者结构题属性的设置，实现方式如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//过滤条件</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(<span class="number">_</span> closure: FilterClosure)</span></span> -&gt; <span class="type">PtEqualC</span> &#123;</div><div class="line">    filterBl = closure()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 filterBl 是类的一个属性，后面会根据这个属性来决定动作是否继续执行。比如属性的设置会去判断<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">left</span><span class="params">(<span class="number">_</span> wp:WgPt)</span></span> -&gt; <span class="type">PtEqualC</span> &#123;</div><div class="line">    filterBl ? <span class="keyword">self</span>.pe.<span class="keyword">left</span> = wp : ()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>once 这个函数也会判断<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">once</span><span class="params">(<span class="number">_</span> closure:<span class="params">(<span class="number">_</span> pc: PtEqualC)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">PtEqualC</span>&#123;</div><div class="line">    <span class="keyword">if</span> filterBl &#123;</div><div class="line">        closure(<span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="number">_</span> = resetPe()</div><div class="line">    <span class="number">_</span> = resetFilter()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时 once 这个函数还会重置 filterBl 和重置设置的结构题，一箭三雕，相当于一个完整的设置周期。</p>
<p>有了这样一套函数，再复杂的设置过程以及逻辑处理都可以很清晰统一的表达出来，下面可以看一个复杂布局比如映射成原生表达式的代码效果：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UIView *myViewContainer = [UIView new];</span></div><div class="line">lyStr += newEqualStr(vType: .view, id: cId) + <span class="string">"\n"</span></div><div class="line"></div><div class="line"><span class="comment">//属性拼装</span></div><div class="line">lyStr += <span class="type">HTNMt</span>.<span class="type">PtEqualC</span>().accumulatorLine(&#123; (pe) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.ptEqualToStr(pe: pe)</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    p.<span class="keyword">left</span>(.top).leftId(cId).end()</div><div class="line">    <span class="keyword">if</span> fl.isFirst &#123;</div><div class="line">        <span class="comment">//myViewContainer.top = 0.0;</span></div><div class="line">        p.rightType(.float).rightFloat(<span class="number">0</span>).add()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//myViewContainer.top = lastView.bottom;</span></div><div class="line">        p.rightId(fl.lastId + <span class="string">"Container"</span>).rightType(.pt).<span class="keyword">right</span>(.bottom).add()</div><div class="line">    &#125;</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    <span class="comment">//myViewContainer.left = 0.0;</span></div><div class="line">    p.leftId(cId).<span class="keyword">left</span>(.<span class="keyword">left</span>).rightType(.float).rightFloat(<span class="number">0</span>).add()</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    <span class="comment">//myViewContainer.width = self.myView.width;</span></div><div class="line">    p.leftId(cId).<span class="keyword">left</span>(.width).rightType(.pt).rightIdPrefix(<span class="string">"self."</span>).rightId(id).<span class="keyword">right</span>(.width).add()</div><div class="line">    </div><div class="line">    <span class="comment">//myViewContainer.height = self.myView.height;</span></div><div class="line">    p.<span class="keyword">left</span>(.height).<span class="keyword">right</span>(.height).add()</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    <span class="comment">//self.myView.width -= 16 * 2;</span></div><div class="line">    p.<span class="keyword">left</span>(.width).leftId(id).leftIdPrefix(<span class="string">"self."</span>).rightType(.float).rightFloat(fl.viewPt.padding.<span class="keyword">left</span> * <span class="number">2</span>).equalType(.decrease).add()</div><div class="line">    </div><div class="line">    <span class="comment">//self.myView.height -= 8 * 2;</span></div><div class="line">    p.<span class="keyword">left</span>(.height).rightFloat(fl.viewPt.padding.top * <span class="number">2</span>).add()</div><div class="line">    </div><div class="line">    <span class="comment">//self.myView.top = 8;</span></div><div class="line">    p.equalType(.normal).<span class="keyword">left</span>(.top).rightType(.float).rightFloat(fl.viewPt.padding.top).add()</div><div class="line">    </div><div class="line">    <span class="comment">//属性 verticalAlign 或 horizontalAlign 是 padding 和其它排列时的区别处理</span></div><div class="line">    <span class="keyword">if</span> fl.viewPt.horizontalAlign == .padding &#123;</div><div class="line">        <span class="comment">//self.myView.left = 16;</span></div><div class="line">        p.<span class="keyword">left</span>(.<span class="keyword">left</span>).rightFloat(fl.viewPt.padding.<span class="keyword">left</span>).add()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//[self.myView sizeToFit];</span></div><div class="line">        p.add(sizeToFit(elm: <span class="string">"self.<span class="subst">\(id)</span>"</span>))</div><div class="line">        p.<span class="keyword">left</span>(.height).rightType(.pt).rightId(cId).<span class="keyword">right</span>(.height).add()</div><div class="line">        <span class="keyword">switch</span> fl.viewPt.horizontalAlign &#123;</div><div class="line">        <span class="keyword">case</span> .center:</div><div class="line">            p.<span class="keyword">left</span>(<span class="type">HTNMt</span>.<span class="type">WgPt</span>.center).<span class="keyword">right</span>(.center).add()</div><div class="line">        <span class="keyword">case</span> .<span class="keyword">left</span>:</div><div class="line">            p.<span class="keyword">left</span>(.<span class="keyword">left</span>).<span class="keyword">right</span>(.<span class="keyword">left</span>).add()</div><div class="line">        <span class="keyword">case</span> .<span class="keyword">right</span>:</div><div class="line">            p.<span class="keyword">left</span>(.<span class="keyword">right</span>).<span class="keyword">right</span>(.<span class="keyword">right</span>).add()</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            ()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).mutiEqualStr</div></pre></td></tr></table></figure></p>
<p>完整代码在这里：<a href="https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/H5Editor/H5EditorObjc.swift" target="_blank" rel="external">https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/H5Editor/H5EditorObjc.swift</a></p>
<p>PS：最近在一个公司分享时有人希望推荐下 iOS 相关的博客，当时我推荐了孙源的博客，其实孙源也推荐过一个博客，当时由于地址没记住没有说出来，现在推荐给大家：<a href="https://www.mikeash.com/" target="_blank" rel="external">https://www.mikeash.com/</a> 他的twitter：<a href="https://twitter.com/mikeash?lang=en" target="_blank" rel="external">https://twitter.com/mikeash</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近项目开发一直在使用 swift，因为 HTN 项目最近会有另外一位同事加入，所以打算对最近涉及到的一些技术和自己的一些想法做个记录，同时
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Why Swift? Generics(泛型), Collection(集合类型), POP(协议式编程), Memory Management(内存管理)</title>
    <link href="http://ming1016.github.io/2018/01/24/why-swift/"/>
    <id>http://ming1016.github.io/2018/01/24/why-swift/</id>
    <published>2018-01-24T09:14:03.000Z</published>
    <updated>2018-01-25T05:37:11.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇文章主要是为了给组内要做的分享准备内容。这段时间几个项目都用到 Swift，在上次 GIAC 大会上就被问到为什么要用 Swift，正好这个主题可以聊聊 Swift 的哪些特性吸引了我。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>先来个例子看下泛型是解决什么问题的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nations = [<span class="string">"中国"</span>, <span class="string">"美国"</span>, <span class="string">"日本"</span>]</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showNations</span><span class="params">(arr : [String])</span></span> &#123;</div><div class="line">    arr.<span class="built_in">map</span> &#123; str <span class="keyword">in</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(str)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先定一个字符串数组，然后把里面的字符串打印出来。这里的 map 写法还可以优化下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.<span class="built_in">map</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</div></pre></td></tr></table></figure></p>
<p>那么还能做什么优化呢。将 showNations 的入参数组泛型以支持多类型，比如 [int]，[double] 等。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showArray</span>&lt;T&gt;<span class="params">(arr: [T])</span></span> &#123;</div><div class="line">    arr.<span class="built_in">map</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出泛型能够很方便的将不同类型数据进行相同操作的逻辑归并在一起。</p>
<h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><p>先看下我的 HTN 项目里状态机的 Transition 结构体的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTNTransition</span>&lt;<span class="title">S</span>: <span class="title">Hashable</span>, <span class="title">E</span>: <span class="title">Hashable</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> event: <span class="type">E</span></div><div class="line">    <span class="keyword">let</span> fromState: <span class="type">S</span></div><div class="line">    <span class="keyword">let</span> toState: <span class="type">S</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(event: <span class="type">E</span>, fromState: <span class="type">S</span>, toState: <span class="type">S</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.event = event</div><div class="line">        <span class="keyword">self</span>.fromState = fromState</div><div class="line">        <span class="keyword">self</span>.toState = toState</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 fromState，toState 和 event 可以是不同类型的数据，可以是枚举，字符串或者整数等，定义 S 和 E 两个不同的泛型可以让状态和事件类型不相同，这样接口会更加的灵活，更容易适配更多的项目。</p>
<p>大家会注意到 S 和 E 的冒号后面还有个 Hashable 协议，这就是要求它们符合这个协议的类型约束。使用协议的话可以使得这两个类型更加的规范和易于扩展。</p>
<p>Swift 的基本类型 String，Int，Double 和 Bool 等都是遵循 Hashable 的，还有无关联值的枚举也是的。Hashable 提供了一个 hashValue 方法用在判断遵循协议对象是否相等时用。</p>
<p>Hashable 协议同时也是遵守 Equatable 协议，通过实现 == 运算符来确定自定义的类或结构是否相同。</p>
<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>在协议里定义的关联类型也可以用泛型来处理。比如我们先定义一个协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HTNState</span> </span>&#123;</div><div class="line">    associatedtype <span class="type">StateType</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> item: StateType)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>采用非泛型的实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">states</span>: <span class="title">HTNState</span> </span>&#123;</div><div class="line">    <span class="keyword">typealias</span> <span class="type">StateType</span> = <span class="type">Int</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> item: Int)</span></span> &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>采用泛型遵循协议可以按照下面方式来写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">states</span>&lt;<span class="title">T</span>&gt;: <span class="title">HTNState</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样关联类型也能够享受泛型的好处了。</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>但是在使用关联类型的时候需要注意当声明一个使用了关联属性的协议作为属性时，比如下面的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">stateDelegate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">var</span> state: <span class="type">T</span></div><div class="line">    <span class="keyword">var</span> delegate: <span class="type">HTNState</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先会提示 no initializers 的错误，接着会提示 error: protocol ‘HTNState’ can only be used as a generic constraint because it has Self or associated type requirements 。意思是 HTNState 协议只能作为泛型约束来用，因为它里面包含必需的 self 或者关联类型。</p>
<p>那么该如何处理呢？这里需要通过类型擦除来解决，主要思路就是加个中间层在代码中让这个抽象的类型具体化。实际上在 Swift 的标准库里就有类型擦除很好的运用，比如 AnySequence 的协议。</p>
<h2 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h2><p>函数，扩展和关联类型都可以使用 where 语句。where 语句是对泛型在应用时的一种约束。比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stateFilter</span>&lt;FromState:HTNState, ToState:HTNState&gt;<span class="params">(<span class="number">_</span> from:FromState, <span class="number">_</span> to:ToState)</span></span> <span class="keyword">where</span> <span class="type">FromState</span>.<span class="type">StateType</span> == <span class="type">ToState</span>.<span class="type">StateType</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数就要求他们的 StateType 具有相同类型。</p>
<h2 id="泛型和-Any-类型"><a href="#泛型和-Any-类型" class="headerlink" title="泛型和 Any 类型"></a>泛型和 Any 类型</h2><p>这两个类型看起来很相似，但是一定要小心两者的区别。他们区别在于 Any 类型会避开类型的检查，所以尽量少用最好不用。泛型一方面很灵活一方面也很安全，下面举个例子感受下两者的区别：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;T&gt;<span class="params">(<span class="number">_</span> input: T)</span></span> -&gt; <span class="type">T</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> input;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyAdd</span><span class="params">(<span class="number">_</span> input: Any)</span></span> -&gt; <span class="type">Any</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> input;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数都是可以允许任意类型的 input 参数，不同在于返回的类型在 anyAdd 函数里是可以和入参不一样的，这样就会失控，在后续的操作中容易出错。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>先来了解下集合的基本概念，首先集合是泛型的比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> stateArray: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"工作"</span>,<span class="string">"吃饭"</span>,<span class="string">"玩游戏"</span>,<span class="string">"睡觉"</span>]</div></pre></td></tr></table></figure></p>
<p>集合它需要先有个遍历的功能，通过 GeneratorType 协议，可以不关注具体元素类型只要不断的用迭代器调 next 就可以得到全部元素。但是使用迭代器没法进行多次的遍历，这时就需要使用 Sequence 来解决这个问题。像集合的 forEach，elementsEqual，contains，minElement，maxElement，map，flatMap，filter，reduce 等功能都是因为有了 Sequence 的多次遍历。</p>
<p>最后 Collection 概念是因为 Sequence 无法确定集合里的位置而在 Sequence 的基础上实现了 Indexable 协议。有了 Collection 就可以确定元素的位置，包括开始位置和结束位置，这样就能够确定哪些元素是已经访问过的，从而避免多次访问同一个元素。还能够通过一个给定的位置直接找到那个位置的元素。</p>
<p>以上描述如下图：<br><img src="/uploads/why-swift/01.png" alt=""></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Swift 里有个简单的 AnyIterator<element> 结构体<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyIterator</span>&lt;<span class="title">Element</span>&gt;: <span class="title">IteratorProtocol</span> </span>&#123; </div><div class="line">	<span class="keyword">init</span>(<span class="number">_</span> body: @escaping () -&gt; <span class="type">Element</span>?)</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></element></p>
<p>AnyIterator 实现了 IteratorProtocol 和 Sequence 协议。通过下面的例子我们来看看如何使用 AnyIterator ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">stateItr</span> : <span class="title">IteratorProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> num:<span class="type">Int</span> = <span class="number">1</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>?&#123;</div><div class="line">        num += <span class="number">2</span></div><div class="line">        <span class="keyword">return</span> num</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNext</span>&lt;I: IteratorProtocol&gt;<span class="params">( elm: I)</span></span> -&gt; <span class="type">AnyIterator</span>&lt;<span class="type">I</span>.<span class="type">Element</span>&gt; <span class="keyword">where</span> <span class="type">I</span>.<span class="type">Element</span> == <span class="type">Int</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> l = elm</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(l.next()</span> ?? 0)"</span>)</div><div class="line">    <span class="keyword">return</span> <span class="type">AnyIterator</span> &#123; l.next() &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">findNext(elm: findNext(elm: findNext(elm: stateItr())))</div></pre></td></tr></table></figure></p>
<p>首先是定义个遵循了 IteratorProtocol 并实现了 next 函数的类。再实现一个 AnyIterator 的迭代器方法，这样通过这个方法的调用就可以不断的去找符合的元素了。</p>
<p>这里有个对 where 语句的运用，where I.Element == Int。如果把这句改成 where I.Element == String 会出现下面的错误提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Playground execution failed:</div><div class="line"></div><div class="line">error: MyPlayground.playground:18:37: error: cannot invoke &apos;findNext(elm:)&apos; with an argument list of type &apos;(elm: stateItr)&apos;</div><div class="line">findNext(elm: findNext(elm: findNext(elm: stateItr())))</div><div class="line">                                    ^</div><div class="line"></div><div class="line">MyPlayground.playground:11:6: note: candidate requires that the types &apos;Int&apos; and &apos;String&apos; be equivalent (requirement specified as &apos;I.Element&apos; == &apos;String&apos; [with I = stateItr])</div><div class="line">func findNext&lt;I: IteratorProtocol&gt;( elm: I) -&gt; AnyIterator&lt;I.Element&gt; where I.Element == String</div><div class="line">     ^</div></pre></td></tr></table></figure></p>
<p>编译器会在代码检查阶段通过代码跟踪就发现类型不匹配的安全隐患，这里不得不对 Swift 的设计点个赞先</p>
<h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><p>上面的迭代器只会以单次触发的方式反复计算下个元素，但是对于希望能够重新查找或重新生成已生成的元素，这样还需要有个新的迭代器和一个子 Sequence。在 Sequence 协议里可以看到这样的定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">    <span class="comment">//Element 表示序列元素的类型</span></div><div class="line">    associatedtype <span class="type">Element</span> <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">Element</span> == <span class="type">Self</span>.<span class="type">Iterator</span>.<span class="type">Element</span></div><div class="line">    <span class="comment">//迭代接口类型</span></div><div class="line">    associatedtype <span class="type">Iterator</span> : <span class="type">IteratorProtocol</span></div><div class="line">    <span class="comment">//子 Sequence 类型</span></div><div class="line">    associatedtype <span class="type">SubSequence</span></div><div class="line">    <span class="comment">//返回 Sequence 元素的迭代器</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Iterator</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新查找靠的是这个新的迭代器，而对于切片这样的会重新生成新 Sequence 的操作就需要 SubSequence 进行存储和返回。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>对 Sequence 进行进一步的完善，最重要的就是使其具有下标索引，使得元素能够通过下标索引方式取到。Collection 是个有限的范围，有开始索引和结束索引，所以 Collection 和 Sequence 的无限范围是不一样的。有了有限的范围 Collection 就可以有 count 属性进行计数了。</p>
<p>除了标准库里的 String，Array，Dictionary 和 Set 外比如 Data 和 IndexSet 也由于遵循了 Collection 协议而获得了标准库了那些集合类型的能力。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>在泛型的第一个例子里我们就看到了 map 的使用，我们看看 map 的定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(transform: <span class="params">(<span class="keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]</div></pre></td></tr></table></figure></p>
<p>这里 (Self.Generator.Element) -&gt; T 就是 map 闭包的定义，Self.Generator.Element 就是当前元素的类型。</p>
<h2 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h2><p>二维数组经过 flatmap 会降维到一维，还能过滤掉 nil 值。下面看看 Swift 源码（swift/stdlib/public/core/SequenceAlgorithms.swift.gyb）中 flatmap 的实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><span class="comment">// flatMap()</span></div><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">  <span class="comment">/// Returns an array containing the concatenated results of calling the</span></div><div class="line">  <span class="comment">/// given transformation with each element of this sequence.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// Use this method to receive a single-level collection when your</span></div><div class="line">  <span class="comment">/// transformation produces a sequence or collection for each element.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// In this example, note the difference in the result of using `map` and</span></div><div class="line">  <span class="comment">/// `flatMap` with a transformation that returns an array.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let numbers = [1, 2, 3, 4]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let mapped = numbers.map &#123; Array(count: $0, repeatedValue: $0) &#125;</span></div><div class="line">  <span class="comment">///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let flatMapped = numbers.flatMap &#123; Array(count: $0, repeatedValue: $0) &#125;</span></div><div class="line">  <span class="comment">///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// In fact, `s.flatMap(transform)`  is equivalent to</span></div><div class="line">  <span class="comment">/// `Array(s.map(transform).joined())`.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Parameter transform: A closure that accepts an element of this</span></div><div class="line">  <span class="comment">///   sequence as its argument and returns a sequence or collection.</span></div><div class="line">  <span class="comment">/// - Returns: The resulting flattened array.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Complexity: O(*m* + *n*), where *m* is the length of this sequence</span></div><div class="line">  <span class="comment">///   and *n* is the length of the result.</span></div><div class="line">  <span class="comment">/// - SeeAlso: `joined()`, `map(_:)`</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(</span></span></div><div class="line">    <span class="number">_</span> transform: <span class="params">($&#123;GElement&#125;)</span> <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span></div><div class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.$&#123;<span class="type">GElement</span>&#125;] &#123;</div><div class="line">    <span class="keyword">var</span> result: [<span class="type">SegmentOfResult</span>.$&#123;<span class="type">GElement</span>&#125;] = []</div><div class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</div><div class="line">      result.append(contentsOf: <span class="keyword">try</span> transform(element))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">  <span class="comment">/// Returns an array containing the non-`nil` results of calling the given</span></div><div class="line">  <span class="comment">/// transformation with each element of this sequence.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// Use this method to receive an array of nonoptional values when your</span></div><div class="line">  <span class="comment">/// transformation produces an optional value.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// In this example, note the difference in the result of using `map` and</span></div><div class="line">  <span class="comment">/// `flatMap` with a transformation that returns an optional `Int` value.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let mapped: [Int?] = possibleNumbers.map &#123; str in Int(str) &#125;</span></div><div class="line">  <span class="comment">///     // [1, 2, nil, nil, 5]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let flatMapped: [Int] = possibleNumbers.flatMap &#123; str in Int(str) &#125;</span></div><div class="line">  <span class="comment">///     // [1, 2, 5]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Parameter transform: A closure that accepts an element of this</span></div><div class="line">  <span class="comment">///   sequence as its argument and returns an optional value.</span></div><div class="line">  <span class="comment">/// - Returns: An array of the non-`nil` results of calling `transform`</span></div><div class="line">  <span class="comment">///   with each element of the sequence.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Complexity: O(*m* + *n*), where *m* is the length of this sequence</span></div><div class="line">  <span class="comment">///   and *n* is the length of the result.</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></div><div class="line">    <span class="number">_</span> transform: <span class="params">($&#123;GElement&#125;)</span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</div><div class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</div><div class="line">    <span class="keyword">var</span> result: [<span class="type">ElementOfResult</span>] = []</div><div class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</div><div class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newElement = <span class="keyword">try</span> transform(element) &#123;</div><div class="line">        result.append(newElement)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中可以看出打平的原理是将集合中所有元素都添加到另外一个集合里。在第二个 extension 里通过 if let 语句会挡住那些解包不成功的元素。</p>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>Reduce 是编程语言语义学里的归约语义学，也叫累加器。下面同样可以看看 Swift 源码里对其的实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><span class="comment">// reduce()</span></div><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">  <span class="comment">/// Returns the result of combining the elements of the sequence using the</span></div><div class="line">  <span class="comment">/// given closure.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// Use the `reduce(_:_:)` method to produce a single value from the elements</span></div><div class="line">  <span class="comment">/// of an entire sequence. For example, you can use this method on an array</span></div><div class="line">  <span class="comment">/// of numbers to find their sum or product.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// The `nextPartialResult` closure is called sequentially with an</span></div><div class="line">  <span class="comment">/// accumulating value initialized to `initialResult` and each element of</span></div><div class="line">  <span class="comment">/// the sequence. This example shows how to find the sum of an array of</span></div><div class="line">  <span class="comment">/// numbers.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let numbers = [1, 2, 3, 4]</span></div><div class="line">  <span class="comment">///     let numberSum = numbers.reduce(0, &#123; x, y in</span></div><div class="line">  <span class="comment">///         x + y</span></div><div class="line">  <span class="comment">///     &#125;)</span></div><div class="line">  <span class="comment">///     // numberSum == 10</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// When `numbers.reduce(_:_:)` is called, the following steps occur:</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// 1. The `nextPartialResult` closure is called with `initialResult`---`0`</span></div><div class="line">  <span class="comment">///    in this case---and the first element of `numbers`, returning the sum:</span></div><div class="line">  <span class="comment">///    `1`.</span></div><div class="line">  <span class="comment">/// 2. The closure is called again repeatedly with the previous call's return</span></div><div class="line">  <span class="comment">///    value and each element of the sequence.</span></div><div class="line">  <span class="comment">/// 3. When the sequence is exhausted, the last value returned from the</span></div><div class="line">  <span class="comment">///    closure is returned to the caller.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// If the sequence has no elements, `nextPartialResult` is never executed</span></div><div class="line">  <span class="comment">/// and `initialResult` is the result of the call to `reduce(_:_:)`.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Parameters:</span></div><div class="line">  <span class="comment">///   - initialResult: The value to use as the initial accumulating value.</span></div><div class="line">  <span class="comment">///     `initialResult` is passed to `nextPartialResult` the first time the</span></div><div class="line">  <span class="comment">///     closure is executed.</span></div><div class="line">  <span class="comment">///   - nextPartialResult: A closure that combines an accumulating value and</span></div><div class="line">  <span class="comment">///     an element of the sequence into a new accumulating value, to be used</span></div><div class="line">  <span class="comment">///     in the next call of the `nextPartialResult` closure or returned to</span></div><div class="line">  <span class="comment">///     the caller.</span></div><div class="line">  <span class="comment">/// - Returns: The final accumulated value. If the sequence has no elements,</span></div><div class="line">  <span class="comment">///   the result is `initialResult`.</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(</span></span></div><div class="line">    <span class="number">_</span> initialResult: Result,</div><div class="line">    <span class="number">_</span> nextPartialResult:</div><div class="line">      <span class="params">(<span class="number">_</span> partialResult: Result, $&#123;GElement&#125;)</span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span></div><div class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span> &#123;</div><div class="line">    <span class="keyword">var</span> accumulator = initialResult</div><div class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</div><div class="line">      accumulator = <span class="keyword">try</span> nextPartialResult(accumulator, element)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> accumulator</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到里面会通过 initialResult 来记录前面的返回结果和当前元素进行在闭包里的操作。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>看看数组的基本用法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建数组</span></div><div class="line"><span class="keyword">var</span> nums = [<span class="type">Int</span>]() <span class="comment">//创建空数组</span></div><div class="line"><span class="keyword">var</span> mArray = nums + [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] + [<span class="number">5</span>,<span class="number">9</span>]<span class="comment">//合并多个有相同类型元素数组的值</span></div><div class="line"><span class="keyword">var</span> animals: [<span class="type">String</span>] = [<span class="string">"dragon"</span>, <span class="string">"cat"</span>, <span class="string">"mice"</span>, <span class="string">"dog"</span>]</div><div class="line"></div><div class="line"><span class="comment">//添加数组</span></div><div class="line">animals.append(<span class="string">"bird"</span>)</div><div class="line">animals += [<span class="string">"ant"</span>]</div><div class="line"></div><div class="line"><span class="comment">//获取和改变数组</span></div><div class="line"><span class="keyword">var</span> firstItem = mArray[<span class="number">0</span>]</div><div class="line">animals[<span class="number">0</span>] = <span class="string">"red dragon"</span></div><div class="line">animals[<span class="number">2</span>...<span class="number">4</span>] = [<span class="string">"black dragon"</span>, <span class="string">"white dragon"</span>] <span class="comment">//使用下标改变多个元素</span></div><div class="line">animals.insert(<span class="string">"chinese dragon"</span>, at: <span class="number">0</span>) <span class="comment">//在索引值之前添加元素</span></div><div class="line"><span class="keyword">let</span> mapleSyrup = animals.remove(at: <span class="number">0</span>) <span class="comment">//移除数组中的一个元素</span></div><div class="line"><span class="keyword">let</span> apples = animals.removeLast() <span class="comment">//移除最后一个元素</span></div><div class="line"></div><div class="line"><span class="comment">////数组遍历</span></div><div class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals &#123;</div><div class="line">    <span class="built_in">print</span>(animal)</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (index, animal) <span class="keyword">in</span> animals.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"animal <span class="subst">\(String(index + <span class="number">1</span>)</span>): <span class="subst">\(animal)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> animal 1: red dragon</div><div class="line"> animal 2: cat</div><div class="line"> animal 3: black dragon</div><div class="line"> animal 4: white dragon</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<h2 id="弱引用的-Swift-数组"><a href="#弱引用的-Swift-数组" class="headerlink" title="弱引用的 Swift 数组"></a>弱引用的 Swift 数组</h2><p>Swift 里的数组默认会强引用里面的元素，但是有时候可能希望能够弱引用，那么就可以使用 NSPointerArray。它在初始化的时候可以决定是用弱引用方式还是强引用方式。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> strongArr = <span class="type">NSPointerArray</span>.strongObjects() <span class="comment">// 强引用</span></div><div class="line"><span class="keyword">let</span> weakArr = <span class="type">NSPointerArray</span>.weakObjects() <span class="comment">// Maintains weak references</span></div></pre></td></tr></table></figure></p>
<p>Dictionary 的要想用弱引用可以使用 NSMapTable，Set 对应的是 NSHashTable。</p>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>看看基本用法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建 Dictionary</span></div><div class="line"><span class="keyword">var</span> strs = [<span class="type">Int</span>: <span class="type">String</span>]()</div><div class="line"><span class="keyword">var</span> colors: [<span class="type">String</span>: <span class="type">String</span>] = [<span class="string">"red"</span>: <span class="string">"#e83f45"</span>, <span class="string">"yellow"</span>: <span class="string">"#ffe651"</span>]</div><div class="line">strs[<span class="number">16</span>] = <span class="string">"sixteen"</span></div><div class="line"></div><div class="line"><span class="comment">//updateValue 这个方法会返回更新前的值</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue = colors.updateValue(<span class="string">"#e83f47"</span>, forKey: <span class="string">"red"</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The old value for DUB was <span class="subst">\(oldValue)</span>."</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//遍历</span></div><div class="line"><span class="keyword">for</span> (color, value) <span class="keyword">in</span> colors &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(color)</span>: <span class="subst">\(value)</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//map</span></div><div class="line"><span class="keyword">let</span> newColorValues = colors.<span class="built_in">map</span> &#123; <span class="string">"hex:<span class="subst">\($<span class="number">0</span>.value)</span>"</span> &#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(newColorValues)</span>"</span>)</div><div class="line"></div><div class="line"><span class="comment">//mapValues 返回完整的新 Dictionary</span></div><div class="line"><span class="keyword">let</span> newColors = colors.mapValues &#123; <span class="string">"hex:<span class="subst">\($<span class="number">0</span>)</span>"</span> &#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(newColors)</span>"</span>)</div></pre></td></tr></table></figure></p>
<h1 id="协议式编程"><a href="#协议式编程" class="headerlink" title="协议式编程"></a>协议式编程</h1><p>Swift 被设计成单继承，如果希望是多继承就需要使用协议。协议还有个比较重要的作用就是通过 associatedtype 要求使用者遵守指定的泛型约束。</p>
<p>下面先看看传统编程的开发模式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dragon</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackDragon</span>: <span class="title">Dragon</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteDragon</span>: <span class="title">Dragon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">BlackDragon</span>().fire()</div><div class="line"><span class="type">WhiteDragon</span>().fire()</div></pre></td></tr></table></figure></p>
<p>这个例子可以看出 fire() 就是重复代码，那么首先想到的方法就是通过直接在基类里添加这个方法或者通过 extension 来对他们基类进行扩展：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dragon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时我们希望加个方法让 Dragon 能够 fly：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dragon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fly~~~"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样 BlackDragon 和 WhiteDragon 就都有这两个能力了，如果我们设计出一个新的龙 YellowDragon 或者更多 Dragon 都没有 fly 的能力，这时该如何。因为没法多继承，那么没法拆成两个基类，这样必然就会出现重复代码。但是有了协议这个问题就好解决了。具体实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DragonFire</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DragonFly</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DragonFire</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DragonFly</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fly~~~"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackDragon</span>: <span class="title">DragonFire</span>, <span class="title">DragonFly</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteDragon</span>: <span class="title">DragonFire</span>, <span class="title">DragonFly</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowDragon</span>: <span class="title">DragonFire</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurpleDragon</span>: <span class="title">DragonFire</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="type">BlackDragon</span>().fire()</div><div class="line"><span class="type">WhiteDragon</span>().fire()</div><div class="line"><span class="type">BlackDragon</span>().fly()</div><div class="line"><span class="type">YellowDragon</span>().fire()</div></pre></td></tr></table></figure></p>
<p>可以看到一来没有了重复代码，二来结构也清晰了很多而且更容易扩展，Dragon 的种类和能力的组合也更加方便和清晰。extension 使得协议有了实现默认方法的能力。</p>
<p>关于多继承 Swift 是采用 Trait 的方式，其它语言 C++ 是直接支持多继承的，方式是这个类会持有多个父类的实例。Java 的多继承只继承能做什么，怎么做还是要自己来。和 Trait 类似的解决方案是 Mixin，Ruby 就是用的这种元编程思想。</p>
<p>协议还可以继承，还可以通过 &amp; 来聚合，判断一个类是否遵循了一个协议可以使用 is 关键字。</p>
<p>当然协议还可以作为类型，比如一个数组泛型元素指定为一个协议，那么这个数组里的元素只要遵循这个协议就可以了。</p>
<h1 id="Swift-内存管理"><a href="#Swift-内存管理" class="headerlink" title="Swift 内存管理"></a>Swift 内存管理</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>在 Heap 上内存分配的时候需要锁定 Heap 上能够容纳存放对象的空闲块，主要是为了线程安全，我们需要对这些进行锁定和同步。</p>
<p>Heap 是完全二叉树，即除最底层节点外都是填满的，最底层节点填充是从左到右。Swift 的 Heap 是通过双向链表实现。由于 Heap 是可以 retain 和 release 所以很容易分配空间就不连续了。采用链表的目的是希望能够将内存块连起来，在 release 时通过调整链表指针来整合空间。</p>
<p>在 retain 时不可避免需要遍历 Heap，找到合适大小的内存块，能优化的也只是记录以前遍历的情况减少一些遍历。但是 Heap 是很大的，这样每次遍历还是很耗时，而且 release 为了能够整合空间还需要判断当前内存块的前一块和后面那块是否为空闲等，如果空闲还需要遍历链表查询，所以最终的解决方式是双向链表。只把空闲内存块用指针连起来形成链表，这样 retain 时可以减少遍历，效率理论上可以提高一倍，在 release 时将多余空间插入到 Heap 开始的位置和先前移到前面的空间进行整合。</p>
<p>即使效率高了但是还是比不过 Stack，所以苹果也将以前 OC 里的一些放在 Heap 里的类型改造成了值类型。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack 的结构很简单，push 和 pop 就完事了，内存上只需要维护 Stack 末端的指针即可。由于它的简单所以处理一些时效性不高，临时的事情是非常合适的，所以可以把 Stack 看成是一个交换临时数据的内存区域。在多线程上，由于 Stack 是线程独有的，所以也不需要考虑线程安全相关问题。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>Swift 也有内存对齐的概念<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragonFirePosition</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x:<span class="type">Int64</span> <span class="comment">//8 Bytes</span></div><div class="line">    <span class="keyword">var</span> y:<span class="type">Int32</span> <span class="comment">//4 Bytes</span></div><div class="line">    <span class="comment">//8 + 4</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragonHomePosition</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> y:<span class="type">Int32</span> <span class="comment">//4 Bytes + 对齐内存(4 Bytes)</span></div><div class="line">    <span class="keyword">var</span> x:<span class="type">Int64</span> <span class="comment">//8 Bytes</span></div><div class="line">    <span class="comment">//4 + 4 + 8</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> firePositionSize = <span class="type">MemoryLayout</span>&lt;<span class="type">DragonFirePosition</span>&gt;.size <span class="comment">//12</span></div><div class="line"><span class="keyword">let</span> homePositionSize = <span class="type">MemoryLayout</span>&lt;<span class="type">DragonHomePosition</span>&gt;.size <span class="comment">//16</span></div></pre></td></tr></table></figure></p>
<h2 id="Swift-派发机制"><a href="#Swift-派发机制" class="headerlink" title="Swift 派发机制"></a>Swift 派发机制</h2><p>派发目的是让 CPU 知道被调用的函数在哪里。Swift 语言是支持编译型语言的直接派发，函数表派发和消息机制派发三种派发方式的，下面分别对这三种派发方式说明下。</p>
<h3 id="直接派发"><a href="#直接派发" class="headerlink" title="直接派发"></a>直接派发</h3><p>C++ 默认使用的是直接派发，加上 virtual 修饰符可以改成函数表派发。直接派发是最快的，原因是调用指令会少，还可以通过编译器进行比如内联等方式的优化。缺点是由于缺少动态性而不支持继承。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragonFirePosition</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x:<span class="type">Int64</span></div><div class="line">    <span class="keyword">var</span> y:<span class="type">Int32</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">land</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">DragonWillFire</span><span class="params">(<span class="number">_</span> position:DragonFirePosition)</span></span> &#123;</div><div class="line">    position.land()</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> position = <span class="type">DragonFirePosition</span>(x: <span class="number">342</span>, y: <span class="number">213</span>)</div><div class="line"><span class="type">DragonWillFire</span>(position)</div></pre></td></tr></table></figure></p>
<p>编译 inline 后 DragonWillFire(DragonFirePosition(x: 342, y: 213)) 会直接跳到方法实现的地方，结果就变成 position.land()。</p>
<h3 id="函数表派发"><a href="#函数表派发" class="headerlink" title="函数表派发"></a>函数表派发</h3><p>Java 默认就是使用的函数表派发，通过 final 修饰符改成直接派发。函数表派发是有动态性的，在 Swift 里函数表叫 witness table，大部分语言叫 virtual table。一个类里会用数组来存储里面的函数指针，override 父类的函数会替代以前的函数，子类添加的函数会被加到这个数组里。举个例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">swim</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//normal eat</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyingFish</span>: <span class="title">Fish</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//flying fish eat</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器会给 Fish 类和 FlyingFish 类分别创建 witness table。在 Fish 的函数表里有 swim 和 eat 函数，在 FlyingFish 函数表里有父类 Fish 的 swim，覆盖了父类的 eat 和新增加的函数 fly。</p>
<p>一个函数被调用时会先去读取对象的函数表，再根据类的地址加上该的函数的偏移量得到函数地址，然后跳到那个地址上去。从编译后的字节码这方面来看就是两次读取一次跳转，比直接派发还是慢了些。</p>
<h3 id="消息机制派发"><a href="#消息机制派发" class="headerlink" title="消息机制派发"></a>消息机制派发</h3><p>这种机制是在运行时可以改变函数的行为，KVO 和 CoreData 都是这种机制的运用。OC 默认就是使用的消息机制派发，使用 C 来直接派发获取高性能。Swift 可以通过 dynamic 修饰来支持消息机制派发。</p>
<p>当一个消息被派发，运行时就会按照继承关系向上查找被调用的函数。但是这样效率不高，所以需要通过缓存来提高效率，这样查找性能就能和函数派发差不多了。</p>
<h3 id="具体派发"><a href="#具体派发" class="headerlink" title="具体派发"></a>具体派发</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>值类型都会采用直接派发。无论是 class 还是协议 的 extension 也都是直接派发。class 和协议是函数表派发。</p>
<h4 id="指定派发方式"><a href="#指定派发方式" class="headerlink" title="指定派发方式"></a>指定派发方式</h4><ul>
<li>final：让类里的函数使用直接派发，这样该函数将会没有动态性，运行时也没法取到这个函数。</li>
<li>dynamic：可以让类里的函数使用消息机制派发，可以让 extension 里的函数被 override。</li>
</ul>
<h4 id="派发优化"><a href="#派发优化" class="headerlink" title="派发优化"></a>派发优化</h4><p>Swift 会在这上面做优化，比如一个函数没有 override，Swift 就可能会使用直接派发的方式，所以如果属性绑定了 KVO 它的 getter 和 setter 方法可能会被优化成直接派发而导致 KVO 的失效，所以记得加上 dynamic 的修饰来保证有效。后面 Swift 应该会在这个优化上去做更多的处理。</p>
<h2 id="基本数据类型内存管理"><a href="#基本数据类型内存管理" class="headerlink" title="基本数据类型内存管理"></a>基本数据类型内存管理</h2><p>通过 MemoryLayout 来看看基本数据类型的内存是占用多大<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.size      <span class="comment">//8</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.size    <span class="comment">//2</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Bool</span>&gt;.size     <span class="comment">//1</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Float</span>&gt;.size    <span class="comment">//4</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.size   <span class="comment">//8</span></div></pre></td></tr></table></figure></p>
<h2 id="Struct-内存管理"><a href="#Struct-内存管理" class="headerlink" title="Struct 内存管理"></a>Struct 内存管理</h2><p>对于 Struct 在编译中就能够确定空间，也就不需要额外的空间给运行时用，运行过程调用时就是直接传地址。</p>
<p>下面我们再看看 Struct 的 MemoryLayout<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragonFirePosition</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x:<span class="type">Int64</span> <span class="comment">//8 Bytes</span></div><div class="line">    <span class="keyword">var</span> y:<span class="type">Int32</span> <span class="comment">//4 Bytes</span></div><div class="line">    <span class="comment">//8 + 4</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">land</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">DragonFirePosition</span>&gt;.size       <span class="comment">//12</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">DragonFirePosition</span>&gt;.alignment  <span class="comment">//8</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">DragonFirePosition</span>&gt;.<span class="built_in">stride</span>     <span class="comment">//16</span></div></pre></td></tr></table></figure></p>
<p>alignment 可以看出是按照 8 Bytes 来对齐的，所以这里 struct 是用到了字节对齐，实际占用大小通过 stride 可以看出就是 8 * 2 为16。</p>
<p>如果把 var x:Int64 改成可选类型会增加 4个 Bytes，不过就这个 case 来说实际大小还是16，这个也是因为内存对齐的原因。</p>
<h2 id="Class-内存管理"><a href="#Class-内存管理" class="headerlink" title="Class 内存管理"></a>Class 内存管理</h2><p>Class 本身是在 Stack 上分配的，在 Heap 上还需要保存 Class 的 Type 信息，这个 Type 信息里有函数表，在函数派发时就可以按照这个函数表进行派发了。继承的话子类只要在自己的 Type 信息里记录自己的信息即可。</p>
<h2 id="协议类型内存管理"><a href="#协议类型内存管理" class="headerlink" title="协议类型内存管理"></a>协议类型内存管理</h2><p>协议类型的内存模型是 Existential Container。先看下面例子<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DragonFire</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DragonFire</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YellowDragon</span>: <span class="title">DragonFire</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> eyes = <span class="string">"blue"</span></div><div class="line">    <span class="keyword">let</span> teeth = <span class="number">48</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> classSize = <span class="type">MemoryLayout</span>&lt;<span class="type">YellowDragon</span>&gt;.size  <span class="comment">//32</span></div><div class="line"><span class="keyword">let</span> protocolSize = <span class="type">MemoryLayout</span>&lt;<span class="type">DragonFire</span>&gt;.size <span class="comment">//40</span></div></pre></td></tr></table></figure></p>
<p>这个例子里看这个结构体即遵循了这个协议而且内容还比这个协议多，而协议的 size 还要大，这个是为啥呢？这个是由于 Existential Container 的前三个 word 是叫 Value buffer 用来存储 inline 的值。第四个 word 是 Value Witness Table，存储值的各种操作比如 allocate，copy，destruct 和 deallocate 等。第五个 word 是 Protocol Witness Table 是存储协议的函数。</p>
<h2 id="泛型的内存管理"><a href="#泛型的内存管理" class="headerlink" title="泛型的内存管理"></a>泛型的内存管理</h2><p>泛型采用的和 Existential Container 原理类似。Value Witness Table 和 Protocol Witness Table 会作为隐形的参数传递到泛型方法里。不过经过编译器的层层 inline 优化，最终类型都会被推导出来也就不再需要 Existential Container 这一套了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;写这篇文章主要是为了给组内要做的分享准备内容。这段时间几个项目都用到 Swift，在上次 GIAC 大会上就被问到为什么要用 Swift，正
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>GIAC 大会上分享的《Swift 将 Web 代码转成60帧满帧原生应用的方案及实践》的幻灯片</title>
    <link href="http://ming1016.github.io/2018/01/10/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/"/>
    <id>http://ming1016.github.io/2018/01/10/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/</id>
    <published>2018-01-10T07:31:54.000Z</published>
    <updated>2018-01-10T09:14:04.687Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/01.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/02.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/03.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/04.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/05.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/06.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/07.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/08.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/09.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/10.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/11.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/12.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/13.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/14.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/15.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/16.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/17.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/18.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/19.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/20.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/01.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/slides-of-g
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
  </entry>
  
  <entry>
    <title>花野</title>
    <link href="http://ming1016.github.io/2018/01/04/huaye/"/>
    <id>http://ming1016.github.io/2018/01/04/huaye/</id>
    <published>2018-01-04T11:27:32.000Z</published>
    <updated>2018-01-04T11:31:06.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/huaye/01.png" alt=""></p>
<p>早上七点半闹钟响起，我皱眉闭眼伸手去把床头柜上的闹钟关掉。昨晚睡前看电视剧看多了，我决定再眯一会，意识模糊的又呼呼过去，怎的刚才梦里那蛇又追过来了，眼看要一口要咬到我的大腿了，我居然给吓醒了，呼！算了，反正再睡又要被蛇咬，看看时间，呀，八点了，还有半个小时就要出门上班了，我赶紧起身双脚插上拖鞋双手抓住后面头发扎起辫子，挽起双手袖子赶着弄早点吃，来到厨房发现垃圾老公又忘带出去，都说处女座心细，我怎么瞧不出。</p>
<p>穿上我的小西装直奔到我们小区门口亿达房产售楼处。</p>
<p>“小琴，今儿又是掐着点到呢，真羡慕你们住的近的”我隔壁同事王潘凑过来说道。</p>
<p>“我三十三，你二十四，以后别叫我小琴小琴的了。”</p>
<p>“秦琴，对哦，都三十了快当大妈年纪了，结婚也有七年了吧，怎么还不生个娃啊，看着小区里这么多小青年的娃娃一个个都长的这么大了。虽然你看起来是普通了点，哦，该不会是您老公没兴趣跟你做那事吧。”</p>
<p>我随便应付了两句就开始坐下开始准备工作了。</p>
<p>是啊，结婚也十年了，我也确实是不够漂亮，但绝对不是王潘说的那样。说起来还是要怪我那不挣钱的老公，我怕孩子生下来养不起。</p>
<p>“你们小区房最大多少平的。”</p>
<p>这位客户身穿白色小西装修长身材乌黑长发正用左手摘下墨镜右手按着我的桌上问我话。我急忙从发呆状态中回过神来。</p>
<p>“哦，我们这最大的是大三居，两厅两卫，一百五十平的，你等等，我查查看看还有几套。”边说着我边在电脑上的亿达数据管理后台里检索着。</p>
<p>“这样，你看，一共一千七百五十万，这里有户型图你先看看，等会我再带你去看看房。这户型现在只有最后一套了。”我熟练的用手指着屏幕示意让她来看。当然不管是谁都说是最后一套这个是我们行业的标准行话。</p>
<p>“不用了，我先交定金定下吧。”</p>
<p>这位富婆麻利的交完定金就开着她的宾利车走了。我站在店门口叹了口气。</p>
<p>隔壁王潘走过来望了望外面又望了望我说：“这主子够爽快的，这么年轻就这么有钱，肯定是被哪个男的给包养了。”</p>
<p>“我只是觉得她挺漂亮的。”</p>
<p>话虽这么说，其实这样的客户确实少见，买房这事哪个主不是考虑考虑再考虑的。连我这么一个事不关己高高挂起的非八卦人士也对这富婆好奇起来。</p>
<p>几个月后，我带着疲惫的身躯和沙哑的嗓子迎着月光下班。路过小区的一处滑滑梯时忽然看见那富婆正在挣脱一名身材高大年轻男人，一时好奇，同时为了不引起富婆的注意，我悄悄坐到一旁长木椅上，假装跟其他妈妈一样拿起手机，看似陪着孩子在外面溜着玩。滑滑梯这块孩子太多特别是傍晚这个点。富婆和那男的之间的对话我听的也不是很清楚。这时微信朋友圈娜娜发了个题为“十四年后，同学的美国女儿和我的中国女儿有怎样的差异”的文章，这个标题党文章引起我的兴趣，我尽然读了进去。</p>
<p>“小琴，你在这里等谁呢？”</p>
<p>我一惊，看富婆正坐在我身旁仔细打量着我呢。</p>
<p>“哦，没等谁，坐着休息会，看看手机来着。”我勉强的笑了笑</p>
<p>“这次买房真是麻烦你了，帮着我跑前跑后的。”</p>
<p>“没什么，这个是我的工作嘛，应该的。”其实她这活比其他人轻松多了，其他人那问长问短的麻烦死了。</p>
<p>富婆名叫林月珍，丈夫是非常著名的索土唱片公司的大老板，这段时间里帮着她弄房子的事情，知道了她是因为和他丈夫闹矛盾才分居的，什么矛盾我没问她也没说。</p>
<p>此时我发现月珍一直看着我没有说话，嘴角带着一丝丝的笑意，好像看出了些什么似的，弄得我都有些心虚了，微微的低下了头。</p>
<p>“我知道，你看见我跟一个男的拉拉扯扯的才坐在这的吧。”月珍继续盯着我。</p>
<p>“我……”</p>
<p>“他不是我先生。”</p>
<p>“那他是？”</p>
<p>“你一定是在想这又是一个只有貌美和年轻的女子嫁给了一个事业有成的老男人，在家寂寞空虚没地位，于是出轨找年轻帅气男子求安慰的俗气故事吧。”</p>
<p>“没有，我没有这个意思。”我急忙摇手示意。</p>
<p>“如果我说事情就是这样的呢。”</p>
<p>“咦！真是这样！”</p>
<p>“看，你就是这样想的。”月珍转过头，眼光看着前方，一下子眼神变得忧郁起来，微风吹着她黑黑的长发飘落在长长的睫毛上，她伸手将头发撘到后面说道：“其实不是这样的。”</p>
<p>气氛沉寂下来，其实我很想知道为什么但是也没有去问，我不希望我看起来很八婆。</p>
<p>“对了，明天我家有个派对，记得来哦。”月珍突然转移了话题。</p>
<p>“恩，一定。”</p>
<p>次日。我如约来到她家。来了后我就后悔了，派对上我的衣服是最差，我那地摊上买的包包我真恨不得把它塞到墙缝中。通过观察我发现月珍的朋友差不多都是娱乐圈和房产圈的人，跟他们完全没有话题，聊了几句我就一个人躲到一旁吃点心去了。</p>
<p>“小琴，来，我给你介绍下，这位是你们亿达集团总裁蒋星的儿子蒋启泽先生。”月珍拍了下我的肩膀说道。</p>
<p>我放下手中的点心，下意识的双手在衣服上擦了擦，站了起来，抬起头看见蒋启泽穿着一身白色西装，打着黑色领带，高挑的鼻梁，白净清秀的脸，威严的双眼蕴藏着一点含蓄期待的着我。要不是月珍说他是亿达集团总裁的公子，我还以为他是哪个明星来着。</p>
<p>“这位是就是我刚才说的秦琴，你们先聊着，我去招呼下其他人。”月珍将我介绍完就离开了。</p>
<p>我跟蒋启泽相互打了招呼就一起坐了下来。坐在这么一个有钱，高个又帅气的男人旁边，想着他身边坐着一个这么普通的我，一股自卑感狂袭过来。</p>
<p>“我在这个小区售楼处上班，也算是你父亲集团的一名小卒子了。”我忙找了个话题。</p>
<p>“嗯，这个我知道了，林月珍先跟我说了，她还说你帮了她很多忙，叫我以后多关照下你。”他说着，眼神严肃，并没有看我。</p>
<p>也是，我有什么好看的。派对结束后，感觉好累，回到家中，老公已经睡着，我躺在床上闭上双眼，我只是个普通的售楼小姐，难道还期待着什么吗？而且我也是有老公的人了。</p>
<p>一周后，我来到售楼处，发现蒋启泽站在门口。</p>
<p>“秦琴，你今天迟到了，下次要注意了。”他突然冒出了这句。</p>
<p>“咦，你怎么到这来了。”</p>
<p>这时王潘跑了过来，把我往旁边一拉告诉我说蒋启泽现在要来接管我们售楼处。</p>
<p>“遵命，长官，下次我一定注意。”我半开玩笑着说到，也不知怎么的，我突然觉得心情好了很多，难道是因为他吗。</p>
<p>每当我从他座位经过时，总是感觉背后他在注视着我，不知道我这种自恋的信心是从哪来的。他作为领导是成功的，这几个月我们的业绩明显提升了，我觉得这跟他的身份和魅力是分不开，我们售楼处女性居多，别管老的年轻的，结婚没结婚的都很喜欢他，当然也包括了我。</p>
<p>“我发现你变漂亮了。蒋启泽挺不错吧。”在小区一亭子里月珍一脸坏笑的看着我。</p>
<p>“是你叫他来这的？”</p>
<p>“我可没有这么大能耐能请得动，他转到这来我也是大吃一惊呢。”月珍坏笑的越发明显了，她接着说道：“他放着亿达总部的事不做来到一个小小售楼处当个领班，我真好奇那天派对上你跟他聊了什么呢。”</p>
<p>我摇了摇头。他第一天来这上班，其他人都到了他却一直站在门口，是因为在等我。不，不，这怎么可能。</p>
<p>晚上，老公早早就躺在了床上，我爬到他上面，笑眯眯的问他：“你觉得我最近有什么变化吗？”</p>
<p>“没看出来。”</p>
<p>“太不关注我了，别人都说我漂亮了呢。”</p>
<p>“没觉得，不过看起来是比以前要更开心了，对我也比以前要好了，别人说出轨的女人就是这样的。”龙炎一本正经的说。</p>
<p>“是啊，谁叫你上次对我父母不好了。我现在找了个大帅哥来慰藉我受伤的心灵。不理你了”我一把将枕头打到他的头上，拉上被子背对着他睡下了。</p>
<p>龙炎也是淡定居然没有啃声。我心有不甘，又不想主动探究。</p>
<p>“上次是谁对谁不好了。”沉寂了半天龙炎终于说话了，可是上来就是这句。</p>
<p>“我知道我父亲有不对的地方，但是你看看你的态度，太不成熟了。”我回道。上次我父亲和他父亲因为意见不合出现了分歧，我父亲言语间轻视了龙炎的父亲，龙炎就让我父亲回去，后来连着几天都没有理我们。</p>
<p>“我就是不成熟，我知道你爸瞧不起我也瞧不起我家人。”感觉这事是戳中了龙炎的痛点，屋子里灯光已关但还是能看见他眼角亮着泪光。他性子很脆弱，家庭很普通，人很努力，结婚前看他雄性壮志的挺看好他的。可这些年来在他的音乐事业上一直也没有突破，感觉再这样下去也不是办法，只能我自己多努力了。想着每天我忙死忙活的想多挣些钱，忙得那么晚回家就看见他呼呼睡，心里就来气。</p>
<p>“不服气，你就努力让我爸瞧得起啊。”我这句话声音有点大了，龙炎可能看出我生气了，也没有再回我。其实现在想想当初要不是我看上了他，像他这样的性格估计现在都还找不到女朋友。</p>
<p>因为昨晚被龙炎气的，上班都没有好心情，这就是所谓的家庭的牵绊吧，成家后就没法活的洒脱了。除非找对了人。到了公司发现蒋启泽还没有来，一般他都是很早到的，我爱睡懒觉总是来得晚。</p>
<p>“你这失魂落魄的是怎么了？”这是王潘例行每天都要凑过来点评下我一天开始的状态。</p>
<p>“没什么，家里琐碎事。”</p>
<p>“你们家那个大音乐家又让你生气了？”八卦女就是八卦女，一猜就准。</p>
<p>“我怎么感觉不是呢。”王潘把我无精打采的头往她那面一扭，说道：“我看你一直盯着蒋总那边看，是不是奇怪为啥他今儿没来。”</p>
<p>“对，他为什么今天没来。”我突然来劲了。</p>
<p>“就说嘛，我看这段时间你的心早就不在大音乐家那了。整天偷看蒋总。”</p>
<p>“去！”我把王潘往旁边一推。</p>
<p>“下面的消息可能会让你失望了，听说蒋总回去了，能不能回来还不一定呢。回去干嘛我可不知道，你不要问我。”王潘一边挥着手一边离开去干活了。</p>
<p>是谁让蒋启泽回去的，他爸？哎，比起我们这个小小的分部他们的事那不知道要重要多少倍。现在我都还不清楚为什么他要到我们这里做领班。可能是他爸想让他历练历练，看他做的不错又叫他回去了？</p>
<p>接下来的日子就不好受了，每天看到蒋启泽空空的位置就会觉得心也空空的。这样的心情发生在我这样一个少妇的身上也真够呛的。我又不是少女了怎么还会有这样的感觉。想想我少女时也没有过这种感觉，可能没有遇到蒋启泽这样的人吧。</p>
<p>过了一个月，还没有蒋启泽的消息，我开始紧张了，想着可能他是不是不会回来了，我只想能够每天看下他就好，也没有什么其它的奢望。他在时的感觉真是很好，他的为人处世稳重而又不失活泼，魅力四射，感染着团队每个人，真的很希望他能够再回来。我是不是有些自私了。</p>
<p>“你们那情况怎么样？”我收到到蒋启泽的一条手机消息。</p>
<p>“还行，不过完成这个月销售额还是有风险。”</p>
<p>“我下周二回来，一起努力完成这个月任务吧。”</p>
<p>“嗯，好的。”</p>
<p>“挺想能够快些回来。”</p>
<p>“我们也很想你，快些回来吧。”发完这条消息，我开心的从沙发上蹦了起来，手拿靠枕左右摇摆扭着屁股。</p>
<p>砰，门开了，龙炎一脸阴沉走进家门。</p>
<p>“今天工作怎样？”我努力想用我好的心情去感染下龙炎，于是热情开心的对他说。</p>
<p>“工作丢了。”</p>
<p>我的脸一下拉了下来，心想肯定是他那又坏又倔的脾气惹老板生气了。</p>
<p>“这次又是什么原因？”我严厉的问他。</p>
<p>“他不让我弹我自己的曲子，说难听。”</p>
<p>“那你就弹他们喜欢的曲子呗，男子汉能屈能伸，我们家现在这个情况有什么不能够先放一放，先把这个家稳定了呀。你这样三天两头的换工作，日子怎么过，我还想要个小孩呢。你就不能为了我做些牺牲吗？每天关在工作室里，都这么晚回，这么多年没有事业也没有朋友，像这样什么时候才是头。”</p>
<p>“我就是这性格，改不了了。”</p>
<p>本来刚好起来的心情全给毁掉了。</p>
<p>蒋启泽回到公司后可以看得出不止我一个人兴奋不已，就连王潘都凑上去将自己精心准备的礼物送给他，看来他回来之前是跟每个人都说了一个遍。过了一段时间，蒋启泽要带他夫人和孩子去度假，不过这次我看着他那空空的位置一点都没有担心的感觉，因为这次终究是能回来的。</p>
<p>年终时公司年会上，有个合影环节，蒋启泽主动过来要求跟我合影，合影时他紧紧的靠着我，我脑海中浮现出一个微博上看到的那种女粉丝和男影星合影的画面。年会时的一些其它环节蒋启泽也是全程陪着我，我们一起玩了抓娃娃，夹玻璃球，跳舞毯等等一些娱乐项目。</p>
<p>春天到了，又到了大家一起拓展的时候，大巴上小船长拓展公司的培训师们就开始陪着我们玩游戏了。来到目的地，这次拓展的地方选择是一处四面环山，北面山壁下还有条浅河，分完房间放好行李，大伙来到一个广场开始了分队。一共三队，我们组自个起了个很霸气的名字镶黄旗，教官分旗子时我们领的是黄旗，因为最大的头蒋启泽在我们这队，而镶黄旗是满族由皇帝亲自来统领的上上旗。接着蒋启泽还在黄旗四周涂上红色颜料，中间画上了一条黑龙让使看起来更像镶黄旗。</p>
<p>在做第一个拓展时我们三个队就开始较劲了，感觉大家那股子劲一下子就调动了起来，连我也有了些集体存亡感，只可惜这第一个项目猜图考的是记忆和知识，我这平时就只喜欢备着面巾纸看肥皂剧的主，智力和知识含量皆缺对这个项目也只能是有心而无力了。</p>
<p>午饭后在房间休息到三点，开始了我们期待的水上竞技项目。这个项目就跟电视上的那个一样，我想着这下可以好好看看大家怎么掉下水出丑了，当然理想总是丰满性感的，现实却是跟我一样骨感。</p>
<p>比完水上竞技后，我发现河边有一排竹筏，于是取掉挂岸绳一脚踏了上去，坐在船尾竹椅上拿起竹竿准备撑杆起舵。这时竹筏突然左侧一斜，水浪往上一溅。我抬头看见蒋启泽正双手平伸努力着掌握平衡。</p>
<p>“嗨，这竹筏可真够不稳的。”他说。待竹筏平稳后，他继续说道：“你这一身湿的，怎么也不跟他们一起回房间换身衣服。”</p>
<p>“你不也是。”</p>
<p>“我哪，我不是看你要玩这竹筏就来陪陪你。”说着，他将包里带的浴巾取出走到我身边将它披在了我的身上。</p>
<p>“你真细心，还想着带这个。”</p>
<p>“习惯了。不过你今天够呛的，别人最多掉水个一两次吧，看你爬几步就要掉一次。我都不忍心看下去了。”</p>
<p>他一副怜悯的眼色看着我，我也无所谓了，反正从小我就缺乏体育细胞。</p>
<p>“还好有你，三分钟就到了终点，教官都说其它公司也很少有人能够达到这个成绩，猜图六个来回就全中了，我们这组的这两个第一你是头功，不愧是队长。不像我，估计是日本肥皂剧看多了，越看越笨。”</p>
<p>“看美剧是练脑子，看韩剧是意淫，看国产剧就想着千万千万可不要结婚啊，否则以后的婆婆分分钟整死你。”</p>
<p>“哈哈。”我忍不住捂着嘴巴笑起来。“那日剧呢？”</p>
<p>“日剧……看日剧会觉得生活美好。所以秦琴你肯定是个纯真善良的好姑娘。”</p>
<p>“还纯真，还姑娘呢，我结婚都7年了。”明明听着挺开心的。</p>
<p>“我也结婚了，不也有人说我像小伙子嘛。”</p>
<p>“你本来就像个小伙子，一个乳臭未干的小伙子。”</p>
<p>“好哇，这样说你上司，看我怎么收拾你。”他坏笑着使脚用力一跺。</p>
<p>这突然的失衡，我一下子掉到水中，他也跟着跳到水中，水不深只到我腰间，蒋启泽一手扶着我的肩，一手在我头发和脸上擦着，我双眼一直看着他的眼睛。</p>
<p>害羞内敛，若即若离，水中，冷静的双眼，欲拒还迎的诱惑，被湿身的身体，等待着咬下禁忌的果实……我伸出手抱住了他，仰头闭上了双眼。</p>
<p>他推开了我，连同着我的心也被他用力地推得远远的。</p>
<p>我爬上竹筏撑杆滑向岸，夕阳逆光下的湖面映射出我无地自容的脸，是我太飘飘然了，没法保证自己不会出轨，不管是精神上的还是身体上的，小说亦或电视剧中可歌可泣的爱情故事当然存在，只是对于我这样普通又敏感的人，身体里爱情欲望的火苗一旦被强烈的异性荷尔蒙点燃，就会燃烧出巨大的火焰。</p>
<p>晚上烧烤时，我坐在位置上发呆，想将自己的行为抹去，厌恶着自己。</p>
<p>“来，吃点我烤的鸡翅，烤的人太多了，好不容易抢了个位置烤。”王潘一手拿着一根一手将一盘鸡翅放在了桌上，贴近我的耳朵悄悄的说：“我看见了哦。”</p>
<p>“看见什么了。”我斜眼看了她一眼。</p>
<p>“别装了，划竹筏那会。”</p>
<p>“那又怎么了。”</p>
<p>“唉，我说你啊，缺少女性魅力，我可是说真的，你就不能打扮打扮，穿得时尚些。这些男人不管结婚的没结婚的都喜欢有魅力有味道的女人，总想着征服想要的女人，你一定要明白，这样才能让男人有欲望。不过，你就是长得太一般般了。”</p>
<p>“喂！”</p>
<p>王潘说完又拿着一个空盘子去烧烤了。虽然她这样说还是很难过，但是能让我松了口气，愚蠢难堪的我让他讨厌了，这样就不用再有期待了。</p>
<p>这段时间蒋启泽和我的亲近让我忘乎所以，仔细想想他对每位同事都很好，对我有时候会特别点可能是因为我一直以来我的业绩比其他人要好点吧，所谓上司对下属的感情投资无非就是这样。我还傻傻的期待着那些成人童话的情节，我好蠢。</p>
<p>拓展第二天是要进行上山寻宝游戏，其实就是比看哪个队能够先到山顶。由于要求是全队成员都到达才算赢，所以沿路的风景谁都无暇顾及，生怕自己会拖全队的后腿。</p>
<p>昨晚没有睡好，平时也没有锻炼，山路走了一半不到就已经气喘吁吁，满脸汗滴，低头迈着蹒跚的步子渐渐落到队伍的最后，我几乎打算放弃了，想要坐在路边石头上休息。</p>
<p>前面一只手向我伸来，抬头刺眼的阳光下逆光着他高大的黑影。我抓住他，他巨大的手紧紧的握着我。</p>
<p>他是出于队长的责任还是昨日的愧疚都不再重要，看着他手臂上的汗水和他宽大的背影，我只想和他能够多呆一会。</p>
<p>来到山顶的一颗大树下，他用手拂过我的头发，轻轻拭去我未干的汗水：“你知道我为什么会调到这里来的吗？”</p>
<p>“不知道。”我装作疑惑的表情。</p>
<p>“你知道。”他说。树荫阳光交辉晒在他英俊帅气的脸上，他温柔地看着我说：“还不是因为你。”</p>
<p>“我，这么平凡，为什么？”</p>
<p>“第一次看到你就觉得你很亲切，那么朴素，和我身边那些人完全不一样。”</p>
<p>我脸唰的一下子就红了起来，和昨晚的心情对比如同过山车一样。说：“看来你这富家公子山珍海味吃多了，有时也想换换我这样粗俗大妈类型的口味。”</p>
<p>“我也不知道为什么，每次看到你时我都觉得你需要我，体内充满了无限的力量，让我有想做更好自己的欲望。”</p>
<p>“那你的夫人不需要你吗？”</p>
<p>“你不要提她，可以吗？”他伸手捂住了我的嘴，然后慢慢放下。</p>
<p>他为难的看着我，低下了头说道：“我很迷茫，我对这样的关系一直都很害怕。”</p>
<p>燃烧的火焰，不实际的妄恋，待我回过神来时已进退两难，葬身火海，我不想去伤害谁，也不愿背叛任何人，可能你会觉得那不是爱，只是冲动的欲望。</p>
<p>“不过。”他转向我，双手握住我的肩，说：“我已经无法回头。”</p>
<p>弯腰抱住我，湿润的唇舌交融一起。说实话，我想和他一直这样，明明我还没有做好与伦理道德为敌的准备。他是有妇之夫，我是有夫之妇，我知道我们不能这样亲密，绝对不行，此时我脑海里没有出现我老公。一想到我的心不再如平静般的湖水，就会感到无比难受。但是，即便如此，我也还是……一下下就好，想被他拥抱，我就知足，不希望更多，我一直是这样的想着，但是，在他怀中时，我也紧紧的抱住了他，想要更多，在我心里还有一个我。我知道是我依恋，除非是这火焰燃烧尽，不然我没法死心，对这过眼云烟的恋情，对温柔体贴的他死心。</p>
<p>余光中我仿佛看到远处有人在看着我们，我不禁探头望去。</p>
<p>“怎么了？”他问。</p>
<p>“我感觉有人在那边看。”</p>
<p>蒋启泽也往那边看了看，说道：“看你紧张的，做贼心虚吧。”</p>
<p>“你不也是。”我说。</p>
<p>是啊，其他人怎么看我们，恋人，还是夫妻，不，都不是，我们这样的关系存在对于他们都是不可原谅的。不过，我现在很幸福，前所未有的幸福。</p>
<p>下山路上，太阳盘旋在山脊上面，阳光照耀在山间密树林的枝叶上，野鸟的鸣叫，小溪潺潺声，前面拐角处蒋启泽跟队友们拿着我们的镶黄旗在等着我，他微笑就像清凉的微风将我汗水和疲劳吹去，我跑向队伍，跑向他。</p>
<p>拓展结束后回到售楼处，龙炎在那里等着我回家，我将蒋启泽和我老公互相做了介绍就回了家。</p>
<p>自那以后，无论是工作中还是在家里，他一直在我脑海里，期待着每天上班能和他见面，幻想里，我能够在旁人面前对他撒娇，戏弄他，欺负他，无拘无束开心的让人无法相信。有了这些感觉，才会有更好的心情，用更好的微笑面对自己的老公。这就是所谓的因自知理亏而对丈夫和家会更好吧。</p>
<p>这天，我又迟到，不过蒋启泽没在门口，平日只要是我迟到他必定会站着等我来。我将包放到桌上，往他的办公室望去，发现里面有一个陌生男子。过了一会那陌生男子召集我们大家开了会，这才得知蒋启泽调回了总部。手一软笔直接掉到本子上。</p>
<p>我们说到底就是偷情，如果被家人和周围的人知道了，这辈子就晚了，如今他知道要回头，那他还是幸福的。偷情是一种背叛家人伤害周围的人异于通常的肮脏淫乱的欲望，涉足后就无法找到出口，也没有返回的可能，它是能够摧毁所有禁忌之果，它与我终究无缘。</p>
<p>回到家里，坦白说我不想做饭，是因为他？是，只是想到以后见不到面就让我没法动弹，他温柔的声音还在我的耳边萦绕。感觉自己就要被燃烧成灰烬，我最终没有能够成为被人唾弃的坏女人。</p>
<p>这时门铃响起，我打开门发现是林月珍，她依然还是那么光鲜夺人，穿着石色Heritage Trench风衣，手中挂着Jaune Vif色鳄鱼皮Be Dior手提包。</p>
<p>“我听蒋启泽说了，他可能不会再回来了。”</p>
<p>我招呼着她进来，默默的没有说话。</p>
<p>“看来是的了。你跟他那个了？”</p>
<p>我摇了摇头。</p>
<p>“那接吻了？”她问。</p>
<p>我点了点头。</p>
<p>“这个蒋启泽也是的，只是接个吻就跑了。”月珍看着我无神的双眼，用手揪了揪我的脸，说道：“你不要担心，他会这样做，说明他对你是认真的，不然他不会因为想得更远而害怕。他缺乏的是让你们一起面对的决心。”</p>
<p>“你还这么说，你的家庭不就是因为第三者才弄成这样的么，你还希望我充当这样的角色。”</p>
<p>“谁告诉你我跟丈夫分居是因为这个。”她一下子激动起来，过了一会，她又平静的说：“只是一个误会，现在我们好了，今天我也是来告诉你我马上要搬回我丈夫那了，儿子还等着他妈妈呢。”</p>
<p>“那太好了，恭喜你们的复合，不过就是可惜以后就很难再看到你这样有魅力的人妻了。”</p>
<p>月珍不好意思的轻推了我一下说：“还有，周末我们会去草原给一个新签约的很有前途的歌手做庆祝，你们家也一起去吧，我还有好多话想跟你聊呢。”</p>
<p>“好啊。”</p>
<p>我也有好多话想跟她说，也只能跟她说了。</p>
<p>晚上，龙炎回到家中，看桌上没有饭菜，他放下他背上的吉他包，自己走向厨房开始做吃的。</p>
<p>“你怎么不问我为什么没有做饭。”我说。</p>
<p>“我来做吧。”他说。</p>
<p>“你周末有空吗？”我问。</p>
<p>“没有，周末我还有个演出。”</p>
<p>“每次都这样，等会吃完了，龙炎你是又要去房间写歌吧，早上我还没醒你又要去你那工作室了吧。天天写，天天弹，天天唱，你是个机器吗？每次都说还在努力，努力了这么多年还是这样，你说你不行吧，对我也就这样，我到底为什么嫁给了你。”</p>
<p>我怎么会这样，将被抛弃后的急躁都发泄到了龙炎身上，但是为什么我觉得还有个人能够让我发泄真好，难道夫妻之间就是因此而存在的吗？</p>
<p>但是龙炎并没有反驳我什么，他总是这样，他只要他的音乐就够了，人在哪方面满足了，就会对其它方面不屑一顾。而我，就好像怨妇一样。</p>
<p>一个吻无论有多炙热，也终需归于平静。</p>
<p>这次来草原打算来清空下自己。</p>
<p>傍晚，一辆大巴停在我们篝火旁，车下来四五个人，走近，我仔细瞧见是龙炎和他们乐队的人。我拉着身边的月珍走了过去。</p>
<p>“龙炎，你怎么也来这了。”我说。</p>
<p>“哦。”龙炎看了眼我身旁的月珍，停顿了下，接着说：“我是来这里表演的。就是那晚我跟你说的那个演出。”</p>
<p>“这样啊。哦对了，我忘记做介绍了，这个是我老公，叫龙炎，一眼就能看出是做音乐的。”接着我神气的向龙炎指了指月珍，说：“这个就是我跟你提过的那位客户林月珍，怎么样，很漂亮吧。”</p>
<p>龙炎看向月珍，月珍却侧过脸去，面带为难。</p>
<p>“咦，看的好认真啊，是不是都有点后悔早结婚了。不过呢，你可不要乱想，人家白富美可是不会看上你的。”我说。</p>
<p>“小琴，龙炎不是那样的人。”月珍说。</p>
<p>“你又不了解他，怎么这么肯定。”我说。</p>
<p>“你们慢聊，我去工作了。”龙炎说完就去搬乐器了。</p>
<p>我和月珍坐在草地上看着龙炎他们在篝火对面忙着摆放，调着音，天色已黑。</p>
<p>“我从小就是很受欢迎的那种人。”月珍说道。她头仰起看着夜晚的星空继续说道：“我承认，美丽的女人在人生上会有很多优势，像我就得到了几乎所有女人都渴望得到的。但是太完美的生活，反而让我没有了食欲。每天起床睁开眼到晚上躺下闭上眼，我的生活不过是不断的重复前一天的事情而已，没有任何激情可言。三十多岁却已经像一百多，几乎能够看到下一个三十年后的自己。我们都是如此，不安时渴望安全感，安稳时却又想着浪迹天涯。一个女人厌倦了乏味而不愿放弃是因为已经习惯，但是习惯永远无法击败新鲜感带来的刺激。”</p>
<p>月珍看了看我说：“我也和你一样对一个已婚男子动心，但是却没有你那么幸运。他对我始终止步于普通朋友。他落魄野性和冷漠，就像一匹销魂的孤独草原狼，还有一副整个世界都欠了他的样子真是深得我心。结婚前我交过很多男朋友，觉得初恋般的第一口是比第二第三口好吃的，新鲜的比陈的好吃，热的比凉的好吃，但是却发现没吃过的才是最好吃的。”</p>
<p>“还有会对月珍你都不动心的男人，我还真想见见呢。”我说。</p>
<p>“哈哈。那人你天天都能见到”月珍笑着说。</p>
<p>我天天能见到的人…</p>
<p>“不会是？”当然我会想到龙炎。</p>
<p>“恩，是的。你知道吗？他签约我们唱片公司了，他的第一盘专辑一定会大卖，虽然他是因为我才被我爱人发掘到的，但是最终还是靠的他自己的才华才得到了这次机会。但是你放心，你老公从来没有对我的追求有过任何反应，我现在对他也已经死心了。”她说。</p>
<p>“蒋启泽也知道你跟龙炎的事情？”我问。</p>
<p>“对，我跟他说过，以前龙炎的表演他也看过。”</p>
<p>“什么时候说的。”</p>
<p>“一个月前吧。怎么了？”</p>
<p>一个月前，那不是在比上次拓展更早，之后他见过我和龙炎一起，当时我还介绍了他是我老公。难道他避开我是因为龙炎，都说第三者越是对涉足家庭另一方越了解负罪感就会越强烈，上次在山上他也不希望我问他老婆的事情就是最好的证明。我仿佛明白了蒋启泽离开的原因了。</p>
<p>表演开始了，自从我和龙炎结婚以来他的演出我一场也没有再看过。今儿坐在宽广的草地上听着他自己写的歌有种回到大学的感觉，他在台上还是和那时一样，一副所有事情都和自己无关却完全沉浸在自己音乐的表情。</p>
<p>那时就是这样一个总是若无旁人的男孩却在我自习时突然出现在门口把我叫了出去，说他每次见到我都会心跳不已。</p>
<p>随着表演的进行，我发现他的歌比以前更好听了，越来越专业和世俗了，他还是对生活妥协了。我好像看到了他的成长和付出的回报。</p>
<p>表演结束，龙炎走到我身边说：“本来准备回家跟你说这事的。”</p>
<p>他靠近我胸前，贴近我，双手将我抱住，闭上双眼，仿佛疲倦的斗士在我耳边说：“生个孩子吧，我想让他也玩音乐。”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/huaye/01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;早上七点半闹钟响起，我皱眉闭眼伸手去把床头柜上的闹钟关掉。昨晚睡前看电视剧看多了，我决定再眯一会，意识模糊的又呼呼过去，怎的刚才梦里那蛇又追过来了，眼看要一口要咬到我的大腿了，我
    
    </summary>
    
      <category term="My novel" scheme="http://ming1016.github.io/categories/My-novel/"/>
    
    
      <category term="Novel" scheme="http://ming1016.github.io/tags/Novel/"/>
    
  </entry>
  
  <entry>
    <title>白芈</title>
    <link href="http://ming1016.github.io/2018/01/04/baimi/"/>
    <id>http://ming1016.github.io/2018/01/04/baimi/</id>
    <published>2018-01-04T11:24:38.000Z</published>
    <updated>2018-01-04T11:30:55.499Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/baimi/01.png" alt=""></p>
<p>“你过线了！”我说。</p>
<p>“过了怎么了！”</p>
<p>“你这个猪，占这么大的位置！”</p>
<p>“你个猴，瘦不拉几的，要那么大位置干嘛！”</p>
<p>类似这样的对话几乎每天都会有，这天更是一发不可收拾。同桌余敏推了我一下，我耐不住心中的烦闷，接着就是一脚朝她肚子踢过去。她连同着椅子一起滑倒到侧对面一排桌子，结果，她哭了。</p>
<p>在办公室。</p>
<p>“西陵，你是男生，跟女生打架算什么本事。”老师说。</p>
<p>“她先推我的。”</p>
<p>“她说是你骂她猪，哪有这样侮辱同学的，待会去跟她道歉，听到没？”</p>
<p>“西陵，你在看什么，我问你话你听到没。”</p>
<p>我看着窗外，窗外树枝在风中吱吱的响着，我讨厌老师，讨厌她把我调到后面跟余敏同桌。窗外传来课间休息时的喧闹声，我往更远处的操场方向看去，看到了旗杆，还有旗杆下的大讲台，发现白芈站在大讲台边上。我立刻起身手扶窗檐伸颈望去。</p>
<p>“喂，你到底在看什么？”老师继续问。</p>
<p>“哦。”我转过身来，说：“我在看外面是不是下雨了。”</p>
<p>“这大晴天的下什么雨。算了，你走，先出去，以后要是我再听说你欺负余敏就叫你爸妈过来。”</p>
<p>老师低着头示意我出去。</p>
<p>放学了，我赶着去街机厅玩游戏，经过大讲台时，突然一个声音叫住了我。</p>
<p>“怎么样，不跟我同桌很没意思吧。”</p>
<p>我没有抬头，我知道是白芈，这声音我太熟悉了。我没有回答，低着头慢慢的走开了。</p>
<p>白芈是我跟余敏之前的同桌，因为白芈比较瘦小，我也很瘦，所以我们是坐在前几排离黑板很近。白芈她是四年级中途转学过来的，我应该算是这里她的第一个同桌了，一开始我们就很谈得来。我从小就是属于那种很不爱说话的人，但是和她总有讲不完的话，上课时也是小声偷偷的聊天。</p>
<p>有一次爸爸给我买了一个挂在胸前的黄色表，白芈特别喜欢，我就送给了她。但是，没多久，由于我们总是上课讲悄悄话，我就被调到了后排跟余敏同桌了。</p>
<p>没跟白芈同桌的日子我总觉得缺少什么，想念和她同桌的那段时间。可能是这个原因，于是把心中的压抑发泄到了余敏身上。</p>
<p>到了六年级，临近小学毕业了。一堂课上我困意十足，于是右手托着半个脸庞，蒙蒙半睁眼间，发现十一点钟方向的白芈正趴着桌上脸朝后看着我，这样一直看着我，我跟她对视了很久。下课后我跑到单杠那一个人开心的拉着引体向上，拉着拉着回想起来刚才的情景，心想会不会是梦，上课时我是睡着了吗？</p>
<p>“什么事情这么高兴呢？”哥们程亮问我。</p>
<p>“没什么！”我继续拉着我的引体向上。</p>
<p>“是跟你喜欢的女孩有关吧。”</p>
<p>“我没有喜欢的女孩。”我假装一脸不屑的说。</p>
<p>“我看一本书上说一个人三岁后就会有喜欢的异性了，经过研究证明了的，无不例外，不要骗我了，跟我说说是谁？”程亮坏笑着问我</p>
<p>“那你就是承认你三岁就有喜欢的人咯。”我反问。</p>
<p>“那当然，那会我就喜欢我们钢琴老师了，现在喜欢我们班长，快说说你的。”程亮倒是挺大方的。</p>
<p>“嗯…”我还是比较犹豫，总感觉这心里的小秘密说出来挺不好意思的，陈亮喜欢班长倒是不奇怪，我感觉班上怎么说都有一大半男生都会喜欢她，以前也跟班长同桌过，不过因为合不来用铅笔戳了她的手，后来被她老哥给揍了一顿。</p>
<p>“我跟她同桌过，我就说这么多。”我努力想避开这个问题。</p>
<p>“你同桌过那么多人，我怎么知道是谁。我都跟你说了我的，你还不愿意告诉我，没意思。”</p>
<p>程亮慢慢靠近我，一只手挡住我的耳朵悄悄跟我说：“我看今天白芈找你留联系方式和家庭地址时脸都是红的，你们俩不会有什么吧。”</p>
<p>“不是大家都留了吗？要不是你们在旁边乱起哄说什么让我写的详细点怕找不到那些话，她会脸红吗？”</p>
<p>“她可没有让我们留，她都是找的女生留的，就你一个男生，不然我们怎么会开这个玩笑，看来是她对你有意思哦。对了，她也跟你同桌过，我还记得那天她刚跟你同桌的那一天。你专门跑过来问我觉得白芈是不是很漂亮。我觉得我猜的没错。”</p>
<p>我无话可说，程亮居然还记得两年前的事，不过这两年我觉得我应该是喜欢白芈的，虽然我们都没有怎么说过话。</p>
<p>初中时，我和白芈读了不同的学校，但是每当我经过小学或者碰到和白芈一个学校的小学同学时都会想起和她同桌时的画面和那次对视的情景来。</p>
<p>在初中的生活中我加入了校足球队，业余生活慢慢充实起来，我的身体渐渐趋于细长型，脸部轮廓也越来越清晰，为校队争取到四强后，全校同学基本都认识了我，好几次我在马路边走时，对面一群女生叫着我的名字。</p>
<p>虽然平时的训练很辛苦，回到家基本就是倒头就睡那种，不过在冲凉和睡前的那一小会我还是会时不时的想起白芈。</p>
<p>一天中午比赛完后我来到教师后面的树林子里乘凉发现白芈跟现在和我同班的我们的小学同学林薇聊着什么，她看到我来了后匆匆跟林薇道别就离开了，一句话也没跟我说，好像刻意避开我一样。白芈走后，林薇一边哭一遍朝教室那边走去，见势我急忙上去问她：“发生什么事情了？”</p>
<p>“没什么，不关你的事，你不要管。”</p>
<p>我觉得奇怪又好奇，看到林薇哭的这么伤心，心想会不会是她喜欢的小学同学喜欢别人了，然后白芈过来告诉她了。但是这个又不大好意思在这个时候八卦，于是想转移话题，说：“白芈怎么过来了？”</p>
<p>林薇看我一直跟着她问这问那，擦着眼泪不耐烦的回答道：“来找你的行吧。”</p>
<p>“找我干嘛！”</p>
<p>“喜欢你不行啊。”说完转身跑开了。</p>
<p>其实这就是我想要听到的吧，但是心里明明知道林薇这样回答我是很明显的敷衍，想想要是真的来看我的话怎么看到我就走了，而且是一看到我就低头跑开，况且林薇哭是什么意思啊。但是即使是这么明显的敷衍的话，我却还希望是真的啊。</p>
<p>一天梦中，我梦见在我在书店门口碰见了白芈，她没有看见我，我们插肩而过。结果第二天我去书店时，在门口真的碰见了她，这画面跟梦里一模一样。</p>
<p>在后面的日子一共碰见过好几次，有时是在另外一个书店，有时是在路上，不过基本上都是我看到她，她好像都没看到我。说起来真的很神奇，我基本没有在外面碰到过除了白芈以外的同学，可是却能够看到她好几次，这究竟是缘，还是只因为我太关注她。</p>
<p>最后的一次碰面，也是我们初中以来唯一和最后一次交谈，虽然只有那么短短的一句话。</p>
<p>那天我在书店挑完书准备结账，这时正巧白芈也在那结账。</p>
<p>“白芈！你也在这买书？”我问道。</p>
<p>“是啊，我经常来这。”</p>
<p>接着就是一阵长长的沉默，她低着头，我也低着头，我总想说点什么，却总是欲言又止，眼睛不知道看何处。想想以前小学时我们欢快的聊天画面，现在的我们如同陌生人一般保持着距离。这时，她的右手臂碰到了我的左手臂，我本来就很紧张，这下更加紧张了，我没有挪开手，只希望她是不小心碰到的然后移开。可是她没有挪开，她会是和我有一样的有所顾及吗？我能明显感觉到她的颤抖，不过我根本没法去多想些什么，因为我的上身也在抖动着，一只腿突然也软了下来，我只得用我的右手臂搁在收账台上做支撑。白芈结完帐先离开了，我才慢慢的恢复过来。</p>
<p>再后来，我当了老师，一直没见过白芈。一开始总盼望能够再次见到她，后来渐渐的也就不再有想见的想法了，慢慢的把她藏在自己心里和自己融为了一体。</p>
<p>许多年过去了，我也做过很多其他事情，有过低落有过风光，但心里却渐渐平静起来。</p>
<p>这天我习惯性的来到一家书店找书看，在一栏打折书上发现一本封面是一个黄色的儿童表的书，这个表看起来跟以前我叔叔送我的那个表很像，于是我就随手翻起这本短篇小说集子的目录来，翻到次页，突然，我发现有篇名字叫做“西陵的表”，西陵， 这不是我的名字吗？接着我直接翻到那一页读了起来。里面写到：</p>
<p>“这年，我的父亲又换一份工作，我跟母亲随着他一起搬到那个厂子的附近。这次的房子更小了，父亲每天回到家都看起来很憔悴，母亲三天两头都会跟他吵，多半都是埋怨父亲的无能吧。</p>
<p>那时我刚读完小学三年级，即将来到一个陌生的学校面对陌生的同学，我从小就不爱说话，心里充满着对未知的恐惧。上学的第一天，我见到了我的同桌西陵，他是一个很乖很腼腆的男生，看到了他，我心里感觉踏实了很多，于是我总想着找他说话，开始时，西陵总是低着头简单的回复我几句，后来我发现每次其他同学带玩具到班上来时他都会凑过去看，于是我就问他喜欢什么动画片和玩具，他一谈起这些就像变了个人似的滔滔不绝，看着他说着某某角色怎样怎样厉害的兴奋的表情，我总觉得特别的羡慕。</p>
<p>西陵说他爸妈管的严，动画片不让他看，他就偷偷的看，然后他爸妈也不跟他买玩具。但是尽管这样，西陵从来都不抱怨他爸妈，他总是乖乖的，感觉就像只温顺的小猫，每次跟我讲话或对视时都是腼腆的低着头。</p>
<p>有天他带着一个黄色的表过来，我看那个表特别可爱，在上课时就伸手去拿那个表玩，西陵突然从颈子上取下表递给我说送给我了。这应该是我收到的第一个男生送的礼物了吧。</p>
<p>一次上课时我问西陵这个表的右侧那个按键是做什么用时，他接过手边对我解释边示范，这时被老师发现了，第二节课班主任就把他换到了后排。</p>
<p>西陵被换到后面去后，我经常在下课的时候听见他跟他的新同桌余敏对骂，我想他是怎么了，跟我同桌时那个害羞温顺的男孩怎么了。是因为我吗？会是因为跟我分开不开心还是觉得我害他被换到了后排心里有气，当然我是宁愿是前者了。</p>
<p>就在西陵跟余敏发生冲突被老师叫到办公室批评的那天，一放学我就早早跑出教室站在大讲台的边沿上等西陵，当西陵经过时，我很想确定他的想法，但是我不希望他是怪我，于是我就满怀希望的急忙上前问他是不是因为没有跟我同桌而觉得没有意思。问完，只见西陵一直低着头也没有看我一眼就这样走过去了。当时我的心立即由热转凉，看着他低着头离开的背影，有些筹措，心里特别后悔那次课上找他讲话。</p>
<p>正是夏日当头，中午时分总是令人困乏。下午的第一节是地理课，是我不喜欢的一门课，我毫无精神的趴在桌上将书立了起来正好挡住我的头。我习惯的朝五点钟方向看了去，只见西陵右手托着脸正看着我，他一脸疲乏，面无表情，他的眼睛一直看着我，我有点无从适从，却又表现的很平静，我想这是个机会我跟他道歉。于是我没有出声，用嘴型说出了对不起，但是西陵显然太困了，当我说完他已经趴在桌上睡了。</p>
<p>小学的生活就这样结束了。</p>
<p>初中因为西陵父亲的原因，他进入了我们那最好的初中，跟他一起进入那个初中还有另外一个小学同学林薇，也是我们的大美女班长，而我跟着大部分小学同学去了附近的一所初中。</p>
<p>初中后我就经常到他们学校找林薇，这个起因是林薇很喜欢以前一个小学同学程亮，程亮也很喜欢林薇，但是在不同学校后一旦有些不愉快就不是那么方便解决了，所以呢，小两口一闹矛盾程亮就找我让我帮着说说好话什么，林薇也是，如此以来我就是和事佬两头帮着说好话。他们俩毕竟当时还小，经不起风浪，以前还好，天天能够在一起，现在好了，难得碰面，而且一碰面就斗嘴。</p>
<p>说实在的，大部分时间他们都在生对方的闷气。</p>
<p>这天，程亮让我帮他传个话，说以后不跟林薇见面了，就算是分手吧。</p>
<p>我来到林薇那，说是有个非常重要的事情要告诉她，哪知道林薇早就猜到了，然后她问我他是不是喜欢其他女生，我当然说没有了，其实也是真没有。哪知道林薇哼哼了几声，说肯定是我和程亮好了，我听到这里当然生气了，想着这段时间为了他们的事情跑前跑后，虽然我是自愿帮这个忙的。</p>
<p>但是我帮他们一是为了朋友，同时也是有点小私心了。跟西陵不在一个学校后，我一直想多了解点他的情况，每次我都会以关心老同学的口气向林薇询问西陵的情况。</p>
<p>为了消除林薇的猜忌，我对她说我跟程亮只是好朋友，他也不是因为我才跟她分手的。林薇依旧不信，她说程亮说人懂事时就会有喜欢的人，不然就是不正常的，如果要让她相信我，除非我告诉她我现在喜欢谁。我当时有些尴尬，我不是很想把我的想法告诉她，但是如果不说的话，这个误会会越来越深，我只好跟她说了实话，说我每次跑到这其实是希望了解西陵现在的情况，希望能够在这看到西陵。</p>
<p>我刚说完这话。</p>
<p>西陵突然在林薇身后出现了。我当时一惊，害怕西陵听到刚才我说的话，急忙低下头，匆匆的跟林薇道了下别就跑掉了。</p>
<p>一路上，我的脸一阵一阵的发热，我也不知道西陵到底有没有听到我说的话。如果他听到了他会怎么想，这些我都不敢想。在看到他的那一瞬间，我发现他比小学时更高了，脸庞轮廓更加清晰了，更俊美了。真的像林薇说的，西陵刚到初中就被选入校队，每次的练习赛中，由于西陵的表现很出色，而且外形气质属于忧郁冷静型的，导致他特别受女生的欢迎，还有很多高中的女生也会跑来为他加油。</p>
<p>林薇和程亮分手后，我常常一个人来到西陵他们学校的操场边看西陵他们练习足球。有次我去看了会他们的练习，然后我就到他们学校附近一个书店买书。</p>
<p>刚买完书出门时，正好碰到西陵进门，我担心他会问起我为什么到他们学校这买书，我头也没抬就这样快速的走出了书店。</p>
<p>跟他擦肩而过的瞬间我的余光看到他的手臂和腿部的汗水，泥土和伤痕，脑海里浮现起他跟我们校队的那场比赛，浮现出西陵在那场比赛中不停的奔跑，长传出的漂亮弧线球，铲断，大力的射门，浮现出西陵训练时认真的模样，浮现出我们校队队员训练时懒散的模样。</p>
<p>后来我就经常的到他们学校附近的书店看书，这样我就能够经常碰见他了。日复一日的浸泡在书店中，渐渐的我对看书和写作的兴趣也越来越高，这就是为什么日后我把写作当作了我一辈子的事业来做的原因。</p>
<p>和他最后的一次碰面，我正在买书结账时，忽然旁边出现一个高大的身影，双手把手中的书放到桌上，双眼看着我，叫了我的名字。</p>
<p>我抬头看见是西陵，突然间的很想说很多话，可能是我太在乎他了，不知道他现在会不会还是跟小学时那样亲切，我只说我是经常来这里。西陵还是和小学时那样腼腆的笑了笑然后低下了头，一下子，我也不知道说些什么，只得也低下了头。</p>
<p>书店的老板正在清算我的书，时间虽然很短，但是对于我来说实在太漫长了，我有点窒息的感觉，一不小心我的手臂靠在了西陵的手臂上，我没有立刻挪开，但是精神的过度紧张让我的身子颤抖起来，这时我发现西陵的手臂也在抖动，难道他也紧张吗？我不由的往他那看过去，只见他满脸通红一直红到脖子上。</p>
<p>那以后，父亲所工作的厂子倒闭了，不得不又换到另外一个地方，就这样我离开了和西陵一起过的地方。</p>
<p>再大些了后，我和其他女人一样嫁了人，生了小孩。</p>
<p>但是，西陵送我的表我还一直挂在胸前，即使它已经失去了光泽，陈旧，没法显示时间，即使我已经变成了老女人，我依旧带着它。每当看到它或想到它在胸前，我都会回想起西陵，都会回想起小学中和西陵同桌的时光。</p>
<p>西陵！你知道吗，自从你送我这块表后，我都一直带着它，那时我就爱上了你，一直到现在，会到永远。”</p>
<p>看完，我心情无比复杂，本来已经平静的心开始骚动起来，泪水早已把书纸弄湿。</p>
<p>“你好，我叫白芈。你叫什么名字啊？”</p>
<p>“西陵。”</p>
<p>“西陵，我是刚转过来的。”</p>
<p>“刚才老师不是介绍过么。”</p>
<p>我偷偷看了她一眼，白芈很瘦，瓜子脸，高高鼻梁，清澈的眼睛。她发现我在看她，也笑着看着我，我不好意思的转过头，不过眼睛余光还能看到她还在继续看着我笑。</p>
<p>漫步在小学里，虽然教学楼都翻新了个遍，但是那个大讲台依旧留在那里，我站在当时白芈站的地方下面，白芈的身影渐渐出现，仿佛她一直在等着我回答她：“没能跟你同桌真的很没有意思”。</p>
<p>“白芈，我很想再跟你同桌，我很想。。。”我伸出手准备去牵她下来，但泪水已经滴滴嗒嗒不住的落在了手臂上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/baimi/01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;“你过线了！”我说。&lt;/p&gt;
&lt;p&gt;“过了怎么了！”&lt;/p&gt;
&lt;p&gt;“你这个猪，占这么大的位置！”&lt;/p&gt;
&lt;p&gt;“你个猴，瘦不拉几的，要那么大位置干嘛！”&lt;/p&gt;
&lt;p&gt;类似这
    
    </summary>
    
      <category term="My novel" scheme="http://ming1016.github.io/categories/My-novel/"/>
    
    
      <category term="Novel" scheme="http://ming1016.github.io/tags/Novel/"/>
    
  </entry>
  
  <entry>
    <title>在滴滴，我是如何指数级提升开发技术的？</title>
    <link href="http://ming1016.github.io/2017/10/24/how-do-i-improve-the-development/"/>
    <id>http://ming1016.github.io/2017/10/24/how-do-i-improve-the-development/</id>
    <published>2017-10-24T11:16:27.000Z</published>
    <updated>2017-10-24T11:19:08.784Z</updated>
    
    <content type="html"><![CDATA[<p>如何提升开发技术的方法很多，比如专注，刻苦，热情，兴趣等，不过我这里不会提这些，下面想说的是我觉得能够指数级提升的窍门和一些自己在求索路上的一些体会，也算是一个阶段性的总结吧。趁着今天是程序员节，给大家做个分享，希望对需要的同学有用。</p>
<h2 id="窍门一，将代码放到-GitHub-上"><a href="#窍门一，将代码放到-GitHub-上" class="headerlink" title="窍门一，将代码放到 GitHub 上"></a>窍门一，将代码放到 GitHub 上</h2><p>看到这个标题一般人的反应就是觉得自己的代码和那些高大上的开源库比起来相形见绌，有种拿不出手的感觉。但是要想提高技术，是提高自己的技术，只要和自己比就好了。将代码发出来不是献丑而是为了交流，交流就会获得信息，都说信息时代科技进步都是指数级，这个道理在这里也同样适用。</p>
<p>记得以前我特别喜欢 Google 做的 Google Reader，每天打开电脑第一件事器就是浏览下关注的那些 RSS Feeds，自己定制的信息流和 Google Reder 对信息的完整保留，体验上轻松的标记已读和全部已读，当时是再也找不出替代品了。在 Google 关闭这个服务后很长一段时间我都没有看过 RSS，转向使用 Twitter 和后来的微博来关注自己感兴趣的内容，比如国内的一些插画家，漫画家，游戏媒体，Cosplay 当然还有一些感兴趣的相关开发的人。</p>
<p>后来，我发现关注微博的人多了后，一些好的博客内容很容易被埋没在 timeline 中。这个时候我发现了 Reeder 这个 RSS 阅读器 APP，体验做得非常棒，不光是 UI 设计和交互，还有应用的流畅度，离线浏览等体验都是顶级的。我打算也弄一个学习下，就跟小学时喜欢七龙珠就模仿着画一样。实现基本几个功能后我就发到了 GitHub 上，结果碰到了好几个也喜欢 RSS 的开发者，他们看我在 README.md 里提到了后面计划做的事情，分别提了 PR 完成了那些功能，还有一个把界面翻天覆地的改了一通，还加了 icon 和启动图，最后还加上了两个主题选择，还修改了好几处代码不规范和不合理的地方，我 review 完就知此人设计和代码功底都很深，对这样一个艺术和程序完美结合的人佩服不已。</p>
<p>后来这个项目让我认识了不少的朋友，在他们提交的代码里我也学习到了很多。</p>
<h2 id="窍门二，选择优秀同事"><a href="#窍门二，选择优秀同事" class="headerlink" title="窍门二，选择优秀同事"></a>窍门二，选择优秀同事</h2><p>和优秀同事共事利于成长这是个显而易见的道理，但我为什么还要单拎出来说呢。因为这个点我体会非常深，也感觉是我技术提升的一个很大的节点。在这些优秀的同事里有位大家都很熟悉的孙源一直是我学习的榜样。记得在微博上第一次看到他分享的 RunLoop（视频地址：<a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XODgxODkzODI0.html</a> ） 就很有感触，讲得通俗易懂由浅入深，后面只要他有新的文章和新的技术分享不管是对外的还是公司内部的还有直播平台的我都一个一个看完了，其中有好几篇都看了好多遍。这个过程犹如海绵吸水，停不下来。</p>
<p>滴滴里还有好多高手，方方面面，除了对各个技术点有深入研究的人外，还有整体架构设计高手。安全，性能，数据，智能都有着很多非常专业和领域影响力的老师们，公司内会有很多技术讲座，涉及到各个领域，滴滴的大数据和人工智能在业界也是很有名的，内部也有着系列的讲座可以去学习，最近的系列课程我都有在追。每期的讲师都是这个领域最有权威的人。当然也少不了孙源的讲座，自热每次我也都听了。</p>
<h2 id="窍门三，主题分享"><a href="#窍门三，主题分享" class="headerlink" title="窍门三，主题分享"></a>窍门三，主题分享</h2><p>记得第一次技术分享是在组内做的一个白板分享，为了避免分享时跑题和讲不全，我在分享前专门把要分享的内容在 A4 纸上画了一遍。白板讲时拿着那张纸边看边讲，讲完后我发现在 A4 纸上画的这个过程最有价值了，在这个过程里我对整个相关内容会做一个总结，会考虑重点，铺垫等等因数，这个轮回下来在整理过程中我发现其实对知识点有了更深的记忆。</p>
<p>每次的分享其实都会考虑比较多的事情，首先是内容。谁都不愿意听到处都能够看到的东西，这样为了保证新鲜感，首先要根据自己的主题看看那些到处都能看到的东西是什么（这个过程其实比较痛苦需要查找大量资料），尽量避免那些大家耳熟能详的料，多分享些经过自己思考总结出来的理解，我觉得某个知识点只是搞懂了和实践成功了还是远远不够的，在搞懂的基础上去想为什么这样设计而不那样设计，通过自己的理解想通了那才是有意思的事情。这样就会迫使自己看大量的知识，自然而然也就学习到了大量的知识，是不是有种被推着往前进的感觉。</p>
<p>再就是要考虑准备的时间，如果时间长那么就可以专门准备一个 Demo 现场来演示，或者美化美化幻灯片之类。时间短的话只要力保内容有用就好了。上次 GMTC 大会前组织方极客帮专门邀请了左耳朵耗子来给我们这些讲师们分享如何做分享。他提到很重要的一点就是内容要有用，就是所谓的干货，为了不让分享枯燥那么使用讲故事的方式来吸引听众是最有效和最容易让人记住的。</p>
<p>分享当然还有一个很重要的好处就是和其他分享者还有听众交朋友，每次分享都会遇见很多人，新朋友老朋友，还有不同公司的人，能够了解到其它公司正在做什么，他们的成果和他们正在攻克的难题，了解现在流行的方案是什么。开阔了视野也就开阔了思路。</p>
<h2 id="窍门四，在定的时间节点里将涉及到的问题尽可能问到底"><a href="#窍门四，在定的时间节点里将涉及到的问题尽可能问到底" class="headerlink" title="窍门四，在定的时间节点里将涉及到的问题尽可能问到底"></a>窍门四，在定的时间节点里将涉及到的问题尽可能问到底</h2><p>大多数人都是有惰性的，那么什么样的窍门是能够适合所有人的呢。我觉得时间的节点设定非常关键。先说下什么是时间节点呢？比如某版本需求提测时间点，再比如某次分享的时间点。有了这个时间点，就可以在节点时间到达前将问题考究透，这段时间先不去关注其它东西，运气好的话时间充沛就能够考究的多些。每次节点完成都可以好好犒劳下自己，这样下次进入另一个周期时能够充满战斗力。</p>
<p>有一个我影响很深刻的工程大小瘦身的任务，这个也是有个时间节点。在这个任务下达之前，我们已经手动做过了一轮对无用资源的清理，剩下的只能依靠工具了。我几乎用遍了所有相关工具，当时有种孙悟空在东海龙宫试兵器的感觉，怎么都不顺手。又没有定海神针，那么只能自己造了。现有工具主要的问题是准确度不高，所以每次都需要手动核对下，这样每个版本来回几次，我们代码又这么多，这种工作量会让人吃不消的。但是任务又不能不完成，想着用户在外面急着打车需要安装滴滴时，程序包太大耽误下载时间又浪费流量该多不好。</p>
<p>这种检查核对工作重复枯燥又很耗时，工期又很紧，但是为了用户体验，我还是决定挑战下自己。我发现，提高准确度达到不需要人工检查是很有难度的，连 App Code 都没有做到。可人有急智，我发现通过模拟编译的过程，将代码整理成有效的结构进行分析和比对可以很容易自己控制各种检查规则。想完就撸起袖子加油干，几天后就做了出来。不过开始时没注意时间复杂度，导致速度慢得无法接受。于是一点一点地抠，把它们一个个转成空间复杂度后速度得到了质的飞跃。接下来几天，在实际工程代码检查过程中又解决了一些运行时写法的问题。为了提高体验我还做了一键清理，将无用的代码直接注释掉。这样在后面版本里节省了大量的人工检查时间。这次的“瘦身”过程也在今年的 GMTC 大会上做了分享，分享的 Slides 我放到了这里 <a href="https://pan.baidu.com/s/1skPAIID" target="_blank" rel="external">https://pan.baidu.com/s/1skPAIID</a> 。里面涉及的编译相关的技术，我也写了篇博客进行总结，地址：<a href="https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM" target="_blank" rel="external">https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM</a>。</p>
<p>再列个经历，当时在研究自动布局的过程中，我发现苹果基于自动布局抽象出一个 Stack View 来做布局，这种布局思路更加规范，更容易提高开发效率，但是却不支持低版本 iOS 系统。那时，我就在想能不能和 VFL 语言结合起来，这样开发起来岂不会效率更高？想了几天，觉得考虑的比较全面了，就差一个落地项目来推着自己完成它了，我就跟老大申请了在一个小版本对一个大需求涉及的页面和功能进行重构。当时就是想着是有了一个时间节点就能够推着自己走了，想做的事情也不会烂尾。</p>
<p>理想是丰满的，可现实却是骨感的——只有4天开发时间，前3天我才勉强完成库的开发，里面残缺不堪的，所以我只好把周末都搭上去了。周日下午，主要流程都完成后，我买了杯咖啡来到软件园湖边休息了半个小时。现在回想，这半个小时算是版本开发周期里除了睡觉外唯一的休息了。从开发到后面测试的那些天里，我都是每天6点到公司，晚上12点离开公司。最后，掐着点完成了功能版本的上线。</p>
<p>这个库我也是基于自动布局来包装的一个类似 Stack View 的库，能支持低版本，同时设计了一个简洁的界面描述语言，通过解析这个语言来对应生成界面，这样开发时只需要使用简单的语言描述即可。虽然这个开发的过程比较痛苦，但是完成后的喜悦感和成就感还是蛮大的不是么。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何提升开发技术的方法很多，比如专注，刻苦，热情，兴趣等，不过我这里不会提这些，下面想说的是我觉得能够指数级提升的窍门和一些自己在求索路上的一些体会，也算是一个阶段性的总结吧。趁着今天是程序员节，给大家做个分享，希望对需要的同学有用。&lt;/p&gt;
&lt;h2 id=&quot;窍门一，将代码
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Study" scheme="http://ming1016.github.io/tags/Study/"/>
    
  </entry>
  
  <entry>
    <title>HTML 转原生 HTN 项目开发记录</title>
    <link href="http://ming1016.github.io/2017/10/16/html-to-native-htn-development-record/"/>
    <id>http://ming1016.github.io/2017/10/16/html-to-native-htn-development-record/</id>
    <published>2017-10-16T07:49:00.000Z</published>
    <updated>2017-11-06T06:46:49.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是记录 HTN 项目开发的过程。关于这个项目先前在 Swift 开发者大会上我曾经演示过，不过当时项目结构不完善，不易扩展，也没有按照标准来。所以这段时间，我研究了下 W3C 的标准和 WebKit 的一些实现，对于这段时间的研究也写了篇文章<a href="http://www.starming.com/2017/10/11/deeply-analyse-webkit/" target="_blank" rel="external">深入剖析 WebKit</a>。重构了下这个项目，我可以先说下已经完成的部分，最后列下后面的规划。项目已经放到了 Github 上：<a href="https://github.com/ming1016/HTN" target="_blank" rel="external">https://github.com/ming1016/HTN</a> 后面可以对着代码看。</p>
<h2 id="项目使用介绍"><a href="#项目使用介绍" class="headerlink" title="项目使用介绍"></a>项目使用介绍</h2><p>通过解析 html 生成 DOM 树，解析 CSS，生成渲染树，计算布局，最终生成原生 Textrue 代码。下面代码可以看到完整的过程的各个方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> treeBuilder = <span class="type">HTMLTreeBuilder</span>(htmlStr) <span class="comment">//htmlStr 就是 需要转的 html 代码</span></div><div class="line"><span class="number">_</span> = treeBuilder.parse() <span class="comment">//解析 html 生成 DOM 树</span></div><div class="line"><span class="keyword">let</span> cssStyle = <span class="type">CSSParser</span>(treeBuilder.doc.allStyle()).parseSheet() <span class="comment">//解析 CSS</span></div><div class="line"><span class="keyword">let</span> document = <span class="type">StyleResolver</span>().resolver(treeBuilder.doc, styleSheet: cssStyle) <span class="comment">//生成渲染树</span></div><div class="line"></div><div class="line"><span class="comment">//转 Textrue</span></div><div class="line"><span class="keyword">let</span> layoutElement = <span class="type">LayoutElement</span>().createRenderer(doc: document) <span class="comment">//计算布局</span></div><div class="line"><span class="number">_</span> = <span class="type">HTMLToTexture</span>(nodeName:<span class="string">"Flexbox"</span>).converter(layoutElement); <span class="comment">//生成原生 Textrue 代码</span></div></pre></td></tr></table></figure></p>
<p>比如有下面的 html</p>
<p><img src="/uploads/html-to-native-htn-development-record/04.png" alt="04"></p>
<p>在浏览器里显示是这样</p>
<p><img src="/uploads/html-to-native-htn-development-record/06.png" alt="06"></p>
<p>通过 HTN 生成的原生代码</p>
<p><img src="/uploads/html-to-native-htn-development-record/05.png" alt="05"></p>
<p>在 iPhone X 模拟器的效果如下</p>
<p><img src="/uploads/html-to-native-htn-development-record/07.png" alt="07"></p>
<p>下面详细介绍下具体的实现关键点</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>这部分最关键的部分是在 HTML/HTMLTokenizer.swift 里。首先会根据 W3C 里的 Tokenization 的标准 <a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="external">https://dev.w3.org/html5/spec-preview/tokenization.html</a> 来定义一个状态的枚举，如下，可以目前完成这些状态的情况<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//枚举</span></div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">S</span>: <span class="title">HTNStateType</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">DataState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CharacterReferenceInDataState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">RCDATAState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CharacterReferenceInRCDATAState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">RAWTEXTState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">PLAINTEXTState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">TagOpenState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">EndTagOpenState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">TagNameState</span> <span class="comment">//half done</span></div><div class="line">        </div><div class="line">        <span class="keyword">case</span> <span class="type">RCDATALessThanSignState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">RCDATAEndTagOpenState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">RCDATAEndTagNameState</span></div><div class="line">        </div><div class="line">        <span class="keyword">case</span> <span class="type">RAWTEXTLessThanSignState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">RAWTEXTEndTagOpenState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">RAWTEXTEndTagNameState</span></div><div class="line">        </div><div class="line">        <span class="comment">//Script</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataLessThanSignState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEndTagOpenState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEndTagNameState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEscapeStartState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEscapeStartDashState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEscapedState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEscapedDashState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEscapedDashDashState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEscapedLessThanSignState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEscapedEndTagOpenState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataEscapedEndTagNameState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataDoubleEscapeStartState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataDoubleEscapedState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataDoubleEscapedDashState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataDoubleEscapedDashDashState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataDoubleEscapedLessThanSignState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ScriptDataDoubleEscapeEndState</span></div><div class="line">        </div><div class="line">        <span class="comment">//Tag</span></div><div class="line">        <span class="keyword">case</span> <span class="type">BeforeAttributeNameState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AttributeNameState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AfterAttributeNameState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">BeforeAttributeValueState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AttributeValueDoubleQuotedState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AttributeValueSingleQuotedState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AttributeValueUnquotedState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CharacterReferenceInAttributeValueState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AfterAttributeValueQuotedState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">SelfClosingStartTagState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">BogusCommentState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">ContinueBogusCommentState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">MarkupDeclarationOpenState</span> <span class="comment">//half done</span></div><div class="line">        </div><div class="line">        <span class="comment">//Comment</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CommentStartState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CommentStartDashState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CommentState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CommentEndDashState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CommentEndState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CommentEndBangState</span></div><div class="line">        </div><div class="line">        <span class="comment">//DOCTYPE</span></div><div class="line">        <span class="keyword">case</span> <span class="type">DOCTYPEState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">BeforeDOCTYPENameState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">DOCTYPENameState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AfterDOCTYPENameState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AfterDOCTYPEPublicKeywordState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">BeforeDOCTYPEPublicIdentifierState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">DOCTYPEPublicIdentifierDoubleQuotedState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">DOCTYPEPublicIdentifierSingleQuotedState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AfterDOCTYPEPublicIdentifierState</span> <span class="comment">//half done</span></div><div class="line">        <span class="keyword">case</span> <span class="type">BetweenDOCTYPEPublicAndSystemIdentifiersState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AfterDOCTYPESystemKeywordState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">BeforeDOCTYPESystemIdentifierState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">DOCTYPESystemIdentifierDoubleQuotedState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">DOCTYPESystemIdentifierSingleQuotedState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">AfterDOCTYPESystemIdentifierState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">BogusDOCTYPEState</span></div><div class="line">        </div><div class="line">        <span class="keyword">case</span> <span class="type">CDATASectionState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CDATASectionRightSquareBracketState</span></div><div class="line">        <span class="keyword">case</span> <span class="type">CDATASectionDoubleRightSquareBracketState</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>处理这些状态采用的是状态机原理。根据状态机数学模型提取出需要的状态集合，事件集合，事件集合在这里是所遇字符的集合做了一个状态机，具体实现在 HTNFundation/HTNStateMachine.swift。状态转移函数我定义的是 func listen(_ event: E, transit fromState: S, to toState: S, callback: @escaping (HTNTransition<s, e="">) -&gt; Void) ，这里的 block 是在状态转移时需要做的事情定义 。为了能够减少状态转移太多太碎，也多写了几个函数来处理比如一组来源状态到同一个转移状态和针对某些事件状态不变的函数。</s,></p>
<p>有了状态机后面的处理就会很方便，这里的事件就是一个一个的字符，不同字符在不同的状态下的处理。下面可以举个多状态转同一状态的实现，具体代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> anglebracketRightEventFromStatesArray = [<span class="type">S</span>.<span class="type">DOCTYPEState</span>,</div><div class="line">                                             <span class="type">S</span>.<span class="type">CommentEndState</span>,</div><div class="line">                                             <span class="type">S</span>.<span class="type">TagOpenState</span>,</div><div class="line">                                             <span class="type">S</span>.<span class="type">EndTagOpenState</span>,</div><div class="line">                                             <span class="type">S</span>.<span class="type">AfterAttributeValueQuotedState</span>,</div><div class="line">                                             <span class="type">S</span>.<span class="type">BeforeDOCTYPENameState</span>,</div><div class="line">                                             <span class="type">S</span>.<span class="type">AfterDOCTYPEPublicIdentifierState</span>]</div><div class="line">stateMachine.listen(<span class="type">E</span>.<span class="type">AngleBracketRight</span>, transit: anglebracketRightEventFromStatesArray, to: <span class="type">S</span>.<span class="type">DataState</span>) &#123; (t) <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> t.fromState == <span class="type">S</span>.<span class="type">TagOpenState</span> || t.fromState == <span class="type">S</span>.<span class="type">EndTagOpenState</span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>._bufferStr.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">self</span>._bufferToken.data = <span class="keyword">self</span>._bufferStr.lowercased()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.addHTMLToken()</div><div class="line">    <span class="keyword">self</span>.advanceIndexAndResetCurrentStr()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>W3C 也定义每个状态的处理，非常详细完整，WebKit 基本把这些定义都实现了，HTN 目前只实现了能够满足构建 DOM 树的部分。W3C 的定义可以举个 StartTags 的状态如下图<br><img src="/uploads/html-to-native-htn-development-record/01.png" alt="01"></p>
<p>在进入构建 DOM 树之前我们需要设计一些类和结构来记录我们的内容，这里采用了 WebKit 类似的类结构设计，下图是 WebKit 的 DOM 树相关的类设计图<br><img src="/uploads/html-to-native-htn-development-record/02.png" alt="02"></p>
<p>完成了这些状态处理，接下来就可以根据这些 HTMLToken 来组装我们的 DOM 树了。这部分的实现在 HTML/HTMLTreeBuilder.swift 里。构建 DOM 树同样使用了先前的写的状态机，只是这里的状态集和事件集不同而已，W3C 也定义一些状态可以用<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">S</span>: <span class="title">HTNStateType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">InitialModeState</span></div><div class="line">    <span class="keyword">case</span> <span class="type">BeforeHTMLState</span></div><div class="line">    <span class="keyword">case</span> <span class="type">BeforeHeadState</span></div><div class="line">    <span class="keyword">case</span> <span class="type">InHeadState</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AfterHeadState</span></div><div class="line">    <span class="keyword">case</span> <span class="type">InBodyState</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AfterBodyState</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AfterAfterBodyState</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从名字就能很方便的看出每个状态的意思。这里的事件集使用的是 HTMLToken 里的类型，根据不同类型来放置到合适的位置。树的父级子级是通过定义的一个堆栈来控制，具体构建实现可以看 func parse() -&gt; [HTMLToken] 这个函数。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>解析 CSS 需要先了解下 CSS 的 BNF，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ruleset</div><div class="line">  : selector [ &apos;,&apos; S* selector ]*</div><div class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</div><div class="line">  ;</div><div class="line">selector</div><div class="line">  : simple_selector [ combinator selector | S+ [ combinator selector ] ]</div><div class="line">  ;</div><div class="line">simple_selector</div><div class="line">  : element_name [ HASH | class | attrib | pseudo ]*</div><div class="line">  | [ HASH | class | attrib | pseudo ]+</div><div class="line">  ;</div><div class="line">class</div><div class="line">  : &apos;.&apos; IDENT</div><div class="line">  ;</div><div class="line">element_name</div><div class="line">  : IDENT | &apos;*&apos;</div><div class="line">  ;</div><div class="line">attrib</div><div class="line">  : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</div><div class="line">    [ IDENT | STRING ] S* ] &apos;]&apos;</div><div class="line">  ;</div><div class="line">pseudo</div><div class="line">  : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</div><div class="line">  ;</div></pre></td></tr></table></figure></p>
<p>根据 BNF 来确定状态集和事件集。下面是我定义的状态集和事件集<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">S</span>: <span class="title">HTNStateType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">UnknownState</span>     <span class="comment">//</span></div><div class="line">    <span class="keyword">case</span> <span class="type">SelectorState</span>    <span class="comment">// 比如 div p, #id</span></div><div class="line">    <span class="keyword">case</span> <span class="type">PropertyKeyState</span>   <span class="comment">// 属性的 key</span></div><div class="line">    <span class="keyword">case</span> <span class="type">PropertyValueState</span> <span class="comment">// 属性的 value</span></div><div class="line">    </div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span>以下后期支持，优先级2</span></div><div class="line">    <span class="keyword">case</span> <span class="type">PseudoClass</span>      <span class="comment">// :nth-child(2)</span></div><div class="line">    <span class="keyword">case</span> <span class="type">PseudoElement</span>    <span class="comment">// ::first-line</span></div><div class="line">    </div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span>以下后期支持，优先级3</span></div><div class="line">    <span class="keyword">case</span> <span class="type">PagePseudoClass</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AttributeExact</span>   <span class="comment">// E[attr]</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AttributeSet</span>     <span class="comment">// E[attr|="value"]</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AttributeHyphen</span>  <span class="comment">// E[attr~="value"]</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AttributeList</span>    <span class="comment">// E[attr*="value"]</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AttributeContain</span> <span class="comment">// E[attr^="value"]</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AttributeBegin</span>   <span class="comment">// E[attr$="value"]</span></div><div class="line">    <span class="keyword">case</span> <span class="type">AttributeEnd</span></div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span>@media 这类 @规则 ，后期支持，优先级4</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">E</span>: <span class="title">HTNEventType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">SpaceEvent</span>   <span class="comment">//空格</span></div><div class="line">    <span class="keyword">case</span> <span class="type">CommaEvent</span>   <span class="comment">// ,</span></div><div class="line">    <span class="keyword">case</span> <span class="type">DotEvent</span>     <span class="comment">// .</span></div><div class="line">    <span class="keyword">case</span> <span class="type">HashTagEvent</span> <span class="comment">// #</span></div><div class="line">    <span class="keyword">case</span> <span class="type">BraceLeftEvent</span>  <span class="comment">// &#123;</span></div><div class="line">    <span class="keyword">case</span> <span class="type">BraceRightEvent</span> <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">case</span> <span class="type">ColonEvent</span> <span class="comment">// :</span></div><div class="line">    <span class="keyword">case</span> <span class="type">SemicolonEvent</span>  <span class="comment">// ;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样在状态的处理过程中也需要一个合理的类结构关系设计来满足，这里也参考了 WebKit 里的设计，如下：<br><img src="/uploads/html-to-native-htn-development-record/03.png" alt="03"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局处理目前 HTN 主要是将样式属性和 DOM 树里的 Element 对应上。具体实现是在 Layout/StyleResolver.swift 里。思路是先将所有 CSSRule 和对应的 CSSSelector 做好映射，接着在递归 DOM 树的过程中与每个 Element 对应上。主要代码实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">resolver</span><span class="params">(<span class="number">_</span> doc:Document, styleSheet:CSSStyleSheet)</span></span> -&gt; <span class="type">Document</span>&#123;</div><div class="line">    <span class="comment">//样式映射表</span></div><div class="line">    <span class="comment">//这种结构能够支持多级 Selector</span></div><div class="line">    <span class="keyword">var</span> matchMap = [<span class="type">String</span>:[<span class="type">String</span>:[<span class="type">String</span>:<span class="type">String</span>]]]()</div><div class="line">    <span class="keyword">for</span> rule <span class="keyword">in</span> styleSheet.ruleList &#123;</div><div class="line">        <span class="keyword">for</span> selector <span class="keyword">in</span> rule.selectorList &#123;</div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> matchLast = selector.matchList.last <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">var</span> matchDic = matchMap[matchLast]</div><div class="line">            <span class="keyword">if</span> matchDic == <span class="literal">nil</span> &#123;</div><div class="line">                matchDic = [<span class="type">String</span>:[<span class="type">String</span>:<span class="type">String</span>]]()</div><div class="line">                matchMap[matchLast] = matchDic</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//这里可以按照后加入 rulelist 的优先级更高的原则进行覆盖操作</span></div><div class="line">            <span class="keyword">if</span> matchMap[matchLast]![selector.identifier] == <span class="literal">nil</span> &#123;</div><div class="line">                matchMap[matchLast]![selector.identifier] = [<span class="type">String</span>:<span class="type">String</span>]()</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> rule.propertyList &#123;</div><div class="line">                matchMap[matchLast]![selector.identifier]![a.key] = a.value</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> elm <span class="keyword">in</span> doc.children &#123;</div><div class="line">        <span class="keyword">self</span>.attach(elm <span class="keyword">as</span>! <span class="type">Element</span>, matchMap: matchMap)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> doc</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归将样式属性都加上</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">attach</span><span class="params">(<span class="number">_</span> element:Element, matchMap:[String:[String:[String:String]]])</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> token = element.startTagToken <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> matchMap[token.data] != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="comment">//<span class="doctag">TODO:</span> 还不支持 selector 里多个标签名组合，后期加上</span></div><div class="line">        addProperty(token.data, matchMap: matchMap, element: element)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//增加 property 通过处理 token 里的属性列表里的 class 和 id 在 matchMap 里找</span></div><div class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> token.attributeList &#123;</div><div class="line">        <span class="keyword">if</span> attr.name == <span class="string">"class"</span> &#123;</div><div class="line">            addProperty(<span class="string">"."</span> + attr.value.lowercased(), matchMap: matchMap, element: element)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> attr.name == <span class="string">"id"</span> &#123;</div><div class="line">            addProperty(<span class="string">"#"</span> + attr.value.lowercased(), matchMap: matchMap, element: element)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> element.children.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> element.children &#123;</div><div class="line">            <span class="keyword">self</span>.attach(element <span class="keyword">as</span>! <span class="type">Element</span>, matchMap: matchMap)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addProperty</span><span class="params">(<span class="number">_</span> key:String, matchMap:[String:[String:[String:String]]], element:Element)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> dic = matchMap[key] <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> aDic <span class="keyword">in</span> dic &#123;</div><div class="line">        <span class="keyword">var</span> selectorArr = aDic.key.components(separatedBy: <span class="string">" "</span>)</div><div class="line">        <span class="keyword">if</span> selectorArr.<span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</div><div class="line">            <span class="comment">//带多个 selector 的情况</span></div><div class="line">            selectorArr.removeLast()</div><div class="line">            <span class="keyword">if</span> !recursionSelectorMatch(selectorArr, parentElement: element.parent <span class="keyword">as</span>! <span class="type">Element</span>) &#123;</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> ruleDic = dic[aDic.key] <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将属性加入 element 的属性列表里</span></div><div class="line">        <span class="keyword">for</span> property <span class="keyword">in</span> ruleDic &#123;</div><div class="line">            element.propertyMap[property.key] = property.value</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过 recursionSelectorMatch 来按照 CSS Selector 从右到左的递归出是否匹配路径，具体实现代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归找出匹配的多路径</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursionSelectorMatch</span><span class="params">(<span class="number">_</span> selectors:[String], parentElement:Element)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">var</span> selectorArr = selectors</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">var</span> last = selectorArr.last <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//表示全匹配了</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> parent = parentElement.parent <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> isMatch = <span class="literal">false</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> last.hasPrefix(<span class="string">"."</span>) &#123;</div><div class="line">        last.characters.removeFirst()</div><div class="line">        <span class="comment">//<span class="doctag">TODO:</span>这里还需要考虑attribute 空格多个 class 名的情况</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> startTagToken = parentElement.startTagToken <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> startTagToken.attributeDic[<span class="string">"class"</span>] == last &#123;</div><div class="line">            isMatch = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> last.hasPrefix(<span class="string">"#"</span>) &#123;</div><div class="line">        last.characters.removeFirst()</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> startTagToken = parentElement.startTagToken <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> startTagToken.attributeDic[<span class="string">"id"</span>] == last &#123;</div><div class="line">            isMatch = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> startTagToken = parentElement.startTagToken <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> startTagToken.data == last &#123;</div><div class="line">            isMatch = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> isMatch &#123;</div><div class="line">        <span class="comment">//匹配到会继续往前去匹配</span></div><div class="line">        selectorArr.removeLast()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> recursionSelectorMatch(selectorArr, parentElement: parent <span class="keyword">as</span>! <span class="type">Element</span>)</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="转原生"><a href="#转原生" class="headerlink" title="转原生"></a>转原生</h2><p>已完成一部分简单布局属性转换 Texture 原生代码。具体实现部分可以参看 HTMLToTexture.swift 文件。</p>
<h2 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h2><ul>
<li>解析 HTML 构建 DOM 树，解析 CSS 构建渲染树</li>
<li>CSS Selector 的 Tag 路径支持，Tag 和 class，id 的组合选择。</li>
<li>flexbox 属性，margin 和 padding 映射 Texture 原生代码</li>
</ul>
<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul>
<li>支持图片标签，支持 CSS background 背景属性</li>
<li>html 的 class 属性还不支持空格多个 class 名</li>
<li>text-transform 属性的支持</li>
<li>em 转 pt，em 是相对父元素值的乘积值。</li>
<li><p>支持CSS选择器的 :before 和 :after</p>
</li>
<li><p>HTN 的 Objective-C 版。</p>
</li>
<li>支持转 Objective-C 的原生代码。</li>
<li>解析转换器内嵌在应用程序内部，支持服务器下发 h5 代码转换。</li>
<li><p>应用内转换时的缓存的处理，将render树结构体进行缓存的处理</p>
</li>
<li><p>HTML 内 JS 解析，支持逻辑控制 HTML</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要是记录 HTN 项目开发的过程。关于这个项目先前在 Swift 开发者大会上我曾经演示过，不过当时项目结构不完善，不易扩展，也没有按
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="Web" scheme="http://ming1016.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 WebKit</title>
    <link href="http://ming1016.github.io/2017/10/11/deeply-analyse-webkit/"/>
    <id>http://ming1016.github.io/2017/10/11/deeply-analyse-webkit/</id>
    <published>2017-10-11T03:42:25.000Z</published>
    <updated>2017-10-23T05:11:35.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML-标准"><a href="#HTML-标准" class="headerlink" title="HTML 标准"></a>HTML 标准</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul>
<li>HTML DOM 树的插入状态规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode</a></li>
<li>HTML Tokenize 规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#tokenization" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a> <a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="external">https://dev.w3.org/html5/spec-preview/tokenization.html</a></li>
<li>HTMLElement 堆栈规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a></li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>1990年 Berners-Lee 发明了 WorldWideWeb 浏览器，后改名 Nexus，在1991年公布了源码。</p>
<p>1993年 Marc Andreessen 的团队开发了 Mosaic，1994年推出我们熟悉的 Netscape Navigator 网景浏览器，在最火爆的时候曾占是绝大多数人的选择。同时他还成立了网景公司。</p>
<p>1995年微软推出了 Internet Explorer 浏览器，简称 IE，通过免费绑定进 Windows 95 系统最终替代了 Netscape，赢得了浏览器大战。</p>
<p>1998年网景公司成立了 Mozilla 基金会组织，同时开源浏览器代码，2004年推出有多标签和支持扩展的 Firefox 火狐浏览器开始慢慢的占领市场份额。</p>
<p>2003年苹果发布了 Safari 浏览器，2005年放出了核心源码 WebKit。</p>
<p>2008年 Google 以苹果的 WebKit 为内核，建立了新的项目 Chromium，在此基础上开发了自己浏览器 Chrome。</p>
<p>2012年 WHATWG 和 W3C 推出 HTML5 技术规范。HTML5 包含了10大类别，offline 离线，storage 存储，connectivity 连接，file access 文件访问，semantics 语义，audio / video 音频视频，3D/graphics 3D和图形，presentation 展示，performance 性能和 Nuts and bolts 其它。</p>
<p>完整的浏览器发展史可以在这里看：<a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="external">https://en.wikipedia.org/wiki/Timeline_of_web_browsers</a></p>
<h2 id="WebKit-全貌"><a href="#WebKit-全貌" class="headerlink" title="WebKit 全貌"></a>WebKit 全貌</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>可以看到浏览器技术的发展到了后期基本都是基于 WebKit 开发的，那么我们就来了解下 WebKit 吧。先看看它的全貌。<br>先看看它的大模块：<br><img src="/uploads/deeply-analyse-webkit/45.png" alt="45"><br>WebKit 为了能够具有 Chromium 那样的多进程优点而推出了 WebKit2 抽象出一组新的编程接口，下面是 WebKit2 的进程结构模型：<br><img src="/uploads/deeply-analyse-webkit/46.png" alt="46"><br>整个 WebKit 架构，如下：<br><img src="/uploads/deeply-analyse-webkit/49.png" alt="49"><br>实线部分是共享的，虚线部分会根据不同的平台有不同的实现。</p>
<p>下面是 WebKit 最核心最复杂的排版引擎 WebCore 的结构图：<br><img src="/uploads/deeply-analyse-webkit/74.png" alt="74"></p>
<p><img src="/uploads/deeply-analyse-webkit/01.png" alt="01"></p>
<p>解析后会产生 DOM Tree，解析 CSS 会产生 CSS Rule Tree，Javascript 会通过 DOM API 和 CSS Object Model（CSSOM） API 来操作 DOM Tree 和 CSS Rule Tree。</p>
<p>DOM Tree<br><img src="/uploads/deeply-analyse-webkit/02.png" alt="02"><br>从网页 URL 到构建完 DOM 树的过程如图<br><img src="/uploads/deeply-analyse-webkit/47.png" alt="47"></p>
<p>CSS Rule Tree<br><img src="/uploads/deeply-analyse-webkit/03.png" alt="03"></p>
<p>通过上面的两个数构造的 Style Context Tree<br><img src="/uploads/deeply-analyse-webkit/04.png" alt="04"></p>
<p>浏览器引擎最后会 通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。这个过程如下：<br><img src="/uploads/deeply-analyse-webkit/48.png" alt="48"></p>
<p>计算每个 Node 的位置，执行 Layout 过程<br><img src="/uploads/deeply-analyse-webkit/05.png" alt="05"></p>
<p>Compute style 是计算 CSS 样式，layout 是定位坐标和大小，各种 position，overflow，z-index 等。这些箭头表示动态修改了 DOM 属性和 CSS 属性会导致 Layout 执行。</p>
<h3 id="WebKit-源代码结构说明"><a href="#WebKit-源代码结构说明" class="headerlink" title="WebKit 源代码结构说明"></a>WebKit 源代码结构说明</h3><ul>
<li>JavaScriptCore：默认 JavaScript 引擎，Google 已经使用了 V8 作为其 Chromium 的 JS 引擎。</li>
<li>WebCore：浏览器渲染引擎，包含了各个核心模块。</li>
<li>WebCore/css：CSS 解释器，CSS 规则等。</li>
<li>WebCore/dom：各种 DOM 元素和 DOM Tree 结构相关的类。</li>
<li>WebCore/html：HTML 解释器和各种 HTML 元素等相关内容。</li>
<li>WebCore/rendering：Render Object 相关，还有页面渲染的样式和布局等。</li>
<li>WebCore/inspector：网页调试工具。</li>
<li>WebCore/loader：主资源和派生资源的加载相关实现，还有派生资源的 Memory Cache 等。</li>
<li>WebCore/page：页面相关的操作，页面结构和交互事件等。</li>
<li>WebCore/platform：各个平台相关的代码，比如 iOS，Mac 等</li>
<li>WebCore/storage：存储相关，比如 WebStorage，Index DB 等接口的实现。</li>
<li>WebCore/workers：Worker 线程封装，提供 JS 多线程执行环境。</li>
<li>WebCore/xml：XML 相关比如 XML Parser，XPath，XSLT 等。</li>
<li>WebCore/accessibility：图形控件访问接口。</li>
<li>WebCore/bindings：DOM 元素和 JS 绑定的接口。</li>
<li>WebCore/bridge：C，JavaScript 和 Objective-C 的桥接。</li>
<li>WebCore/editing：页面编辑相关，比如 DOM 修改，拼写检查等。</li>
<li>WebCore/history：Page Cache 实现前进后退浏览记录等。</li>
<li>WebCore/mathml：数学表达式在网页中的规范代码实现。</li>
<li>WebCore/plugins：NPPlugin 的支持接口</li>
<li>WebCore/svg：矢量图形的支持。</li>
<li>WebKit：平台相关的接口，每个目录都是不同的平台接口实现。</li>
<li>WTF：基础类库，类似 C++ 的 STL 库，有比如字符串操作，智能指针，线程等。</li>
<li>DumpRenderTree：用于生成 RenderTree</li>
<li>TestWebKitAPI：测试 WebKit 的 API 的测试代码</li>
</ul>
<h3 id="WebKit-代码风格"><a href="#WebKit-代码风格" class="headerlink" title="WebKit 代码风格"></a>WebKit 代码风格</h3><ul>
<li>内存管理：使用的引用计数，在 RefCounted 模板类里有 ref() 加和 unref() 减来进行控制，很多类都是继承了这个模板类。后期加入了 RefPtr 和 PassRefPtr 智能指针模板类，采用的是重载赋值操作符的方式能够自动完成计数加减，这样基本没有内存泄漏的可能。</li>
<li>代码自动生成：C++ 对象到 JS 对象的 Binding 实现使用的是代码自动生成，用 Perl 脚本 根据 IDL 接口描述文件完成代码自动生成。还有部分 CSS 和 HTML 解析也用到了，这样 CSS 属性值和 HTML 标签属性的添加也够节省大量时间，需要修改 .in 配置文件即可。</li>
<li>代码编写风格：可以在官网查看到：<a href="https://webkit.org/code-style-guidelines/" target="_blank" rel="external">https://webkit.org/code-style-guidelines/</a> 想给 WebKit 做贡献的同学们可以好好看看了。</li>
</ul>
<h3 id="WebKit-的设计模式"><a href="#WebKit-的设计模式" class="headerlink" title="WebKit 的设计模式"></a>WebKit 的设计模式</h3><p>下面可以看看在 WebKit 里使用了哪些设计模式，是如何使用的。</p>
<ul>
<li>单例：WebKit 里的 Loader 管理 CacheResource 就是单例模式。</li>
<li>工厂模式：可以在 WebKit 源码里搜索结尾是 Factory 的代码，它们一般都是用的工厂模式。</li>
<li>观察者模式：名称结尾是 Client 都是观察者模式，比如 FrameLoaderClient 可以看成是观察者类，被观察者 FrameLoader 会向 Client 观察者类通知自身状态的变化。</li>
<li>组合模式：用于树状结构对象，比如 DOM Tree，Render Tree，组成它们的类 ContainerNode 和 RenderObject 可以看成组合模式。</li>
<li>命令模式：DOM 模块的 Event 类和 Editing 模块的 Command 类都是命令模式。</li>
</ul>
<h3 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h3><h4 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h4><p><img src="/uploads/deeply-analyse-webkit/06.png" alt="06"></p>
<ul>
<li>Frame：中心类，通过它找其它类</li>
<li>FrameLoader：加载资源用的</li>
<li>Document：具体实现是 HTMLDocument</li>
<li>Page：窗口的操作</li>
<li>EventHandler：输入事件的处理，比如键盘，鼠标，触屏等</li>
</ul>
<h4 id="WebCore-Frame"><a href="#WebCore-Frame" class="headerlink" title="WebCore::Frame"></a>WebCore::Frame</h4><p><img src="/uploads/deeply-analyse-webkit/29.png" alt="29"></p>
<ul>
<li>FrameTree：管理父 Frame 和子 Frame 的关系，比如 main frame 里的 iframe。</li>
<li>FrameLoader：frame 的加载</li>
<li>NavigationScheduler：主要用来管理页面跳转，比如重定向，meta refresh 等。</li>
<li>DOMWindow：管理 DOM 相关的事件，属性和消息。</li>
<li>FrameView：Frame 的排版。</li>
<li>Document：用来管理 DOM 里的 node，每个 tag 都会有对应的 DOM node 关联。</li>
<li>ScriptController：管理 js 脚本。</li>
<li>Editor：管理页面比如 copy，paste和输入等编辑操作。</li>
<li>SelectionController：管理 Frame 里的选择操作。</li>
<li>AnimationControlle：动画控制。</li>
<li>EventHandler：处理事件比如鼠标，按键，滚动和 resize 等事件。</li>
</ul>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p><img src="/uploads/deeply-analyse-webkit/43.png" alt="43"><br>上图可以看到渲染引擎处于浏览器三层结构的最上层。下面是渲染的过程：<br><img src="/uploads/deeply-analyse-webkit/44.png" alt="44"></p>
<h3 id="Frame-的主要接口"><a href="#Frame-的主要接口" class="headerlink" title="Frame 的主要接口"></a>Frame 的主要接口</h3><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client)</div><div class="line">&#123;</div><div class="line">    ASSERT(page);</div><div class="line">    ASSERT(client);</div><div class="line">    <span class="keyword">return</span> adoptRef(*<span class="keyword">new</span> Frame(*page, ownerElement, *client));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Frame::create 里会调用到 Frame 的构造函数，创建 Frame 对象。<br>初始调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">webPage::setView</div><div class="line">webPage::setViewportSize</div><div class="line">webPage::mainFrame</div><div class="line">webPagePrivate::createMainFrame</div><div class="line">webFrameData::webFrameData</div><div class="line">Frame::create</div></pre></td></tr></table></figure></p>
<p>解析中发现 iframe 时的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FrameLoader::finishedLoading</div><div class="line">HTMLDocumentParser::append</div><div class="line">HTMLTreeBuilder::processToken</div><div class="line">HTMLElementBase::openURL</div><div class="line">SubFrameLoader::requestFrame</div><div class="line">FrameLoaderClient::creatFrame</div><div class="line">webFrameData::webFrameData</div><div class="line">Frame::create</div></pre></td></tr></table></figure></p>
<h4 id="createView"><a href="#createView" class="headerlink" title="createView"></a>createView</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Frame::createView(<span class="keyword">const</span> IntSize&amp; viewportSize, <span class="keyword">const</span> Color&amp; backgroundColor, <span class="keyword">bool</span> transparent,</div><div class="line">    <span class="keyword">const</span> IntSize&amp; fixedLayoutSize, <span class="keyword">const</span> IntRect&amp; fixedVisibleContentRect,</div><div class="line">    <span class="keyword">bool</span> useFixedLayout, ScrollbarMode horizontalScrollbarMode, <span class="keyword">bool</span> horizontalLock,</div><div class="line">    ScrollbarMode verticalScrollbarMode, <span class="keyword">bool</span> verticalLock)</div></pre></td></tr></table></figure>
<p>会创建出用于排版的 FrameView 对象。需要一些和排版相关的信息，比如初始 viewport 的大小，背景色，滚动条模式等，完成创建调用 Frame::setView 设置为当前 FrameView。<br>调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FrameLoader::commitProvisionalLoad</div><div class="line">FrameLoader::transitionToCommitted</div><div class="line">FrameLoaderClient::transitionToCommittedForNewPage</div><div class="line">Frame::createView</div></pre></td></tr></table></figure></p>
<h4 id="setDocument"><a href="#setDocument" class="headerlink" title="setDocument"></a>setDocument</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)</div></pre></td></tr></table></figure>
<p>用来关联 Frame 和 Document 对象<br>Frame 初始化调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WebFrame::webFrame</div><div class="line">webFramePrivate::init</div><div class="line">Frame::init</div><div class="line">FrameLoader::init</div><div class="line">DocumentWriter::begin</div><div class="line">Frame::setDocument</div></pre></td></tr></table></figure></p>
<p>js 脚本更改数据时的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DocumentLoader::receivedData</div><div class="line">DocumentLoader::commitLoad</div><div class="line">FrameLoaderClient::committedLoad</div><div class="line">DocumentLoader::commitData</div><div class="line">DocumentWriter::setEncoding</div><div class="line">DocumentWriter::willSetEncoding</div><div class="line">FrameLoader::receivedFirstData</div><div class="line">DocumentWriter::begin</div><div class="line">FrameLoader::clear</div><div class="line">Frame::setDocument</div></pre></td></tr></table></figure></p>
<h2 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h2><p>全称是 Web Template Library，是 WebKit 的基础库，实现了智能指针，字符串和 Container，提供跨平台原子操作，时间和线程的封装，能够高效的对内存进行管理。WebCore 里都是 WTF 的代码而没有 STL。</p>
<h3 id="Smart-ptr-智能指针"><a href="#Smart-ptr-智能指针" class="headerlink" title="Smart ptr 智能指针"></a>Smart ptr 智能指针</h3><p>对原生指针的封装，这样 C++ 可以自动化的实现资源管理和指针衍生操作比如拷贝，引用计数，autoLocker 和 Lazy evaluation 等。</p>
<p>智能指针主要就是实现动态分配对象的内存并且能自动回收，原理就是智能指针的对象会作为栈上分配的自动变量在退出作用域时被自动析构。</p>
<p>智能指针的实现方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> T ValueType;</div><div class="line">        <span class="keyword">typedef</span> ValueType *PtrType;</div><div class="line">        </div><div class="line">        <span class="comment">//构造析构函数</span></div><div class="line">        SmartPtr() :m_ptr(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">        SmartPtr(PtrType ptr) :m_ptr(ptr) &#123;&#125;</div><div class="line">        ~SmartPtr() &#123; </div><div class="line">            <span class="keyword">if</span>(m_ptr) <span class="keyword">delete</span> m_ptr; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//拷贝构造函数</span></div><div class="line">        SmartPtr(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp; o); <span class="comment">//堆上分配的对象</span></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; o);</div><div class="line">        </div><div class="line">        <span class="comment">//拷贝赋值运算符</span></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; SmartPtr&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; o);</div><div class="line"></div><div class="line">        <span class="comment">//指针运算，是为了让智能指针在行为上更类似原生指针</span></div><div class="line">        ValueType&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; </div><div class="line">            <span class="keyword">return</span> *m_ptr; </div><div class="line">        &#125;</div><div class="line">        PtrType <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</div><div class="line">            <span class="keyword">return</span> m_ptr;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//逻辑运算符重载</span></div><div class="line">        <span class="comment">//对指针是否为空的简洁判断 if(!ptr)，如果定义了 operator!() 智能指针就可以用 if(!SmartPtr)</span></div><div class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!() <span class="keyword">const</span> &#123;</div><div class="line">            <span class="keyword">return</span> !m_ptr;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//转成 raw ptr</span></div><div class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">PtrType</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> m_ptr;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        PtrType m_ptr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建智能指针对象格式</span></div><div class="line">SmartPtr(<span class="keyword">new</span> ValueType());</div></pre></td></tr></table></figure></p>
<h3 id="RefPtr"><a href="#RefPtr" class="headerlink" title="RefPtr"></a>RefPtr</h3><p>RefPtr 需要操作对象来引用计数，包含 ref() 和 deref() 方法的类对象才可以由 RefPtr 引用。为了不让 RefPtr 引用的类都用手工去添加 ref() 和 deref() WTF 提供了 RefCounted 类模板，在 WTF/Source/wtf/RefCounted.h 里。类模板的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefCountedBase</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ref</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</div><div class="line">        ASSERT(!m_adoptionIsRequired);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        ++m_refCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasOneRef</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT(!m_deletionHasBegun);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        <span class="keyword">return</span> m_refCount == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">refCount</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> m_refCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relaxAdoptionRequirement</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</div><div class="line">        ASSERT(m_adoptionIsRequired);</div><div class="line">        m_adoptionIsRequired = <span class="literal">false</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    RefCountedBase()</div><div class="line">        : m_refCount(<span class="number">1</span>)</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        , m_deletionHasBegun(<span class="literal">false</span>)</div><div class="line">        , m_adoptionIsRequired(<span class="literal">true</span>)</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~RefCountedBase()</div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT(m_deletionHasBegun);</div><div class="line">        ASSERT(!m_adoptionIsRequired);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Returns whether the pointer should be freed or not.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">derefBase</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</div><div class="line">        ASSERT(!m_adoptionIsRequired);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        ASSERT(m_refCount);</div><div class="line">        <span class="keyword">unsigned</span> tempRefCount = m_refCount - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (!tempRefCount) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">            m_deletionHasBegun = <span class="literal">true</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        m_refCount = tempRefCount;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deletionHasBegun</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> m_deletionHasBegun;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">adopted</span><span class="params">(RefCountedBase*)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">unsigned</span> m_refCount;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> m_deletionHasBegun;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> m_adoptionIsRequired;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">RefCounted</span> :</span> <span class="keyword">public</span> RefCountedBase &#123;</div><div class="line">    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deref</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (derefBase())</div><div class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    RefCounted() &#123; &#125;</div><div class="line">    ~RefCounted()</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面可以看到 RefCounted 类定义有 RefCountedBase 类和 RefCounted 类，RefCounted 类会被大量继承，任何类如果想被 RefPtr 引用只需要继承 RefCounted<class>即可。在 RefPtr.h 里可以看到 refIfNotNull 和 derefIfNotNull 定义了计数的增加和减少。</class></p>
<h3 id="Assert-断言的实现和应用"><a href="#Assert-断言的实现和应用" class="headerlink" title="Assert 断言的实现和应用"></a>Assert 断言的实现和应用</h3><p>断言在 WTF 里是这样定义的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ASSERT(assertion) do &#123; \</span></div><div class="line">    <span class="meta-keyword">if</span> (!(assertion)) &#123; \</div><div class="line">        <span class="comment">//打印用</span></div><div class="line">        WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \</div><div class="line">        <span class="comment">//重点</span></div><div class="line">        CRASH(); \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CRASH</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NDEBUG) &amp;&amp; OS(DARWIN)</span></div><div class="line"><span class="comment">// Crash with a SIGTRAP i.e EXC_BREAKPOINT.</span></div><div class="line"><span class="comment">// We are not using __builtin_trap because it is only guaranteed to abort, but not necessarily</span></div><div class="line"><span class="comment">// trigger a SIGTRAP. Instead, we use inline asm to ensure that we trigger the SIGTRAP.</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CRASH() do &#123; \</span></div><div class="line">    <span class="comment">//直接 inline 汇编代码</span></div><div class="line">    WTFBreakpointTrap(); \</div><div class="line">    __builtin_unreachable(); \</div><div class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CRASH() WTFCrash()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !defined(CRASH)</span></span></div><div class="line"></div><div class="line"><span class="comment">//根据不同 CPU 定义不同的 WTFBreakpointTrap() 汇编宏</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CPU(X86_64) || CPU(X86)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTFBreakpointTrap()  __asm__ volatile (<span class="meta-string">"int3"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> CPU(ARM_THUMB2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTFBreakpointTrap()  __asm__ volatile (<span class="meta-string">"bkpt #0"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> CPU(ARM64)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTFBreakpointTrap()  __asm__ volatile (<span class="meta-string">"brk #0"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTFBreakpointTrap() WTFCrash() <span class="comment">// Not implemented.</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>WTF 提供的内存管理和 STL 类似，为容器和应用提供内存分配接口。先看 WTF_MAKE_FAST_ALLOCATED 这个宏<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTF_MAKE_FAST_ALLOCATED \</span></div><div class="line">public: \</div><div class="line">    void* operator new(size_t, void* p) &#123; return p; &#125; \</div><div class="line">    void* operator new[](size_t, void* p) &#123; return p; &#125; \</div><div class="line">    \</div><div class="line">    void* operator new(size_t size) \</div><div class="line">    &#123; \</div><div class="line">        return ::WTF::fastMalloc(size); \</div><div class="line">    &#125; \</div><div class="line">    \</div><div class="line">    void operator delete(void* p) \</div><div class="line">    &#123; \</div><div class="line">        ::WTF::fastFree(p); \</div><div class="line">    &#125; \</div><div class="line">    \</div><div class="line">    void* operator new[](size_t size) \</div><div class="line">    &#123; \</div><div class="line">        return ::WTF::fastMalloc(size); \</div><div class="line">    &#125; \</div><div class="line">    \</div><div class="line">    void operator delete[](void* p) \</div><div class="line">    &#123; \</div><div class="line">        ::WTF::fastFree(p); \</div><div class="line">    &#125; \</div><div class="line">    void* operator new(size_t, NotNullTag, void* location) \</div><div class="line">    &#123; \</div><div class="line">        ASSERT(location); \</div><div class="line">        return location; \</div><div class="line">    &#125; \</div><div class="line">private: \</div><div class="line">typedef int __thisIsHereToForceASemicolonAfterThisMacro</div></pre></td></tr></table></figure></p>
<p>这个宏定义了 operator new 和 operator delete。operator new 是直接调用 fastMalloc 完成内存分配，下面看看 fastMalloc 的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fastMalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    ASSERT_IS_WITHIN_LIMIT(size);</div><div class="line">    <span class="keyword">return</span> bmalloc::api::<span class="built_in">malloc</span>(size);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 WTF 使用了 bmalloc 来 malloc，这个 bmalloc 被苹果号称在性能上要远超于 TCMalloc 和 STL 里在 malloc 之上实现一个内存池的的思路也完全不一样。关于 TCMalloc 的实现和原理可以参看：<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="external">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a> 。关于 STL 内存管理的实现可以在 《STL 源码分析》第二章里有详细说明。</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>WTF 里很多的容器，比如 BlockStack，Deque，Vector 和 HashTable。</p>
<h4 id="Vector-动态数组"><a href="#Vector-动态数组" class="headerlink" title="Vector 动态数组"></a>Vector 动态数组</h4><p>WTF 里的 Vector 和 STL 里的 Vector 一样也是一种数据结构，相当于动态数组，当不知道需要的数组规模多大时可以达到最大节约空间的目的，那么看看 WTF 是如何实现 Vector 的吧，关键地方我在代码里做了注释说明。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T, size_t inlineCapacity = 0, typename OverflowHandler = CrashOnOverflow, size_t minCapacity = 16, typename Malloc = FastMalloc&gt;</div><div class="line">class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; &#123;</div><div class="line">    WTF_MAKE_FAST_ALLOCATED;</div><div class="line">private:</div><div class="line">    //VectorBuffer 是内部存储数据的容器</div><div class="line">    typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;</div><div class="line">    //Vector 里元素的初始化，复制和移动这些操作都在 VectorTypeOperations 里</div><div class="line">    typedef VectorTypeOperations&lt;T&gt; TypeOperations;</div><div class="line"></div><div class="line">public:</div><div class="line">    typedef T ValueType;</div><div class="line">    //iterator 直接使用的原生指针</div><div class="line">    typedef T* iterator;</div><div class="line">    typedef const T* const_iterator;</div><div class="line">    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;</div><div class="line">    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</div><div class="line"></div><div class="line">    Vector()</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Unlike in std::vector, this constructor does not initialize POD types.</div><div class="line">    explicit Vector(size_t size)</div><div class="line">        : Base(size, size)</div><div class="line">    &#123;</div><div class="line">        asanSetInitialBufferSizeTo(size);</div><div class="line"></div><div class="line">        if (begin())</div><div class="line">            TypeOperations::initialize(begin(), end());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Vector(size_t size, const T&amp; val)</div><div class="line">        : Base(size, size)</div><div class="line">    &#123;</div><div class="line">        asanSetInitialBufferSizeTo(size);</div><div class="line"></div><div class="line">        if (begin())</div><div class="line">            TypeOperations::uninitializedFill(begin(), end(), val);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Vector(std::initializer_list&lt;T&gt; initializerList)</div><div class="line">    &#123;</div><div class="line">        reserveInitialCapacity(initializerList.size());</div><div class="line"></div><div class="line">        asanSetInitialBufferSizeTo(initializerList.size());</div><div class="line"></div><div class="line">        for (const auto&amp; element : initializerList)</div><div class="line">            uncheckedAppend(element);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~Vector()</div><div class="line">    &#123;</div><div class="line">        if (m_size)</div><div class="line">            TypeOperations::destruct(begin(), end());</div><div class="line"></div><div class="line">        asanSetBufferSizeToFullCapacity(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Vector(const Vector&amp;);</div><div class="line">    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</div><div class="line">    explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</div><div class="line"></div><div class="line">    Vector&amp; operator=(const Vector&amp;);</div><div class="line">    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</div><div class="line">    Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</div><div class="line"></div><div class="line">    Vector(Vector&amp;&amp;);</div><div class="line">    Vector&amp; operator=(Vector&amp;&amp;);</div><div class="line">    </div><div class="line">    //返回 Vector 里元素个数</div><div class="line">    size_t size() const &#123; return m_size; &#125;</div><div class="line">    static ptrdiff_t sizeMemoryOffset() &#123; return OBJECT_OFFSETOF(Vector, m_size); &#125;</div><div class="line">    </div><div class="line">    //返回的是 Vector 中的容量，容量随着元素增加和删除而变化</div><div class="line">    size_t capacity() const &#123; return Base::capacity(); &#125;</div><div class="line">    bool isEmpty() const &#123; return !size(); &#125;</div><div class="line">    </div><div class="line">    //这里提供的是数组的访问功能</div><div class="line">    T&amp; at(size_t i)</div><div class="line">    &#123;</div><div class="line">        if (UNLIKELY(i &gt;= size()))</div><div class="line">            OverflowHandler::overflowed();</div><div class="line">        return Base::buffer()[i];</div><div class="line">    &#125;</div><div class="line">    const T&amp; at(size_t i) const </div><div class="line">    &#123;</div><div class="line">        if (UNLIKELY(i &gt;= size()))</div><div class="line">            OverflowHandler::overflowed();</div><div class="line">        return Base::buffer()[i];</div><div class="line">    &#125;</div><div class="line">    T&amp; at(Checked&lt;size_t&gt; i)</div><div class="line">    &#123;</div><div class="line">        RELEASE_ASSERT(i &lt; size());</div><div class="line">        return Base::buffer()[i];</div><div class="line">    &#125;</div><div class="line">    const T&amp; at(Checked&lt;size_t&gt; i) const</div><div class="line">    &#123;</div><div class="line">        RELEASE_ASSERT(i &lt; size());</div><div class="line">        return Base::buffer()[i];</div><div class="line">    &#125;</div><div class="line">    //返回数组中第几个元素</div><div class="line">    T&amp; operator[](size_t i) &#123; return at(i); &#125;</div><div class="line">    const T&amp; operator[](size_t i) const &#123; return at(i); &#125;</div><div class="line">    T&amp; operator[](Checked&lt;size_t&gt; i) &#123; return at(i); &#125;</div><div class="line">    const T&amp; operator[](Checked&lt;size_t&gt; i) const &#123; return at(i); &#125;</div><div class="line"></div><div class="line">    T* data() &#123; return Base::buffer(); &#125;</div><div class="line">    const T* data() const &#123; return Base::buffer(); &#125;</div><div class="line">    static ptrdiff_t dataMemoryOffset() &#123; return Base::bufferMemoryOffset(); &#125;</div><div class="line">    //迭代功能的实现，获取 begin 和 end，Vector 元素有了插入和删除操作都需要重新 begin 和 end。</div><div class="line">    iterator begin() &#123; return data(); &#125;</div><div class="line">    iterator end() &#123; return begin() + m_size; &#125;</div><div class="line">    const_iterator begin() const &#123; return data(); &#125;</div><div class="line">    const_iterator end() const &#123; return begin() + m_size; &#125;</div><div class="line"></div><div class="line">    reverse_iterator rbegin() &#123; return reverse_iterator(end()); &#125;</div><div class="line">    reverse_iterator rend() &#123; return reverse_iterator(begin()); &#125;</div><div class="line">    const_reverse_iterator rbegin() const &#123; return const_reverse_iterator(end()); &#125;</div><div class="line">    const_reverse_iterator rend() const &#123; return const_reverse_iterator(begin()); &#125;</div><div class="line"></div><div class="line">    T&amp; first() &#123; return at(0); &#125;</div><div class="line">    const T&amp; first() const &#123; return at(0); &#125;</div><div class="line">    T&amp; last() &#123; return at(size() - 1); &#125;</div><div class="line">    const T&amp; last() const &#123; return at(size() - 1); &#125;</div><div class="line">    </div><div class="line">    T takeLast()</div><div class="line">    &#123;</div><div class="line">        T result = WTFMove(last());</div><div class="line">        removeLast();</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //O(n) 遍历查找的操作，所以数据量大时查找用 hashtable 效果会更好</div><div class="line">    template&lt;typename U&gt; bool contains(const U&amp;) const;</div><div class="line">    template&lt;typename U&gt; size_t find(const U&amp;) const;</div><div class="line">    template&lt;typename MatchFunction&gt; size_t findMatching(const MatchFunction&amp;) const;</div><div class="line">    template&lt;typename U&gt; size_t reverseFind(const U&amp;) const;</div><div class="line">    </div><div class="line">    template&lt;typename U&gt; bool appendIfNotContains(const U&amp;);</div><div class="line">    </div><div class="line">    //实现 STL 里的方法，这里的 insert，append 和 resize 等操作的时候会通过 reserveCapacity 或 tryReserveCapacity 来进行空间扩展达到动态数组的能力</div><div class="line">    void shrink(size_t size);</div><div class="line">    void grow(size_t size);</div><div class="line">    void resize(size_t size);</div><div class="line">    void resizeToFit(size_t size);</div><div class="line">    void reserveCapacity(size_t newCapacity);</div><div class="line">    bool tryReserveCapacity(size_t newCapacity);</div><div class="line">    void reserveInitialCapacity(size_t initialCapacity);</div><div class="line">    void shrinkCapacity(size_t newCapacity);</div><div class="line">    void shrinkToFit() &#123; shrinkCapacity(size()); &#125;</div><div class="line"></div><div class="line">    void clear() &#123; shrinkCapacity(0); &#125;</div><div class="line"></div><div class="line">    void append(ValueType&amp;&amp; value) &#123; append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;</div><div class="line">    template&lt;typename U&gt; void append(U&amp;&amp;);</div><div class="line">    template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);</div><div class="line">    template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);</div><div class="line"></div><div class="line">    void uncheckedAppend(ValueType&amp;&amp; value) &#123; uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;</div><div class="line">    template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);</div><div class="line"></div><div class="line">    template&lt;typename U&gt; void append(const U*, size_t);</div><div class="line">    template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);</div><div class="line">    template&lt;typename U&gt; bool tryAppend(const U*, size_t);</div><div class="line"></div><div class="line">    template&lt;typename U&gt; void insert(size_t position, const U*, size_t);</div><div class="line">    template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);</div><div class="line">    template&lt;typename U, size_t c&gt; void insertVector(size_t position, const Vector&lt;U, c&gt;&amp;);</div><div class="line"></div><div class="line">    void remove(size_t position);</div><div class="line">    void remove(size_t position, size_t length);</div><div class="line">    template&lt;typename U&gt; bool removeFirst(const U&amp;);</div><div class="line">    template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);</div><div class="line">    template&lt;typename U&gt; unsigned removeAll(const U&amp;);</div><div class="line">    template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0);</div><div class="line"></div><div class="line">    void removeLast() </div><div class="line">    &#123;</div><div class="line">        if (UNLIKELY(isEmpty()))</div><div class="line">            OverflowHandler::overflowed();</div><div class="line">        shrink(size() - 1); </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void fill(const T&amp;, size_t);</div><div class="line">    void fill(const T&amp; val) &#123; fill(val, size()); &#125;</div><div class="line"></div><div class="line">    template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);</div><div class="line"></div><div class="line">    MallocPtr&lt;T&gt; releaseBuffer();</div><div class="line"></div><div class="line">    void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</div><div class="line">    &#123;</div><div class="line">#if ASAN_ENABLED</div><div class="line">        if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.</div><div class="line">            return;</div><div class="line">#endif</div><div class="line"></div><div class="line">        // Make it possible to copy inline buffers.</div><div class="line">        asanSetBufferSizeToFullCapacity();</div><div class="line">        other.asanSetBufferSizeToFullCapacity();</div><div class="line"></div><div class="line">        Base::swap(other, m_size, other.m_size);</div><div class="line">        std::swap(m_size, other.m_size);</div><div class="line"></div><div class="line">        asanSetInitialBufferSizeTo(m_size);</div><div class="line">        other.asanSetInitialBufferSizeTo(other.m_size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void reverse();</div><div class="line"></div><div class="line">    void checkConsistency();</div><div class="line"></div><div class="line">    template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;</div><div class="line"></div><div class="line">private:</div><div class="line">    void expandCapacity(size_t newMinCapacity);</div><div class="line">    T* expandCapacity(size_t newMinCapacity, T*);</div><div class="line">    bool tryExpandCapacity(size_t newMinCapacity);</div><div class="line">    const T* tryExpandCapacity(size_t newMinCapacity, const T*);</div><div class="line">    template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*); </div><div class="line">    template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);</div><div class="line">    template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);</div><div class="line">    template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);</div><div class="line"></div><div class="line">    void asanSetInitialBufferSizeTo(size_t);</div><div class="line">    void asanSetBufferSizeToFullCapacity(size_t);</div><div class="line">    void asanSetBufferSizeToFullCapacity() &#123; asanSetBufferSizeToFullCapacity(size()); &#125;</div><div class="line"></div><div class="line">    void asanBufferSizeWillChangeTo(size_t);</div><div class="line"></div><div class="line">    using Base::m_size;</div><div class="line">    using Base::buffer;</div><div class="line">    using Base::capacity;</div><div class="line">    using Base::swap;</div><div class="line">    using Base::allocateBuffer;</div><div class="line">    using Base::deallocateBuffer;</div><div class="line">    using Base::tryAllocateBuffer;</div><div class="line">    using Base::shouldReallocateBuffer;</div><div class="line">    using Base::reallocateBuffer;</div><div class="line">    using Base::restoreInlineBufferIfNeeded;</div><div class="line">    using Base::releaseBuffer;</div><div class="line">#if ASAN_ENABLED</div><div class="line">    using Base::endOfBuffer;</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="HashTable-哈希表"><a href="#HashTable-哈希表" class="headerlink" title="HashTable 哈希表"></a>HashTable 哈希表</h4><p>HashTable 实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Extractor, <span class="keyword">typename</span> HashFunctions, <span class="keyword">typename</span> Traits, <span class="keyword">typename</span> KeyTraits&gt;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;</div><div class="line">        <span class="keyword">typedef</span> HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;</div><div class="line">        <span class="keyword">typedef</span> Traits ValueTraits;</div><div class="line">        <span class="keyword">typedef</span> Key KeyType;</div><div class="line">        <span class="keyword">typedef</span> Value ValueType;</div><div class="line">        <span class="keyword">typedef</span> IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;</div><div class="line">        <span class="keyword">typedef</span> HashTableAddResult&lt;iterator&gt; AddResult;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DUMP_HASHTABLE_STATS_PER_TABLE</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stats</span> &#123;</span></div><div class="line">            Stats()</div><div class="line">                : numAccesses(<span class="number">0</span>)</div><div class="line">                , numRehashes(<span class="number">0</span>)</div><div class="line">                , numRemoves(<span class="number">0</span>)</div><div class="line">                , numReinserts(<span class="number">0</span>)</div><div class="line">                , maxCollisions(<span class="number">0</span>)</div><div class="line">                , numCollisions(<span class="number">0</span>)</div><div class="line">                , collisionGraph()</div><div class="line">            &#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">unsigned</span> numAccesses;</div><div class="line">            <span class="keyword">unsigned</span> numRehashes;</div><div class="line">            <span class="keyword">unsigned</span> numRemoves;</div><div class="line">            <span class="keyword">unsigned</span> numReinserts;</div><div class="line"></div><div class="line">            <span class="keyword">unsigned</span> maxCollisions;</div><div class="line">            <span class="keyword">unsigned</span> numCollisions;</div><div class="line">            <span class="keyword">unsigned</span> collisionGraph[<span class="number">4096</span>];</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">recordCollisionAtCount</span><span class="params">(<span class="keyword">unsigned</span> count)</span></span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (count &gt; maxCollisions)</div><div class="line">                    maxCollisions = count;</div><div class="line">                numCollisions++;</div><div class="line">                collisionGraph[count]++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">dumpStats</span><span class="params">()</span></span></div><div class="line">            &#123;</div><div class="line">                dataLogF(<span class="string">"\nWTF::HashTable::Stats dump\n\n"</span>);</div><div class="line">                dataLogF(<span class="string">"%d accesses\n"</span>, numAccesses);</div><div class="line">                dataLogF(<span class="string">"%d total collisions, average %.2f probes per access\n"</span>, numCollisions, <span class="number">1.0</span> * (numAccesses + numCollisions) / numAccesses);</div><div class="line">                dataLogF(<span class="string">"longest collision chain: %d\n"</span>, maxCollisions);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">1</span>; i &lt;= maxCollisions; i++) &#123;</div><div class="line">                    dataLogF(<span class="string">"  %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\n"</span>, collisionGraph[i], i, <span class="number">100.0</span> * (collisionGraph[i] - collisionGraph[i+<span class="number">1</span>]) / numAccesses, <span class="number">100.0</span> * collisionGraph[i] / numAccesses);</div><div class="line">                &#125;</div><div class="line">                dataLogF(<span class="string">"%d rehashes\n"</span>, numRehashes);</div><div class="line">                dataLogF(<span class="string">"%d reinserts\n"</span>, numReinserts);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        HashTable();</div><div class="line">        ~HashTable() </div><div class="line">        &#123;</div><div class="line">            invalidateIterators(); </div><div class="line">            <span class="keyword">if</span> (m_table)</div><div class="line">                deallocateTable(m_table, m_tableSize);</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_HASHTABLE_USE_AFTER_DESTRUCTION</span></div><div class="line">            m_table = (ValueType*)(<span class="keyword">uintptr_t</span>)<span class="number">0xbbadbeef</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HashTable(<span class="keyword">const</span> HashTable&amp;);</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(HashTable&amp;)</span></span>;</div><div class="line">        HashTable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HashTable&amp;);</div><div class="line"></div><div class="line">        HashTable(HashTable&amp;&amp;);</div><div class="line">        HashTable&amp; <span class="keyword">operator</span>=(HashTable&amp;&amp;);</div><div class="line"></div><div class="line">        <span class="comment">// When the hash table is empty, just return the same iterator for end as for begin.</span></div><div class="line">        <span class="comment">// This is more efficient because we don't have to skip all the empty and deleted</span></div><div class="line">        <span class="comment">// buckets, and iterating an empty table is a common case that's worth optimizing.</span></div><div class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isEmpty() ? end() : makeIterator(m_table); &#125;</div><div class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> makeKnownGoodIterator(m_table + m_tableSize); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> isEmpty() ? end() : makeConstIterator(m_table); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> makeKnownGoodConstIterator(m_table + m_tableSize); &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_keyCount; &#125;</div><div class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_tableSize; &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !m_keyCount; &#125;</div><div class="line"></div><div class="line">        <span class="function">AddResult <span class="title">add</span><span class="params">(<span class="keyword">const</span> ValueType&amp; value)</span> </span>&#123; <span class="keyword">return</span> add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); &#125;</div><div class="line">        <span class="function">AddResult <span class="title">add</span><span class="params">(ValueType&amp;&amp; value)</span> </span>&#123; <span class="keyword">return</span> add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); &#125;</div><div class="line"></div><div class="line">        <span class="comment">// A special version of add() that finds the object by hashing and comparing</span></div><div class="line">        <span class="comment">// with some other type, to avoid the cost of type conversion if the object is already</span></div><div class="line">        <span class="comment">// in the table.</span></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Extra&gt; <span class="function">AddResult <span class="title">add</span><span class="params">(T&amp;&amp; key, Extra&amp;&amp;)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Extra&gt; <span class="function">AddResult <span class="title">addPassingHashCode</span><span class="params">(T&amp;&amp; key, Extra&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> KeyType&amp; key)</span> </span>&#123; <span class="keyword">return</span> find&lt;IdentityTranslatorType&gt;(key); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> KeyType&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> find&lt;IdentityTranslatorType&gt;(key); &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> KeyType&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> contains&lt;IdentityTranslatorType&gt;(key); &#125;</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> T&amp;)</span> <span class="keyword">const</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> T&amp;)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> KeyType&amp;)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(iterator)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeWithoutEntryConsistencyCheck</span><span class="params">(iterator)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeWithoutEntryConsistencyCheck</span><span class="params">(const_iterator)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Functor&gt;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeIf</span><span class="params">(<span class="keyword">const</span> Functor&amp;)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isEmptyBucket</span><span class="params">(<span class="keyword">const</span> ValueType&amp; value)</span> </span>&#123; <span class="keyword">return</span> isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isDeletedBucket</span><span class="params">(<span class="keyword">const</span> ValueType&amp; value)</span> </span>&#123; <span class="keyword">return</span> KeyTraits::isDeletedValue(Extractor::extract(value)); &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isEmptyOrDeletedBucket</span><span class="params">(<span class="keyword">const</span> ValueType&amp; value)</span> </span>&#123; <span class="keyword">return</span> isEmptyBucket(value) || isDeletedBucket(value); &#125;</div><div class="line"></div><div class="line">        <span class="function">ValueType* <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> </span>&#123; <span class="keyword">return</span> lookup&lt;IdentityTranslatorType&gt;(key); &#125;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">ValueType* <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">ValueType* <span class="title">inlineLookup</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !ASSERT_DISABLED</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">checkTableConsistency</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkTableConsistency</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_HASHTABLE_CONSISTENCY</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">internalCheckTableConsistency</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; checkTableConsistency(); &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">internalCheckTableConsistencyExceptSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; checkTableConsistencyExceptSize(); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internalCheckTableConsistencyExceptSize</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internalCheckTableConsistency</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="function"><span class="keyword">static</span> ValueType* <span class="title">allocateTable</span><span class="params">(<span class="keyword">unsigned</span> size)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocateTable</span><span class="params">(ValueType* table, <span class="keyword">unsigned</span> size)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;ValueType*, <span class="keyword">bool</span>&gt; LookupType;</div><div class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;LookupType, <span class="keyword">unsigned</span>&gt; FullLookupType;</div><div class="line"></div><div class="line">        <span class="function">LookupType <span class="title">lookupForWriting</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> </span>&#123; <span class="keyword">return</span> lookupForWriting&lt;IdentityTranslatorType&gt;(key); &#125;;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">FullLookupType <span class="title">fullLookupForWriting</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">LookupType <span class="title">lookupForWriting</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Extra&gt; <span class="function"><span class="keyword">void</span> <span class="title">addUniqueForInitialization</span><span class="params">(T&amp;&amp; key, Extra&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">checkKey</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeAndInvalidateWithoutEntryConsistencyCheck</span><span class="params">(ValueType*)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeAndInvalidate</span><span class="params">(ValueType*)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(ValueType*)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">shouldExpand</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">mustRehashInPlace</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_keyCount * m_minLoad &lt; m_tableSize * <span class="number">2</span>; &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">shouldShrink</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; &#125;</div><div class="line">        <span class="function">ValueType* <span class="title">expand</span><span class="params">(ValueType* entry = <span class="literal">nullptr</span>)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span> </span>&#123; rehash(m_tableSize / <span class="number">2</span>, <span class="literal">nullptr</span>); &#125;</div><div class="line"></div><div class="line">        <span class="function">ValueType* <span class="title">rehash</span><span class="params">(<span class="keyword">unsigned</span> newTableSize, ValueType* entry)</span></span>;</div><div class="line">        <span class="function">ValueType* <span class="title">reinsert</span><span class="params">(ValueType&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeBucket</span><span class="params">(ValueType&amp; bucket)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteBucket</span><span class="params">(ValueType&amp; bucket)</span> </span>&#123; hashTraitsDeleteBucket&lt;Traits&gt;(bucket); &#125;</div><div class="line"></div><div class="line">        <span class="function">FullLookupType <span class="title">makeLookupResult</span><span class="params">(ValueType* position, <span class="keyword">bool</span> found, <span class="keyword">unsigned</span> hash)</span></span></div><div class="line">            &#123; <span class="keyword">return</span> FullLookupType(LookupType(position, found), hash); &#125;</div><div class="line"></div><div class="line">        <span class="function">iterator <span class="title">makeIterator</span><span class="params">(ValueType* pos)</span> </span>&#123; <span class="keyword">return</span> iterator(<span class="keyword">this</span>, pos, m_table + m_tableSize); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">makeConstIterator</span><span class="params">(ValueType* pos)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> const_iterator(<span class="keyword">this</span>, pos, m_table + m_tableSize); &#125;</div><div class="line">        <span class="function">iterator <span class="title">makeKnownGoodIterator</span><span class="params">(ValueType* pos)</span> </span>&#123; <span class="keyword">return</span> iterator(<span class="keyword">this</span>, pos, m_table + m_tableSize, HashItemKnownGood); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">makeKnownGoodConstIterator</span><span class="params">(ValueType* pos)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> const_iterator(<span class="keyword">this</span>, pos, m_table + m_tableSize, HashItemKnownGood); &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !ASSERT_DISABLED</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">checkTableConsistencyExceptSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkTableConsistencyExceptSize</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_HASHTABLE_ITERATORS</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">invalidateIterators</span><span class="params">()</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invalidateIterators</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> m_maxLoad = <span class="number">2</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> m_minLoad = <span class="number">6</span>;</div><div class="line"></div><div class="line">        ValueType* m_table;</div><div class="line">        <span class="keyword">unsigned</span> m_tableSize;</div><div class="line">        <span class="keyword">unsigned</span> m_tableSizeMask;</div><div class="line">        <span class="keyword">unsigned</span> m_keyCount;</div><div class="line">        <span class="keyword">unsigned</span> m_deletedCount;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_HASHTABLE_ITERATORS</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// All access to m_iterators should be guarded with m_mutex.</span></div><div class="line">        <span class="keyword">mutable</span> const_iterator* m_iterators;</div><div class="line">        <span class="comment">// Use std::unique_ptr so HashTable can still be memmove'd or memcpy'ed.</span></div><div class="line">        <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Lock&gt; m_mutex;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DUMP_HASHTABLE_STATS_PER_TABLE</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stats&gt; m_stats;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>完整具体的实现可以查看 WTF/Source/wtf/HashTable.h。这里需要注意的是 HashTable 是线性存储空间的起始地址是 bengin 和 end 来表示的，capacity 存储空间不足时会使用 doubleHash 的方法来扩容，将原空间大小变成两倍。调用 begin 或 end 时会创建 HashTable 的 const_iterator，它维持了一个指向 value_type 的指针，所以 iterator 的自增和自减就是指针的自增自减，这点比 STL 的 HashMap 采用数组加链表实现要简单。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>WebKit 对线程的处理就是在一个 loop 循环里处理消息队列，在 WTF/Source/wtf/MessageQueue.h 里有对消息队列的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The queue takes ownership of messages and transfer it to the new owner</span></div><div class="line"><span class="comment">// when messages are fetched from the queue.</span></div><div class="line"><span class="comment">// Essentially, MessageQueue acts as a queue of std::unique_ptr&lt;DataType&gt;.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> &#123;</span></div><div class="line">    WTF_MAKE_NONCOPYABLE(MessageQueue);</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MessageQueue() : m_killed(<span class="literal">false</span>) &#123; &#125;</div><div class="line">    ~MessageQueue();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendAndKill</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">appendAndCheckEmpty</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepend</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;)</span></span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt; waitForMessage();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt; tryGetMessage();</div><div class="line">    Deque&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;&gt; takeAllMessages();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt; tryGetMessageIgnoringKilled();</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt; waitForMessageFilteredWithTimeout(MessageQueueWaitResult&amp;, Predicate&amp;&amp;, WallTime absoluteTime);</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeIf</span><span class="params">(Predicate&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">killed</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// The result of isEmpty() is only valid if no other thread is manipulating the queue at the same time.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//m_mutex 是访问 Deque 的互斥锁，是对 pthread_mutex_t 类型的一个封装</span></div><div class="line">    <span class="keyword">mutable</span> Lock m_mutex;</div><div class="line">    </div><div class="line">    <span class="comment">//Condition 是对 pthread_cond_t 类型的封装，m_condition 提供了挂起线程</span></div><div class="line">    Condition m_condition;</div><div class="line">    </div><div class="line">    <span class="comment">//内部主要存储结构</span></div><div class="line">    Deque&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;&gt; m_queue;</div><div class="line">    <span class="keyword">bool</span> m_killed;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看出 MessageQueue 是通过 pthread_mutex_t 来保证线程安全的。WebKit 在运行时会有很多线程，有网络资源加载的线程，解析页面布局的线程，绘制线程，I/O 线程，解码线程等线程。最核心的是解析页面布局线程，其它线程都由它触发，所以可以称为主线程，这个线程在 Mac 端是 MainThread 定义和实现的，在 iOS 端是 WebCoreThread 定义实现的。这些定义比如 callOnMainThread 就是其它异步线程做回调时调用的函数。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>主要作用就是加载资源，有 MainResourceLoader 和 SubResourceLoader。加载的资源有来自网络，本地或者缓存的。Loader 模块本身是平台无关的，只是将需要获得资源的请求传给平台相关的网络模块，接受网络模块返回资源。平台相关的网络模块在 WebCore/platform/network 里。如果是 iOS 就在 WebCore/platform/network/iOS 里，如果 Mac 就在 WebCore/platform/network/mac 里。</p>
<h3 id="Loader-的资源"><a href="#Loader-的资源" class="headerlink" title="Loader 的资源"></a>Loader 的资源</h3><p>网页本身就是一种资源，同时网页还需要其它的一些资源，比如图片，视频，js 代码等。下面是主要资源的类型：</p>
<ul>
<li>HTML：页面主文件</li>
<li>JavaScript：单独的文件后者直接在 HTML 代码里</li>
<li>CSS：同 JavaScript 一样可以是单独文件也可以直接写在 HTML 代码里</li>
<li>图片：各种编码图片比如 jpg 和 png</li>
<li>SVG：矢量图片</li>
<li>CSS Shader：为 CSS 带来 3D 图形特性</li>
<li>音频视频：多媒体资源以及视频字幕</li>
<li>字体：自定义的字体</li>
<li>XSL：对 XSLT 语言编写的文件支持</li>
</ul>
<p>WebKit 里会有不同的类来表示这些资源，它们都会有个共同的基类 CachedResource。如下图所示，其中 HTML 的资源类型是 CachedRawResource 类，类型叫 MainResource 类。<br><img src="/uploads/deeply-analyse-webkit/50.png" alt="50"></p>
<h3 id="FrameLoader"><a href="#FrameLoader" class="headerlink" title="FrameLoader"></a>FrameLoader</h3><p>加载的入口，最终会调到异步 load 过程。主要是提供一个下载一个 Frame 的一些接口。任何一个页面都需要至少一个 mainframe，因此 load 一般都是从 load 一个 mainframe 开始。<br><img src="/uploads/deeply-analyse-webkit/07.png" alt="07"><br><img src="/uploads/deeply-analyse-webkit/39.png" alt="39"></p>
<ul>
<li>MainResourceLoader：加载资源，html 也是资源，还有 css，javascript 和 image 等这些是 SubresourceLoader 来管理的。</li>
<li>CacheResourceLoader：缓存资源读取。</li>
<li>资源加载和缓存是由 ResourceLoader 和 Cache 这两个独立性高的模块来实现。</li>
<li>DocumentWriter：辅助类，将获取的数据写到 writer 里，会创建 DOM 树的根节点 HTMLDocument 对象，作为一个缓冲区进行 DocumentParser 解析操作，同时该类还包含了文档字符解码类和 HTMLDocumentParser 类。</li>
</ul>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><img src="/uploads/deeply-analyse-webkit/08.png" alt="08"></p>
<p>解析前会创建不同的 Dcoument，DocumentLoader 的 commitData 第一次收到数据时会调 DcumentWriter 的 begin，这个 begin 会调用 DocumentWriter::createDocument 创建一个 Document 对象。</p>
<p>这里创建的对象会根据 URL 来创建不同的 Document，这里有 HTMLDocument ，详细实现可以看看 DOMImplementation::createDocument 的实现。</p>
<p>整个资源加载过程，这篇文章有详细的介绍：<a href="https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/" target="_blank" rel="external">https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/</a></p>
<h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><p><img src="/uploads/deeply-analyse-webkit/30.png" alt="30"><br><img src="/uploads/deeply-analyse-webkit/77.png" alt="77"><br><img src="/uploads/deeply-analyse-webkit/78.png" alt="78"></p>
<ul>
<li>Frame 和 FrameLoaderClient：在 Frame 的构造函数中调用 FrameLoader 的构造函数需要传入 Frame 指针和 FrameLoaderClient 指针。一般作为不同平台适配代码，控制 WebKit 的使用逻辑。FrameLoader 会把加载过程的状态，还有结果等信息传递给 FrameLoaderClient，这样的话 FrameLoaderClient 就能够掌控 FrameLoader 的动作。</li>
<li>SubFrameLoader：维护子 Frame。</li>
<li>DocumentWriter：有一个 m_writer 对象在 Frame 的数据 load 完成时进行下一步比如解码处理。</li>
<li>DocumentLoader：FrameLoader 会维护三个 DocumentLoader。m_policyDocumentLoader 是 policy check 的阶段。m_provisionalDocumentLoader 会负责 startLoadingMainResource 的调用。m_documentLoader 是数据到了后使用的，前一个 Frame 的 DocumentLoader 不能再用。</li>
<li>HistoryController：管理历史记录，保存和恢复 Document 和 Page 的状态到 HistoryItem，维护浏览页面的前进后退队列，这样就可以实现前进和后退等操作。FrameLoader 通过 HistoryController 来操作 m_backForwardController 对象。</li>
<li>ResourceLoadNotifier：当 ResourceLoader 有变化时来通知 FrameLoader，用于它们之间的通信。</li>
<li>SubframeLoader：用来控制 MainFrame 里的 iframe 的加载。</li>
<li>FrameLoaderStateMachine：描述 FrameLoader 处理 DocumentLoader 的节点的状态，看是在创建状态还是显示状态。</li>
<li>PolicyChecker：对 FrameLoader 做校验，有三种，第一种 NewWindow Policy，指对新开 tab 或 window 时校验。第二种 NavigationPolicy 是对页面请求的校验。第三种 ContentPolicy 是对请求收到的数据判断 Mime type 等的校验。PolicyChecker 会提供对应几口，由 FrameLoaderClient 来对这些请求校验确定是否继续加载或者做其它操作。</li>
</ul>
<h3 id="FrameLoader-的主要接口"><a href="#FrameLoader-的主要接口" class="headerlink" title="FrameLoader 的主要接口"></a>FrameLoader 的主要接口</h3><h4 id="Frame-init"><a href="#Frame-init" class="headerlink" title="Frame::init"></a>Frame::init</h4><p>FrameLoader 自身的初始化。<br>初始化的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WebFrame::WebFrame(webPage* parent,WebFrameData *frameData)</div><div class="line">WebFramePrivate::init(WebFrame* webframe,WebFrameData* frameData)</div><div class="line">Frame::init()</div><div class="line">FrameLoader::init()</div></pre></td></tr></table></figure></p>
<h4 id="FrameLoader-commitProvisionalLoad"><a href="#FrameLoader-commitProvisionalLoad" class="headerlink" title="FrameLoader::commitProvisionalLoad"></a>FrameLoader::commitProvisionalLoad</h4><p>提交 provisional 阶段时下载的数据<br>完成 Document loading 的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DocumentLoader::finishLoading</div><div class="line">DocumentLoader::commitIfReady</div><div class="line">FrameLoader::commitProvisionalLoad</div></pre></td></tr></table></figure></p>
<p>资源数据接受提交调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ResourceLoader::didReceiveData</div><div class="line">MainResourceLoader::addData</div><div class="line">DocumentLoader::receiveData</div><div class="line">DocumentLoader::commitLoad</div><div class="line">DocumentLoader::commitIfReady</div><div class="line">DocumentLoader::commitProvisionalLoad</div></pre></td></tr></table></figure></p>
<h4 id="Frame-finishedLoading"><a href="#Frame-finishedLoading" class="headerlink" title="Frame::finishedLoading"></a>Frame::finishedLoading</h4><p>网络加载完成的接口，作用是通知 DocumentLoader 和 DocumentWriter 已经完成，可以进行后面的提交数据和解析工作。<br>函数的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ResourceLoader::didFinishLoading</div><div class="line">MainResourceLoader::didFinishLoading</div><div class="line">FrameLoader::finishedLoading</div><div class="line">FrameLoader::init()</div></pre></td></tr></table></figure></p>
<h4 id="FrameLoader-finishedParsing"><a href="#FrameLoader-finishedParsing" class="headerlink" title="FrameLoader::finishedParsing"></a>FrameLoader::finishedParsing</h4><p>完成解析时调用的接口<br>调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DocumentWritter::end</div><div class="line">Document::finishParsing</div><div class="line">Document::finishedParsing</div><div class="line">FrameLoader::finishedParsing</div></pre></td></tr></table></figure></p>
<h4 id="FrameLoader-load-FrameLoadRequest-amp-amp-request"><a href="#FrameLoader-load-FrameLoadRequest-amp-amp-request" class="headerlink" title="FrameLoader::load(FrameLoadRequest&amp;&amp; request)"></a>FrameLoader::load(FrameLoadRequest&amp;&amp; request)</h4><p>加载请求，将 Frame 相关的数据封装成 ResourceRequest 作为参数带入，这个接口会创建出 DocumentLoader。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建 DocumentLoader</span></div><div class="line"><span class="keyword">void</span> FrameLoader::load(FrameLoadRequest&amp;&amp; request)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (m_inStopAllLoaders)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!request.frameName().isEmpty()) &#123;</div><div class="line">        Frame* frame = findFrameForNavigation(request.frameName());</div><div class="line">        <span class="keyword">if</span> (frame) &#123;</div><div class="line">            request.setShouldCheckNewWindowPolicy(<span class="literal">false</span>);</div><div class="line">            <span class="keyword">if</span> (&amp;frame-&gt;loader() != <span class="keyword">this</span>) &#123;</div><div class="line">                frame-&gt;loader().load(WTFMove(request));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (request.shouldCheckNewWindowPolicy()) &#123;</div><div class="line">        NavigationAction action &#123; request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() &#125;;</div><div class="line">        policyChecker().checkNewWindowPolicy(WTFMove(action), request.resourceRequest(), <span class="literal">nullptr</span>, request.frameName(), [<span class="keyword">this</span>] (<span class="keyword">const</span> ResourceRequest&amp; request, FormState* formState, <span class="keyword">const</span> String&amp; frameName, <span class="keyword">const</span> NavigationAction&amp; action, <span class="keyword">bool</span> shouldContinue) &#123;</div><div class="line">            continueLoadAfterNewWindowPolicy(request, formState, frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!request.hasSubstituteData())</div><div class="line">        request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));</div><div class="line">    <span class="comment">//FrameLoader 使用空 SubStituteData 来创建 DocumentLoader 完成 MainResource 的加载。</span></div><div class="line">    Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());</div><div class="line">    applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);</div><div class="line"></div><div class="line">    load(loader.ptr());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//完善 request 信息</span></div><div class="line"><span class="keyword">void</span> FrameLoader::load(DocumentLoader* newDocumentLoader)</div><div class="line">&#123;</div><div class="line">    ResourceRequest&amp; r = newDocumentLoader-&gt;request();</div><div class="line">    <span class="comment">//ResourceRequest 包含了 HTTP Header 的内容，addExtraFieldsToMainResourceRequest 这个方法会添加一些类似 Cookie 策略，User Agent，Cache-Control，Content-type 等信息。</span></div><div class="line">    addExtraFieldsToMainResourceRequest(r);</div><div class="line">    FrameLoadType type;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;originalRequest().url())) &#123;</div><div class="line">        r.setCachePolicy(ReloadIgnoringCacheData);</div><div class="line">        type = FrameLoadType::Same;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;unreachableURL()) &amp;&amp; m_loadType == FrameLoadType::Reload)</div><div class="line">        type = FrameLoadType::Reload;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; !newDocumentLoader-&gt;unreachableURL().isEmpty() &amp;&amp; newDocumentLoader-&gt;substituteData().isValid())</div><div class="line">        type = FrameLoadType::RedirectWithLockedBackForwardList;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        type = FrameLoadType::Standard;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_documentLoader)</div><div class="line">        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (shouldReloadToHandleUnreachableURL(newDocumentLoader)) &#123;</div><div class="line">        history().saveDocumentAndScrollState();</div><div class="line">        ASSERT(type == FrameLoadType::Standard);</div><div class="line">        type = FrameLoadType::Reload;</div><div class="line">    &#125;</div><div class="line">    loadWithDocumentLoader(newDocumentLoader, type, <span class="number">0</span>, AllowNavigationToInvalidURL::Yes);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//校验检查</span></div><div class="line"><span class="keyword">void</span> FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, FormState* formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Retain because dispatchBeforeLoadEvent may release the last reference to it.</span></div><div class="line">    Ref&lt;Frame&gt; protect(m_frame);</div><div class="line"></div><div class="line">    ASSERT(m_client.hasWebView());</div><div class="line">    ASSERT(m_frame.view());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!isNavigationAllowed())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_frame.document())</div><div class="line">        m_previousURL = m_frame.document()-&gt;url();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> URL&amp; newURL = loader-&gt;request().url();</div><div class="line">    <span class="comment">// Log main frame navigation types.</span></div><div class="line">    <span class="keyword">if</span> (m_frame.isMainFrame()) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span>* page = m_frame.page())</div><div class="line">            page-&gt;mainFrameLoadStarted(newURL, type);</div><div class="line"><span class="keyword">static_cast</span>&lt;MainFrame&amp;&gt;(m_frame).performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    policyChecker().setLoadType(type);</div><div class="line">    <span class="keyword">bool</span> isFormSubmission = formState;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> String&amp; httpMethod = loader-&gt;request().httpMethod();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) &#123;</div><div class="line">        RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;</div><div class="line">        NavigationAction action &#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;;</div><div class="line"></div><div class="line">        oldDocumentLoader-&gt;setTriggeringAction(action);</div><div class="line">        oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());</div><div class="line">        policyChecker().stopCheck();</div><div class="line">        policyChecker().checkNavigationPolicy(loader-&gt;request(), <span class="literal">false</span> <span class="comment">/* didReceiveRedirectResponse */</span>, oldDocumentLoader.get(), formState, [<span class="keyword">this</span>] (<span class="keyword">const</span> ResourceRequest&amp; request, FormState*, <span class="keyword">bool</span> shouldContinue) &#123;</div><div class="line">            continueFragmentScrollAfterNavigationPolicy(request, shouldContinue);</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Frame* parent = m_frame.tree().parent())</div><div class="line">        loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());</div><div class="line"></div><div class="line">    policyChecker().stopCheck();</div><div class="line">    </div><div class="line">    <span class="comment">//把 DocumentLoader 赋给 m_policyDocumentLoader</span></div><div class="line">    setPolicyDocumentLoader(loader);</div><div class="line">    </div><div class="line">    <span class="comment">//将请求信息记在 loader.m_triggeringAction 中</span></div><div class="line">    <span class="keyword">if</span> (loader-&gt;triggeringAction().isEmpty())</div><div class="line">        loader-&gt;setTriggeringAction(&#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Element* ownerElement = m_frame.ownerElement()) &#123;</div><div class="line">        <span class="keyword">if</span> (!m_stateMachine.committedFirstRealDocumentLoad()</div><div class="line">            &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().<span class="built_in">string</span>())) &#123;</div><div class="line">            continueLoadAfterNavigationPolicy(loader-&gt;request(), formState, <span class="literal">false</span>, allowNavigationToInvalidURL);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//使用 loader.m_triggeringAction 做校验，处理空白等，用来决定怎么处理请求</span></div><div class="line">    policyChecker().checkNavigationPolicy(loader-&gt;request(), <span class="literal">false</span> <span class="comment">/* didReceiveRedirectResponse */</span>, loader, formState, [<span class="keyword">this</span>, allowNavigationToInvalidURL] (<span class="keyword">const</span> ResourceRequest&amp; request, FormState* formState, <span class="keyword">bool</span> shouldContinue) &#123;</div><div class="line">        <span class="comment">//shouldContinue 的不同流程会不同，formState 是用来判断 HTMLFormElement 表单 FormSubmissionTrigger 枚举状态的，这样也会有不同的流程，接下来看看 continueLoadAfterNavigationPolicy 会怎么去处理这些参数不同的值吧。</span></div><div class="line">        continueLoadAfterNavigationPolicy(request, formState, shouldContinue, allowNavigationToInvalidURL);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">void</span> FrameLoader::continueLoadAfterNavigationPolicy(<span class="keyword">const</span> ResourceRequest&amp; request, FormState* formState, <span class="keyword">bool</span> shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// If we loaded an alternate page to replace an unreachableURL, we'll get in here with a</span></div><div class="line">    <span class="comment">// nil policyDataSource because loading the alternate page will have passed</span></div><div class="line">    <span class="comment">// through this method already, nested; otherwise, policyDataSource should still be set.</span></div><div class="line">    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();</div><div class="line"></div><div class="line">    <span class="comment">// Three reasons we can't continue:</span></div><div class="line">    <span class="comment">//    1) Navigation policy delegate said we can't so request is nil. A primary case of this </span></div><div class="line">    <span class="comment">//       is the user responding Cancel to the form repost nag sheet.</span></div><div class="line">    <span class="comment">//    2) User responded Cancel to an alert popped up by the before unload event handler.</span></div><div class="line">    <span class="comment">//    3) The request's URL is invalid and navigation to invalid URLs is disallowed.</span></div><div class="line">    <span class="keyword">bool</span> canContinue = shouldContinue &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!canContinue) &#123;</div><div class="line">        <span class="comment">// If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we </span></div><div class="line">        <span class="comment">// need to report that the client redirect was cancelled.</span></div><div class="line">        <span class="comment">// <span class="doctag">FIXME:</span> The client should be told about ignored non-quick redirects, too.</span></div><div class="line">        <span class="keyword">if</span> (m_quickRedirectComing)</div><div class="line">            clientRedirectCancelledOrFinished(<span class="literal">false</span>);</div><div class="line"></div><div class="line">        setPolicyDocumentLoader(<span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">        <span class="comment">// If the navigation request came from the back/forward menu, and we punt on it, we have the </span></div><div class="line">        <span class="comment">// problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,</span></div><div class="line">        <span class="comment">// we only do this when punting a navigation for the target frame or top-level frame.  </span></div><div class="line">        <span class="keyword">if</span> ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) &#123;</div><div class="line">            <span class="keyword">if</span> (Page* page = m_frame.page()) &#123;</div><div class="line">                <span class="keyword">if</span> (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem()) &#123;</div><div class="line">                    page-&gt;backForward().setCurrentItem(resetItem);</div><div class="line">                    m_frame.loader().client().updateGlobalHistoryItemForPage();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    FrameLoadType type = policyChecker().loadType();</div><div class="line">    <span class="comment">// A new navigation is in progress, so don't clear the history's provisional item.</span></div><div class="line">    stopAllLoaders(ShouldNotClearProvisionalItem);</div><div class="line">    </div><div class="line">    <span class="comment">// &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()</span></div><div class="line">    <span class="comment">// might detach the current FrameLoader, in which case we should bail on this newly defunct load. </span></div><div class="line">    <span class="keyword">if</span> (!m_frame.page())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//把 DocumentLoader 赋值给 m_provisionalDocumentLoader</span></div><div class="line">    setProvisionalDocumentLoader(m_policyDocumentLoader.get());</div><div class="line">    m_loadType = type;</div><div class="line">    <span class="comment">//设置 FrameLoader 状态为 Provisional</span></div><div class="line">    setState(FrameStateProvisional);</div><div class="line"></div><div class="line">    setPolicyDocumentLoader(<span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isBackForwardLoadType(type)) &#123;</div><div class="line">        <span class="keyword">auto</span>&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();</div><div class="line">        <span class="keyword">if</span> (history().provisionalItem()-&gt;isInPageCache()) &#123;</div><div class="line">            diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);</div><div class="line">            loadProvisionalItemFromCachedPage();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!formState) &#123;</div><div class="line">        continueLoadAfterWillSubmitForm();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_client.dispatchWillSubmitForm(*formState, [<span class="keyword">this</span>] (PolicyAction action) &#123;</div><div class="line">        policyChecker().continueLoadAfterWillSubmitForm(action);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着在 continueLoadAfterWillSubmitForm() 方法里 m_provisionalDocumentLoader 会做些准备工作并将状态设置成正在加载资源的状态。在 prepareForLoadStart 中抛出加载状态，回调给 FrameLoaderClient，调用 DocumentLoader 的 startLoadingMainResource。</p>
<h3 id="WebKit-网络处理"><a href="#WebKit-网络处理" class="headerlink" title="WebKit 网络处理"></a>WebKit 网络处理</h3><p>WebKit 资源的加载都是由其移植方实现的，网络部分代码都在 WebCore/platform/network 里，里面包含了 HTTP Header，MIME，状态码等信息的处理。</p>
<h3 id="ResourceHandle-的相关类"><a href="#ResourceHandle-的相关类" class="headerlink" title="ResourceHandle 的相关类"></a>ResourceHandle 的相关类</h3><p><img src="/uploads/deeply-analyse-webkit/31.png" alt="31"></p>
<ul>
<li>ResouceHandleClient：跟网络传输过程相关，是网络事件对应的回调。</li>
<li>MainResourceLoader：主资源，指的 HTML 页面，会立刻发起，下载失败会向用户报错。没有缓存</li>
<li>SubResourceLoader：派生资源，HTML 页面里内嵌的图片和脚本链接等，会通过 ResourceScheduler 这个类来管理资源加载调度。下载失败不向用户报错。有缓存机制，通过 ResourceCach 保存 CSS JS 等资源原始数据以及解码后的图片数据，一方面可以节省流量一方面可以节省解码时间。</li>
<li>ResourceLoader：是主资源和派生资源加载器的基类，会通过 ResourceNotifier 将回调传给 FrameLoaderClient。</li>
</ul>
<h3 id="ResourceHandleClient"><a href="#ResourceHandleClient" class="headerlink" title="ResourceHandleClient"></a>ResourceHandleClient</h3><p>ResourceHandleClient 定义了一些对应网络加载事件回调处理的虚函数。下面就是 ResourceHandleClient 的定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceHandleClient</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="title">ResourceHandleClient</span><span class="params">()</span></span>;</div><div class="line">    WEBCORE_EXPORT <span class="keyword">virtual</span> ~ResourceHandleClient();</div><div class="line"></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> ResourceRequest <span class="title">willSendRequest</span><span class="params">(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didSendData</span><span class="params">(ResourceHandle*, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="comment">/*bytesSent*/</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="comment">/*totalBytesToBeSent*/</span>)</span> </span>&#123; &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//收到服务器端第一个响应包，通过里面的 HTTP Header 可以判断是否成功</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveResponse</span><span class="params">(ResourceHandle*, ResourceResponse&amp;&amp;)</span> </span>&#123; &#125;</div><div class="line">    <span class="comment">//收到服务器端包含请求数据的响应包</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveData</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">unsigned</span>, <span class="keyword">int</span> <span class="comment">/*encodedDataLength*/</span>)</span> </span>&#123; &#125;</div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveBuffer</span><span class="params">(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, <span class="keyword">int</span> encodedDataLength)</span></span>;</div><div class="line">    <span class="comment">//接受过程结束</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didFinishLoading</span><span class="params">(ResourceHandle*)</span> </span>&#123; &#125;</div><div class="line">    <span class="comment">//接受失败</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didFail</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> ResourceError&amp;)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">wasBlocked</span><span class="params">(ResourceHandle*)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cannotShowURL</span><span class="params">(ResourceHandle*)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">usesAsyncCallbacks</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">loadingSynchronousXHR</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Client will pass an updated request using ResourceHandle::continueWillSendRequest() when ready.</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">willSendRequestAsync</span><span class="params">(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Client will call ResourceHandle::continueDidReceiveResponse() when ready.</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveResponseAsync</span><span class="params">(ResourceHandle*, ResourceResponse&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(PROTECTION_SPACE_AUTH_CALLBACK)</span></div><div class="line">    <span class="comment">// Client will pass an updated request using ResourceHandle::continueCanAuthenticateAgainstProtectionSpace() when ready.</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">canAuthenticateAgainstProtectionSpaceAsync</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> ProtectionSpace&amp;)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// Client will pass an updated request using ResourceHandle::continueWillCacheResponse() when ready.</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(CFURLCONNECTION)</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">willCacheResponseAsync</span><span class="params">(ResourceHandle*, CFCachedURLResponseRef)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> PLATFORM(COCOA)</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">willCacheResponseAsync</span><span class="params">(ResourceHandle*, NSCachedURLResponse *)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(SOUP)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span>* <span class="title">getOrCreateReadBuffer</span><span class="params">(<span class="keyword">size_t</span> <span class="comment">/*requestedLength*/</span>, <span class="keyword">size_t</span>&amp; <span class="comment">/*actualLength*/</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">shouldUseCredentialStorage</span><span class="params">(ResourceHandle*)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveAuthenticationChallenge</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> AuthenticationChallenge&amp;)</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(PROTECTION_SPACE_AUTH_CALLBACK)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canAuthenticateAgainstProtectionSpace</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> ProtectionSpace&amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">receivedCancellation</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> AuthenticationChallenge&amp;)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS) || USE(CFURLCONNECTION)</span></div><div class="line">    <span class="keyword">virtual</span> RetainPtr&lt;CFDictionaryRef&gt; connectionProperties(ResourceHandle*) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(CFURLCONNECTION)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> CFCachedURLResponseRef <span class="title">willCacheResponse</span><span class="params">(ResourceHandle*, CFCachedURLResponseRef response)</span> </span>&#123; <span class="keyword">return</span> response; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(WIN)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">shouldCacheResponse</span><span class="params">(ResourceHandle*, CFCachedURLResponseRef)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PLATFORM(WIN)</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> PLATFORM(COCOA)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> NSCachedURLResponse *<span class="title">willCacheResponse</span><span class="params">(ResourceHandle*, NSCachedURLResponse *response)</span> </span>&#123; <span class="keyword">return</span> response; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>与 ResourceHandleClient 相关的类如下<br><img src="/uploads/deeply-analyse-webkit/80.png" alt="80"></p>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><p><img src="/uploads/deeply-analyse-webkit/98.png" alt="98"></p>
<p><img src="/uploads/deeply-analyse-webkit/32.png" alt="32"></p>
<h4 id="MainResourceLoader-的加载顺序"><a href="#MainResourceLoader-的加载顺序" class="headerlink" title="MainResourceLoader 的加载顺序"></a>MainResourceLoader 的加载顺序</h4><p>MainResourceLoader 加载的是 html 文本资源。<br><img src="/uploads/deeply-analyse-webkit/79.png" alt="79"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">MainResourceLoader::load</div><div class="line">MainResourceLoader::loadNow</div><div class="line">MainResourceLoader::willSendRequest</div><div class="line">ResourceLoader::willSendRequest <span class="comment">//基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient 这样可以操作 ResourceRequest 来做些设置 request header 的操作。</span></div><div class="line">PolicyChecker::checkNavigationPolicy <span class="comment">//检查 NavigationPolicy 可以过滤一些重复的请求</span></div><div class="line">ResourceHandle::create 开始发网络请求</div><div class="line">MainResourceLoader::didReceiveResponse <span class="comment">//主资源收到第一个 HTTP 的响应回调，处理 HTTP header</span></div><div class="line">PolicyChecker:: checkContentPolicy <span class="comment">//进行 ContentPolicy 的检查，通过 dispatchDecidePolicyForMIMEType 来判断是否是下载的请求</span></div><div class="line">MainResourceLoader::continueAfterContentPolicy <span class="comment">//看看 ContentPolicy 检查后是否有错误</span></div><div class="line">ResourceLoader::didReceiveResponse <span class="comment">//基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient</span></div><div class="line">MainResourceLoader::didReceiveData <span class="comment">//主资源开始接受 body 数据</span></div><div class="line">ResourceLoader::didReceiveData <span class="comment">//基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient</span></div><div class="line">MainResourceLoader::addData</div><div class="line">DocumentLoader::receivedData</div><div class="line">DocumentLoader::commitLoad</div><div class="line">FrameLoader::commitProvisionalLoad <span class="comment">//从 provisional 状态到 Committed 状态</span></div><div class="line">FrameLoaderClientQt::committedLoad</div><div class="line">DocumentLoader::commitData</div><div class="line">DocumentWriter::setEncoding</div><div class="line">DocumentWriter::addData</div><div class="line">DocumentParser::appendByte</div><div class="line">DecodedDataDocumentParser::appendBytes <span class="comment">//编码处理</span></div><div class="line">HTMLDocumentParser::append <span class="comment">//解析 HTML</span></div><div class="line">MainResourceLoader::didFinishLoading</div><div class="line">FrameLoader::finishedLoading</div><div class="line">DocumentLoader::finishedLoading</div><div class="line">FrameLoader::finishedLoadingDocument</div><div class="line">DocumentWriter::end</div><div class="line">Document::finishParsing</div><div class="line">HTMLDocumentParser::finish</div></pre></td></tr></table></figure>
<p>在收到第一个响应包后会回调给 MainResourceLoader 的 didReceiveResponse 函数处理 Header 使用 PolicyChecker 的 checkContentPolicy 做校验，当 PolicyAction 为 PolicyUse 回调给 MainResourceLoader 的 continueAfterContentPolicy。结果 ResourceResponse 会通过 ResourceNotifier 通知给外部接受回调的不同平台的 FrameLoaderClient。</p>
<p>在收到后面的带数据的响应包会回调给 MainResourceLoader 的 didReceiveData，通过 ResourceLoader 的 addDataOrBuffer 把收到的数据存到 m_resourceData 里。下面是 addDataOrBuffer 方法的实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ResourceLoader::addDataOrBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">unsigned</span> length, SharedBuffer* buffer, DataPayloadType dataPayloadType)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (m_options.dataBufferingPolicy == DoNotBufferData)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!m_resourceData || dataPayloadType == DataPayloadWholeResource) &#123;</div><div class="line">        <span class="keyword">if</span> (buffer)</div><div class="line">            m_resourceData = buffer;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            m_resourceData = SharedBuffer::create(data, length);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (buffer)</div><div class="line">        m_resourceData-&gt;append(*buffer);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        m_resourceData-&gt;append(data, length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收到的 receiveData 会进入到 DocumentLoader 的 commitLoad 里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DocumentLoader::commitLoad(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">int</span> length)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource</span></div><div class="line">    <span class="comment">// by starting a new load, so retain temporarily.</span></div><div class="line">    RefPtr&lt;Frame&gt; protectedFrame(m_frame);</div><div class="line">    Ref&lt;DocumentLoader&gt; protectedThis(*<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    commitIfReady();</div><div class="line">    FrameLoader* frameLoader = DocumentLoader::frameLoader();</div><div class="line">    <span class="keyword">if</span> (!frameLoader)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)</span></div><div class="line">    <span class="keyword">if</span> (ArchiveFactory::isArchiveMimeType(response().mimeType()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">//FrameLoader 通过 transitionToCommitted 从 Provisional 的状态变为 Committed 状态</span></div><div class="line">    frameLoader-&gt;client().committedLoad(<span class="keyword">this</span>, data, length);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isMultipartReplacingLoad())</div><div class="line">        frameLoader-&gt;client().didReplaceMultipartContent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随后 DocumentLoader 执行 commitData 将前面的内容进行编码 encoding，这些数据会通过 DocumentParser 来解码，解码后的数据 会创建 HTMLDocument 和 Document 对象，后通过 DocumentWriter 传给 DocumentParser。这个过程会在 DocumentWriter 的 begin 方法里完成，具体实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DocumentWriter::begin(<span class="keyword">const</span> URL&amp; urlReference, <span class="keyword">bool</span> dispatch, Document* ownerDocument)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// We grab a local copy of the URL because it's easy for callers to supply</span></div><div class="line">    <span class="comment">// a URL that will be deallocated during the execution of this function.</span></div><div class="line">    <span class="comment">// For example, see &lt;https://bugs.webkit.org/show_bug.cgi?id=66360&gt;.</span></div><div class="line">    URL url = urlReference;</div><div class="line"></div><div class="line">    <span class="comment">// Create a new document before clearing the frame, because it may need to</span></div><div class="line">    <span class="comment">// inherit an aliased security context.</span></div><div class="line">    <span class="comment">//创建了 Document 对象</span></div><div class="line">    Ref&lt;Document&gt; document = createDocument(url);</div><div class="line">    </div><div class="line">    <span class="comment">// If the new document is for a Plugin but we're supposed to be sandboxed from Plugins,</span></div><div class="line">    <span class="comment">// then replace the document with one whose parser will ignore the incoming data (bug 39323)</span></div><div class="line">    <span class="keyword">if</span> (document-&gt;isPluginDocument() &amp;&amp; document-&gt;isSandboxed(SandboxPlugins))</div><div class="line">        document = SinkDocument::create(m_frame, url);</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Do we need to consult the content security policy here about blocked plug-ins?</span></div><div class="line"></div><div class="line">    <span class="keyword">bool</span> shouldReuseDefaultView = m_frame-&gt;loader().stateMachine().isDisplayingInitialEmptyDocument() &amp;&amp; m_frame-&gt;document()-&gt;isSecureTransitionTo(url);</div><div class="line">    <span class="keyword">if</span> (shouldReuseDefaultView)</div><div class="line">        document-&gt;takeDOMWindowFrom(m_frame-&gt;document());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        document-&gt;createDOMWindow();</div><div class="line"></div><div class="line">    <span class="comment">// Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, we need to retain an ongoing set of upgraded</span></div><div class="line">    <span class="comment">// requests in new navigation contexts. Although this information is present when we construct the</span></div><div class="line">    <span class="comment">// Document object, it is discard in the subsequent 'clear' statements below. So, we must capture it</span></div><div class="line">    <span class="comment">// so we can restore it.</span></div><div class="line">    HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; insecureNavigationRequestsToUpgrade;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span>* existingDocument = m_frame-&gt;document())</div><div class="line">        insecureNavigationRequestsToUpgrade = existingDocument-&gt;contentSecurityPolicy()-&gt;takeNavigationRequestsToUpgrade();</div><div class="line">    </div><div class="line">    m_frame-&gt;loader().clear(document.ptr(), !shouldReuseDefaultView, !shouldReuseDefaultView);</div><div class="line">    clear();</div><div class="line"></div><div class="line">    <span class="comment">// m_frame-&gt;loader().clear() might fire unload event which could remove the view of the document.</span></div><div class="line">    <span class="comment">// Bail out if document has no view.</span></div><div class="line">    <span class="keyword">if</span> (!document-&gt;view())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!shouldReuseDefaultView)</div><div class="line">        m_frame-&gt;script().updatePlatformScriptObjects();</div><div class="line"></div><div class="line">    m_frame-&gt;loader().setOutgoingReferrer(url);</div><div class="line">    m_frame-&gt;setDocument(document.copyRef());</div><div class="line"></div><div class="line">    document-&gt;contentSecurityPolicy()-&gt;setInsecureNavigationRequestsToUpgrade(WTFMove(insecureNavigationRequestsToUpgrade));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_decoder)</div><div class="line">        document-&gt;setDecoder(m_decoder.get());</div><div class="line">    <span class="keyword">if</span> (ownerDocument) &#123;</div><div class="line">        document-&gt;setCookieURL(ownerDocument-&gt;cookieURL());</div><div class="line">        document-&gt;setSecurityOriginPolicy(ownerDocument-&gt;securityOriginPolicy());</div><div class="line">        document-&gt;setStrictMixedContentMode(ownerDocument-&gt;isStrictMixedContentMode());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_frame-&gt;loader().didBeginDocument(dispatch);</div><div class="line"></div><div class="line">    document-&gt;implicitOpen();</div><div class="line"></div><div class="line">    <span class="comment">// We grab a reference to the parser so that we'll always send data to the</span></div><div class="line">    <span class="comment">// original parser, even if the document acquires a new parser (e.g., via</span></div><div class="line">    <span class="comment">// document.open).</span></div><div class="line">    m_parser = document-&gt;parser();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_frame-&gt;view() &amp;&amp; m_frame-&gt;loader().client().hasHTMLView())</div><div class="line">        m_frame-&gt;view()-&gt;setContentsSize(IntSize());</div><div class="line"></div><div class="line">    m_state = StartedWritingState;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Document 对象时 DOM 树的根节点，m_writer 在 addData 时会用 DocumentParser 来解码，这个解码是在 DecodedDataDocumentParser 的 appendBytes 里做的。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DecodedDataDocumentParser::appendBytes(DocumentWriter&amp; writer, <span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> length)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!length)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//解码 Loader 模块传来的字节流，解码后的 String 会被 HTMLDocumentParser 的 HTMLInputStream 所持有。</span></div><div class="line">    String decoded = writer.createDecoderIfNeeded()-&gt;decode(data, length);</div><div class="line">    <span class="keyword">if</span> (decoded.isEmpty())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="comment">//解码成功会交给 Parser 处理生成 DOM Tree，形成 Parser 和 MainResourceLoader 同步</span></div><div class="line">    writer.reportDataReceived();</div><div class="line">    append(decoded.releaseImpl());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数据接收完毕会回调 MainResourceLoader 的 didFinishLoading。接下来再调用 FrameLoader 的 finishedLoading 和 finishedLoadingDocument，调用 DocumentWriter 的 end。最后调用 Document 的 finishParsing，这样 MainResource 的加载完成。</p>
<p>下面看看解码的流程：<br><img src="/uploads/deeply-analyse-webkit/85.png" alt="85"><br>decoder 的类图如下:<br><img src="/uploads/deeply-analyse-webkit/86.png" alt="86"></p>
<h4 id="SubResourceLoader-的加载顺序"><a href="#SubResourceLoader-的加载顺序" class="headerlink" title="SubResourceLoader 的加载顺序"></a>SubResourceLoader 的加载顺序</h4><p>SubResourceLoader 加载的都是派生资源，加载派生资源的时序图如下：<br><img src="/uploads/deeply-analyse-webkit/81.png" alt="81"></p>
<p>会在创建 HTMLElement 设置 src 属性时会判断 tagName 是否是 img，是的话就会触发 SubResourceLoader。设置属性和判断的代码在 HTMLConstructionSite 这个类里，具体实现代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">RefPtr&lt;Element&gt; HTMLConstructionSite::createHTMLElementOrFindCustomElementInterface(AtomicHTMLToken&amp; token, JSCustomElementInterface** customElementInterface)</div><div class="line">&#123;</div><div class="line">    auto&amp; localName = token.name();</div><div class="line">    // FIXME: This can't use HTMLConstructionSite::createElement because we</div><div class="line">    // have to pass the current form element.  We should rework form association</div><div class="line">    // to occur after construction to allow better code sharing here.</div><div class="line">    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#create-an-element-for-the-token</div><div class="line">    Document&amp; ownerDocument = ownerDocumentForCurrentNode();</div><div class="line">    bool insideTemplateElement = !ownerDocument.frame();</div><div class="line">    //将 tagName 和节点构造创建成 HTMLImageElement</div><div class="line">    RefPtr&lt;Element&gt; element = HTMLElementFactory::createKnownElement(localName, ownerDocument, insideTemplateElement ? nullptr : form(), true);</div><div class="line">    if (UNLIKELY(!element)) &#123;</div><div class="line">        auto* window = ownerDocument.domWindow();</div><div class="line">        if (customElementInterface &amp;&amp; window) &#123;</div><div class="line">            auto* registry = window-&gt;customElementRegistry();</div><div class="line">            if (UNLIKELY(registry)) &#123;</div><div class="line">                if (auto* elementInterface = registry-&gt;findInterface(localName)) &#123;</div><div class="line">                    *customElementInterface = elementInterface;</div><div class="line">                    return nullptr;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        QualifiedName qualifiedName(nullAtom(), localName, xhtmlNamespaceURI);</div><div class="line">        if (Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid) &#123;</div><div class="line">            element = HTMLElement::create(qualifiedName, ownerDocument);</div><div class="line">            element-&gt;setIsCustomElementUpgradeCandidate();</div><div class="line">        &#125; else</div><div class="line">            element = HTMLUnknownElement::create(qualifiedName, ownerDocument);</div><div class="line">    &#125;</div><div class="line">    ASSERT(element);</div><div class="line"></div><div class="line">    // FIXME: This is a hack to connect images to pictures before the image has</div><div class="line">    // been inserted into the document. It can be removed once asynchronous image</div><div class="line">    // loading is working.</div><div class="line">    if (is&lt;HTMLPictureElement&gt;(currentNode()) &amp;&amp; is&lt;HTMLImageElement&gt;(*element))</div><div class="line">        downcast&lt;HTMLImageElement&gt;(*element).setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(currentNode()));</div><div class="line">    //设置属性，这里会判断是否是 src，如果 element 的 tagName 是 img 就会触发派生资源下载</div><div class="line">    setAttributes(*element, token, m_parserContentPolicy);</div><div class="line">    ASSERT(element-&gt;isHTMLElement());</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 HTMLImageElement 这个类里会用 parseAttribute 方法处理，在这个方法里判断到属性是 srcAttr 时会触发 selectImageSource 方法，方法实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HTMLImageElement::selectImageSource()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// First look for the best fit source from our &lt;picture&gt; parent if we have one.</span></div><div class="line">    ImageCandidate candidate = bestFitSourceFromPictureElement();</div><div class="line">    <span class="keyword">if</span> (candidate.isEmpty()) &#123;</div><div class="line">        <span class="comment">// If we don't have a &lt;picture&gt; or didn't find a source, then we use our own attributes.</span></div><div class="line">        <span class="keyword">auto</span> sourceSize = SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).<span class="built_in">string</span>(), document()).length();</div><div class="line">        candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);</div><div class="line">    &#125;</div><div class="line">    setBestFitURLAndDPRFromImageCandidate(candidate);</div><div class="line">    <span class="comment">//updateFromElementIgnoringPreviousError 是 ImageLoader 类的一个方法，它会调用 updateFromElement 方法来判断资源来源</span></div><div class="line">    m_imageLoader.updateFromElementIgnoringPreviousError();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SubResourceLoader 主要是转给 SubResourceLoaderClient 类来完成，如下图：<br><img src="/uploads/deeply-analyse-webkit/33.png" alt="33"></p>
<p>ResourceLoadScheduler 会对 SubResourceLoader 进行调度管理<br><img src="/uploads/deeply-analyse-webkit/34.png" alt="34"></p>
<ul>
<li>Document：会创建拥有一个 CachedResourceLoader 类的对象实例 m_cachedResourceLoader，这个类有访问派生资源的接口，比如 requestImage，requestCSSStyleSheet，requestUserCSSStyleSheet，requestScript，requestFont，requestXSLStyleSheet，requestLinkPrefetch 等。这里 requestImage 有条件判断，这样外部实现接口就可以通过设置不加载图片，达到很多浏览器里提供那种无图模式了。</li>
<li>CacheResourceLoader：会创建 CachedResourceRequest 对象发请求。在它的构造函数里会传入一个 CachedResource 对象作为参数。还会通过 m_requests 来记录资源请求数量，这样就可以把加载状态回调出去了。</li>
<li>MemoryCache：会维护一个 HashMap ，里面的 value 存储 CachedResource 类缓存的内容。HashMap 定义为 HashMap <string,cachedresource> m_resources;</string,cachedresource></li>
</ul>
<p>在 CachedResourceLoader 里会通过 resourceForUrl 在 Memory Cache 里找对应 url 对应的缓存资源，determineRevalidationPolicy 会返回一个枚举值用来确定用哪种方式加载资源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> RevalidationPolicy &#123; Use, Revalidate, Reload, Load &#125;;</div><div class="line">    <span class="function">RevalidationPolicy <span class="title">determineRevalidationPolicy</span><span class="params">(CachedResource::Type, CachedResourceRequest&amp;, CachedResource* existingResource, ForPreload, DeferOption)</span> <span class="keyword">const</span></span>;</div></pre></td></tr></table></figure></p>
<p>可以看到 RevalidationPolicy 有四种，Use，Revalidate，Reload 和 Load。Use 表示资源已经在缓存里可以直接使用。Revalidate 表示缓存资源已失效，需删除旧资源，重新在缓存里加新资源。Reload 表示已缓存但由于资源类型不同或者 Cache-control:no-cache 设置不用 Cache 的情况需要重新加载。Load 表示缓存里没有，需直接加载。这段逻辑处理在 CachedResourceLoader 里的 requestResource 里有实现，具体代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);</div><div class="line"><span class="keyword">switch</span> (policy) &#123;</div><div class="line"><span class="keyword">case</span> Reload:</div><div class="line">    memoryCache.remove(*resource);</div><div class="line">    FALLTHROUGH;</div><div class="line"><span class="keyword">case</span> Load:</div><div class="line">    <span class="keyword">if</span> (resource)</div><div class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());</div><div class="line">    resource = loadResource(type, WTFMove(request));</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> Revalidate:</div><div class="line">    <span class="keyword">if</span> (resource)</div><div class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());</div><div class="line">    resource = revalidateResource(WTFMove(request), *resource);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> Use:</div><div class="line">    ASSERT(resource);</div><div class="line">    <span class="keyword">if</span> (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) &#123;</div><div class="line">        resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request));</div><div class="line">        <span class="keyword">if</span> (resource-&gt;status() != CachedResource::Status::Cached)</div><div class="line">            policy = Load;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ResourceError error;</div><div class="line">        <span class="keyword">if</span> (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))</div><div class="line">            <span class="keyword">return</span> makeUnexpected(WTFMove(error));</div><div class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());</div><div class="line">        loadTiming.setResponseEnd(MonotonicTime::now());</div><div class="line"></div><div class="line">        memoryCache.resourceAccessed(*resource);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) &#123;</div><div class="line">            <span class="keyword">auto</span> resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());</div><div class="line">            <span class="keyword">if</span> (initiatorContext == InitiatorContext::Worker) &#123;</div><div class="line">                ASSERT(is&lt;CachedRawResource&gt;(resource.get()));</div><div class="line">                downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ASSERT(initiatorContext == InitiatorContext::Document);</div><div class="line">                m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame());</div><div class="line">                m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (forPreload == ForPreload::No)</div><div class="line">            resource-&gt;setLoadPriority(request.priority());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 CachedResourceLoader 的 loadResource 方法里会通过工厂方法 createResource 来创建不同的 CacheResource。</p>
<p>CachedResource 加载<br>CachedResource 实现了 RFC2616 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html" target="_blank" rel="external">https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html</a> 的 w3c 缓存标准，根据资源类型还派生出不同的子类如图所示：<br><img src="/uploads/deeply-analyse-webkit/35.png" alt="35"></p>
<p>会有一个 CachedResourceClient 的集合 m_clients 来记录所有的 CachedResource，同时 CachedResourceClientWalker 这个接口可以遍历这个集合。 CacheResource 会通过 CachedResourceClient::notifyFinished 接口来在数据都到位后来进行通知。</p>
<p>在 CachedResource 里 type 枚举定义了派生资源的类型，通过 defaultPriorityForResourceType 函数方法的返回可以看到各资源加载的优先级具体定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">    <span class="keyword">case</span> CachedResource::MainResource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::VeryHigh;</div><div class="line">    <span class="keyword">case</span> CachedResource::CSSStyleSheet:</div><div class="line">    <span class="keyword">case</span> CachedResource::Script:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::High;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(SVG_FONTS)</span></div><div class="line">    <span class="keyword">case</span> CachedResource::SVGFontResource:</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">case</span> CachedResource::MediaResource:</div><div class="line">    <span class="keyword">case</span> CachedResource::FontResource:</div><div class="line">    <span class="keyword">case</span> CachedResource::RawResource:</div><div class="line">    <span class="keyword">case</span> CachedResource::Icon:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::Medium;</div><div class="line">    <span class="keyword">case</span> CachedResource::ImageResource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::Low;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(XSLT)</span></div><div class="line">    <span class="keyword">case</span> CachedResource::XSLStyleSheet:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::High;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">case</span> CachedResource::SVGDocumentResource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::Low;</div><div class="line">    <span class="keyword">case</span> CachedResource::Beacon:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::VeryLow;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(LINK_PREFETCH)</span></div><div class="line">    <span class="keyword">case</span> CachedResource::LinkPrefetch:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::VeryLow;</div><div class="line">    <span class="keyword">case</span> CachedResource::LinkSubresource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::VeryLow;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(VIDEO_TRACK)</span></div><div class="line">    <span class="keyword">case</span> CachedResource::TextTrackResource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::Low;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    ASSERT_NOT_REACHED();</div><div class="line">    <span class="keyword">return</span> ResourceLoadPriority::Low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个加载的安排是通过 WebResourceLoadScheduler 里的 scheduleLoad 通过上面返回的优先级来的。当然这些实现和平台是相关的会根据不同平台有不同的处理，具体处理如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> WebResourceLoadScheduler::scheduleLoad(ResourceLoader* resourceLoader)</div><div class="line">&#123;</div><div class="line">    ASSERT(resourceLoader);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS)</span></div><div class="line">    <span class="comment">// If there's a web archive resource for this URL, we don't need to schedule the load since it will never touch the network.</span></div><div class="line">    <span class="keyword">if</span> (!isSuspendingPendingRequests() &amp;&amp; resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;iOSOriginalRequest().url())) &#123;</div><div class="line">        resourceLoader-&gt;startLoading();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">if</span> (resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;request().url())) &#123;</div><div class="line">        resourceLoader-&gt;start();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">//根据 url 创建 host，然后加到 ResourceLoadSchedule 的 m_hosts 属性里</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS)</span></div><div class="line">    HostInformation* host = hostForURL(resourceLoader-&gt;iOSOriginalRequest().url(), CreateIfNotFound);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    HostInformation* host = hostForURL(resourceLoader-&gt;url(), CreateIfNotFound);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    ResourceLoadPriority priority = resourceLoader-&gt;request().priority();</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> hadRequests = host-&gt;hasRequests();</div><div class="line">    <span class="comment">//把优先级存放到 host 的 m_requestsPending 属性里</span></div><div class="line">    host-&gt;schedule(resourceLoader, priority);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(COCOA) || USE(CFURLCONNECTION)</span></div><div class="line">    <span class="keyword">if</span> (ResourceRequest::resourcePrioritiesEnabled() &amp;&amp; !isSuspendingPendingRequests()) &#123;</div><div class="line">        <span class="comment">// Serve all requests at once to keep the pipeline full at the network layer.</span></div><div class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Does this code do anything useful, given that we also set maxRequestsInFlightPerHost to effectively unlimited on these platforms?</span></div><div class="line">        servePendingRequests(host, ResourceLoadPriority::VeryLow);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">//这里就是如何根据优先级来进行安排的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS)</span></div><div class="line">    <span class="keyword">if</span> ((priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;iOSOriginalRequest().url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &amp;&amp; !isSuspendingPendingRequests()) &#123;</div><div class="line">        <span class="comment">//重要资源立刻进行</span></div><div class="line">        servePendingRequests(host, priority);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">if</span> (priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &#123;</div><div class="line">        <span class="comment">//重要资源立刻进行</span></div><div class="line">        servePendingRequests(host, priority);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">// Handle asynchronously so early low priority requests don't</span></div><div class="line">    <span class="comment">// get scheduled before later high priority ones.</span></div><div class="line">    <span class="comment">//不重要的就延迟进行，然后根据优先级，由高到低依次加载</span></div><div class="line">    scheduleServePendingRequests();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>servePendingRequests 有两个重载实现，第一个会根据 host 来遍历，然后由第二个重载来具体实现，具体代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> WebResourceLoadScheduler::servePendingRequests(HostInformation* host, ResourceLoadPriority minimumPriority)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> priority = ResourceLoadPriority::Highest;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">auto</span>&amp; requestsPending = host-&gt;requestsPending(priority);</div><div class="line">        <span class="keyword">while</span> (!requestsPending.isEmpty()) &#123;</div><div class="line">            RefPtr&lt;ResourceLoader&gt; resourceLoader = requestsPending.first();</div><div class="line"></div><div class="line">            <span class="comment">// For named hosts - which are only http(s) hosts - we should always enforce the connection limit.</span></div><div class="line">            <span class="comment">// For non-named hosts - everything but http(s) - we should only enforce the limit if the document isn't done parsing </span></div><div class="line">            <span class="comment">// and we don't know all stylesheets yet.</span></div><div class="line">            Document* document = resourceLoader-&gt;frameLoader() ? resourceLoader-&gt;frameLoader()-&gt;frame().document() : <span class="number">0</span>;</div><div class="line">            <span class="keyword">bool</span> shouldLimitRequests = !host-&gt;name().isNull() || (document &amp;&amp; (document-&gt;parsing() || !document-&gt;haveStylesheetsLoaded()));</div><div class="line">            <span class="keyword">if</span> (shouldLimitRequests &amp;&amp; host-&gt;limitRequests(priority))</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            requestsPending.removeFirst();</div><div class="line">            host-&gt;addLoadInProgress(resourceLoader.get());</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS)</span></div><div class="line">            <span class="keyword">if</span> (!IOSApplication::isWebProcess()) &#123;</div><div class="line">                resourceLoader-&gt;startLoading();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="comment">//在这个函数里创建了 ResourceHandle</span></div><div class="line">            resourceLoader-&gt;start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (priority == minimumPriority)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        --priority;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加载完数据后，处理过程和 MainResource 类似，SubResourceLoader 会作为 ResourceHandle 的接受者，会接受 ResourceHandle 的回调，和 MainResource 不同的只是 Memeory Cache 部分，这部分的实现是在 SubResourceLoader 的 didReceiveData 里。实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SubresourceLoader::didReceiveDataOrBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">int</span> length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, <span class="keyword">long</span> <span class="keyword">long</span> encodedDataLength, DataPayloadType dataPayloadType)</div><div class="line">&#123;</div><div class="line">    ASSERT(m_resource);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_resource-&gt;response().httpStatusCode() &gt;= <span class="number">400</span> &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    ASSERT(!m_resource-&gt;resourceToRevalidate());</div><div class="line">    ASSERT(!m_resource-&gt;errorOccurred());</div><div class="line">    ASSERT(m_state == Initialized);</div><div class="line">    <span class="comment">// Reference the object in this method since the additional processing can do</span></div><div class="line">    <span class="comment">// anything including removing the last reference to this object; one example of this is 3266216.</span></div><div class="line">    Ref&lt;SubresourceLoader&gt; protectedThis(*<span class="keyword">this</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//ResourceLoader 里会掉 addDataOrBuffer 会把数据存在 SubResourceLoader 的 m_resourceData 里</span></div><div class="line">    ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!m_loadingMultipartContent) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span>* resourceData = <span class="keyword">this</span>-&gt;resourceData())</div><div class="line">            m_resource-&gt;addDataBuffer(*resourceData);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            m_resource-&gt;addData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以 image 为例如图所示：<br><img src="/uploads/deeply-analyse-webkit/36.png" alt="36"></p>
<p>举个例子 image 加载的顺序。DocLoader 是负责子资源的加载，要加载一个图像，首先 DocLoader 要检查 Cache 中是否有对应的 CacheImage 对象，如果有就不用再次下载和解码直接用之。不在会创建一个新的 CacheImage 对象，这个 CacheImage 会要求 Loader 对象创建 SubresourceLoader 来启动网络请求。</p>
<p>CacheImage 的加载过程如下图：<br><img src="/uploads/deeply-analyse-webkit/82.png" alt="82"></p>
<p>具体调用方法顺序如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">HTMLImageElement::create <span class="comment">//解析到 img 标签 会创建 HTMLImageElement 对象，里面包含 HTMLImageLoader 对象</span></div><div class="line">ImageLoader::updateFromElementIgnoringPreviousError <span class="comment">//解析到 img 的 href 属性</span></div><div class="line">ImageLoader::updateFromElement</div><div class="line">CachedResourceLoader::requestImage</div><div class="line">CachedResourceLoader::requestResource <span class="comment">//判断是否从缓存读取，还是网络获取</span></div><div class="line">CachedResourceLoader::loadResource <span class="comment">//创建不同类型的 CachedResource，这里是 CachedImage</span></div><div class="line">MemoryCache::add <span class="comment">//创建对应的 cache 项目</span></div><div class="line">CachedImage::load</div><div class="line">CachedResource::load</div><div class="line">CachedResourceLoader::load</div><div class="line">CachedResourceRequest::load</div><div class="line">ResourceLoaderScheduler::scheduleSubresourceLoad</div><div class="line">SubresourceLoader::create</div><div class="line">ResourceLoadScheduler::requestTimerFired</div><div class="line">ResourceLoader::start</div><div class="line">ResourceHandle::create</div><div class="line">ResourceLoader::didReceiveResponse <span class="comment">//收到 HTTP Header 的 response</span></div><div class="line">SubresourceLoader::didiReceiveResponse</div><div class="line">CachedResourceRequest::didReceiveResponse <span class="comment">//处理响应</span></div><div class="line">ResourceLoader::didReceiveResponse</div><div class="line">ResourceLoader::didReceiveData <span class="comment">//收到 body 数据</span></div><div class="line">SubresourceLoader::didReceiveData</div><div class="line">ResourceLoader::didReceiveData</div><div class="line">ResourceLoader::addData</div><div class="line">CachedResourceRequest::didReceiveData</div><div class="line">ResourceLoader::didFinishLoading <span class="comment">//数据读取完成</span></div><div class="line">SubresourceLoader::didFinishLoading</div><div class="line">CachedResourceRequest::didFinishLoading</div><div class="line">CachedResource::finish</div><div class="line">CachedResourceLoader::loadDone</div><div class="line">CachedImage::data <span class="comment">//创建 Image 对象，进行解码</span></div></pre></td></tr></table></figure></p>
<p>可以用下图概括下：<br><img src="/uploads/deeply-analyse-webkit/51.png" alt="51"><br>一般的资源加载都是异步执行，但是碰到 JavaScript 文件加载时会阻碍主线程的渲染，这时 WebKit 会在阻碍时去后面收集其它资源的 URL 发并发请求，这样对加载速度会有一定的优化。</p>
<h3 id="资源的生命周期"><a href="#资源的生命周期" class="headerlink" title="资源的生命周期"></a>资源的生命周期</h3><p>资源池采用的是 Least Recent Used 最少使用算法 LRU。通过 HTTP 协议规范中更新规范来确定下次是否需要更新资源。具体做法是先判断资源是否在资源池里，在的话就发一个 HTTP 请求带上一些信息比如资源的修改时间，然后服务器根据这个信息判断是否有更新，如果没有更新就返回 304 状态码，这样就直接使用资源池的原资源，不然就下载最新资源。</p>
<h3 id="WebKit-的-Cache"><a href="#WebKit-的-Cache" class="headerlink" title="WebKit 的 Cache"></a>WebKit 的 Cache</h3><p>WebKit 主要有三种 Cache。</p>
<h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>对浏览页面的缓存用来使页面历史操作加速。单例模式，会有页面上限，会缓存 DOM Tree，Render Tree。在打开一个新页面的时候会在 FrameLoader 的 commitProvisionalLoad 方法里把前一个页面加入 Page Cache。截取相关代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!m_frame.tree().parent() &amp;&amp; history().currentItem()) &#123;</div><div class="line">    <span class="comment">// Check to see if we need to cache the page we are navigating away from into the back/forward cache.</span></div><div class="line">    <span class="comment">// We are doing this here because we know for sure that a new page is about to be loaded.</span></div><div class="line">    PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());</div><div class="line"></div><div class="line">    WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PageCache 的 addIfCacheable 会对缓存进行管理，实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> PageCache::addIfCacheable(HistoryItem&amp; item, Page* page)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (item.isInPageCache())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!page || !canCache(*page))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    ASSERT_WITH_MESSAGE(!page-&gt;isUtilityPage(), <span class="string">"Utility pages such as SVGImage pages should never go into PageCache"</span>);</div><div class="line"></div><div class="line">    setPageCacheState(*page, Document::AboutToEnterPageCache);</div><div class="line"></div><div class="line">    <span class="comment">// Focus the main frame, defocusing a focused subframe (if we have one). We do this here,</span></div><div class="line">    <span class="comment">// before the page enters the page cache, while we still can dispatch DOM blur/focus events.</span></div><div class="line">    <span class="keyword">if</span> (page-&gt;focusController().focusedFrame())</div><div class="line">        page-&gt;focusController().setFocusedFrame(&amp;page-&gt;mainFrame());</div><div class="line"></div><div class="line">    <span class="comment">// Fire the pagehide event in all frames.</span></div><div class="line">    firePageHideEventRecursively(page-&gt;mainFrame());</div><div class="line"></div><div class="line">    <span class="comment">// Check that the page is still page-cacheable after firing the pagehide event. The JS event handlers</span></div><div class="line">    <span class="comment">// could have altered the page in a way that could prevent caching.</span></div><div class="line">    <span class="keyword">if</span> (!canCache(*page)) &#123;</div><div class="line">        setPageCacheState(*page, Document::NotInPageCache);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    destroyRenderTree(page-&gt;mainFrame());</div><div class="line"></div><div class="line">    setPageCacheState(*page, Document::InPageCache);</div><div class="line"></div><div class="line">    <span class="comment">// Make sure we no longer fire any JS events past this point.</span></div><div class="line">    NoEventDispatchAssertion assertNoEventDispatch;</div><div class="line">    <span class="comment">//创建一个新的 CachedPage 存放到 HistoryItem 里</span></div><div class="line">    item.m_cachedPage = <span class="built_in">std</span>::make_unique&lt;CachedPage&gt;(*page);</div><div class="line">    item.m_pruningReason = PruningReason::None;</div><div class="line">    <span class="comment">//将 HistoryItem 添加到 m_items 列表中</span></div><div class="line">    m_items.add(&amp;item);</div><div class="line">    </div><div class="line">    <span class="comment">//检查是否有超过回收的限制，进行资源回收</span></div><div class="line">    prune(PruningReason::ReachedMaxSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当 Page 的 goBack 方法调用时会调用 FrameLoader 的 loadDifferentDocumentItem，同时加载类型设置为 FrameLoadTypeBack，然后页面将会从 Page Cache 里恢复。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>使得相同 url 的资源能够快速获得。单例模式，在浏览器打开时创建，关闭时释放。关联类结构图如下：<br><img src="/uploads/deeply-analyse-webkit/83.png" alt="83"><br>Memory Cache 有三个比较重要的属性。</p>
<ul>
<li>m_resources：类型是 HashMap，key 是 url，值是 CacheResource。</li>
<li>m_allResources：采用的是 LRU 算法，类型是 Vector<lrulist,32> 有 32 个向量，具体实现是在 MemeoryCache 的 lruListFor。回收资源是通过 MemoryCache 里的 prune 来的，会从链表尾开始进行回收直到空间大小达标为止。</lrulist,32></li>
<li>m_liveDecodedResource：类型为 LRUList，解码后的数据会记录在里面。</li>
</ul>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>根据 HTTP 的头信息来设置缓存。属于持久化缓存存储，重新打开浏览器还能节省下载的流量和时间浪费。使用的也是 LRU 算法来控制缓存磁盘空间大小。具体实现是由平台相关代码来完成。</p>
<h2 id="HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token"><a href="#HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token" class="headerlink" title="HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token"></a>HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</h2><h3 id="解析成-HTML-Token-的算法"><a href="#解析成-HTML-Token-的算法" class="headerlink" title="解析成 HTML Token 的算法"></a>解析成 HTML Token 的算法</h3><p><img src="/uploads/deeply-analyse-webkit/17.png" alt="17"><br>初始状态是 Data state，碰到 &lt; 字符状态变为 Tag open state，下个字符为字母时就创建 Start tag token，状态变成 Tag name state，到 &gt; 字符状态变成 Data state，中间的字符都会被加到 token name 里。</p>
<p>在 Tag open state 状态时如果碰到 / 字符那么就会创建 End tag token，同时状态变成 Tag name state。</p>
<p>在 WebKit 中有两个类是专门做词法分析的，一个是做标记的 HTMLToken，另一个是词法解析器 HTMLTokenizer 类，解析任务就是要把字节流解析成一个个 HTMLToken 给语法解析器分析。在 html 解析中一个 element 对应 三个 HTMLToken，一个是起始标签，一个是 element 内容，一个是结束标签 HTMLToken。在 DOM 树上起始结束标签对应一个 element node，内容是另一个 node。</p>
<p>HTMLToken 的所有类型定义在 HTMLToken.h 里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Type &#123;</div><div class="line">    Uninitialized, <span class="comment">//默认类型</span></div><div class="line">    DOCTYPE,       <span class="comment">//文档类型</span></div><div class="line">    StartTag,      <span class="comment">//起始标签</span></div><div class="line">    EndTag,        <span class="comment">//结束标签</span></div><div class="line">    Comment,       <span class="comment">//注释</span></div><div class="line">    Character,     <span class="comment">//元素内容</span></div><div class="line">    EndOfFile,     <span class="comment">//文档结束</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接下来看看 HTMLToken 的成员变量，HTMLTokenizer 类会解析出的这样的结构体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line">    Type m_type;       <span class="comment">//那种类型</span></div><div class="line"></div><div class="line">    DataVector m_data; <span class="comment">//根据类型来，不同类型内容不一样</span></div><div class="line">    UChar m_data8BitCheck;</div><div class="line"></div><div class="line">    <span class="comment">// For StartTag and EndTag</span></div><div class="line">    <span class="keyword">bool</span> m_selfClosing;            <span class="comment">//是否是自封闭</span></div><div class="line">    AttributeList m_attributes;    <span class="comment">//属性列表</span></div><div class="line">    Attribute* m_currentAttribute; <span class="comment">//当前属性</span></div><div class="line"></div><div class="line">    <span class="comment">// For DOCTYPE</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DoctypeData&gt; m_doctypeData;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> m_attributeBaseOffset &#123; <span class="number">0</span> &#125;; <span class="comment">// Changes across document.write() boundaries.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在说 HTMLTokenizer 具体解析实现之前我们先了解下有限状态机。先看看数学模型<br><img src="/uploads/deeply-analyse-webkit/28.png" alt="28"></p>
<p>HTMLTokenizer 里的 processToken 方法具体实现了整个状态机，实现主要是根据 w3c 的 tokenization 标准来实现的：<a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="external">https://dev.w3.org/html5/spec-preview/tokenization.html</a> 。html 的字符集合就是数学模型里的字母表，状态的非空集合都定义在 HTMLTokenizer.h 的 state 枚举里。state 枚举值 DataState 表示初始状态。processToken 里对不同 state 所做的 case 处理就是状态转移函数。下面是 HTMLTokenizer 里的 state 枚举：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//HTML 有限状态机的状态非空集合</span></div><div class="line"><span class="keyword">enum</span> State &#123;</div><div class="line">    DataState, <span class="comment">//初始状态，一般最开始和其它地方碰到 &gt; 符号为截止再次进入这个状态。碰到字母需要设置 HTMLToken 的 type 为 character</span></div><div class="line">    CharacterReferenceInDataState,</div><div class="line">    RCDATAState,</div><div class="line">    CharacterReferenceInRCDATAState,</div><div class="line">    RAWTEXTState,</div><div class="line">    ScriptDataState,</div><div class="line">    PLAINTEXTState,</div><div class="line">    TagOpenState, <span class="comment">//碰到 &lt; 符号。如果前面的 DataState 有值需要提取值到 HTMLToken 的 m_data 里</span></div><div class="line">    EndTagOpenState, <span class="comment">//TagOpenState 状态碰见 / 进入。HTMLToken 的 type 为 endTag</span></div><div class="line">    TagNameState, <span class="comment">//在 TagOpenState 或 EndTagOpenState 状态碰到字母。HTMLToken 的 type 为 StartTag</span></div><div class="line"></div><div class="line">    RCDATALessThanSignState,</div><div class="line">    RCDATAEndTagOpenState,</div><div class="line">    RCDATAEndTagNameState,</div><div class="line"></div><div class="line">    RAWTEXTLessThanSignState,</div><div class="line">    RAWTEXTEndTagOpenState,</div><div class="line">    RAWTEXTEndTagNameState,</div><div class="line"></div><div class="line">    ScriptDataLessThanSignState,</div><div class="line">    ScriptDataEndTagOpenState,</div><div class="line">    ScriptDataEndTagNameState,</div><div class="line">    ScriptDataEscapeStartState,</div><div class="line">    ScriptDataEscapeStartDashState,</div><div class="line">    ScriptDataEscapedState,</div><div class="line">    ScriptDataEscapedDashState,</div><div class="line">    ScriptDataEscapedDashDashState,</div><div class="line">    ScriptDataEscapedLessThanSignState,</div><div class="line">    ScriptDataEscapedEndTagOpenState,</div><div class="line">    ScriptDataEscapedEndTagNameState,</div><div class="line">    ScriptDataDoubleEscapeStartState,</div><div class="line">    ScriptDataDoubleEscapedState,</div><div class="line">    ScriptDataDoubleEscapedDashState,</div><div class="line">    ScriptDataDoubleEscapedDashDashState,</div><div class="line">    ScriptDataDoubleEscapedLessThanSignState,</div><div class="line">    ScriptDataDoubleEscapeEndState,</div><div class="line"></div><div class="line">    BeforeAttributeNameState, <span class="comment">//TagNameState 碰到空格。HTMLToken 的 m_data 会记录前面的 tagname</span></div><div class="line">    AttributeNameState, <span class="comment">//BeforeAttributeNameState 碰见字母进入</span></div><div class="line">    AfterAttributeNameState,</div><div class="line">    BeforeAttributeValueState, <span class="comment">//AttributeNameState 状态碰到 = 会进入，同时会在 HTMLToken 属性列表里增加一个属性，属性名为前面状态记录的</span></div><div class="line">    AttributeValueDoubleQuotedState, <span class="comment">//BeforeAttributeValueState 碰到 " 符号</span></div><div class="line">    AttributeValueSingleQuotedState, <span class="comment">//BeforeAttributeValueState 碰到 ' 符号</span></div><div class="line">    AttributeValueUnquotedState,</div><div class="line">    CharacterReferenceInAttributeValueState,</div><div class="line">    AfterAttributeValueQuotedState, <span class="comment">// 再次碰到 " 或 ' 符号。HTMLToken 记录属性的值</span></div><div class="line">    SelfClosingStartTagState,</div><div class="line">    BogusCommentState,</div><div class="line">    ContinueBogusCommentState, <span class="comment">// Not in the HTML spec, used internally to track whether we started the bogus comment token.</span></div><div class="line">    MarkupDeclarationOpenState, <span class="comment">//TagOpenState 后遇到! 比如&lt;!</span></div><div class="line"></div><div class="line">    <span class="comment">//解析comment</span></div><div class="line">    CommentStartState, <span class="comment">//MarkupDeclarationOpenState 状态后跟了两个 - 比如 &lt;!-- 。HTMLToken 的 type 为 COMMENT</span></div><div class="line">    CommentStartDashState,</div><div class="line">    CommentState, <span class="comment">//CommentStartState 碰到字母进入这个状态</span></div><div class="line">    CommentEndDashState, <span class="comment">//在 CommentState 状态碰见 - 进入。HTMLToken 的 m_data 为 前面记录的 comment 内容</span></div><div class="line">    CommentEndState, <span class="comment">//在 CommentEndDashState 状态碰见 - 进入</span></div><div class="line">    CommentEndBangState,</div><div class="line"></div><div class="line">    <span class="comment">//解析 &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; 这种标签</span></div><div class="line">    DOCTYPEState, <span class="comment">//匹配到 DOCTYPE，&lt;!DOCTYPE</span></div><div class="line">    BeforeDOCTYPENameState, <span class="comment">//DOCTYPE 状态后遇到空格</span></div><div class="line">    DOCTYPENameState, <span class="comment">//BeforeDOCTYPENameState 状态遇到字母，提取 html。HTMLToken 的 m_data 为 html</span></div><div class="line">    AfterDOCTYPENameState, <span class="comment">//DOCTYPENameState 遇到空格 &lt;!DOCTYPE html</span></div><div class="line">    AfterDOCTYPEPublicKeywordState, <span class="comment">//AfterDOCTYPENameState 后匹配到 public。&lt;!DOCTYPE html PUBLIC</span></div><div class="line">    BeforeDOCTYPEPublicIdentifierState, <span class="comment">//AfterDOCTYPEPublicKeywordState 状态后碰到空格</span></div><div class="line">    DOCTYPEPublicIdentifierDoubleQuotedState, <span class="comment">//BeforeDOCTYPEPublicIdentifierState 状态碰到 " 进入</span></div><div class="line">    DOCTYPEPublicIdentifierSingleQuotedState, <span class="comment">//BeforeDOCTYPEPublicIdentifierState 状态碰到 ' 进入</span></div><div class="line">    AfterDOCTYPEPublicIdentifierState, <span class="comment">//再次遇到 " 或 ' 。可将 HTMLToken 的 m_publicIdentifier 确定</span></div><div class="line">    BetweenDOCTYPEPublicAndSystemIdentifiersState, </div><div class="line">    AfterDOCTYPESystemKeywordState,</div><div class="line">    BeforeDOCTYPESystemIdentifierState,</div><div class="line">    DOCTYPESystemIdentifierDoubleQuotedState,</div><div class="line">    DOCTYPESystemIdentifierSingleQuotedState,</div><div class="line">    AfterDOCTYPESystemIdentifierState,</div><div class="line">    BogusDOCTYPEState,</div><div class="line">    CDATASectionState,</div><div class="line"></div><div class="line">    <span class="comment">// These CDATA states are not in the HTML5 spec, but we use them internally.</span></div><div class="line">    CDATASectionRightSquareBracketState,</div><div class="line">    CDATASectionDoubleRightSquareBracketState,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>词法解析主要接口是 nextToken 函数，下图展示了 HTMLTokenizer 的主要工作流程：<br><img src="/uploads/deeply-analyse-webkit/55.png" alt="55"></p>
<h2 id="HTML-语法解析"><a href="#HTML-语法解析" class="headerlink" title="HTML 语法解析"></a>HTML 语法解析</h2><h3 id="HTML-的语法定义"><a href="#HTML-的语法定义" class="headerlink" title="HTML 的语法定义"></a>HTML 的语法定义</h3><p>HTML 的语法规范是由 w3c 组织创建和定义的。语法语句可以使用正式的比如 BNF 来定义，不过对于 html 这种会在创建后允许再插入代码的语言 w3c 使用了 DTD 来定义 HTML，定义的文件可以在这里：<a href="https://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="external">https://www.w3.org/TR/html4/strict.dtd</a></p>
<h3 id="相关类关系图"><a href="#相关类关系图" class="headerlink" title="相关类关系图"></a>相关类关系图</h3><p><img src="/uploads/deeply-analyse-webkit/09.png" alt="09"></p>
<ul>
<li>Document 和 DocumentParser 相互引用</li>
<li>HTMLDocumentParser 父类是 ScriptableDocumentParser，DecodedDataDocumentParser（字符解码功能） 最后是 DocumentParser。</li>
<li>HTMLInputStream：解码后的字符流的保存，作为缓冲区。</li>
<li>HTMLTokenizer：对字符流进行解析，将解析后的信息比如 tag 名属性列表，注释，Doc 声明，结束 tag，文本都存在 HTMLToken 类中。</li>
<li>HTMLTreeBuilder：生成 DOM Tree，这里会做些语义上的检查，比如 head tag 里不能包含 body tag。</li>
<li>HTMLToken：HTMLTokenizer 生成，HTMLTreeBuilder 来使用</li>
<li>HTMLConstructionSite：创建各种 HTMLElement，再完成 DOM Tree，关键标签比如 body，head 和 html 以外都是通过 HTMLElementFactory 来实现。属性使用生成的 Element 里对应的函数来实现。</li>
<li>HTMLPreloadScanner：专门用来查找类似 src，link 这样的属性，获取外部资源，通过 CachedResourceLoader 这个类进行加载。</li>
</ul>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p><img src="/uploads/deeply-analyse-webkit/10.png" alt="10"></p>
<ul>
<li><p>DocumentWriter 调用 DocumentParser::appendBytes 将结果存入 HTMLInputStream 中。</p>
</li>
<li><p>HTMLDocumentParser::pumpTokenizer 函数里的 nextToken 会把字符流解析成 HTMLToken。</p>
</li>
<li><p>把 HTMLToken 对象交给 HTMLTreeBuild，通过 HTMLTreeBuild::processToken 来分析标签是否 OK，再用 HTMLConstructionSite 的 insertHTMLElement，insertHTMLHeadElement 来插入到 HTMLConstructionSite 里，原理是 stack of open elements 栈的方式构造，具体可以看这里：<a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite</a> 通过 HTMLElementFactory 里的 createHTMLElement 来创建 HTMLElement 对象。Element 的 parserSetAttributes 函数用来解析属性。创建完一个 Element 会被加到当前 Node 里，通过 HTMLConstructionSite 的 attachLater 函数异步完成。</p>
</li>
<li><p>然后 HTMLToken 对象还会交给 HTMLPreloadScanner，它会先调用 scan 函数，生成一个 PreloadTask，调用 preload 函数或 CachedResourceLoader 的 preload 进行资源预加载。在 CachedResourceLoader 里的资源是以 url 作为 key，通过 url 来获取资源。具体实现可以看 HTMLPreloadScanner::processToken。</p>
</li>
</ul>
<h3 id="Element-属性设置"><a href="#Element-属性设置" class="headerlink" title="Element 属性设置"></a>Element 属性设置</h3><p>是通过 Element::parserSetAttributes 来设置的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Element::parserSetAttributes(<span class="keyword">const</span> Vector&lt;Attribute&gt;&amp; attributeVector)</div><div class="line">&#123;</div><div class="line">    ASSERT(!isConnected());</div><div class="line">    ASSERT(!parentNode());</div><div class="line">    ASSERT(!m_elementData);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!attributeVector.isEmpty()) &#123;</div><div class="line">        <span class="keyword">if</span> (document().sharedObjectPool())</div><div class="line">            m_elementData = document().sharedObjectPool()-&gt;cachedShareableElementDataWithAttributes(attributeVector);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            m_elementData = ShareableElementData::createWithAttributes(attributeVector);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    parserDidSetAttributes();</div><div class="line"></div><div class="line">    <span class="comment">// Use attributeVector instead of m_elementData because attributeChanged might modify m_elementData.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; attribute : attributeVector)</div><div class="line">        attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedDirectly);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>m_attributeData 存储属性的对象，attributeChange 函数会调用 parseAttribute 函数，作用是让 Element 能够处理 src 这样的属性加载图片</p>
<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>HTMLPreloadScanner 调用 CachedResourceLoader 来加载的。</p>
<h2 id="构建-DOM-Tree"><a href="#构建-DOM-Tree" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h2><p>构建 DOM Tree 需要经过的四个阶段，分别是解码，分词，解析（创建与 Tag 相对应的 Node），创建树（有 DOM Tree，Render Tree，RenderLayer Tree）<br><img src="/uploads/deeply-analyse-webkit/84.png" alt="84"><br>相关类流程图：<br><img src="/uploads/deeply-analyse-webkit/87.png" alt="87"></p>
<p>前三个阶段前面已经介绍，下面主要介绍下创建 DOM 树</p>
<h3 id="DOM-标准规范"><a href="#DOM-标准规范" class="headerlink" title="DOM 标准规范"></a>DOM 标准规范</h3><p>Document Object Model 简称 DOM，全称文档对象模型，可以是 HTML，XML 和 XHTML，DOM 是以面向对象的方式来描述文档的，这样可以通过 JavaScript 或其它面向对象的语言进行访问，创建，删除和修改 DOM 结构。DOM 的接口与平台和语言无关。W3C 定义了一系列的 DOM 接口，目前已经有了四个 level 标准，每个标准都是基于上个标准基础上进行的迭代，如下图是 DOM 规范的演进过程：<br><img src="/uploads/deeply-analyse-webkit/52.png" alt="52"><br>下面对各个 level 进行说明<br>DOM level 1</p>
<ul>
<li>Core：底层接口，接口支持 XML 等任何结构化文档。</li>
<li>HTML：把 HTML 内容定义为 Document 文档，Node 节点，Attribute 属性，Element 元素，Text 文本。</li>
</ul>
<p>DOM level 2</p>
<ul>
<li>Core：对 level 1 的 Core 部分进行扩展，比如 getElementById，还有 namespace 的接口。</li>
<li>HTML：允许动态访问修改文档。</li>
<li>Views：文档的各种视图。</li>
<li>Events：鼠标事件等。</li>
<li>Style：可以修改 HTML 样式的一个属性。</li>
<li>Traveral and range：NodeIterator 和 TreeWalker 遍历树对文档修改，删除等操作。</li>
</ul>
<p>节点DOM level 3</p>
<ul>
<li>Core：加入了新接口 adoptNode 和 textContent。</li>
<li>Load and Save：加载 XML 转成 DOM 表示的文档结构。</li>
<li>Validation：验证文档有效性。</li>
<li>Events：加入键盘支持。</li>
<li>XPath：一种简单直观检索 DOM 节点的方式。</li>
</ul>
<p>DOM 结构构成的基本要素是节点，节点概念比较大，Document 也是一个节点，叫 Document 节点，HTML 里的 Tag 也是一种节点，叫 Element 节点，还有属性节点，Entity 节点，ProcessingIntruction 节点，CDataSection 节点，Comment 节点。下面看看 Document 节点提供的接口，这个接口的描述文件路径是在 WebCore/dom/Document.idl 文件里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line">interface Document : Node &#123;</div><div class="line">    readonly attribute DOMImplementation implementation; // FIXME: Should be [SameObject].</div><div class="line">    [ImplementedAs=urlForBindings] readonly attribute USVString URL;</div><div class="line">    [ImplementedAs=urlForBindings] readonly attribute USVString documentURI;</div><div class="line">    readonly attribute USVString origin;</div><div class="line">    readonly attribute DOMString compatMode;</div><div class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString characterSet;</div><div class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString charset; // Historical alias of .characterSet,</div><div class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString inputEncoding; // Historical alias of .characterSet.</div><div class="line">    readonly attribute DOMString contentType;</div><div class="line"></div><div class="line">    readonly attribute DocumentType? doctype;</div><div class="line">    [DOMJIT=Getter] readonly attribute Element? documentElement;</div><div class="line"></div><div class="line">    HTMLCollection getElementsByTagName(DOMString qualifiedName);</div><div class="line">    HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);</div><div class="line">    HTMLCollection getElementsByClassName(DOMString classNames);</div><div class="line"></div><div class="line">    [NewObject, MayThrowException, ImplementedAs=createElementForBindings] Element createElement(DOMString localName); // FIXME: missing options parameter.</div><div class="line">    [NewObject, MayThrowException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName); // FIXME: missing options parameter.</div><div class="line">    [NewObject] DocumentFragment createDocumentFragment();</div><div class="line">    [NewObject] Text createTextNode(DOMString data);</div><div class="line">    [NewObject, MayThrowException] CDATASection createCDATASection(DOMString data);</div><div class="line">    [NewObject] Comment createComment(DOMString data);</div><div class="line">    [NewObject, MayThrowException] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);</div><div class="line"></div><div class="line">    [CEReactions, MayThrowException, NewObject] Node importNode(Node node, optional boolean deep = false);</div><div class="line">    [CEReactions, MayThrowException] Node adoptNode(Node node);</div><div class="line"></div><div class="line">    [NewObject, MayThrowException] Attr createAttribute(DOMString localName);</div><div class="line">    [NewObject, MayThrowException] Attr createAttributeNS(DOMString? namespaceURI, DOMString qualifiedName);</div><div class="line"></div><div class="line">    [MayThrowException, NewObject] Event createEvent(DOMString type);</div><div class="line"></div><div class="line">    [NewObject] Range createRange();</div><div class="line"></div><div class="line">    // NodeFilter.SHOW_ALL = 0xFFFFFFFF.</div><div class="line">    [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);</div><div class="line">    [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);</div><div class="line"></div><div class="line">    // Extensions from HTML specification (https://html.spec.whatwg.org/#the-document-object).</div><div class="line">    [PutForwards=href, Unforgeable] readonly attribute Location? location;</div><div class="line">    [SetterMayThrowException] attribute USVString domain;</div><div class="line">    readonly attribute USVString referrer;</div><div class="line">    [GetterMayThrowException, SetterMayThrowException] attribute USVString cookie;</div><div class="line">    readonly attribute DOMString lastModified;</div><div class="line">    readonly attribute DocumentReadyState readyState;</div><div class="line"></div><div class="line">    // DOM tree accessors.</div><div class="line">    [CEReactions] attribute DOMString title;</div><div class="line">    [CEReactions] attribute DOMString dir;</div><div class="line">    [CEReactions, DOMJIT=Getter, ImplementedAs=bodyOrFrameset, SetterMayThrowException] attribute HTMLElement? body;</div><div class="line">    readonly attribute HTMLHeadElement? head;</div><div class="line">    readonly attribute HTMLCollection images; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection embeds; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection plugins; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection links; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection forms; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection scripts; // Should be [SameObject].</div><div class="line">    NodeList getElementsByName([AtomicString] DOMString elementName);</div><div class="line">    readonly attribute HTMLScriptElement? currentScript; // FIXME: Should return a HTMLOrSVGScriptElement.</div><div class="line"></div><div class="line">    // dynamic markup insertion</div><div class="line">    // FIXME: The HTML spec says this should consult the &quot;responsible document&quot;. We should ensure</div><div class="line">    // that the caller document matches those semantics. It is possible we should replace it with</div><div class="line">    // the existing &apos;incumbent document&apos; concept.</div><div class="line">    [CEReactions, CallWith=ResponsibleDocument, ImplementedAs=openForBindings, MayThrowException] Document open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);</div><div class="line">    [CallWith=ActiveWindow&amp;FirstWindow, ImplementedAs=openForBindings, MayThrowException] DOMWindow open(USVString url, DOMString name, DOMString features);</div><div class="line">    [CEReactions, ImplementedAs=closeForBindings, MayThrowException] void close();</div><div class="line">    [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void write(DOMString... text);</div><div class="line">    [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void writeln(DOMString... text);</div><div class="line"></div><div class="line">    // User interaction.</div><div class="line">    readonly attribute DOMWindow? defaultView;</div><div class="line">    boolean hasFocus();</div><div class="line">    [CEReactions] attribute DOMString designMode;</div><div class="line">    [CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString? value = null); // FIXME: value should not be nullable.</div><div class="line">    boolean queryCommandEnabled(DOMString commandId);</div><div class="line">    boolean queryCommandIndeterm(DOMString commandId);</div><div class="line">    boolean queryCommandState(DOMString commandId);</div><div class="line">    boolean queryCommandSupported(DOMString commandId);</div><div class="line">    DOMString queryCommandValue(DOMString commandId);</div><div class="line"></div><div class="line">    // Special event handler IDL attributes that only apply to Document objects.</div><div class="line">    [LenientThis] attribute EventHandler onreadystatechange;</div><div class="line"></div><div class="line">    // Extensions from the CSSOM specification (https://drafts.csswg.org/cssom/#extensions-to-the-document-interface).</div><div class="line">    // FIXME: Should likely be moved to DocumentOrShadowRoot.</div><div class="line">    readonly attribute StyleSheetList styleSheets; // FIXME: Should be [SameObject].</div><div class="line"></div><div class="line">    // Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-document-interface).</div><div class="line">    readonly attribute Element? scrollingElement;</div><div class="line"></div><div class="line">    // Extensions from Selection API (https://www.w3.org/TR/selection-api/#extensions-to-document-interface).</div><div class="line">    // FIXME: Should likely be moved to DocumentOrShadowRoot.</div><div class="line">    DOMSelection? getSelection();</div><div class="line"></div><div class="line">    // XPath extensions (https://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator).</div><div class="line">    [MayThrowException] XPathExpression createExpression(optional DOMString expression = &quot;undefined&quot;, optional XPathNSResolver? resolver); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong.</div><div class="line">    XPathNSResolver createNSResolver(Node? nodeResolver);</div><div class="line">    [MayThrowException] XPathResult evaluate(optional DOMString expression = &quot;undefined&quot;, optional Node? contextNode, optional XPathNSResolver? resolver, optional unsigned short type = 0, optional XPathResult? inResult); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong.</div><div class="line"></div><div class="line">    // Extensions from FullScreen API (https://fullscreen.spec.whatwg.org/#api).</div><div class="line">    // FIXME: Should probably be unprefixed.</div><div class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullscreenEnabled;</div><div class="line">    [Conditional=FULLSCREEN_API, ImplementedAs=webkitFullscreenElementForBindings] readonly attribute Element? webkitFullscreenElement;</div><div class="line">    [Conditional=FULLSCREEN_API] void webkitExitFullscreen();</div><div class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitIsFullScreen; // Mozilla version.</div><div class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullScreenKeyboardInputAllowed; // Mozilla version.</div><div class="line">    [Conditional=FULLSCREEN_API, ImplementedAs=webkitCurrentFullScreenElementForBindings] readonly attribute Element webkitCurrentFullScreenElement; // Mozilla version.</div><div class="line">    [Conditional=FULLSCREEN_API] void webkitCancelFullScreen(); // Mozilla version.</div><div class="line">    [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenchange;</div><div class="line">    [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenerror;</div><div class="line"></div><div class="line">    // Extensions from Pointer Lock API (https://www.w3.org/TR/pointerlock/#extensions-to-the-document-interface).</div><div class="line">    [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockchange; // FIXME: Should be enumerable.</div><div class="line">    [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockerror; // FIXME: Should be enumerable.</div><div class="line">    [Conditional=POINTER_LOCK] void exitPointerLock();</div><div class="line"></div><div class="line">    // Extensions from CSS Font Loading API (https://drafts.csswg.org/css-font-loading/#font-face-source).</div><div class="line">    // FIXME: Should be in a separate FontFaceSource interface.</div><div class="line">    readonly attribute FontFaceSet fonts;</div><div class="line"></div><div class="line">    // Extensions from Page visibility API (https://www.w3.org/TR/page-visibility/#sec-document-interface).</div><div class="line">    readonly attribute boolean hidden;</div><div class="line">    readonly attribute VisibilityState visibilityState;</div><div class="line">    attribute EventHandler onvisibilitychange;</div><div class="line"></div><div class="line">    // FIXME: Those were dropped from the CSSOM specification.</div><div class="line">    readonly attribute DOMString? preferredStylesheetSet;</div><div class="line">    attribute DOMString? selectedStylesheetSet;</div><div class="line"></div><div class="line">    // FIXME: Those have been dropped from the DOM specification.</div><div class="line">    readonly attribute DOMString? xmlEncoding;</div><div class="line">    [SetterMayThrowException] attribute DOMString? xmlVersion;</div><div class="line">    attribute boolean xmlStandalone;</div><div class="line"></div><div class="line">    // FIXME: Blink has already dropped this (https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/s3ezjTuC8ig).</div><div class="line">    CSSStyleDeclaration getOverrideStyle(optional Element? element = null, optional DOMString pseudoElement = &quot;undefined&quot;);</div><div class="line"></div><div class="line">    // FIXME: Should be moved to GlobalEventHandlers (http://w3c.github.io/selection-api/#extensions-to-globaleventhandlers).</div><div class="line">    [NotEnumerable] attribute EventHandler onselectstart; // FIXME: Should be enumerable.</div><div class="line">    [NotEnumerable] attribute EventHandler onselectionchange; // FIXME: Should be enumerable.</div><div class="line"></div><div class="line">    // Non standard: It has been superseeded by caretPositionFromPoint which we do not implement yet.</div><div class="line">    Range caretRangeFromPoint(optional long x = 0, optional long y = 0);</div><div class="line"></div><div class="line">    // FIXME: This is not standard and has been dropped from Blink already.</div><div class="line">    RenderingContext? getCSSCanvasContext(DOMString contextId, DOMString name, long width, long height);</div><div class="line"></div><div class="line">    // Non standard (https://developer.apple.com/reference/webkitjs/document/1633863-webkitgetnamedflows).</div><div class="line">    [Conditional=CSS_REGIONS] DOMNamedFlowCollection webkitGetNamedFlows();</div><div class="line"></div><div class="line"></div><div class="line">    // Obsolete features from https://html.spec.whatwg.org/multipage/obsolete.html</div><div class="line"></div><div class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString fgColor;</div><div class="line">    [CEReactions, ImplementedAs=linkColorForBindings] attribute [TreatNullAs=EmptyString] DOMString linkColor;</div><div class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString vlinkColor;</div><div class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString alinkColor;</div><div class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;</div><div class="line"></div><div class="line">    readonly attribute HTMLCollection anchors; /* [SameObject] */</div><div class="line">    readonly attribute HTMLCollection applets; /* [SameObject] */</div><div class="line"></div><div class="line">    void clear();</div><div class="line">    void captureEvents();</div><div class="line">    void releaseEvents();</div><div class="line"></div><div class="line">    [Replaceable] readonly attribute HTMLAllCollection all; /* [SameObject] */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="DOM-Tree-Token-的构造算法"><a href="#DOM-Tree-Token-的构造算法" class="headerlink" title="DOM Tree Token 的构造算法"></a>DOM Tree Token 的构造算法</h3><p>这个算法被描述为一个 state machine，state 为插入模式（insertion modes）。完整算法可以参看 w3c 的定义：<a href="https://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="external">https://www.w3.org/TR/html5/syntax.html#html-parser</a></p>
<p><img src="/uploads/deeply-analyse-webkit/19.png" alt="19"><br>当 parser 创建后也会创建一个 Document 对象。在 tree construction 的阶段，Document 会做为 root 的 element 添加进来。tree constructor 会处理每个 tokenizer 生成的 node。每个 token 会对应一个 DOM element。每个 element 不光会被添加到 DOM tree，还会添加到 stack of open elements里。这个 stack 用于检查嵌套错误和未关闭的 tag。</p>
<p>具体过程是，在 tree construction 阶段的输入是来自 tokenization 的 tokens 排序的阶段。最开始的状态是 initial mode。接收 html token 会变成 before html mode，并且在那个模式里重新处理 token。这会创建一个 HTMLHtmlElement 元素添加到 Document 对象的 root 上。</p>
<p>接下来状态会变成 before head。然后创建 HTMLHeadElement，如果 head 里有 token 就会被添加到这个 tree 里。状态会有 in head 和 after head。</p>
<p>再后面会创建 HTMLBodyElement，添加到树中，状态转成 in body，里面的 html token 会被转成对应的 DOM element 被添加到 body 的 node 中。当收到 body end token 会让状态切换成 after body。接着就是收到 html end tag，转成 after after body 状态，接到 end of file token 会结束 parsing。</p>
<h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p>构建 DOM 的几个关键的类<br><img src="/uploads/deeply-analyse-webkit/53.png" alt="53"></p>
<p><img src="/uploads/deeply-analyse-webkit/11.png" alt="11"></p>
<ul>
<li>HTMLDocumentParser：管理类，解析 html 文本使用词法分析器成 HTMLTokenizer 类，最后输出到 HTMLTreeBuilder。</li>
<li>HTMLTreeBuilder：负责 DOM 树的建立，对 tokens 分类处理，创建一个个节点对象，使用 HTMLConstructionSite 类将这些创建好的节点构建为 DOM 树。</li>
<li>HTMLConstructionSite：不同的标签类型在不同位置会有不同的函数来构建 DOM 树。m_document 代表根节点，即 javascript 里的 window.document 对象。</li>
<li>HTMLElementFactory：一个工厂类对不同类型的标签创建不同的 html 元素，同时建立父子兄弟关系。</li>
</ul>
<p>构建 DOM 树的过程如下图：<br><img src="/uploads/deeply-analyse-webkit/54.png" alt="54"></p>
<p>举个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">			Hello World</div><div class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>转成 DOM Tree 如下：<br><img src="/uploads/deeply-analyse-webkit/69.png" alt="69"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>通过 DocumentLoader 这个类里的 startLoadingMainResource 加载 url<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">FetchRequest <span class="title">fetchRequest</span><span class="params">(m_request, FetchInitiatorTypeNames::document,</span></span></div><div class="line">                            mainResourceLoadOptions);</div><div class="line">  m_mainResource =</div><div class="line">      RawResource::fetchMainResource(fetchRequest, fetcher(), m_substituteData);</div></pre></td></tr></table></figure></p>
<p>DocumentLoader 的 commitData 会去处理 dataReceived 的数据块<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DocumentLoader::commitData(<span class="keyword">const</span> <span class="keyword">char</span>* bytes, <span class="keyword">size_t</span> length) &#123;</div><div class="line">  ensureWriter(m_response.mimeType()); <span class="comment">//会初始化 HTMLDocumentParser 实例化 document 对象</span></div><div class="line">  <span class="keyword">if</span> (length)</div><div class="line">    m_dataReceived = <span class="literal">true</span>;</div><div class="line">  m_writer-&gt;addData(bytes, length); <span class="comment">//给 Parser 解析，这里的bytes就是返回来的 html 文本代码</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//ensureWriter 里有个判断，如果 m_writer 已经初始化就不处理，所以 parser 只会初始化一次</span></div><div class="line"><span class="keyword">void</span> DocumentLoader::ensureWriter(<span class="keyword">const</span> AtomicString&amp; mimeType, <span class="keyword">const</span> KURL&amp; overridingURL) &#123;</div><div class="line">  <span class="keyword">if</span> (m_writer)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h3><p>DOM Tree 已经被 W3 标准化了 <a href="https://www.w3.org/DOM/DOMTR" target="_blank" rel="external">Document Object Model (DOM) Technical Reports</a> 在 DOM Level 3 里 IDL 的定义在 <a href="https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/" target="_blank" rel="external">IDL Definitions</a></p>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>Node 是 DOM 模型的基础类，根据标签的不同可以分成多个类，详细的定义可以看 NodeType，最主要的是 Document，Element 和 Text 三类。下图列出了 Node 节点相关继承关系图：<br><img src="/uploads/deeply-analyse-webkit/56.png" alt="56"></p>
<p>在构建树时是由 Insertion Mode 来控制，这个规则是完全按照 w3c 指定，可以参看：<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode" target="_blank" rel="external">http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode</a> 。构建树级别时是根据堆栈来的，碰到 StartTag 的 token 就会在 m_opnElements 里压栈，碰到 EndTag 的 token 就会出栈。 w3c 对于 Element 的堆栈也有规范：<a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a> 。通过 ContainerNode::parserAddChild 接口添加 Node 到 DOM Tree 中。</p>
<p>需要注意的是有些标签属于 Format 标签不参与嵌套关系属于平级，是不会被加入到 m_openElements 里。这些标签的定义可以参看：<a href="https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements</a></p>
<p><img src="/uploads/deeply-analyse-webkit/37.png" alt="37"></p>
<p>DOM Node 的数据结构<br><img src="/uploads/deeply-analyse-webkit/12.png" alt="12"></p>
<h4 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h4><p>由 HTMLElementFactory 类的 createHTMLElement 来创建，然后通过 Hash map 来记录，key 为 tag name，value 为对应的 element。不同 tag 有不同的 HTMLElement 派生类，类继承图如下：<br><img src="/uploads/deeply-analyse-webkit/75.png" alt="75"></p>
<h4 id="构建-DOM-Tree-1"><a href="#构建-DOM-Tree-1" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h4><p>从 Token 的构建节点。是 HTMLDocumentParser 类调用了 HTMLTreeBuilder 类的 processToken 函数来处理的，该函数在 WebCore/html/parser/HTMLTreeBuilder.cpp 文件里。<br>constructtreefromToken<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HTMLTreeBuilder::processToken(AtomicHTMLToken&amp;&amp; token)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (token.type()) &#123;</div><div class="line">    <span class="keyword">case</span> HTMLToken::Uninitialized:</div><div class="line">        ASSERT_NOT_REACHED();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::DOCTYPE:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processDoctypeToken(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::StartTag:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processStartTag(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::EndTag:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processEndTag(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::Comment:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processComment(WTFMove(token));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::Character:</div><div class="line">        processCharacter(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::EndOfFile:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processEndOfFile(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将节点构建成 DOM Tree，还有给 Tree 的元素节点创建属性节点都是 HTMLConstructionSite 这个类来做的，它会通过 insert 类函数一次将 Token 类型创建的 HTMLElement 对象加入到 DOM Tree。这个类会会先创建一个 html 根节点 HTMLDocument 对象和一个栈 HTMLElementStack 变量，栈里存放没有遇到 EndTag 的 所有 StartTag。根据这个栈来建立父子关系。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomicHTMLToken* token) &#123;</div><div class="line">  HTMLHtmlElement* element = HTMLHtmlElement::create(*m_document);</div><div class="line">  attachLater(m_attachmentRoot, element);</div><div class="line">  m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element, token)); <span class="comment">//push 到 HTMLStackItem 栈里</span></div><div class="line">  executeQueuedTasks();</div><div class="line">&#125;</div><div class="line"><span class="comment">//通过 attachLater 创建 task</span></div><div class="line"><span class="keyword">void</span> HTMLConstructionSite::attachLater(ContainerNode* parent,</div><div class="line">                                       Node* child,</div><div class="line">                                       <span class="keyword">bool</span> selfClosing) &#123;</div><div class="line">  <span class="function">HTMLConstructionSiteTask <span class="title">task</span><span class="params">(HTMLConstructionSiteTask::Insert)</span></span>;</div><div class="line">  task.parent = parent;</div><div class="line">  task.child = child;</div><div class="line">  task.selfClosing = selfClosing;</div><div class="line">  <span class="comment">//判断是否到达最深，512是最深</span></div><div class="line">  <span class="keyword">if</span> (m_openElements.stackDepth() &gt; maximumHTMLParserDOMTreeDepth &amp;&amp;</div><div class="line">      task.parent-&gt;parentNode())</div><div class="line">    task.parent = task.parent-&gt;parentNode();</div><div class="line">  queueTask(task);</div><div class="line">&#125;</div><div class="line"><span class="comment">//executeQueued 添加子节点</span></div><div class="line"><span class="keyword">void</span> ContainerNode::parserAppendChild(Node* newChild) &#123;</div><div class="line">  <span class="keyword">if</span> (!checkParserAcceptChild(*newChild))</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    AdoptAndAppendChild()(*<span class="keyword">this</span>, *newChild, <span class="literal">nullptr</span>);</div><div class="line">  &#125;</div><div class="line">  notifyNodeInserted(*newChild, ChildrenChangeSourceParser);</div><div class="line">&#125;</div><div class="line"><span class="comment">//添加前会先检查是否支持子元素</span></div><div class="line"><span class="keyword">void</span> ContainerNode::appendChildCommon(Node&amp; child) &#123;</div><div class="line">  child.setParentOrShadowHostNode(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">if</span> (m_lastChild) &#123;</div><div class="line">    child.setPreviousSibling(m_lastChild);</div><div class="line">    m_lastChild-&gt;setNextSibling(&amp;child);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    setFirstChild(&amp;child);</div><div class="line">  &#125;</div><div class="line">  setLastChild(&amp;child);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>闭标签会把元素 pop 出来<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m_tree.openElements()-&gt;popUntilPopped(token-&gt;name());</div></pre></td></tr></table></figure></p>
<h3 id="对错误的处理"><a href="#对错误的处理" class="headerlink" title="对错误的处理"></a>对错误的处理</h3><p>parser 一个 html 代码的时候如果是符合规范的那么就都好说，不幸的是很多 html 代码都不规范，所以 parser 需要做些容错。下面列出一些 WebKit 容错的例子</p>
<h4 id="问题"><a href="#问题" class="headerlink" title=" 问题"></a><br> 问题</h4><p>一些网站会用 <br> 替代 <br>，处理的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</div><div class="line">     reportError(MalformedBRError);</div><div class="line">     t-&gt;beginTag = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="stray-table"><a href="#stray-table" class="headerlink" title="stray table"></a>stray table</h4><p>stray table 是一个 table 包含了一个不在 table cell 的 table。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>WebKit 的处理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (m_inStrayTableContent &amp;&amp; localName == tableTag)</div><div class="line">        popBlock(tableTag);</div></pre></td></tr></table></figure></p>
<p>这样会处理成两个同级 table<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="嵌套-form"><a href="#嵌套-form" class="headerlink" title="嵌套 form"></a>嵌套 form</h4><p>将一个 form 放到另一个 form 里。那么第二个 form 会被忽略<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!m_currentFormElement) &#123;</div><div class="line">        m_currentFormElement = <span class="keyword">new</span> HTMLFormElement(formTag,    m_document);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="过深的层级"><a href="#过深的层级" class="headerlink" title="过深的层级"></a>过深的层级</h4><p>同一个类型里只允许嵌套 20 个 tag。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> HTMLParser::allowNestedRedundantTag(<span class="keyword">const</span> AtomicString&amp; tagName)</div><div class="line">&#123;</div><div class="line"><span class="keyword">unsigned</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (HTMLStackElem* curr = m_blockStack;</div><div class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</div><div class="line">     curr = curr-&gt;next, i++) &#123; &#125;</div><div class="line"><span class="keyword">return</span> i != cMaxRedundantTagDepth;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="html-或-body-的-end-tags-缺失"><a href="#html-或-body-的-end-tags-缺失" class="headerlink" title="html 或 body 的 end tags 缺失"></a>html 或 body 的 end tags 缺失</h4><p>这些都会在 end() 是调用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</div><div class="line">        <span class="keyword">return</span>;</div></pre></td></tr></table></figure></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-语法简介"><a href="#CSS-语法简介" class="headerlink" title="CSS 语法简介"></a>CSS 语法简介</h3><p>所有的 CSS 都是由 CSSStyleSheet 集合组成，CSSStyleSheet 是有多个 CSSRule 组成，每个 CSSRule 由 CSSStyleSelector 选择器和 CSSStyleDeclaration 声明组成。CSSStyleDeclaration 是 CSS 属性的键值集合。</p>
<h4 id="CSS-declarations"><a href="#CSS-declarations" class="headerlink" title="CSS declarations"></a>CSS declarations</h4><p><img src="/uploads/deeply-analyse-webkit/40.png" alt="40"><br>在这里可以找到 CSS  的不同的属性。</p>
<h4 id="CSS-declaration-blocks"><a href="#CSS-declaration-blocks" class="headerlink" title="CSS declaration blocks"></a>CSS declaration blocks</h4><p>使用大括号包起来。<br><img src="/uploads/deeply-analyse-webkit/41.png" alt="41"></p>
<h4 id="CSS-selectors-and-rules"><a href="#CSS-selectors-and-rules" class="headerlink" title="CSS selectors and rules"></a>CSS selectors and rules</h4><p>在 CSS declarations block 前加上 selector 来匹配页面上的元素。selector 和 declarations block 在一起被称作 ruleset，简称 rule。<br><img src="/uploads/deeply-analyse-webkit/42.png" alt="42"></p>
<p>selector 可以分为以下类别</p>
<ul>
<li>Simple selectors：简单选择器，通过 class 或 id 类匹配一个或多个元素。</li>
<li>Attribute selectors：属性选择器，通过属性匹配。</li>
<li>Pseudo-classes：伪类，匹配确定状态的比如鼠标悬停元素，当前选中或未选中的复选框， DOM 树中一父节点的第一个子节点的元素。比如 a:visited 表示访问过的链接， a:hover 表示鼠标在上面的链接。</li>
<li>Pseudo-elements：伪元素，匹配处于确定位置的一个或多个元素，比如每个段落的第一个字，某个元素之前生成的内容。比如 [href^=http]::after { content: ‘-&gt;’} 表示属性是 herf 值的开头是 http 的元素内容后面添加 -&gt; 符号。</li>
<li>Combinators：组合器，组合多个选择器用于特定的选择的方法。比如只选择 div 的直系子节点段落。比如 A &gt; B 那么 B 是 A 的直接子节点。</li>
<li>Multiple selectors：多用选择器，将一组声明应用于由多个选择器选择的所有元素。</li>
</ul>
<p>Attribute selectors 属性选择器是针对 data-* 这样的数据属性进行选择的，尝试匹配精确属性值的 Presence and value attribute selector 分为下面几种</p>
<ul>
<li>[attr]：不论值是什么选择所有 attr 属性的元素。</li>
<li>[attr=val]：按照 attr 属性的值为 val 的所有元素。</li>
<li>[attr~=val]：attr 属性的值包含 val 值的所有元素，val 以空格间隔多个值。</li>
</ul>
<p>还有 Substring value attribute selector 这样的伪正则选择器：</p>
<ul>
<li>[attr|=val]：匹配选择以 val 或 val- 开头的元素，-一般用来处理语言编码。</li>
<li>[attr^=val]：匹配选择以 val 开头的元素。</li>
<li>[attr$=val]：匹配选择以 val 结尾的元素。</li>
<li>[attr*=val]：匹配选择包含 val 的元素。</li>
</ul>
<p>Combinators 组合器有以下几种</p>
<ul>
<li>A,B： 匹配 A B 的任意元素。</li>
<li>A B：B 是 A 的后代节点，可以是直接的子节点或者是子节点的子节点。</li>
<li>A &gt; B：B 是 A 的直接子节点。</li>
<li>A + B：B 是 A 的兄弟节点。</li>
<li>A ~ B：B 是 A 兄弟节点中的任意一个。</li>
</ul>
<h4 id="CSS-statements"><a href="#CSS-statements" class="headerlink" title="CSS statements"></a>CSS statements</h4><p>CSS rule 只是 CSS statements 的一种。<br>其它类型是 @-规则，在 CSS 里使用 @-规则来传递元数据，条件信息或其它描述信息。@ 符号后面跟一个描述符来表明用哪种规则，再后面是 CSS declarations block，结束是 ; 符号。</p>
<ul>
<li>@charset：元数据</li>
<li>@import：元数据</li>
<li>@media：嵌套语句，只在运行浏览器的设备匹配条件时才会运用 @-规则里的内容。</li>
<li>@supports：嵌套语句，只有浏览器确实支持采用应用 @-规则里的内容。</li>
<li>@document：嵌套语句，只有当前页面匹配条件采用运用 @-规则的内容。</li>
<li>@font-face：描述性信息</li>
</ul>
<p>比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">import</span> <span class="string">'starming.css'</span>;</div></pre></td></tr></table></figure></p>
<p>表示向当前的 CSS 导入了 starming.css 文件。再举个例子：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> (min-width: <span class="number">801px</span>) &#123;</div><div class="line">    <span class="selector-tag">body</span> &#123;</div><div class="line">        <span class="attribute">margin</span>:<span class="number">0</span> auto;</div><div class="line">        <span class="attribute">width</span>:<span class="number">800px</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个表示页面宽度超过801像素时才会运用 @-规则里的内容。</p>
<h4 id="Shorthand"><a href="#Shorthand" class="headerlink" title="Shorthand"></a>Shorthand</h4><p>有些属性是 Shorthand 属性，比如 font，background，padding，border和 margin。他们允许一行里设置多个属性。<br>比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">maring</span>: 20<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure></p>
<p>等效于<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">margin-top</span>: 20<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">margin-right</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">margin-bottom</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">margin-left</span>: 20<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure></p>
<p>再比如 background 属性<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">black</span> <span class="selector-tag">url</span>(<span class="selector-tag">starming-bg</span><span class="selector-class">.png</span>) 20<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> <span class="selector-tag">repeat-x</span> <span class="selector-tag">fixed</span>;</div></pre></td></tr></table></figure></p>
<p>和下面的属性设置等效<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">black</span>;</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">starming-bg</span><span class="selector-class">.png</span>);</div><div class="line"><span class="selector-tag">background-position</span>: 20<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">repeat-x</span>;</div><div class="line"><span class="selector-tag">background-scroll</span>: <span class="selector-tag">fixed</span>;</div></pre></td></tr></table></figure></p>
<h4 id="Value-and-unit"><a href="#Value-and-unit" class="headerlink" title="Value and unit"></a>Value and unit</h4><ul>
<li>absolute units 绝对单位：px，mm，cm，in：pixel 像素，millimeters 毫米，centimeters 厘米，inches 英寸。pt，pc：Points (1/72 of an inch) 点，picas (12 points.) 十二点活字。</li>
<li>相对单位：em：1em 的计算值默认为 16px。但是要注意 em 单位会继承父元素的字体大小。ex，ch：支持的不是很好。rem：REM(root em)，跟 em 工作方式一样，不同的是总是等于默认基础字体大小。vw，vh：视图宽度的 1/100 和视图高度的 1/100，但是支持没有 rem 那么好。</li>
<li>无单位的值：在某些情况下无单位的值是可以存在的，比如设置 margin: 0; 就是可以的，还有 p { line-height: 1.5 } 这里的值类似一个简单的乘法因子，比如 font-size 为16px的话，行高就为24px。</li>
<li>百分比：相对于父容器所占的百分比，注意如果 font-size 使用百分比是指新的大小相对于父容器的字体大小，和 em 类似，所以 200% 和 2em 类似。</li>
<li>颜色：有165个不同关键字可用，具体见 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords</a> ，还可以使用类似 background-color: #0000ff; 这样的十六进制表示颜色，还有 RGB 表示 background-color: rgb(0,0,255); 。还支持background-color: hsl(240,100%,50%); 这种 HSL 的表示，值依次是色调，值范围是0到360，饱和度0表示没有颜色，明度里0表示全黑，100%表示全白。HSL 是采用圆柱体可视化颜色的工作方式，Wikipedia 上有详细说明：<a href="https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle" target="_blank" rel="external">https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle</a></li>
<li>透明度：可以通过 rgba 和 hsla 来表示，比如 background-color: hsla(240,100%,50%,0.5); 。还可以通过 CSS 属性 opacity 来指定透明度。</li>
<li>函数：只要是一个名字后面用括号包含一个或多个值之间用逗号分隔就是一个函数，比如 background-color: rgba(255,0,0,0.5); transform: translate(50px, 60px); background-image: url(‘myimage.png’);</li>
</ul>
<h4 id="验证-CSS-语法正确性"><a href="#验证-CSS-语法正确性" class="headerlink" title="验证 CSS 语法正确性"></a>验证 CSS 语法正确性</h4><p>可以通过 w3c 提供的服务 <a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="external">http://jigsaw.w3.org/css-validator/</a> 来验证，w3c 还提供了 html 的验证服务 <a href="https://validator.w3.org/#validate_by_uri" target="_blank" rel="external">https://validator.w3.org/#validate_by_uri</a></p>
<h3 id="CSS-BNF"><a href="#CSS-BNF" class="headerlink" title="CSS BNF"></a>CSS BNF</h3><p>CSS 语法 BNF<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ruleset</div><div class="line">  : selector [ &apos;,&apos; S* selector ]*</div><div class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</div><div class="line">  ;</div><div class="line">selector</div><div class="line">  : simple_selector [ combinator selector | S+ [ combinator selector ] ]</div><div class="line">  ;</div><div class="line">simple_selector</div><div class="line">  : element_name [ HASH | class | attrib | pseudo ]*</div><div class="line">  | [ HASH | class | attrib | pseudo ]+</div><div class="line">  ;</div><div class="line">class</div><div class="line">  : &apos;.&apos; IDENT</div><div class="line">  ;</div><div class="line">element_name</div><div class="line">  : IDENT | &apos;*&apos;</div><div class="line">  ;</div><div class="line">attrib</div><div class="line">  : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</div><div class="line">    [ IDENT | STRING ] S* ] &apos;]&apos;</div><div class="line">  ;</div><div class="line">pseudo</div><div class="line">  : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</div><div class="line">  ;</div></pre></td></tr></table></figure></p>
<p>WebKit 会使用 Flex 和 Bison 来解析这个 BNF 文件。CSS 文件会被解析成 StyleSheet object，每个 object 包含 CSS rules object，这些 object 包含 selector 和 declaration 还要其它对应于 CSS 语法的 object。接下来进行会进行 CSSRule 的匹配过程，去找能够和 CSSRule Selector 部分匹配的 HTML 元素。<br><img src="/uploads/deeply-analyse-webkit/68.png" alt="68"></p>
<h3 id="CSS-主要类与关系"><a href="#CSS-主要类与关系" class="headerlink" title="CSS 主要类与关系"></a>CSS 主要类与关系</h3><p><img src="/uploads/deeply-analyse-webkit/57.png" alt="57"><br>上图看出 Document 里包含了一个 DocumentStyleSheetCollection 类和一个 StyleSheetResolver 类，DocumentStyleSheetCollection 包含了所有的 StyleSheet，StyleSheet 里包含了 CSS 的 href，类型，内容等信息，这些内容就是 StyleSheetContents，包含了 StyleRuleBase。</p>
<p>StyleSheetResolver 负责组织用来为 DOM 里的元素匹配的规则，里面包含了一个 DocumentRuleSets 的类，这个类是用来表示多个 RuleSet 的。</p>
<p>CSS 文档结构的类图如下：<br><img src="/uploads/deeply-analyse-webkit/90.png" alt="90"></p>
<h4 id="StyleRuleBase-类的继承关系"><a href="#StyleRuleBase-类的继承关系" class="headerlink" title="StyleRuleBase 类的继承关系"></a>StyleRuleBase 类的继承关系</h4><p>RuleSet 有很多类型，下图是 StyleRuleBase 相关继承关系<br><img src="/uploads/deeply-analyse-webkit/58.png" alt="58"><br>我们来看看这些子类类型都是对应 CSS 里的什么</p>
<ul>
<li>StyleRule：常用的都是这个类型</li>
<li>StyleRuleImport：对应的是 @import</li>
<li>StyleRuleMedia：对应的是 @media</li>
<li>StyleRuleFontFace：对应的 @font-face</li>
<li>StyleRulePage：对应的 @page</li>
<li>StyleRuleKeyFrames：对应的 @-webkit-key-frames</li>
<li>StyleRuleRegion：分区域排版</li>
</ul>
<h4 id="StyleRule-类的结构"><a href="#StyleRule-类的结构" class="headerlink" title="StyleRule 类的结构"></a>StyleRule 类的结构</h4><p><img src="/uploads/deeply-analyse-webkit/59.png" alt="59"></p>
<h3 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h3><p>WebKit 解析的入口函数是 CSSParser::parseSheet。解析过程如下图：<br><img src="/uploads/deeply-analyse-webkit/91.png" alt="91"></p>
<p>字符串转 tokens<br><img src="/uploads/deeply-analyse-webkit/13.png" alt="13"></p>
<p>将 tokens 转成 styleRule。每个 styleRule 包含 selectors 和 properties。<br>定义 matchType<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> MatchType &#123;</div><div class="line">    Unknown,</div><div class="line">    Tag,               <span class="comment">//比如 div</span></div><div class="line">    Id,                <span class="comment">// #id</span></div><div class="line">    Class,             <span class="comment">// .class</span></div><div class="line">    PseudoClass,       <span class="comment">// :nth-child(2)</span></div><div class="line">    PseudoElement,     <span class="comment">// ::first-line</span></div><div class="line">    PagePseudoClass,   <span class="comment">//</span></div><div class="line">    AttributeExact,    <span class="comment">// E[attr="value"]</span></div><div class="line">    AttributeSet,      <span class="comment">// E[attr]</span></div><div class="line">    AttributeHyphen,   <span class="comment">// E[attr|="value"]</span></div><div class="line">    AttributeList,     <span class="comment">// E[attr~="value"]</span></div><div class="line">    AttributeContain,  <span class="comment">// E[attr*="value"]</span></div><div class="line">    AttributeBegin,    <span class="comment">// E[attr^="value"]</span></div><div class="line">    AttributeEnd,      <span class="comment">// E[attr$="value"]</span></div><div class="line">    FirstAttributeSelectorMatch = AttributeExact,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义 selectors 的 Relation 类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> RelationType &#123;</div><div class="line">    SubSelector,       <span class="comment">// No combinator</span></div><div class="line">    Descendant,        <span class="comment">// "Space" combinator</span></div><div class="line">    Child,             <span class="comment">// &gt; combinator</span></div><div class="line">    DirectAdjacent,    <span class="comment">// + combinator</span></div><div class="line">    IndirectAdjacent,  <span class="comment">// ~ combinator</span></div><div class="line">    <span class="comment">// Special cases for shadow DOM related selectors.</span></div><div class="line">    ShadowPiercingDescendant,  <span class="comment">// &gt;&gt;&gt; combinator</span></div><div class="line">    ShadowDeep,                <span class="comment">// /deep/ combinator</span></div><div class="line">    ShadowPseudo,              <span class="comment">// ::shadow pseudo element</span></div><div class="line">    ShadowSlot                 <span class="comment">// ::slotted() pseudo element</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>CSS 的属性是 id 来标识的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> CSSPropertyID &#123;</div><div class="line">    CSSPropertyColor = <span class="number">15</span>,</div><div class="line">    CSSPropertyWidth = <span class="number">316</span>,</div><div class="line">    CSSPropertyMarginLeft = <span class="number">145</span>,</div><div class="line">    CSSPropertyMarginRight = <span class="number">146</span>,</div><div class="line">    CSSPropertyMarginTop = <span class="number">147</span>,</div><div class="line">    CSSPropertyMarkerEnd = <span class="number">148</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认样式，Blink ua全部 CSS 样式：<a href="http://yincheng.site/html/chrome-ua-css.html" target="_blank" rel="external">http://yincheng.site/html/chrome-ua-css.html</a> 。w3c 的默认样式是：<a href="https://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="external">https://www.w3.org/TR/CSS2/sample.html</a></p>
<p>接着会生成 hash map，分成四个类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CompactRuleMap m_idRules;                    <span class="comment">//id</span></div><div class="line">CompactRuleMap m_classRules;                 <span class="comment">//class</span></div><div class="line">CompactRuleMap m_tagRules;                   <span class="comment">//标签</span></div><div class="line">CompactRuleMap m_shadowPseudoElementRules;   <span class="comment">//伪类选择器</span></div></pre></td></tr></table></figure></p>
<p>CSS 解析完会触发  layout tree ，会给每个可视 Node 创建一个 layout 节点，创建时需要计算 style，这个过程包括找到 selector 和 设置 style。</p>
<p>layout 会更新递归所有 DOM 元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ContainerNode::attachLayoutTree(<span class="keyword">const</span> AttachContext&amp; context) &#123;</div><div class="line">  <span class="keyword">for</span> (Node* child = firstChild(); child; child = child-&gt;nextSibling()) &#123;</div><div class="line">    <span class="keyword">if</span> (child-&gt;needsAttach())</div><div class="line">      child-&gt;attachLayoutTree(childrenContext);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后对每个 node 都会按照 id，class，伪元素和标签顺序取出所有对应的 selector<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//id</span></div><div class="line"><span class="keyword">if</span> (element.hasID()) </div><div class="line">  collectMatchingRulesForList(</div><div class="line">      matchRequest.ruleSet-&gt;idRules(element.idForStyleResolution()),</div><div class="line">      cascadeOrder, matchRequest);</div><div class="line"><span class="comment">//class</span></div><div class="line"><span class="keyword">if</span> (element.isStyledElement() &amp;&amp; element.hasClass()) &#123; </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; element.classNames().size(); ++i)</div><div class="line">    collectMatchingRulesForList(</div><div class="line">        matchRequest.ruleSet-&gt;classRules(element.classNames()[i]),</div><div class="line">        cascadeOrder, matchRequest);</div><div class="line">&#125;</div><div class="line"><span class="comment">//伪类</span></div><div class="line">...</div><div class="line"><span class="comment">//tag 和 selector</span></div><div class="line">collectMatchingRulesForList(</div><div class="line">    matchRequest.ruleSet-&gt;tagRules(element.localNameForSelectorMatching()),</div><div class="line">    cascadeOrder, matchRequest);</div><div class="line"><span class="comment">//通配符</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>可以看到 id 是唯一的，容易直接取到，class 就需要遍历数组来设置 style。</p>
<p>在 classRules 里会进行检验<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!checkOne(context, subResult))</div><div class="line">  <span class="keyword">return</span> SelectorFailsLocally;</div><div class="line"><span class="keyword">if</span> (context.selector-&gt;isLastInTagHistory()) &#123; </div><div class="line">    <span class="keyword">return</span> SelectorMatches;</div><div class="line">&#125;</div><div class="line"><span class="comment">//checkOne 的实现</span></div><div class="line"><span class="keyword">switch</span> (selector.match()) &#123; </div><div class="line">  <span class="keyword">case</span> CSSSelector::Tag:</div><div class="line">    <span class="keyword">return</span> matchesTagName(element, selector.tagQName());</div><div class="line">  <span class="keyword">case</span> CSSSelector::Class:</div><div class="line">    <span class="keyword">return</span> element.hasClass() &amp;&amp;</div><div class="line">           element.classNames().contains(selector.value());</div><div class="line">  <span class="keyword">case</span> CSSSelector::Id:</div><div class="line">    <span class="keyword">return</span> element.hasID() &amp;&amp;</div><div class="line">           element.idForStyleResolution() == selector.value();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 Relation 类型是 Descendant 表示是后代，就需要在 checkOne 后处理 relation。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (relation) &#123; </div><div class="line">  <span class="keyword">case</span> CSSSelector::Descendant:</div><div class="line">    <span class="keyword">for</span> (nextContext.element = parentElement(context); nextContext.element;</div><div class="line">         nextContext.element = parentElement(nextContext)) &#123; </div><div class="line">      MatchStatus match = matchSelector(nextContext, result);</div><div class="line">      <span class="keyword">if</span> (match == SelectorMatches || match == SelectorFailsCompletely)</div><div class="line">        <span class="keyword">return</span> match;</div><div class="line">      <span class="keyword">if</span> (nextSelectorExceedsScope(nextContext))</div><div class="line">        <span class="keyword">return</span> SelectorFailsCompletely;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> SelectorFailsCompletely;</div><div class="line">      <span class="keyword">case</span> CSSSelector::Child:</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这个就是 selector 从右到左解释的实现，它会递归所有父节点，再次执行 checkOne ，这样直到找到需要的父节点以及如果需要的父节点的父节点才会停止递归。所以选择器不要写太长，会影响效率。</p>
<h3 id="CSS-规则匹配"><a href="#CSS-规则匹配" class="headerlink" title="CSS 规则匹配"></a>CSS 规则匹配</h3><p>CSS 解析完，节点会调用 CSSStyleSelector 的 styleForElement 来给节点创建 RenderStyle 实例。RenderObject 需要 RenderStyle 的排版信息。</p>
<p>CSSStyleSelector 会从 CSSRuleList 里将匹配的样式属性取出进行规则匹配，相关类图如下：<br><img src="/uploads/deeply-analyse-webkit/92.png" alt="92"><br>匹配的流程图如下：<br><img src="/uploads/deeply-analyse-webkit/93.png" alt="93"></p>
<h3 id="设置-style"><a href="#设置-style" class="headerlink" title="设置 style"></a>设置 style</h3><p>设置的顺序是先设置父节点，在使用默认的 UA 的 style，最后再使用 Author 的 style。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">style-&gt;inheritFrom(*state.parentStyle())</div><div class="line">matchUARules(collector);</div><div class="line">matchAuthorRules(*state.element(), collector);</div></pre></td></tr></table></figure>
<p>在执行每一步时如有一个 styleRule 匹配的话都会放到当前元素的 m_matchedRule 里，然后计算优先级，优先级算法就是从右到左取每个 selector 优先级之和，实现如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> CSSSelector* selector = <span class="keyword">this</span>; selector;</div><div class="line">     selector = selector-&gt;tagHistory()) &#123; </div><div class="line">  temp = total + selector-&gt;specificityForOneSelector();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> total;</div></pre></td></tr></table></figure></p>
<p>每个不同类型的 selector 的优先级如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (m_match) &#123;</div><div class="line">    <span class="keyword">case</span> Id: </div><div class="line">      <span class="keyword">return</span> <span class="number">0x010000</span>;</div><div class="line">    <span class="keyword">case</span> PseudoClass:</div><div class="line">      <span class="keyword">return</span> <span class="number">0x000100</span>;</div><div class="line">    <span class="keyword">case</span> Class:</div><div class="line">    <span class="keyword">case</span> PseudoElement:</div><div class="line">    <span class="keyword">case</span> AttributeExact:</div><div class="line">    <span class="keyword">case</span> AttributeSet:</div><div class="line">    <span class="keyword">case</span> AttributeList:</div><div class="line">    <span class="keyword">case</span> AttributeHyphen:</div><div class="line">    <span class="keyword">case</span> AttributeContain:</div><div class="line">    <span class="keyword">case</span> AttributeBegin:</div><div class="line">    <span class="keyword">case</span> AttributeEnd:</div><div class="line">      <span class="keyword">return</span> <span class="number">0x000100</span>;</div><div class="line">    <span class="keyword">case</span> Tag:</div><div class="line">      <span class="keyword">return</span> <span class="number">0x000001</span>;</div><div class="line">    <span class="keyword">case</span> Unknown:</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出 id 的优先级最大是 0x010000 = 65536，类，属性，伪类优先级是 0x000100 = 256，标签是 0x000001 = 1</p>
<p>举个优先级计算的例子<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*优先级为257 = 265 + 1*/</span></div><div class="line"><span class="selector-class">.text</span> <span class="selector-tag">h1</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">8em</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*优先级为65537 = 65536 + 1*/</span></div><div class="line"><span class="selector-id">#my-text</span> <span class="selector-tag">h1</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">16em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将所有 CSS 规则放到 collector 的 m_matchedRules 里，再根据优先级从小到大排序，这样，越执行到后面优先级越高，可以覆盖前面的。</p>
<p>目前优先级是 ID 选择器大于类型选择器，大于标签选择器，大于相邻选择器，大于子选择器，大于后代选择器。</p>
<p>排序规则<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compareRules</span><span class="params">(<span class="keyword">const</span> MatchedRule&amp; matchedRule1,</span></span></div><div class="line">                                <span class="keyword">const</span> MatchedRule&amp; matchedRule2) &#123;</div><div class="line">  <span class="keyword">unsigned</span> specificity1 = matchedRule1.specificity();</div><div class="line">  <span class="keyword">unsigned</span> specificity2 = matchedRule2.specificity();</div><div class="line">  <span class="keyword">if</span> (specificity1 != specificity2)</div><div class="line">    <span class="keyword">return</span> specificity1 &lt; specificity2;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> matchedRule1.position() &lt; matchedRule2.position();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>规则和优先级完后就开始设置元素的 style 了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">applyMatchedPropertiesAndCustomPropertyAnimations(</div><div class="line">        state, collector.matchedResult(), element);</div><div class="line"></div><div class="line">applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(</div><div class="line">      state, matchResult.allRules(), <span class="literal">false</span>, applyInheritedOnly, needsApplyPass);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> range : ImportantAuthorRanges(matchResult)) &#123;</div><div class="line">    applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(</div><div class="line">        state, range, <span class="literal">true</span>, applyInheritedOnly, needsApplyPass);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>最后的 style 是什么样的，style 会生成一个 ComputedStyle 对象。对象结构如下：<br><img src="/uploads/deeply-analyse-webkit/14.png" alt="14"></p>
<p><img src="/uploads/deeply-analyse-webkit/15.png" alt="15"></p>
<h3 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h3><p>CSS 对象模型 CSSOM 提供了便于 JavaScript 操作 CSS 的接口 CSSStyleSheet。通过这个接口我们可以很容易获取 CSS 的 href，cssRule 这样的信息。</p>
<p>W3C 还定义了 CSSOM View，增加了 Window，Document，Element，HTMLElement 和 MouseEvent 的接口。比如 Window 对 CSSOM View 的支持就可以在 WebCore/page/DOMWindow.idl 里查看到，我摘出和 CSSOM View 相关的规范定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-window-interface).</div><div class="line">[NewObject] MediaQueryList matchMedia(CSSOMString query);</div><div class="line">[Replaceable] readonly attribute Screen screen; // FIXME: Should be [SameObject].</div><div class="line"></div><div class="line">// Browsing context (CSSOM-View).</div><div class="line">void moveTo(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</div><div class="line">void moveBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</div><div class="line">void resizeTo(optional unrestricted float width = NaN, optional unrestricted float height = NaN); // Parameters should be mandatory and of type long.</div><div class="line">void resizeBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</div><div class="line"></div><div class="line">// Viewport (CSSOM-View).</div><div class="line">[Replaceable] readonly attribute long innerHeight;</div><div class="line">[Replaceable] readonly attribute long innerWidth;</div><div class="line"></div><div class="line">// Viewport scrolling (CSSOM-View).</div><div class="line">[Replaceable] readonly attribute double scrollX;</div><div class="line">[Replaceable, ImplementedAs=scrollX] readonly attribute double pageXOffset;</div><div class="line">[Replaceable] readonly attribute double scrollY;</div><div class="line">[Replaceable, ImplementedAs=scrollY] readonly attribute double pageYOffset;</div><div class="line">[ImplementedAs=scrollTo] void scroll(optional ScrollToOptions options);</div><div class="line">[ImplementedAs=scrollTo] void scroll(unrestricted double x, unrestricted double y);</div><div class="line">void scrollTo(optional ScrollToOptions options);</div><div class="line">void scrollTo(unrestricted double x, unrestricted double y);</div><div class="line">void scrollBy(optional ScrollToOptions option);</div><div class="line">void scrollBy(unrestricted double x, unrestricted double y);</div><div class="line"></div><div class="line">// Client (CSSOM-View).</div><div class="line">[Replaceable] readonly attribute long screenX;</div><div class="line">[Replaceable] readonly attribute long screenY;</div><div class="line">[Replaceable] readonly attribute long outerWidth;</div><div class="line">[Replaceable] readonly attribute long outerHeight;</div><div class="line">[Replaceable] readonly attribute double devicePixelRatio;</div></pre></td></tr></table></figure></p>
<p>可以看出 CSSOM View 定义了 Window 的大小，滚动，位置等各种信息。</p>
<h2 id="RenderObject-Tree"><a href="#RenderObject-Tree" class="headerlink" title="RenderObject Tree"></a>RenderObject Tree</h2><p>当 DOM tree 构建过程中，在 HTMLConstruction 的 attachToCurrent 方法里会通过 createRendererIfNeeded 方法构建的另外一个 tree，叫 Render tree。构成这个 tree 的元素都是 RenderObject。RenderObject 会记录各个 node 的 render 信息，比如 RenderStyle，Node 和 RenderLayer 等。当 WebKit 创建 DOM Tree 的同时也会创建 RenderObject 对象，DOM Tree 动态加入一个新节点时也会创建相应的 RenderObject 对象。</p>
<p>整个 tree 的创建过程都是由 NodeRenderingContext 类来完成。下图是如何创建 RenderObject 对象和构建 RenderObject Tree 的。<br><img src="/uploads/deeply-analyse-webkit/64.png" alt="64"><br>上图所示，WebKit 会先检查 DOM 节点是否需要新的  RenderObject 对象，需要的话会创建或者获取一个 NodeRenderingContext 对象来创建 RenderObject 对象。NodeRenderingContext 的作用是分析设置 RenderObject 对象父结点，兄弟节点等信息然后完成插入 RenderObject 树。</p>
<h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><p>RenderObject 需要知道 CSS 相关属性，会引用在 CSS 解析过程中生成的 CSSStyleSelector 提供的 RenderStyle。RenderObject 的创建过程如下：<br><img src="/uploads/deeply-analyse-webkit/88.png" alt="88"></p>
<p>RenderObject 被创建时创建时相关的类如下图所示：<br><img src="/uploads/deeply-analyse-webkit/62.png" alt="62"><br>Element 对象会递归调用 attach 函数，会检查是否需要创建一个新的 RenderObject。需要创建的话会使用 NodeRenderingContext 类来创建不同 DOM 节点类型的 RenderObject。attach 的具体过程是在当前的 Render 节点的父节点会将当前的 Render 节点插入到合适位置，父节点再设置当前节点的兄弟节点。attach 过程见下图：<br><img src="/uploads/deeply-analyse-webkit/89.png" alt="89"></p>
<p>RenderObject 树和 DOM 树一样也有很多类型，下面是 RenderObject 基类和子类示意图：<br><img src="/uploads/deeply-analyse-webkit/63.png" alt="63"></p>
<p>RenderObject 核心对象关系图如下：<br><img src="/uploads/deeply-analyse-webkit/94.png" alt="94"></p>
<p>RenderBox 类是 Box 模型的类，包含了外边距，内边距，边框等信息。</p>
<p>RenderObject 的继承关系图如下：<br><img src="/uploads/deeply-analyse-webkit/76.png" alt="76"></p>
<p>RenderObject 的一些主要虚函数</p>
<ul>
<li>parent()，firstChild()，nextSibling()，previousSibling()，addChild()，removeChild() 这些遍历和修改 RenderObject 树的函数。</li>
<li>layout()，style()，enclosingBox() 这些计算和获取布局的函数。</li>
<li>isASubClass 类似这样判断那种子类类型的函数。</li>
<li>paint()，repaint() 这样讲内容绘制传入绘制结果对象的坐标和绘图函数。</li>
</ul>
<p>RenderObject 用来构建 Render Tree 的相关方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">RenderElement* <span class="title">parent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_parent; &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDescendantOf</span><span class="params">(<span class="keyword">const</span> RenderObject*)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="function">RenderObject* <span class="title">previousSibling</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_previous; &#125;</div><div class="line"><span class="function">RenderObject* <span class="title">nextSibling</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_next; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Use RenderElement versions instead.</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> RenderObject* <span class="title">firstChildSlow</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">virtual</span> RenderObject* <span class="title">lastChildSlow</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</div><div class="line"></div><div class="line"><span class="function">RenderObject* <span class="title">nextInPreOrder</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">nextInPreOrder</span><span class="params">(<span class="keyword">const</span> RenderObject* stayWithin)</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">nextInPreOrderAfterChildren</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">nextInPreOrderAfterChildren</span><span class="params">(<span class="keyword">const</span> RenderObject* stayWithin)</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">previousInPreOrder</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">previousInPreOrder</span><span class="params">(<span class="keyword">const</span> RenderObject* stayWithin)</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">WEBCORE_EXPORT RenderObject* <span class="title">childAt</span><span class="params">(<span class="keyword">unsigned</span>)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="function">RenderObject* <span class="title">firstLeafChild</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">lastLeafChild</span><span class="params">()</span> <span class="keyword">const</span></span>;</div></pre></td></tr></table></figure></p>
<p>RenderObject 用来布局相关的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">needsLayout</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout()</div><div class="line">        || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">selfNeedsLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.needsLayout(); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">needsPositionedMovementLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.needsPositionedMovementLayout(); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">needsPositionedMovementLayoutOnly</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()</div><div class="line">        &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">posChildNeedsLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.posChildNeedsLayout(); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">needsSimplifiedNormalFlowLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.needsSimplifiedNormalFlowLayout(); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">normalChildNeedsLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.normalChildNeedsLayout(); &#125;</div></pre></td></tr></table></figure></p>
<p>RenderBoxModelObject 是 RenderObject 的子类，是对 CSS Box 的封装，里面定义了 CSS Box 的各个接口。</p>
<p>RenderBox 是 RenderBoxModelObject 的子类，会重载 RenderObject 和 RenderBoxModelObject 的一些方法。</p>
<p>RenderBlock 是 RenderBox 的子类，封装 CSS 里 Block 的元素，里面有布局 Inline，block，和定位相关的方法，有删除，插入 Float 浮动节点还有计算浮动节点位置等方法，绘制相关的比如绘制 Float 节点，绘制 outline，绘制选择区等方法。</p>
<p>RenderView 继承自 RenderBlock，Render Tree 的根节点，是 Tree 布局和渲染的入口。</p>
<p>RenderInlineBox 是 RenderBoxModelObject 的子类，会封装 CSS 里的 Inline 元素。里面的方法主要处理 Inline 的自动换多行情况。对多行的处理 RenderInlineBox 会有个 RenderInlineBoxList 类的 m_lineBoxes 持有有多个 InlineBox 的行元素。RenderBox 和 InlineBox 的关系类图如下：<br><img src="/uploads/deeply-analyse-webkit/95.png" alt="95"><br>RenderStyle 会保存 CSS 解析结果，这些 CSS 属性会保存在 InheritedFlags 和 NonInheritedFlags 里，InheritedFlags 保存的都是文本方向和文本对齐等属性，NonInheritedFlags 里保存了浮动，定位，overflow 等属性，还有大量的访问和设置 CSS 属性的方法。</p>
<p>RenderText 继承 RenderObject，提供处理文字相关功能。相关的类图如下：<br><img src="/uploads/deeply-analyse-webkit/96.png" alt="96"></p>
<h3 id="StyleResolver"><a href="#StyleResolver" class="headerlink" title="StyleResolver"></a>StyleResolver</h3><p>RenderStyle 来自 CSS，保存了 Render Tree 绘制需要的所有内容，StyleResolver 就是负责将 CSS 转成 RenderStyle。StyleResolver 类根据元素的信息，例如标签名和类别等，保存到新建的 RenderStyle 对象中，它们最后被 RenderObject 类所管理和使用。<br><img src="/uploads/deeply-analyse-webkit/61.png" alt="61"></p>
<p>规则的匹配是由 ElementRuleCollector 类计算获得，根据元素属性信息，从 DocumentRuleSets 类里获得规则集合按照 ID，Class，Tag 等信息获得元素的样式，具体的过程如下：<br><img src="/uploads/deeply-analyse-webkit/60.png" alt="60"><br>创建 RenderObject 类时 StyleResolver 会收集样式信息给 RenderStyle 对象，这样 RenderStyle 对象包含了完整的样式信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PassRefPtr&lt;RenderStyle&gt; styleForElement(Element*, RenderStyle* parentStyle = <span class="number">0</span>, StyleSharingBehavior = AllowStyleSharing,  </div><div class="line">    RuleMatchingBehavior = MatchAllRules, RenderRegion* regionForStyling = <span class="number">0</span>);   </div><div class="line"> ......  </div><div class="line">  </div><div class="line">PassRefPtr&lt;RenderStyle&gt; pseudoStyleForElement(PseudoId, Element*, RenderStyle* parentStyle);  </div><div class="line">  </div><div class="line">PassRefPtr&lt;RenderStyle&gt; styleForPage(<span class="keyword">int</span> pageIndex);  </div><div class="line">PassRefPtr&lt;RenderStyle&gt; defaultStyleForElement();  </div><div class="line">PassRefPtr&lt;RenderStyle&gt; styleForText(Text*);  </div><div class="line">  </div><div class="line"><span class="keyword">static</span> PassRefPtr&lt;RenderStyle&gt; styleForDocument(Document*, CSSFontSelector* = <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>StyleResolver 是 Document 的子对象。当 CSS 发生变化（style 发生变化）就会调用 recalcStyle，recalcStyle 调用 Element::StyleForRender，Element::StyleForRender 调用 styleForElement。</p>
<h3 id="styleForElement-进行-CSS-选择和匹配"><a href="#styleForElement-进行-CSS-选择和匹配" class="headerlink" title="styleForElement 进行 CSS 选择和匹配"></a>styleForElement 进行 CSS 选择和匹配</h3><p>具体代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存 element</span></div><div class="line">initElement(element);</div><div class="line">initForStyleResolve(element, defaultParent);  </div><div class="line">....  </div><div class="line"></div><div class="line"><span class="comment">//规则匹配  </span></div><div class="line">MatchResult matchResult;  </div><div class="line"><span class="keyword">if</span> (matchingBehavior == MatchOnlyUserAgentRules)  </div><div class="line">    matchUARules(matchResult);  </div><div class="line"><span class="keyword">else</span>  </div><div class="line">    matchAllRules(matchResult, matchingBehavior != MatchAllRulesExcludingSMIL);  </div><div class="line"></div><div class="line"><span class="comment">//将规则和 element 做映射</span></div><div class="line">applyMatchedProperties(matchResult, element);</div><div class="line"></div><div class="line"><span class="comment">//matchUARules</span></div><div class="line"><span class="keyword">void</span> StyleResolver::matchUARules(MatchResult&amp; result, RuleSet* rules)  </div><div class="line">&#123;</div><div class="line">    m_matchedRules.clear();</div><div class="line">    result.ranges.lastUARule = result.matchedProperties.size() - <span class="number">1</span>;</div><div class="line">    <span class="comment">//收集匹配规则</span></div><div class="line">    collectMatchingRules(rules, result.ranges.firstUARule, result.ranges.lastUARule, <span class="literal">false</span>);  </div><div class="line">	<span class="comment">//规则排序</span></div><div class="line">    sortAndTransferMatchedRules(result);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="RuleSet"><a href="#RuleSet" class="headerlink" title="RuleSet"></a>RuleSet</h3><p>matchUARules 的 RuleSet 代表 CSS 规则，比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">background </span>: red; &#125;</div></pre></td></tr></table></figure></p>
<p>RuleSet 的成员变量<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RuleSet</span> ... &#123;</span></div><div class="line">.....</div><div class="line">AtomRuleMap m_idRules;</div><div class="line">AtomRuleMap m_classRules;</div><div class="line">AtomRuleMap m_tagRules;</div><div class="line">AtomRuleMap m_shadowPseudoElementRules;</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>sortAndTransferMatchedRules 是为了保证正确的匹配顺序。</p>
<p>RuleSet 来自浏览器定义的默认 RuleSet，也可来自写页面定义的 Author RuleSet，对于 Element 还有自身的规则。只有继承 StyledElement 的内联 CSS 的 Element 才能够有 RuleSet。实现是在 StyledElement::rebuildPresentationAttributeStyle 里实现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> StyledElement::rebuildPresentationAttributeStyle()  </div><div class="line">&#123;  </div><div class="line">.....  </div><div class="line">  </div><div class="line">    RefPtr&lt;StylePropertySet&gt; style;</div><div class="line">    <span class="keyword">if</span> (cacheHash &amp;&amp; cacheIterator-&gt;value) &#123;  </div><div class="line">        style = cacheIterator-&gt;value-&gt;value;  </div><div class="line">        presentationAttributeCacheCleaner().didHitPresentationAttributeCache();  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        style = StylePropertySet::create(isSVGElement() ? SVGAttributeMode : CSSQuirksMode);  </div><div class="line">        <span class="keyword">unsigned</span> size = attributeCount();  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;  </div><div class="line">            <span class="keyword">const</span> Attribute* attribute = attributeItem(i);  </div><div class="line">            collectStyleForPresentationAttribute(*attribute, style.get());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// ImmutableElementAttributeData doesn't store presentation attribute style, so make sure we have a MutableElementAttributeData.  </span></div><div class="line">    ElementAttributeData* attributeData = mutableAttributeData();  </div><div class="line">  </div><div class="line">    attributeData-&gt;m_presentationAttributeStyleIsDirty = <span class="literal">false</span>;  </div><div class="line">    attributeData-&gt;setPresentationAttributeStyle(style-&gt;isEmpty() ? <span class="number">0</span> : style);  </div><div class="line">....</div></pre></td></tr></table></figure></p>
<p>关于 AuthorStyle 用 StyleResolver::m_authorStyle 来保存 html 里所有 style tag 和 link 的外部 css。当 CSS 被改变或者页面大小变化时会调用 Document::styleResolverChanged 函数，接着调用 DocumentStyleCollection::updateActiveStyleSheets，最后调用 StyleResolver::appendAuthorStyleSheets。</p>
<h3 id="Render-tree-和-DOM-tree-做对应"><a href="#Render-tree-和-DOM-tree-做对应" class="headerlink" title="Render tree 和 DOM tree 做对应"></a>Render tree 和 DOM tree 做对应</h3><p>其实并不是一一对应的，比如说 head 标签或者 display 属性为 none 的就不会在 Render tree 中。</p>
<p>有些 render object 有对应的 DOM node，但是不在 tree 的相同位置，比如 floats 和 absolutely position 的元素，他们会放在 tree 的其它地方，会映根据设置的 frame 直接射到对应的位置。如下图，虚线表示他们能够对应的：<br><img src="/uploads/deeply-analyse-webkit/65.png" alt="65"><br><img src="/uploads/deeply-analyse-webkit/73.png" alt="73"></p>
<p>上图可以看到一般的 Element 比如 HTMLBodyElement 和 HTMLDivElement 对应的都是 RenderBlock。</p>
<h3 id="构建-Render-Tree-的流程"><a href="#构建-Render-Tree-的流程" class="headerlink" title="构建 Render Tree 的流程"></a>构建 Render Tree 的流程</h3><p>解决样式和创建一个 renderer 称作 attachment，每个 Element 有一个 attach 方法，Render Tree 的创建就是从这里开始，attachment 是同步的，Element 节点插入 DOM tree 会调用新 node 的 attach 方法。在处理 html 和 body 标签时会创建 Render Tree 的 root。root Render Object 对应了 CSS 里的 containing block，top block 会包含所有的其它 block。Render Object 通过 RenderObject::CreateObject 静态方法创建，创建时会计算出 Element 的 CSSStyle。 浏览器 window 显示区域 viewport，在 WebKit 里叫做 RenderView。</p>
<h3 id="RenderLayer-Tree"><a href="#RenderLayer-Tree" class="headerlink" title="RenderLayer Tree"></a>RenderLayer Tree</h3><p>RenderLayer Tree 是基于 RenderObject Tree 建立的，它们是多个 RenderObject 对应一个 RenderLayer 的关系。在创建完 RenderObject Tree WebKit 还会创建 RenderLayer Tree，根节点是 RenderView 实例，根据一些条件来判断是否需要创建一个新的 RenderLayer 对象，再设置 RenderLayer 对象的父对象和兄弟对象。RenderLayer 需要满足一定条件才会创建，下面是那些需要创建新 RenderLayer 对象的条件：</p>
<ul>
<li>HTMLElement 节点对应的 RenderBlock 节点。</li>
<li>有设置 relative，absolute，transform 的 CSS position 属性的。</li>
<li>透明效果的 RenderObject 节点。</li>
<li>节点有 overflow， apha mask 或反射效果的 RenderObject 节点。</li>
<li>设置了 CSS filter 属性的节点。</li>
<li>使用 Canvas 或 WebGL 的 RenderObject 节点。</li>
<li>Video 节点对应的 RenderObject 节点。</li>
</ul>
<p>RenderObject Tree 和 RenderLayer Tree 的关系如下图：<br><img src="/uploads/deeply-analyse-webkit/66.png" alt="66"><br>接下来看看 RenderObject Tree 和 RenderLayer Tree 的布局信息如下图所示：<br><img src="/uploads/deeply-analyse-webkit/67.png" alt="67"></p>
<h3 id="style-计算"><a href="#style-计算" class="headerlink" title="style 计算"></a>style 计算</h3><p>构建 render tree 需要计算每个 render object 的视觉特性。是通过计算每个 element 的 style 属性来做到的。</p>
<p>这个样式包含了各种来源的 style sheets，有 inline style element 和 html 里视觉属性设置比如 bgcolor 这样的属性，后面这些都会转为 CSS style 的属性。来源还有浏览器默认的 style sheets，这个 style sheets 可以是用户自定义的。</p>
<p>我们先看看 style 计算可能会有一些什么样问题</p>
<ul>
<li>Style 的数据是个非常大的结构，因为里面有大量的 style 属性这样会有内存问题。</li>
<li>如果没有优化为每个 element 查找合适的规则会导致性能问题。为每个 element 到整个规则列表查找合适的规则是个巨大消耗。Selectors 可能会有个很复杂的结构，比如 div div div div {…} 这样的话匹配时会有很多遍历来匹配。</li>
<li>应用规则涉及到比较复杂的层级规则。</li>
</ul>
<p>下面来说下如何解决这些问题</p>
<h4 id="共享-style-数据"><a href="#共享-style-数据" class="headerlink" title="共享 style 数据"></a>共享 style 数据</h4><p>WebKit 的 nodes 是 style objects（RenderStyle），这些 objects 可以被 nodes 在某些情况下共享，这些 nodes 可以是兄弟节点或表兄弟节点。有下面这些情况是可以 style 共享的</p>
<ul>
<li>element 必须有相同的鼠标状态</li>
<li>都没有 id</li>
<li>tag 名能匹配上</li>
<li>class 属性能匹配上</li>
<li>一组映射的属性是相同的</li>
<li>链接状态能匹配上</li>
<li>focus 状态能匹配上</li>
<li>任何 element 都不会被属性 selectors 影响</li>
<li>elements 不能有 inline style 属性</li>
<li>不要使用兄弟 selectors</li>
</ul>
<h4 id="Rule-tree"><a href="#Rule-tree" class="headerlink" title="Rule tree"></a>Rule tree</h4><p>WebKit 会把 style objects 和 DOM 的 node 相关联。通过正确的顺序将所有逻辑规则值转成计算值，比如百分比会被转换成绝对单位，rule tree 可以使节点之间共享这些值，避免多次计算，同时节省内存。所有匹配的规则都会存在一个 tree 里。tree 的最下面的 node 有着最高的优先级。Rule tree 是当 node style 需要的时候才会去根据规则计算的。<br><img src="/uploads/deeply-analyse-webkit/70.png" alt="70"></p>
<p>通过上图看看设置 rule tree 的好处吧，如果我们要找到 B - E - I 的规则我们能够省掉很多工作，因为我们已经计算了 A - B - E - I。</p>
<h4 id="可确定样式分到各个-structs-里"><a href="#可确定样式分到各个-structs-里" class="headerlink" title="可确定样式分到各个 structs 里"></a>可确定样式分到各个 structs 里</h4><p>一些样式的信息是可以一开始就确定的，比如 border 和 color。所有属性分为可继承和不可继承两种，如果是需要继承需要特别指定，默认都是不可继承的。</p>
<p>rule tree 帮着我们缓存全部的 structs，这样的好处是如果下面的 node 没有可用的 struct，那么可以使用上一级 node 的缓存里的来用。</p>
<h4 id="使用-rule-tree-计算-style-contexts"><a href="#使用-rule-tree-计算-style-contexts" class="headerlink" title="使用 rule tree 计算 style contexts"></a>使用 rule tree 计算 style contexts</h4><p>当确定要为某个 element 计算 style context 时，我们首先计算 rule tree 的路径或者使用一个已经存在的。接着我们开始在我们新的 style context 里应用路径里的规则去填充 structs。</p>
<p>从路径下面的 node 开始，然后往上直到 struct 完成。如果 struct 没有符合的 rule node，那么往 rule tree  上面 node 找，知道找到就可以直接使用，这样就是被优化了，整个 struct 都是共享的。</p>
<p>如果没有找到一个为这个 struct 的 rule node 定义，那么先检查是否是可继承的，如果是就使用父 struct 的 context。如果这个条件也没满足那么就使用默认的值。</p>
<p>如果一个 element 有兄弟节点指向相同的 tree node，那么全部 style context 可以被共享。</p>
<p>看个例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">                          this is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> big error <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                          this is also a</div><div class="line">                          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> very  big  error<span class="tag">&lt;/<span class="name">span</span>&gt;</span> error</div><div class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>another error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>下面是 CSS 的定义<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;</div><div class="line"><span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;</div><div class="line"><span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;</div><div class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;</div><div class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;</div><div class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</div></pre></td></tr></table></figure></p>
<p>这里有两个 structs 需要填充， color struct 和 margin struct。color struct 只包含一个值， margin struct 有四个。下面是 rule tree<br><img src="/uploads/deeply-analyse-webkit/71.png" alt="71"></p>
<p>context tree：<br><img src="/uploads/deeply-analyse-webkit/72.png" alt="72"></p>
<p>假设到第二个 div 标签时，我们会创建一个 style context 给这个 node 并且填充 style struct。我们找到 1，2和6这个 rule 是满足的，而且在 rule tree 里已经存在了一个这样的路径，我们只需要把 F 添加到这个 node 里。这样形成一个 context tree 来保存这些对应关系。</p>
<p>现在需要填充 style struct，先从 margin struct 开始，比如 rule tree 里最后 node F 没有添加到 margin struct 里，我们可以往 rule tree 的上面找，找到并且使用之，最后我们找到 node B 这个是最近的一个有 margin struct 的 node。</p>
<p>已经定义了 color struct，那么就不能使用缓存的 struct，这样就不用往 rule tree 上级 node 去找，接着就把值转成 RGB 什么的并且缓存到这个 node 里。</p>
<p>对于第二个 span element，它会指向 rule G，就像前一个 span 一样。如果兄弟 node 都是指向同一个 rule node，那么它们是可以共享整个 style context 的。</p>
<p>如果是继承的 struct 会在 context tree 上进行缓存，color 属性是可继承的。</p>
<h4 id="比较容易匹配的-rules"><a href="#比较容易匹配的-rules" class="headerlink" title="比较容易匹配的 rules"></a>比较容易匹配的 rules</h4><p>下面是不同的 style rules 的来源：</p>
<ul>
<li><p>CSS rules，来自于 style sheets 或者在 style elements 里</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Inline style 属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:blue"</span> /&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>HTML 视觉属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">bgcolor</span>=<span class="string">"blue"</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>后面两个属于容易匹配 element，可以使用 element 作为 map 的 key。解析 style sheet 后，通过 selector rules 会添加一些 has maps。有 id 的 map，有 class name 的 map，还有 tag name 的 map。如果 selector 是 id 那么 rule 会添加到 id map 里。</p>
<p>如果是 class name 那么会添加到 class map 里。</p>
<p>这个操作更容易匹配 rule。完全没必要去查找每个声明，我们可以从对应的 element 的 map 里提取相关的 rule。</p>
<p>下面举个例子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-class">.error</span> &#123;<span class="attribute">color</span>:red&#125;</div><div class="line"><span class="selector-id">#messageDiv</span> &#123;<span class="attribute">height</span>:<span class="number">50px</span>&#125;</div><div class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</div></pre></td></tr></table></figure>
<p>第一个 rule 会被加到 class map 里。第二个会加入到 id map 里，第三个会被添加到 tag map 里。</p>
<p>对于下面的 HTML<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>an error occurred <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">" messageDiv"</span>&gt;</span>this is a message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们会先试着找 p 这个 element 的 rules，在 class map 里能找到 error 这个 key 里有 rule p.error。div 这个 element 可以在 id map 和 tag map 里找到。下面看看 div 的这个 rule<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table div &#123;margin:5px&#125;</div></pre></td></tr></table></figure></p>
<p>selector 都是从右到左来查找的，先在 tag map 里找 div，然后再看看左边是 table tag，所以不吻合。</p>
<h4 id="Style-sheet-的-cascade-排序"><a href="#Style-sheet-的-cascade-排序" class="headerlink" title="Style sheet 的 cascade 排序"></a>Style sheet 的 cascade 排序</h4><p>一个 style 属性可以被定义在多个 style sheets 里，那么应用 rules 的顺序就显得非常的重要，在 CSS 的定义里把这个顺序叫做 cascade 排序，意思是从低到高。</p>
<ul>
<li>浏览器的设置</li>
<li>用户的设置</li>
<li>网页里普通的设置</li>
<li>网页里重要的设置</li>
<li>用户重要的设置</li>
</ul>
<h4 id="CSS-specification"><a href="#CSS-specification" class="headerlink" title="CSS specification"></a>CSS specification</h4><p>selector 的 specifity 在 w3c 里有定义 <a href="https://www.w3.org/TR/CSS2/cascade.html#specificity" target="_blank" rel="external">https://www.w3.org/TR/CSS2/cascade.html#specificity</a></p>
<p>计算方法如下</p>
<ul>
<li>style attribute 数量 =a</li>
<li>ID attribute 数量 =b</li>
<li>其它的 attribute 和 pseudo-classes 数量 =c</li>
<li>element names 和 pseudo-element 数量 =d</li>
</ul>
<p>举个例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> *             &#123;&#125;  /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</div><div class="line"> li            &#123;&#125;  /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</div><div class="line"> li:first-line &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line"> ul li         &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line"> ul ol+li      &#123;&#125;  /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</div><div class="line"> h1 + *[rel=up]&#123;&#125;  /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</div><div class="line"> ul ol li.red  &#123;&#125;  /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</div><div class="line"> li.red.level  &#123;&#125;  /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</div><div class="line"> #x34y         &#123;&#125;  /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</div><div class="line"> style=""          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">HEAD</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-id">#x97z</span> &#123; <span class="attribute">color</span>: red &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">HEAD</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">BODY</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">P</span> <span class="attr">ID</span>=<span class="string">x97z</span> <span class="attr">style</span>=<span class="string">"color: green"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">BODY</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>从例子可以看出 p element 的 color 会是 green，因为 style attribute 会覆盖 Style element 里的设置，因为它有更高的 specificity。</p>
<h4 id="Rules-排序"><a href="#Rules-排序" class="headerlink" title="Rules 排序"></a>Rules 排序</h4><p>这些 rules 匹配后就需要对其排序了，WebKit 使用的是冒泡排序，通过重写 &gt; 操作符<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> spec1 = r1.selector()-&gt;specificity();</div><div class="line">    <span class="keyword">int</span> spec2 = r2.selector()-&gt;specificity();</div><div class="line">    <span class="keyword">return</span> (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h2><p>当 renderer 创建完并添加到 tree 里时是没有位置和高这些信息的，需要计算，WebKit 计算位置大小等信息的过程称为布局计算。</p>
<p>HTML 使用的是流式布局模型，那么就表示大多数情况一次就可以按照从左到右从顶到底算出布局需要的值。需要注意的是 HTML tables 需要的次数可能不仅一次。</p>
<p>Layout 是个递归的过程，以 FrameView::layout 为起始，调用 Render Tree 根节点的 layout，对应 HTML 里的 element，Layout 持续递归 frame hierarchy 计算每个 renderer 的几何信息。root 的 position 是0,0，把浏览器里可见的部分尺寸叫做 viewport。每个 renderer 都有 layout 或 reflow 方法，每个 renderer 都会去调用子视图的 layout 方法。FrameView::layout 可以被布局 WebViewCore::layout 方法触发。</p>
<h3 id="Layout-处理过程"><a href="#Layout-处理过程" class="headerlink" title="Layout 处理过程"></a>Layout 处理过程</h3><p>完成上面那些过程后就会开始布局，上面的过程达到开始布局 FrameView::layout 的方法堆栈如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">FrameView:: layout( <span class="keyword">bool</span> allowSubtree) <span class="comment">// 栈 顶 </span></div><div class="line">Document:: implicitClose() </div><div class="line">FrameLoader:: checkCallImplicitClose() </div><div class="line">FrameLoader:: checkCompleted() </div><div class="line">FrameLoader:: finishedParsing() </div><div class="line">Document:: finishedParsing() </div><div class="line">HTMLParser:: finished() </div><div class="line">HTMLTokenizer:: end() </div><div class="line">HTMLTokenizer:: finish() </div><div class="line">Document:: finishParsing() </div><div class="line">FrameLoader:: endIfNotLoadingMainResource() </div><div class="line">FrameLoader:: end() </div><div class="line">DocumentLoader:: finishedLoading() </div><div class="line">FrameLoader:: finishedLoading() </div><div class="line">MainResourceLoader:: didFinishLoading() </div><div class="line">ResourceLoader:: didFinishLoading( WebCore:: ResourceHandle * h)</div></pre></td></tr></table></figure></p>
<p>layout 会先暂停 layout 定时器的实现，然后更新样式，获取到 RenderView 然后调用它的 layout 方法开始布局，具体相关的代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div></pre></td><td class="code"><pre><div class="line">void FrameView::layout(bool allowSubtree)</div><div class="line">&#123;</div><div class="line">    ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate());</div><div class="line"></div><div class="line">    LOG(Layout, "FrameView %p (%dx%d) layout, main frameview %d, allowSubtree=%d", this, size().width(), size().height(), frame().isMainFrame(), allowSubtree);</div><div class="line">    //判断是否已在 layout 过程中，避免多次 layout</div><div class="line">    if (isInRenderTreeLayout()) &#123;</div><div class="line">        LOG(Layout, "  in layout, bailing");</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (layoutDisallowed()) &#123;</div><div class="line">        LOG(Layout, "  layout is disallowed, bailing");</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Protect the view from being deleted during layout (in recalcStyle).</div><div class="line">    Ref&lt;FrameView&gt; protectedThis(*this);</div><div class="line"></div><div class="line">    // Many of the tasks performed during layout can cause this function to be re-entered,</div><div class="line">    // so save the layout phase now and restore it on exit.</div><div class="line">    SetForScope&lt;LayoutPhase&gt; layoutPhaseRestorer(m_layoutPhase, InPreLayout);</div><div class="line"></div><div class="line">    // Every scroll that happens during layout is programmatic.</div><div class="line">    SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</div><div class="line"></div><div class="line">    bool inChildFrameLayoutWithFrameFlattening = isInChildFrameWithFrameFlattening();</div><div class="line"></div><div class="line">    if (inChildFrameLayoutWithFrameFlattening) &#123;</div><div class="line">        if (!m_frameFlatteningViewSizeForMediaQuery) &#123;</div><div class="line">            LOG_WITH_STREAM(MediaQueries, stream &lt;&lt; "FrameView " &lt;&lt; this &lt;&lt; " snapshotting size " &lt;&lt;  ScrollView::layoutSize() &lt;&lt; " for media queries");</div><div class="line">            m_frameFlatteningViewSizeForMediaQuery = ScrollView::layoutSize();</div><div class="line">        &#125;</div><div class="line">        startLayoutAtMainFrameViewIfNeeded(allowSubtree);</div><div class="line">        //获取 root。这个 root 就是 RenderView 对象</div><div class="line">        RenderElement* root = m_layoutRoot ? m_layoutRoot : frame().document()-&gt;renderView();</div><div class="line">        if (!root || !root-&gt;needsLayout())</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TraceScope tracingScope(LayoutStart, LayoutEnd);</div><div class="line"></div><div class="line">#if PLATFORM(IOS)</div><div class="line">    if (updateFixedPositionLayoutRect())</div><div class="line">        allowSubtree = false;</div><div class="line">#endif</div><div class="line">    //也是避免多次触发，会把 layoutTimer 先停止</div><div class="line">    m_layoutTimer.stop();</div><div class="line">    m_delayedLayout = false;</div><div class="line">    m_setNeedsLayoutWasDeferred = false;</div><div class="line">    </div><div class="line">    //我们不应该在 painting 时进入 layout</div><div class="line">    ASSERT(!isPainting());</div><div class="line">    if (isPainting())</div><div class="line">        return;</div><div class="line"></div><div class="line">    InspectorInstrumentationCookie cookie = InspectorInstrumentation::willLayout(frame());</div><div class="line">    AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());</div><div class="line">    </div><div class="line">    if (!allowSubtree &amp;&amp; m_layoutRoot)</div><div class="line">        convertSubtreeLayoutToFullLayout();</div><div class="line"></div><div class="line">    ASSERT(frame().view() == this);</div><div class="line">    ASSERT(frame().document());</div><div class="line"></div><div class="line">    Document&amp; document = *frame().document();</div><div class="line">    ASSERT(document.pageCacheState() == Document::NotInPageCache);</div><div class="line">    //对样式先进行更新</div><div class="line">    &#123;</div><div class="line">        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);</div><div class="line"></div><div class="line">        if (!m_nestedLayoutCount &amp;&amp; !m_inSynchronousPostLayout &amp;&amp; m_postLayoutTasksTimer.isActive() &amp;&amp; !inChildFrameLayoutWithFrameFlattening) &#123;</div><div class="line">            // This is a new top-level layout. If there are any remaining tasks from the previous</div><div class="line">            // layout, finish them now.</div><div class="line">            SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);</div><div class="line">            performPostLayoutTasks();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m_layoutPhase = InPreLayoutStyleUpdate;</div><div class="line"></div><div class="line">        // Viewport-dependent media queries may cause us to need completely different style information.</div><div class="line">        auto* styleResolver = document.styleScope().resolverIfExists();</div><div class="line">        if (!styleResolver || styleResolver-&gt;hasMediaQueriesAffectedByViewportChange()) &#123;</div><div class="line">            LOG(Layout, "  hasMediaQueriesAffectedByViewportChange, enqueueing style recalc");</div><div class="line">            document.styleScope().didChangeStyleSheetEnvironment();</div><div class="line">            // FIXME: This instrumentation event is not strictly accurate since cached media query results do not persist across StyleResolver rebuilds.</div><div class="line">            InspectorInstrumentation::mediaQueryResultChanged(document);</div><div class="line">        &#125;</div><div class="line">        document.evaluateMediaQueryList();</div><div class="line">        // If there is any pagination to apply, it will affect the RenderView's style, so we should</div><div class="line">        // take care of that now.</div><div class="line">        applyPaginationToViewport();</div><div class="line">        // Always ensure our style info is up-to-date. This can happen in situations where</div><div class="line">        // the layout beats any sort of style recalc update that needs to occur.</div><div class="line">        document.updateStyleIfNeeded();</div><div class="line">        // If there is only one ref to this view left, then its going to be destroyed as soon as we exit,</div><div class="line">        // so there's no point to continuing to layout</div><div class="line">        if (hasOneRef())</div><div class="line">            return;</div><div class="line"></div><div class="line">        // Close block here so we can set up the font cache purge preventer, which we will still</div><div class="line">        // want in scope even after we want m_layoutSchedulingEnabled to be restored again.</div><div class="line">        // The next block sets m_layoutSchedulingEnabled back to false once again.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_layoutPhase = InPreLayout;</div><div class="line"></div><div class="line">    RenderLayer* layer = nullptr;</div><div class="line">    bool subtree = false;</div><div class="line">    RenderElement* root = nullptr;</div><div class="line"></div><div class="line">    ++m_nestedLayoutCount;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);</div><div class="line"></div><div class="line">        autoSizeIfEnabled();</div><div class="line">        //重新设置 RenderView 对象，准备开始 layout</div><div class="line">        root = m_layoutRoot ? m_layoutRoot : document.renderView();</div><div class="line">        if (!root)</div><div class="line">            return;</div><div class="line">        subtree = m_layoutRoot;</div><div class="line"></div><div class="line">        if (!m_layoutRoot) &#123;</div><div class="line">            auto* body = document.bodyOrFrameset();</div><div class="line">            if (body &amp;&amp; body-&gt;renderer()) &#123;</div><div class="line">                if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled()) &#123;</div><div class="line">                    body-&gt;renderer()-&gt;setChildNeedsLayout();</div><div class="line">                &#125; else if (is&lt;HTMLBodyElement&gt;(*body)) &#123;</div><div class="line">                    if (!m_firstLayout &amp;&amp; m_size.height() != layoutHeight() &amp;&amp; body-&gt;renderer()-&gt;enclosingBox().stretchesToViewport())</div><div class="line">                        body-&gt;renderer()-&gt;setChildNeedsLayout();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">#if !LOG_DISABLED</div><div class="line">            if (m_firstLayout &amp;&amp; !frame().ownerElement())</div><div class="line">                LOG(Layout, "FrameView %p elapsed time before first layout: %.3fs\n", this, document.timeSinceDocumentCreation().value());</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m_needsFullRepaint = !subtree &amp;&amp; (m_firstLayout || downcast&lt;RenderView&gt;(*root).printing());</div><div class="line"></div><div class="line">        if (!subtree) &#123;</div><div class="line">            ScrollbarMode hMode;</div><div class="line">            ScrollbarMode vMode;    </div><div class="line">            calculateScrollbarModesForLayout(hMode, vMode);</div><div class="line"></div><div class="line">            if (m_firstLayout || (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())) &#123;</div><div class="line">                if (m_firstLayout) &#123;</div><div class="line">                    setScrollbarsSuppressed(true);</div><div class="line"></div><div class="line">                    m_firstLayout = false;</div><div class="line">                    m_firstLayoutCallbackPending = true;</div><div class="line">                    m_lastViewportSize = sizeForResizeEvent();</div><div class="line">                    m_lastZoomFactor = root-&gt;style().zoom();</div><div class="line"></div><div class="line">                    // Set the initial vMode to AlwaysOn if we're auto.</div><div class="line">                    if (vMode == ScrollbarAuto)</div><div class="line">                        setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.</div><div class="line">                    // Set the initial hMode to AlwaysOff if we're auto.</div><div class="line">                    if (hMode == ScrollbarAuto)</div><div class="line">                        setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.</div><div class="line">                    Page* page = frame().page();</div><div class="line">                    if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())</div><div class="line">                        scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());</div><div class="line">                    setScrollbarModes(hMode, vMode);</div><div class="line">                    setScrollbarsSuppressed(false, true);</div><div class="line">                &#125; else</div><div class="line">                    setScrollbarModes(hMode, vMode);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            LayoutSize oldSize = m_size;</div><div class="line">            m_size = layoutSize();</div><div class="line"></div><div class="line">            if (oldSize != m_size) &#123;</div><div class="line">                LOG(Layout, "  layout size changed from %.3fx%.3f to %.3fx%.3f", oldSize.width().toFloat(), oldSize.height().toFloat(), m_size.width().toFloat(), m_size.height().toFloat());</div><div class="line">                m_needsFullRepaint = true;</div><div class="line">                if (!m_firstLayout) &#123;</div><div class="line">                    RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;</div><div class="line">                    auto* body = document.bodyOrFrameset();</div><div class="line">                    RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;</div><div class="line">                    if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())</div><div class="line">                        bodyRenderer-&gt;setChildNeedsLayout();</div><div class="line">                    else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())</div><div class="line">                        rootRenderer-&gt;setChildNeedsLayout();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            m_layoutPhase = InPreLayout;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        layer = root-&gt;enclosingLayer();</div><div class="line">        SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(m_layoutRoot);</div><div class="line"></div><div class="line">        RenderView::RepaintRegionAccumulator repaintRegionAccumulator(&amp;root-&gt;view());</div><div class="line"></div><div class="line">        ASSERT(m_layoutPhase == InPreLayout);</div><div class="line">        m_layoutPhase = InRenderTreeLayout;</div><div class="line"></div><div class="line">        forceLayoutParentViewIfNeeded();</div><div class="line"></div><div class="line">        ASSERT(m_layoutPhase == InRenderTreeLayout);</div><div class="line">#ifndef NDEBUG</div><div class="line">        RenderTreeNeedsLayoutChecker checker(*root);</div><div class="line">#endif</div><div class="line">        //从 RenderView 这个根级开始进行 layout。</div><div class="line">        root-&gt;layout();</div><div class="line">        ASSERT(!root-&gt;view().renderTreeIsBeingMutatedInternally());</div><div class="line"></div><div class="line">#if ENABLE(TEXT_AUTOSIZING)</div><div class="line">        if (frame().settings().textAutosizingEnabled() &amp;&amp; !root-&gt;view().printing()) &#123;</div><div class="line">            float minimumZoomFontSize = frame().settings().minimumZoomFontSize();</div><div class="line">            float textAutosizingWidth = frame().page() ? frame().page()-&gt;textAutosizingWidth() : 0;</div><div class="line">            if (int overrideWidth = frame().settings().textAutosizingWindowSizeOverride().width())</div><div class="line">                textAutosizingWidth = overrideWidth;</div><div class="line"></div><div class="line">            LOG(TextAutosizing, "Text Autosizing: minimumZoomFontSize=%.2f textAutosizingWidth=%.2f", minimumZoomFontSize, textAutosizingWidth);</div><div class="line">            </div><div class="line">            if (minimumZoomFontSize &amp;&amp; textAutosizingWidth) &#123;</div><div class="line">                root-&gt;adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth);</div><div class="line">                if (root-&gt;needsLayout())</div><div class="line">                    root-&gt;layout();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">        ASSERT(m_layoutPhase == InRenderTreeLayout);</div><div class="line">        m_layoutRoot = nullptr;</div><div class="line">        // Close block here to end the scope of changeSchedulingEnabled and SubtreeLayoutStateMaintainer.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_layoutPhase = InViewSizeAdjust;</div><div class="line"></div><div class="line">    bool neededFullRepaint = m_needsFullRepaint;</div><div class="line"></div><div class="line">    if (!subtree &amp;&amp; !downcast&lt;RenderView&gt;(*root).printing()) &#123;</div><div class="line">        adjustViewSize();</div><div class="line">        // FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by</div><div class="line">        // navigating away from the current document (see webkit.org/b/173329).</div><div class="line">        if (hasOneRef())</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_layoutPhase = InPostLayout;</div><div class="line"></div><div class="line">    m_needsFullRepaint = neededFullRepaint;</div><div class="line"></div><div class="line">    // Now update the positions of all layers.</div><div class="line">    if (m_needsFullRepaint)</div><div class="line">        root-&gt;view().repaintRootContents();</div><div class="line"></div><div class="line">    root-&gt;view().releaseProtectedRenderWidgets();</div><div class="line"></div><div class="line">    ASSERT(!root-&gt;needsLayout());</div><div class="line"></div><div class="line">    layer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layer, subtree, m_needsFullRepaint));</div><div class="line"></div><div class="line">    updateCompositingLayersAfterLayout();</div><div class="line"></div><div class="line">    m_layoutPhase = InPostLayerPositionsUpdatedAfterLayout;</div><div class="line"></div><div class="line">    m_layoutCount++;</div><div class="line"></div><div class="line">#if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)</div><div class="line">    if (AXObjectCache* cache = root-&gt;document().existingAXObjectCache())</div><div class="line">        cache-&gt;postNotification(root, AXObjectCache::AXLayoutComplete);</div><div class="line">#endif</div><div class="line"></div><div class="line">#if ENABLE(DASHBOARD_SUPPORT)</div><div class="line">    updateAnnotatedRegions();</div><div class="line">#endif</div><div class="line"></div><div class="line">#if ENABLE(IOS_TOUCH_EVENTS)</div><div class="line">    document.setTouchEventRegionsNeedUpdate();</div><div class="line">#endif</div><div class="line"></div><div class="line">    updateCanBlitOnScrollRecursively();</div><div class="line"></div><div class="line">    handleDeferredScrollUpdateAfterContentSizeChange();</div><div class="line"></div><div class="line">    handleDeferredScrollbarsUpdateAfterDirectionChange();</div><div class="line"></div><div class="line">    if (document.hasListenerType(Document::OVERFLOWCHANGED_LISTENER))</div><div class="line">        updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());</div><div class="line"></div><div class="line">    frame().document()-&gt;markers().invalidateRectsForAllMarkers();</div><div class="line"></div><div class="line">    if (!m_postLayoutTasksTimer.isActive()) &#123;</div><div class="line">        if (!m_inSynchronousPostLayout) &#123;</div><div class="line">            if (inChildFrameLayoutWithFrameFlattening)</div><div class="line">                updateWidgetPositions();</div><div class="line">            else &#123;</div><div class="line">                SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);</div><div class="line">                performPostLayoutTasks(); // Calls resumeScheduledEvents().</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!m_postLayoutTasksTimer.isActive() &amp;&amp; (needsLayout() || m_inSynchronousPostLayout || inChildFrameLayoutWithFrameFlattening)) &#123;</div><div class="line">            // If we need layout or are already in a synchronous call to postLayoutTasks(), </div><div class="line">            // defer widget updates and event dispatch until after we return. postLayoutTasks()</div><div class="line">            // can make us need to update again, and we can get stuck in a nasty cycle unless</div><div class="line">            // we call it through the timer here.</div><div class="line">            m_postLayoutTasksTimer.startOneShot(0_s);</div><div class="line">        &#125;</div><div class="line">        if (needsLayout())</div><div class="line">            layout();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InspectorInstrumentation::didLayout(cookie, *root);</div><div class="line">    DebugPageOverlays::didLayout(frame());</div><div class="line"></div><div class="line">    --m_nestedLayoutCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RenderView 的 layout 里会调用 layoutContent 方法。这个方法的实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RenderView::layoutContent(<span class="keyword">const</span> LayoutState&amp; state)</div><div class="line">&#123;</div><div class="line">    UNUSED_PARAM(state);</div><div class="line">    ASSERT(needsLayout());</div><div class="line"></div><div class="line">    RenderBlockFlow::layout();</div><div class="line">    <span class="keyword">if</span> (hasRenderNamedFlowThreads())</div><div class="line">        flowThreadController().layoutRenderNamedFlowThreads();</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></div><div class="line">    checkLayoutState(state);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现这个方法实现很简单，里面主要是通过 RenderBlockFlow 来进行 layout 的。RenderBlockFlow 是 RenderBlock 的子类，layout 方法是在 RenderBlock 里实现，里面直接调了 layoutBlock 方法，这个方法是在 RenderBlockFlow 里重载实现的。下面看看 RenderBlockFlow 的实现吧：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line">void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)</div><div class="line">&#123;</div><div class="line">    ASSERT(needsLayout());</div><div class="line">    //当不需要布局子节点同时能 simplifiedLayout 重新布局成功</div><div class="line">    if (!relayoutChildren &amp;&amp; simplifiedLayout())</div><div class="line">        return;</div><div class="line"></div><div class="line">    LayoutRepainter repainter(*this, checkForRepaintDuringLayout());</div><div class="line">    //重新计算逻辑宽度</div><div class="line">    if (recomputeLogicalWidthAndColumnWidth())</div><div class="line">        relayoutChildren = true;</div><div class="line"></div><div class="line">    rebuildFloatingObjectSetFromIntrudingFloats();</div><div class="line"></div><div class="line">    //先保留一份以前的高度为后面做对比用</div><div class="line">    LayoutUnit previousHeight = logicalHeight();</div><div class="line">    // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),</div><div class="line">    // for consistency with other render classes?</div><div class="line">    //然后将 logicalHeight 设置为 0，避免累加以前的。</div><div class="line">    setLogicalHeight(0);</div><div class="line"></div><div class="line">    bool pageLogicalHeightChanged = false;</div><div class="line">    checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);</div><div class="line"></div><div class="line">    const RenderStyle&amp; styleToUse = style();</div><div class="line">    LayoutStateMaintainer statePusher(view(), *this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);</div><div class="line"></div><div class="line">    preparePaginationBeforeBlockLayout(relayoutChildren);</div><div class="line">    if (!relayoutChildren)</div><div class="line">        relayoutChildren = namedFlowFragmentNeedsUpdate();</div><div class="line"></div><div class="line">    // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track</div><div class="line">    // our current maximal positive and negative margins. These values are used when we</div><div class="line">    // are collapsed with adjacent blocks, so for example, if you have block A and B</div><div class="line">    // collapsing together, then you'd take the maximal positive margin from both A and B</div><div class="line">    // and subtract it from the maximal negative margin from both A and B to get the</div><div class="line">    // true collapsed margin. This algorithm is recursive, so when we finish layout()</div><div class="line">    // our block knows its current maximal positive/negative values.</div><div class="line">    //</div><div class="line">    // Start out by setting our margin values to our current margins. Table cells have</div><div class="line">    // no margins, so we don't fill in the values for table cells.</div><div class="line">    bool isCell = isTableCell();</div><div class="line">    if (!isCell) &#123;</div><div class="line">        initMaxMarginValues();</div><div class="line">        </div><div class="line">        setHasMarginBeforeQuirk(styleToUse.hasMarginBeforeQuirk());</div><div class="line">        setHasMarginAfterQuirk(styleToUse.hasMarginAfterQuirk());</div><div class="line">        setPaginationStrut(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LayoutUnit repaintLogicalTop = 0;</div><div class="line">    LayoutUnit repaintLogicalBottom = 0;</div><div class="line">    LayoutUnit maxFloatLogicalBottom = 0;</div><div class="line">    if (!firstChild() &amp;&amp; !isAnonymousBlock())</div><div class="line">        setChildrenInline(true);</div><div class="line">    //Inline 和 Block 的不同布局处理</div><div class="line">    if (childrenInline())</div><div class="line">        layoutInlineChildren(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</div><div class="line">    else</div><div class="line">        layoutBlockChildren(relayoutChildren, maxFloatLogicalBottom);</div><div class="line"></div><div class="line">    // Expand our intrinsic height to encompass floats.</div><div class="line">    LayoutUnit toAdd = borderAndPaddingAfter() + scrollbarLogicalHeight();</div><div class="line">    if (lowestFloatLogicalBottom() &gt; (logicalHeight() - toAdd) &amp;&amp; createsNewFormattingContext())</div><div class="line">        setLogicalHeight(lowestFloatLogicalBottom() + toAdd);</div><div class="line">    </div><div class="line">    if (relayoutForPagination(statePusher) || relayoutToAvoidWidows(statePusher)) &#123;</div><div class="line">        ASSERT(!shouldBreakAtLineToAvoidWidow());</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Calculate our new height. 计算新高</div><div class="line">    LayoutUnit oldHeight = logicalHeight();</div><div class="line">    LayoutUnit oldClientAfterEdge = clientLogicalBottom();</div><div class="line"></div><div class="line">    // Before updating the final size of the flow thread make sure a forced break is applied after the content.</div><div class="line">    // This ensures the size information is correctly computed for the last auto-height region receiving content.</div><div class="line">    if (is&lt;RenderFlowThread&gt;(*this))</div><div class="line">        downcast&lt;RenderFlowThread&gt;(*this).applyBreakAfterContent(oldClientAfterEdge);</div><div class="line"></div><div class="line">    updateLogicalHeight();</div><div class="line">    LayoutUnit newHeight = logicalHeight();</div><div class="line">    if (oldHeight != newHeight) &#123;</div><div class="line">        if (oldHeight &gt; newHeight &amp;&amp; maxFloatLogicalBottom &gt; newHeight &amp;&amp; !childrenInline()) &#123;</div><div class="line">            // One of our children's floats may have become an overhanging float for us. We need to look for it.</div><div class="line">            for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) &#123;</div><div class="line">                if (blockFlow.isFloatingOrOutOfFlowPositioned())</div><div class="line">                    continue;</div><div class="line">                if (blockFlow.lowestFloatLogicalBottom() + blockFlow.logicalTop() &gt; newHeight)</div><div class="line">                    addOverhangingFloats(blockFlow, false);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //前面保留的先前高度和重新计算后的高度比较有变化就重新布局子结点</div><div class="line">    bool heightChanged = (previousHeight != newHeight);</div><div class="line">    if (heightChanged)</div><div class="line">        relayoutChildren = true;</div><div class="line"></div><div class="line">    layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());</div><div class="line"></div><div class="line">    //Add overflow from children (unless we're multi-column, since in that case all our child overflow is clipped anyway).</div><div class="line">    computeOverflow(oldClientAfterEdge);</div><div class="line">    </div><div class="line">    statePusher.pop();</div><div class="line"></div><div class="line">    fitBorderToLinesIfNeeded();</div><div class="line"></div><div class="line">    if (view().layoutState()-&gt;m_pageLogicalHeight)</div><div class="line">        setPageLogicalOffset(view().layoutState()-&gt;pageLogicalOffset(this, logicalTop()));</div><div class="line"></div><div class="line">    updateLayerTransform();</div><div class="line"></div><div class="line">    // Update our scroll information if we're overflow:auto/scroll/hidden now that we know if</div><div class="line">    // we overflow or not.</div><div class="line">    updateScrollInfoAfterLayout();</div><div class="line"></div><div class="line">    // FIXME: This repaint logic should be moved into a separate helper function!</div><div class="line">    // Repaint with our new bounds if they are different from our old bounds.</div><div class="line">    bool didFullRepaint = repainter.repaintAfterLayout();</div><div class="line">    if (!didFullRepaint &amp;&amp; repaintLogicalTop != repaintLogicalBottom &amp;&amp; (styleToUse.visibility() == VISIBLE || enclosingLayer()-&gt;hasVisibleContent())) &#123;</div><div class="line">        // FIXME: We could tighten up the left and right invalidation points if we let layoutInlineChildren fill them in based off the particular lines</div><div class="line">        // it had to lay out. We wouldn't need the hasOverflowClip() hack in that case either.</div><div class="line">        LayoutUnit repaintLogicalLeft = logicalLeftVisualOverflow();</div><div class="line">        LayoutUnit repaintLogicalRight = logicalRightVisualOverflow();</div><div class="line">        if (hasOverflowClip()) &#123;</div><div class="line">            // If we have clipped overflow, we should use layout overflow as well, since visual overflow from lines didn't propagate to our block's overflow.</div><div class="line">            // Note the old code did this as well but even for overflow:visible. The addition of hasOverflowClip() at least tightens up the hack a bit.</div><div class="line">            // layoutInlineChildren should be patched to compute the entire repaint rect.</div><div class="line">            repaintLogicalLeft = std::min(repaintLogicalLeft, logicalLeftLayoutOverflow());</div><div class="line">            repaintLogicalRight = std::max(repaintLogicalRight, logicalRightLayoutOverflow());</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        LayoutRect repaintRect;</div><div class="line">        if (isHorizontalWritingMode())</div><div class="line">            repaintRect = LayoutRect(repaintLogicalLeft, repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop);</div><div class="line">        else</div><div class="line">            repaintRect = LayoutRect(repaintLogicalTop, repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft);</div><div class="line"></div><div class="line">        if (hasOverflowClip()) &#123;</div><div class="line">            // Adjust repaint rect for scroll offset</div><div class="line">            repaintRect.moveBy(-scrollPosition());</div><div class="line"></div><div class="line">            // Don't allow this rect to spill out of our overflow box.</div><div class="line">            repaintRect.intersect(LayoutRect(LayoutPoint(), size()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Make sure the rect is still non-empty after intersecting for overflow above</div><div class="line">        if (!repaintRect.isEmpty()) &#123;</div><div class="line">            repaintRectangle(repaintRect); // We need to do a partial repaint of our content.</div><div class="line">            if (hasReflection())</div><div class="line">                repaintRectangle(reflectedRect(repaintRect));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    clearNeedsLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上方法里有两个分支，一个是 layoutInlineChildren 一个是 layoutBlockChildren。由于 Inline 属于动态调整高度所以比 Block 的实现要负责很多，layoutInlineChildren 方式是 Inline 布局的入口。</p>
<h3 id="Layout-Tree-创建"><a href="#Layout-Tree-创建" class="headerlink" title="Layout Tree 创建"></a>Layout Tree 创建</h3><p>Parsing 完成会触发 Layout Tree。Layout Tree 的目的就是存储需要绘制的数据，Layout 就是处理 Nodes 在页面上的大小和位置。Chrome，firefox和 android 使用的是<a href="https://skia.org/" target="_blank" rel="external">Skia</a> 开源 2D 图形库做底层 Paint 引擎。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Document::finishedParsing() &#123;</div><div class="line">      updateStyleAndLayoutTree();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个 Node 都会创建一个 LayoutObject，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LayoutObject* newLayoutObject = m_node-&gt;createLayoutObject(style);</div><div class="line">parentLayoutObject-&gt;addChild(newLayoutObject, nextLayoutObject);</div></pre></td></tr></table></figure></p>
<h3 id="Layout-值的计算"><a href="#Layout-值的计算" class="headerlink" title="Layout 值的计算"></a>Layout 值的计算</h3><p>Layout Tree 创建完成就开始计算 layout 的值，比如宽，margin 等。Block 类型节点的位置计算实现是在 RenderBlock 里的 layoutBlockChild 方法里实现的，该方法主要是先确定节点的 top 坐标，然后计算布局变化后 margin，float 和 分页等对 top 值的影响确定影响后的 top 坐标，最后使用 determineLogicalLeftPositionForChild 得到 left 坐标。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)</div><div class="line">&#123;</div><div class="line">    LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();</div><div class="line">    LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();</div><div class="line"></div><div class="line">    <span class="comment">// The child is a normal flow object. Compute the margins we will use for collapsing now.</span></div><div class="line">    child.computeAndSetBlockDirectionMargins(*<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Try to guess our correct logical top position. In most cases this guess will</span></div><div class="line">    <span class="comment">// be correct. Only if we're wrong (when we compute the real logical top position)</span></div><div class="line">    <span class="comment">// will we have to potentially relayout.</span></div><div class="line">    LayoutUnit estimateWithoutPagination;</div><div class="line">    <span class="comment">//估算 top 坐标，estimateLogicalTopPosition 会先获取 RenderBlock 的高来作为初始的 top，再根据 margin 分页和 float 来调整 top 坐标</span></div><div class="line">    LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);</div><div class="line"></div><div class="line">    <span class="comment">// Cache our old rect so that we can dirty the proper repaint rects if the child moves.</span></div><div class="line">    LayoutRect oldRect = child.frameRect();</div><div class="line">    LayoutUnit oldLogicalTop = logicalTopForChild(child);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !ASSERT_DISABLED</span></div><div class="line">    LayoutSize oldLayoutDelta = view().layoutDelta();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// Position the child as though it didn't collapse with the top.</span></div><div class="line">    <span class="comment">//先设置布局前 top 坐标</span></div><div class="line">    setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);</div><div class="line">    estimateRegionRangeForBoxChild(child);</div><div class="line"></div><div class="line">    RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">bool</span> markDescendantsWithFloats = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())</div><div class="line">        markDescendantsWithFloats = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(logicalTopEstimate.mightBeSaturated()))</div><div class="line">        <span class="comment">// logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for</span></div><div class="line">        <span class="comment">// very large elements. If it does the comparison with oldLogicalTop might yield a</span></div><div class="line">        <span class="comment">// false negative as adding and removing margins, borders etc from a saturated number</span></div><div class="line">        <span class="comment">// might yield incorrect results. If this is the case always mark for layout.</span></div><div class="line">        markDescendantsWithFloats = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!child.avoidsFloats() || child.shrinkToAvoidFloats()) &#123;</div><div class="line">        <span class="comment">// If an element might be affected by the presence of floats, then always mark it for</span></div><div class="line">        <span class="comment">// layout.</span></div><div class="line">        LayoutUnit fb = <span class="built_in">std</span>::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());</div><div class="line">        <span class="keyword">if</span> (fb &gt; logicalTopEstimate)</div><div class="line">            markDescendantsWithFloats = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (childBlockFlow) &#123;</div><div class="line">        <span class="keyword">if</span> (markDescendantsWithFloats)</div><div class="line">            childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();</div><div class="line">        <span class="keyword">if</span> (!child.isWritingModeRoot())</div><div class="line">            previousFloatLogicalBottom = <span class="built_in">std</span>::max(previousFloatLogicalBottom, oldLogicalTop + childBlockFlow-&gt;lowestFloatLogicalBottom());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    child.markForPaginationRelayoutIfNeeded();</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> childHadLayout = child.everHadLayout();</div><div class="line">    <span class="comment">//对子节点进行布局</span></div><div class="line">    <span class="keyword">bool</span> childNeededLayout = child.needsLayout();</div><div class="line">    <span class="keyword">if</span> (childNeededLayout)</div><div class="line">        child.layout();</div><div class="line"></div><div class="line">    <span class="comment">// Cache if we are at the top of the block right now.</span></div><div class="line">    <span class="keyword">bool</span> atBeforeSideOfBlock = marginInfo.atBeforeSideOfBlock();</div><div class="line"></div><div class="line">    <span class="comment">//保证 top 坐标和子节点布局后能够同步</span></div><div class="line">    <span class="comment">// Now determine the correct ypos based off examination of collapsing margin</span></div><div class="line">    <span class="comment">// values.</span></div><div class="line">    LayoutUnit logicalTopBeforeClear = collapseMargins(child, marginInfo);</div><div class="line"></div><div class="line">    <span class="comment">// Now check for clear.</span></div><div class="line">    LayoutUnit logicalTopAfterClear = clearFloatsIfNeeded(child, marginInfo, oldPosMarginBefore, oldNegMarginBefore, logicalTopBeforeClear);</div><div class="line">    </div><div class="line">    <span class="keyword">bool</span> paginated = view().layoutState()-&gt;isPaginated();</div><div class="line">    <span class="keyword">if</span> (paginated)</div><div class="line">        logicalTopAfterClear = adjustBlockChildForPagination(logicalTopAfterClear, estimateWithoutPagination, child, atBeforeSideOfBlock &amp;&amp; logicalTopBeforeClear == logicalTopAfterClear);</div><div class="line"></div><div class="line">    <span class="comment">//经过上面的子节点布局完后重新计算得到新高</span></div><div class="line">    setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);</div><div class="line"></div><div class="line">    <span class="comment">// Now we have a final top position. See if it really does end up being different from our estimate.</span></div><div class="line">    <span class="comment">// clearFloatsIfNeeded can also mark the child as needing a layout even though we didn't move. This happens</span></div><div class="line">    <span class="comment">// when collapseMargins dynamically adds overhanging floats because of a child with negative margins.</span></div><div class="line">    <span class="keyword">if</span> (logicalTopAfterClear != logicalTopEstimate || child.needsLayout() || (paginated &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;shouldBreakAtLineToAvoidWidow())) &#123;</div><div class="line">        <span class="keyword">if</span> (child.shrinkToAvoidFloats()) &#123;</div><div class="line">            <span class="comment">// The child's width depends on the line width. When the child shifts to clear an item, its width can</span></div><div class="line">            <span class="comment">// change (because it has more available line width). So mark the item as dirty.</span></div><div class="line">            child.setChildNeedsLayout(MarkOnlyThis);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (childBlockFlow) &#123;</div><div class="line">            <span class="keyword">if</span> (!child.avoidsFloats() &amp;&amp; childBlockFlow-&gt;containsFloats())</div><div class="line">                childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();</div><div class="line">            child.markForPaginationRelayoutIfNeeded();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (updateRegionRangeForBoxChild(child))</div><div class="line">        child.setNeedsLayout(MarkOnlyThis);</div><div class="line"></div><div class="line">    <span class="comment">// In case our guess was wrong, relayout the child.</span></div><div class="line">    child.layoutIfNeeded();</div><div class="line"></div><div class="line">    <span class="comment">// We are no longer at the top of the block if we encounter a non-empty child.  </span></div><div class="line">    <span class="comment">// This has to be done after checking for clear, so that margins can be reset if a clear occurred.</span></div><div class="line">    <span class="keyword">if</span> (marginInfo.atBeforeSideOfBlock() &amp;&amp; !child.isSelfCollapsingBlock())</div><div class="line">        marginInfo.setAtBeforeSideOfBlock(<span class="literal">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Now place the child in the correct left position</span></div><div class="line">    <span class="comment">//计算获得 left 坐标。determineLogicalLeftPositionForChild 会先去计算 border-left 和 padding-left 然后计算 margin-left 来确定 left 坐标。最后通过 setLogicalLeftForChild 将确认的 left 坐标记录下。</span></div><div class="line">    determineLogicalLeftPositionForChild(child, ApplyLayoutDelta);</div><div class="line"></div><div class="line">    <span class="comment">// Update our height now that the child has been placed in the correct position.</span></div><div class="line">    setLogicalHeight(logicalHeight() + logicalHeightForChildForFragmentation(child));</div><div class="line">    <span class="keyword">if</span> (mustSeparateMarginAfterForChild(child)) &#123;</div><div class="line">        setLogicalHeight(logicalHeight() + marginAfterForChild(child));</div><div class="line">        marginInfo.clearMargin();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// If the child has overhanging floats that intrude into following siblings (or possibly out</span></div><div class="line">    <span class="comment">// of this block), then the parent gets notified of the floats now.</span></div><div class="line">    <span class="keyword">if</span> (childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())</div><div class="line">        maxFloatLogicalBottom = <span class="built_in">std</span>::max(maxFloatLogicalBottom, addOverhangingFloats(*childBlockFlow, !childNeededLayout));</div><div class="line"></div><div class="line">    LayoutSize childOffset = child.location() - oldRect.location();</div><div class="line">    <span class="keyword">if</span> (childOffset.width() || childOffset.height()) &#123;</div><div class="line">        view().addLayoutDelta(childOffset);</div><div class="line"></div><div class="line">        <span class="comment">// If the child moved, we have to repaint it as well as any floating/positioned</span></div><div class="line">        <span class="comment">// descendants. An exception is if we need a layout. In this case, we know we're going to</span></div><div class="line">        <span class="comment">// repaint ourselves (and the child) anyway.</span></div><div class="line">        <span class="keyword">if</span> (childHadLayout &amp;&amp; !selfNeedsLayout() &amp;&amp; child.checkForRepaintDuringLayout())</div><div class="line">            child.repaintDuringLayoutIfMoved(oldRect);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//渲染</span></div><div class="line">    <span class="keyword">if</span> (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) &#123;</div><div class="line">        child.repaint();</div><div class="line">        child.repaintOverhangingFloats(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (paginated) &#123;</div><div class="line">        <span class="keyword">if</span> (RenderFlowThread* flowThread = flowThreadContainingBlock())</div><div class="line">            flowThread-&gt;flowThreadDescendantBoxLaidOut(&amp;child);</div><div class="line">        <span class="comment">// Check for an after page/column break.</span></div><div class="line">        LayoutUnit newHeight = applyAfterBreak(child, logicalHeight(), marginInfo);</div><div class="line">        <span class="keyword">if</span> (newHeight != height())</div><div class="line">            setLogicalHeight(newHeight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ASSERT(view().layoutDeltaMatches(oldLayoutDelta));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断值的类型是固定值还是百分比的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (length.type()) &#123;</div><div class="line">  <span class="keyword">case</span> Fixed:</div><div class="line">    <span class="keyword">return</span> LayoutUnit(length.value()); <span class="comment">//返回 LayoutUnit 封装的数据 1px = 1 &lt;&lt; 6 = 64 unit</span></div><div class="line">  <span class="keyword">case</span> Percent:</div><div class="line">    <span class="comment">//maximumValue 是传进来的最大值</span></div><div class="line">    <span class="keyword">return</span> LayoutUnit(</div><div class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(maximumValue * length.percent() / <span class="number">100.0f</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>计算 margin 的值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CSS 2.1: "If both 'margin-left' and 'margin-right' are 'auto', their used</span></div><div class="line"><span class="comment">// values are equal. This horizontally centers the element with respect to</span></div><div class="line"><span class="comment">// the edges of the containing block."</span></div><div class="line"><span class="keyword">const</span> ComputedStyle&amp; containingBlockStyle = containingBlock-&gt;styleRef();</div><div class="line"><span class="keyword">if</span> (marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto()) &#123;</div><div class="line">  LayoutUnit centeredMarginBoxStart = <span class="built_in">std</span>::max(</div><div class="line">      LayoutUnit(),</div><div class="line">      (availableWidth - childWidth) / <span class="number">2</span>); </div><div class="line">  marginStart = centeredMarginBoxStart;</div><div class="line">  marginEnd = availableWidth - childWidth - marginStart;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Box Model 里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">m_frameRect.setWidth(width);</div><div class="line">m_marginBox.setStart(marginLeft);</div></pre></td></tr></table></figure></p>
<p>经过计算后的 Render Tree 具有布局信息，比如下面的 html 代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>First line.<span class="tag">&lt;<span class="name">br</span>&gt;</span>Second one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>布局计算后带布局信息的 Render Tree 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RenderBlock &#123;HTML&#125; at (0, 0) size 640x480 </div><div class="line">|—— RenderBody &#123;BODY&#125; at (0, 80) size 640x480 [bgcolor=# FFFFFF] </div><div class="line">| |—— RenderBlock &#123;P&#125; at (0, 0) size 640x80 </div><div class="line">| | |—— RenderText &#123;#text&#125; at (0, 0) size 48x24 &quot;First line.&quot; </div><div class="line">| | |—— RenderBR &#123;BR&#125; at (20, 20) size 0x0 </div><div class="line">| | |—— RenderText &#123;#text&#125; at (0, 24) size 48x24 &quot;Second one.&quot;</div></pre></td></tr></table></figure></p>
<h3 id="Box-Model-数据结构"><a href="#Box-Model-数据结构" class="headerlink" title="Box Model 数据结构"></a>Box Model 数据结构</h3><p><img src="/uploads/deeply-analyse-webkit/16.png" alt="16"><br>所有的 elements 都有 display 属性用来确定显示类型。属性值有</p>
<ul>
<li>block：生成一个 block box</li>
<li>inline：生成一个或多个 inline boxes</li>
<li>none：不生成 box</li>
</ul>
<p>默认是 inline 的，但是浏览器会设置其它默认值，比如说 div 就是 block 的，完整的定义可以参看 w3c 定义的：<a href="http://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="external">http://www.w3.org/TR/CSS2/sample.html</a></p>
<h4 id="定位的方案"><a href="#定位的方案" class="headerlink" title="定位的方案"></a>定位的方案</h4><p>有三种方案</p>
<ul>
<li>Normal：由 render tree 来决定的位置。</li>
<li>Float：会先按照正常流程来排列，然后再尽可能的往左或往右移动。</li>
<li>Absolute：让其在 render tree 的位置和 DOM tree 不一样</li>
</ul>
<p>定位方案是根据 position 属性和 float 属性来决定的，static 和 relative 就是正常的排列， absolute 和 fixed 就是 absolute 定位。</p>
<p>对于 float 的处理，首先需要判断宽度是否需要 fit content<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> LayoutBox::sizesLogicalWidthToFitContent(</div><div class="line">    <span class="keyword">const</span> Length&amp; logicalWidth) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">if</span> (isFloating() || isInlineBlockOrInlineTable())</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是 float 或者 inline-block ，宽度靠内容来撑，行内的内容会将间隔控制成一个空格，前后空格和多余空格都会忽略。</p>
<p>对于 float:left 的计算<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//logicalRightOffsetForPositioningFloat 剩余空间如果不小于 floatLogicalLeft 时循环结束</span></div><div class="line"><span class="keyword">while</span> (logicalRightOffsetForPositioningFloat(</div><div class="line">           logicalTopOffset, logicalRightOffset, &amp;heightRemainingRight) -</div><div class="line">           floatLogicalLeft &lt;</div><div class="line">       floatLogicalWidth) &#123;</div><div class="line">  <span class="comment">//下移</span></div><div class="line">  logicalTopOffset +=</div><div class="line">      <span class="built_in">std</span>::min&lt;LayoutUnit&gt;(heightRemainingLeft, heightRemainingRight);</div><div class="line">  <span class="comment">//新的 floatLogicalLeft</span></div><div class="line">  floatLogicalLeft = logicalLeftOffsetForPositioningFloat(</div><div class="line">      logicalTopOffset, logicalLeftOffset, &amp;heightRemainingLeft);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//看看 floatLogicalLeft 是否大于 left 的 offset 和 padding left 的差值</span></div><div class="line">floatLogicalLeft = <span class="built_in">std</span>::max(</div><div class="line">    logicalLeftOffset - borderAndPaddingLogicalLeft(), floatLogicalLeft);</div></pre></td></tr></table></figure></p>
<h4 id="Box-类型"><a href="#Box-类型" class="headerlink" title="Box 类型"></a>Box 类型</h4><p>Block box：在浏览器的 window 里有自己的矩形<br><img src="/uploads/deeply-analyse-webkit/20.png" alt="20"></p>
<p>Inline box：没有自己的 block，但是会在一个 block 里<br><img src="/uploads/deeply-analyse-webkit/21.png" alt="21"></p>
<p>Block 是按照垂直排列，Inline 是按照水平来排列<br><img src="/uploads/deeply-analyse-webkit/22.png" alt="22"></p>
<p>Inline boxes 会被包含在 line boxes 里，lines 的高度至少和最高的 box 一样，甚至更高，当 boxes 用的是 baseline，这意味着多个元素底部对齐。如果容器宽度不够，inline 会变成多 lines。<br><img src="/uploads/deeply-analyse-webkit/23.png" alt="23"></p>
<p>下面举个例子看看 Inline  类型的例子，比如有如下的 html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>First line.<span class="tag">&lt;<span class="name">br</span>&gt;</span>Second one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这段 html 的 Render Tree 如下：<br><img src="/uploads/deeply-analyse-webkit/97.png" alt="97"></p>
<h4 id="Position-类型"><a href="#Position-类型" class="headerlink" title="Position 类型"></a>Position 类型</h4><p>Relative：相对定位，先按照正常的定位然后根据设置的值再移动。<br><img src="/uploads/deeply-analyse-webkit/24.png" alt="24"></p>
<p>Float：会被移动到左边或右边侧<br><img src="/uploads/deeply-analyse-webkit/25.png" alt="25"></p>
<p>Absolute 和 fixed：不会参与 normal flow，只按照精确定位，尺寸值相对于容器，对于 fixed 来说，是相对于 view port 的。fixed box 不会随着 document 的滚动而移动。<br><img src="/uploads/deeply-analyse-webkit/26.png" alt="26"></p>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>分层可以通过指定 CSS 的 z-index 属性。它表示了 box 的第三个维度，位置按照 z 轴来。这些 box 会被分成 stacks，叫做 stacking contexts，每个栈顶的 box 更靠近用户。stack 根据 z-index 的属性排序。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">div</span> &#123; </div><div class="line">        <span class="attribute">position</span>: absolute; </div><div class="line">        <span class="attribute">left</span>: <span class="number">2in</span>; </div><div class="line">        <span class="attribute">top</span>: <span class="number">2in</span>; </div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">style</span>=<span class="string">"z-index: 3;background-color:red; width: 1in; height: 1in; "</span>&gt;</span><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">style</span>=<span class="string">"z-index: 1;background-color:green;width: 2in; height: 2in;"</span>&gt;</span><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>效果如下：<br><img src="/uploads/deeply-analyse-webkit/27.png" alt="27"></p>
<p>可以看到层级是按照 z-index 来排的。</p>
<h4 id="大小的计算"><a href="#大小的计算" class="headerlink" title="大小的计算"></a>大小的计算</h4><p>border 及以内区域使用 m_frameRect 对象表示。不同方法通过不同的计算能够获取到不同的值比如 clientWidth 的计算方法是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// More IE extensions.  clientWidth and clientHeight represent the interior of</span></div><div class="line"><span class="comment">// an object excluding border and scrollbar.</span></div><div class="line">LayoutUnit LayoutBox::clientWidth() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> m_frameRect.width() - borderLeft() - borderRight() -</div><div class="line">         verticalScrollbarWidth();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>offsetWidth  是 frameRect 的宽度<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IE extensions. Used to calculate offsetWidth/Height.</span></div><div class="line"><span class="function">LayoutUnit <span class="title">offsetWidth</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> m_frameRect.width(); &#125;</div><div class="line"><span class="function">LayoutUnit <span class="title">offsetHeight</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> m_frameRect.height(); &#125;</div></pre></td></tr></table></figure></p>
<p>Margin 区域是用 LayoutRectOutsets<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LayoutUnit m_top;</div><div class="line">LayoutUnit m_right;</div><div class="line">LayoutUnit m_bottom;</div><div class="line">LayoutUnit m_left;</div></pre></td></tr></table></figure></p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>位置的计算，即 x 和 y 是通过下面两个函数计算得到<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据 margin 得到 y 值</span></div><div class="line">LayoutUnit logicalTopBeforeClear =</div><div class="line">    collapseMargins(child, layoutInfo, childIsSelfCollapsing,</div><div class="line">                    childDiscardMarginBefore, childDiscardMarginAfter);</div><div class="line"><span class="comment">// 得到 x 值</span></div><div class="line">determineLogicalLeftPositionForChild(child);</div></pre></td></tr></table></figure></p>
<p>计算是个递归过程，由子元素到父元素。这样做的原因是有的父元素的高是由子元素撑起的，需要先知道子元素才能够推出父元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTML-标准&quot;&gt;&lt;a href=&quot;#HTML-标准&quot; class=&quot;headerlink&quot; title=&quot;HTML 标准&quot;&gt;&lt;/a&gt;HTML 标准&lt;/h2&gt;&lt;h3 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Web" scheme="http://ming1016.github.io/tags/Web/"/>
    
      <category term="WebKit" scheme="http://ming1016.github.io/tags/WebKit/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 iOS 性能优化</title>
    <link href="http://ming1016.github.io/2017/06/20/deeply-ios-performance-optimization/"/>
    <id>http://ming1016.github.io/2017/06/20/deeply-ios-performance-optimization/</id>
    <published>2017-06-20T02:25:42.000Z</published>
    <updated>2017-10-11T03:15:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题种类"><a href="#问题种类" class="headerlink" title="问题种类"></a>问题种类</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在集合里数据量小的情况下时间复杂度对于性能的影响看起来微乎其微。但如果某个开发的功能是一个公共功能，无法预料调用者传入数据的量时，这个复杂度的优化显得非常重要了。<br><img src="/uploads/deeply-ios-performance-optimization/01.png" alt=""><br>上图列出了各种情况的时间复杂度，比如高效的排序算法一般都是 O(n log n)。接下来看看下图：<br><img src="/uploads/deeply-ios-performance-optimization/02.png" alt=""><br>图中可以看出 O(n) 是个分水岭，大于它对于性能就具有很大的潜在影响，如果是个公共的接口一定要加上说明，自己调用也要做到心中有数。当然最好是通过算法优化或者使用合适的系统接口方法，权衡内存消耗争取通过空间来换取时间。</p>
<p>下面通过集合里是否有某个值来举个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//O(1)</span></div><div class="line"><span class="keyword">return</span> array[idx] == value;</div><div class="line"></div><div class="line"><span class="comment">//O(n)</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (array[i] == value) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="comment">//O(n2) 找重复的值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) &#123;</div><div class="line">        <span class="keyword">if</span> ( i != j &amp;&amp; array[i] == array[j]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div></pre></td></tr></table></figure></p>
<p>那么 OC 里几种常用集合对象提供的接口方法时间复杂度是怎么样的。</p>
<h3 id="NSArray-NSMutableArray"><a href="#NSArray-NSMutableArray" class="headerlink" title="NSArray / NSMutableArray"></a>NSArray / NSMutableArray</h3><p>首先我们发现他们是有排序，并允许重复元素存在的，那么这么设计就表明了集合存储没法使用里面的元素做 hash table 的 key 进行相关的快速操作，。所以不同功能接口方法性能是会有很大的差异。</p>
<ul>
<li>containsObject:，containsObject:，indexOfObject*，removeObject: 会遍历里面元素查看是否与之匹对，所以复杂度等于或大于 O(n)</li>
<li>objectAtIndex:，firstObject:，lastObject:，addObject:，removeLastObject: 这些只针对栈顶栈底操作的时间复杂度都是 O(1)</li>
<li>indexOfObject:inSortedRange:options:usingComparator: 使用的是二分查找，时间复杂度是 O(log n)</li>
</ul>
<h3 id="NSSet-NSMutableSet-NSCountedSet"><a href="#NSSet-NSMutableSet-NSCountedSet" class="headerlink" title="NSSet / NSMutableSet / NSCountedSet"></a>NSSet / NSMutableSet / NSCountedSet</h3><p>这些集合类型是无序没有重复元素。这样就可以通过 hash table 进行快速的操作。比如 addObject:, removeObject:, containsObject: 都是按照 O(1) 来的。需要注意的是将数组转成 Set 时会将重复元素合成一个，同时失去排序。</p>
<h3 id="NSDictionary-NSMutableDictionary"><a href="#NSDictionary-NSMutableDictionary" class="headerlink" title="NSDictionary / NSMutableDictionary"></a>NSDictionary / NSMutableDictionary</h3><p>和 Set 差不多，多了键值对应。添加删除和查找都是 O(1) 的。需要注意的是 Keys 必须是符合 NSCopying。</p>
<h3 id="containsObject-方法在数组和-Set-里不同的实现"><a href="#containsObject-方法在数组和-Set-里不同的实现" class="headerlink" title="containsObject 方法在数组和 Set 里不同的实现"></a>containsObject 方法在数组和 Set 里不同的实现</h3><p>在数组中的实现<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>) containsObject: (<span class="keyword">id</span>)anObject</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> ([<span class="keyword">self</span> indexOfObject: anObject] != <span class="built_in">NSNotFound</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSUInteger</span>) indexOfObject: (<span class="keyword">id</span>)anObject</div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span>	c = [<span class="keyword">self</span> count];</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; anObject != <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">unsigned</span>	i;</div><div class="line">      IMP	get = [<span class="keyword">self</span> methodForSelector: oaiSel];</div><div class="line">      <span class="built_in">BOOL</span>	(*eq)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>)</div><div class="line">	= (<span class="built_in">BOOL</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))[anObject methodForSelector: eqSel];</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++)</div><div class="line">	<span class="keyword">if</span> ((*eq)(anObject, eqSel, (*get)(<span class="keyword">self</span>, oaiSel, i)) == <span class="literal">YES</span>)</div><div class="line">	  <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">NSNotFound</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到会遍历所有元素在查找到后才进行返回.</p>
<p>接下来可以看看 containsObject 在 Set 里的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>) containsObject: (<span class="keyword">id</span>)anObject</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> (([<span class="keyword">self</span> member: anObject]) ? <span class="literal">YES</span> : <span class="literal">NO</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//在 GSSet,m 里有对 member 的实现</span></div><div class="line">- (<span class="keyword">id</span>) member: (<span class="keyword">id</span>)anObject</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (anObject != <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">      GSIMapNode node = GSIMapNodeForKey(&amp;map, (GSIMapKey)anObject);</div><div class="line">      <span class="keyword">if</span> (node != <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">	  <span class="keyword">return</span> node-&gt;key.obj;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找元素时是通过键值方式从 map 映射表里取出，因为 Set 里元素是唯一的，所以可以 hash 元素对象作为 key 达到快速获取值的目的。</p>
<h2 id="用-GCD-来做优化"><a href="#用-GCD-来做优化" class="headerlink" title="用 GCD 来做优化"></a>用 GCD 来做优化</h2><p>我们可以通过 GCD 提供的方法来将一些需要耗时操作放到非主线程上做，使得 App 能够运行的更加流畅响应更快。但是使用 GCD 时需要注意避免可能引起线程爆炸和死锁的情况，还有非主线程处理任务也不是万能的，如果一个处理需要消耗大量内存或者大量CPU操作 GCD 也没法帮你，只能通过将处理进行拆解分步骤分时间进行处理才比较妥当。</p>
<h3 id="异步处理事件"><a href="#异步处理事件" class="headerlink" title="异步处理事件"></a>异步处理事件</h3><p><img src="/uploads/deeply-ios-performance-optimization/03.png" alt=""><br>上图是最典型的异步处理事件的方法</p>
<h3 id="需要耗时长的任务"><a href="#需要耗时长的任务" class="headerlink" title="需要耗时长的任务"></a>需要耗时长的任务</h3><p><img src="/uploads/deeply-ios-performance-optimization/04.png" alt=""><br>将 GCD 的 block 通过 dispatch_block_create_with_qos_class 方法指定队列的 QoS 为 QOS_CLASS_UTILITY。这种 QoS 系统会针对大的计算，I/O，网络以及复杂数据处理做电量优化。</p>
<h3 id="避免线程爆炸"><a href="#避免线程爆炸" class="headerlink" title="避免线程爆炸"></a>避免线程爆炸</h3><ul>
<li>使用串行队列</li>
<li>使用 NSOperationQueues 的并发限制方法 NSOperationQueue.maxConcurrentOperationCount</li>
</ul>
<p>举个例子，下面的写法就比较危险，可能会造成线程爆炸和死锁<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span>; i++) &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(q, ^&#123;...&#125;);</div><div class="line">&#125;</div><div class="line">dispatch_barrier_sync(q, ^&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/deeply-ios-performance-optimization/05.png" alt=""></p>
<p>那么怎么能够避免呢？首先可以使用 dispatch_apply<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_apply(<span class="number">999</span>, q, ^(size_t i)&#123;...&#125;);</div></pre></td></tr></table></figure></p>
<p>或者使用 dispatch_semaphore<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define CONCURRENT_TASKS 4</span></div><div class="line">sema = dispatch_semaphore_create(CONCURRENT_TASKS);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span>; i++)&#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line">        dispatch_semaphore_signal(sema);</div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="GCD-相关-Crash-日志"><a href="#GCD-相关-Crash-日志" class="headerlink" title="GCD 相关 Crash 日志"></a>GCD 相关 Crash 日志</h3><p>管理线程问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread 1:: Dispatch queue: com.apple.libdispatch-manager</div><div class="line">0   libsystem_kernel.dylib   0x00007fff8967e08a kevent_qos + 10</div><div class="line">1   libdispatch.dylib        0x00007fff8be05811 _dispatch_mgr_invoke + 251</div><div class="line">2   libdispatch.dylib        0x00007fff8be05465 _dispatch_mgr_thread + 52</div></pre></td></tr></table></figure></p>
<p>线程闲置时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread 6:</div><div class="line">0   libsystem_kernel.dylib       0x00007fff8967d772 __workq_kernreturn + 10</div><div class="line">1   libsystem_pthread.dylib      0x00007fff8fd317d9 _pthread_wqthread + 1283</div><div class="line">2   libsystem_pthread.dylib      0x00007fff8fd2ed95 start_wqthread + 13</div></pre></td></tr></table></figure></p>
<p>线程活跃时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread 3 Crashed:: Dispatch queue: &lt;queue name&gt;</div><div class="line">&lt;my code&gt;</div><div class="line">7   libdispatch.dylib        0x07fff8fcfd323 _dispatch_call_block_and_release</div><div class="line">8   libdispatch.dylib        0x07fff8fcf8c13 _dispatch_client_callout + 8</div><div class="line">9   libdispatch.dylib        0x07fff8fcfc365 _dispatch_queue_drain + 1100</div><div class="line">10  libdispatch.dylib        0x07fff8fcfdecc _dispatch_queue_invoke + 202</div><div class="line">11  libdispatch.dylib        0x07fff8fcfb6b7 _dispatch_root_queue_drain + 463</div><div class="line">12  libdispatch.dylib        0x07fff8fd09fe4 _dispatch_worker_thread3 + 91</div><div class="line">13  libsystem_pthread.dylib  0x07fff93c17637 _pthread_wqthread + 729</div><div class="line">14  libsystem_pthread.dylib  0x07fff93c1540d start_wqthread + 13</div></pre></td></tr></table></figure></p>
<p>主线程闲置时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread 0 Crashed:: Dispatch queue: com.apple.main-thread</div><div class="line">0   libsystem_kernel.dylib     0x00007fff906614de mach_msg_trap + 10</div><div class="line">1   libsystem_kernel.dylib     0x00007fff9066064f mach_msg + 55</div><div class="line">2   com.apple.CoreFoundation   0x00007fff9a8c1eb4 __CFRunLoopServiceMachPort</div><div class="line">3   com.apple.CoreFoundation   0x00007fff9a8c137b __CFRunLoopRun + 1371</div><div class="line">4   com.apple.CoreFoundation   0x00007fff9a8c0bd8 CFRunLoopRunSpecific + 296</div><div class="line">...</div><div class="line">10  com.apple.AppKit           0x00007fff8e823c03 -[NSApplication run] + 594</div><div class="line">11  com.apple.AppKit           0x00007fff8e7a0354 NSApplicationMain + 1832</div><div class="line">12  com.example                0x00000001000013b4 start + 52</div></pre></td></tr></table></figure></p>
<p>主队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Thread 0 Crashed:: Dispatch queue: com.apple.main-thread</div><div class="line">&lt;my code&gt;</div><div class="line">12  com.apple.Foundation      0x00007fff931157e8 __NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 7</div><div class="line">13  com.apple.Foundation      0x00007fff931155b5 -[NSBlockOperation main] + 9</div><div class="line">14  com.apple.Foundation      0x00007fff93114a6c -[__NSOperationInternal _start:] + 653</div><div class="line">15  com.apple.Foundation      0x00007fff93114543 __NSOQSchedule_f + 184</div><div class="line">16  libdispatch.dylib         0x00007fff935d6c13 _dispatch_client_callout + 8</div><div class="line">17  libdispatch.dylib         0x00007fff935e2cbf _dispatch_main_queue_callback_4CF + 861</div><div class="line">18  com.apple.CoreFoundation  0x00007fff8d9223f9 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</div><div class="line">19  com.apple.CoreFoundation  0x00007fff8d8dd68f __CFRunLoopRun + 2159</div><div class="line">20  com.apple.CoreFoundation  0x00007fff8d8dcbd8 CFRunLoopRunSpecific + 296</div><div class="line">...</div><div class="line">26  com.apple.AppKit          0x00007fff999a1bd3 -[NSApplication run] + 594</div><div class="line">27  com.apple.AppKit          0x00007fff9991e324 NSApplicationMain + 1832</div><div class="line">28  libdyld.dylib             0x00007fff9480f5c9 start + 1</div></pre></td></tr></table></figure></p>
<h2 id="I-O-性能优化"><a href="#I-O-性能优化" class="headerlink" title="I/O 性能优化"></a>I/O 性能优化</h2><p>I/O 是性能消耗大户，任何的 I/O 操作都会使低功耗状态被打破，所以减少 I/O 次数是这个性能优化的关键点，为了达成这个目下面列出一些方法。</p>
<ul>
<li>将零碎的内容作为一个整体进行写入</li>
<li>使用合适的 I/O 操作 API</li>
<li>使用合适的线程</li>
<li>使用 NSCache 做缓存能够减少 I/O</li>
</ul>
<h3 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h3><p><img src="/uploads/deeply-ios-performance-optimization/06.png" alt=""><br>达到如图的目的为何不直接用字典来做呢？<br>NSCache 具有字典的所有功能，同时还有如下的特性：</p>
<ul>
<li>自动清理系统占用内存</li>
<li>NSCache 是线程安全</li>
<li>-(void)cache:(NSCache *)cache willEvictObject:(id)obj;   缓存对象将被清理时的回调 </li>
<li>evictsObjectsWithDiscardedContent 可以控制是否清理</li>
</ul>
<p>那么 NSCache是如何做到这些特性的呢？</p>
<p>接下来学习下 NSCache 是如何做的。首先 NSCache 是会持有一个 NSMutableDictionary。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@implementation NSCache</div><div class="line">- (id) init</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (nil == (self = [super init]))</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> nil;</div><div class="line">    &#125;</div><div class="line">  _objects = [NSMutableDictionary <span class="keyword">new</span>];</div><div class="line">  _accesses = [NSMutableArray <span class="keyword">new</span>];</div><div class="line">  <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要设计一个 Cached 对象结构来保存一些额外的信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@interface _GSCachedObject : NSObject</div><div class="line">&#123;</div><div class="line">  @<span class="keyword">public</span></div><div class="line">  id object; <span class="comment">//cache 的值</span></div><div class="line">  NSString *key; <span class="comment">//设置 cache 的 key</span></div><div class="line">  <span class="keyword">int</span> accessCount; <span class="comment">//保存访问次数，用于自动清理</span></div><div class="line">  NSUInteger cost; <span class="comment">//setObject:forKey:cost:</span></div><div class="line">  BOOL isEvictable; <span class="comment">//线程安全</span></div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>在 Cache 读取的时候会对 _accesses 数组的添加删除通过 isEvictable 布尔值来保证线程安全操作。使用 Cached 对象里的 accessCount 属性进行 +1 操作为后面自动清理的条件判断做准备。具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (id) objectForKey: (id)key</div><div class="line">&#123;</div><div class="line">  _GSCachedObject *obj = [_objects objectForKey: key];</div><div class="line">  <span class="keyword">if</span> (nil == obj)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> nil;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">if</span> (obj-&gt;isEvictable) <span class="comment">//保证添加删除操作线程安全</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">// 将 obj 移到 access list 末端</span></div><div class="line">      [_accesses removeObjectIdenticalTo: obj];</div><div class="line">      [_accesses addObject: obj];</div><div class="line">    &#125;</div><div class="line">  obj-&gt;accessCount++;</div><div class="line">  _totalAccesses++;</div><div class="line">  <span class="keyword">return</span> obj-&gt;object;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在每次 Cache 添加时会先去检查是否自动清理，会创建一个 Cached 对象将 key，object，cost 等信息记录下添加到 _accesses 数组和 _objects 字典里。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) setObject: (id)obj forKey: (id)key cost: (NSUInteger)num</div><div class="line">&#123;</div><div class="line">  _GSCachedObject *oldObject = [_objects objectForKey: key];</div><div class="line">  _GSCachedObject *newObject;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (nil != oldObject)</div><div class="line">    &#123;</div><div class="line">      [self removeObjectForKey: oldObject-&gt;key];</div><div class="line">    &#125;</div><div class="line">  [self _evictObjectsToMakeSpaceForObjectWithCost: num];</div><div class="line">  newObject = [_GSCachedObject <span class="keyword">new</span>];</div><div class="line">  <span class="comment">// Retained here, released when obj is dealloc'd</span></div><div class="line">  newObject-&gt;object = RETAIN(obj);</div><div class="line">  newObject-&gt;key = RETAIN(key);</div><div class="line">  newObject-&gt;cost = num;</div><div class="line">  <span class="keyword">if</span> ([obj conformsToProtocol: @protocol(NSDiscardableContent)])</div><div class="line">    &#123;</div><div class="line">      newObject-&gt;isEvictable = YES;</div><div class="line">      [_accesses addObject: newObject];</div><div class="line">    &#125;</div><div class="line">  [_objects setObject: newObject forKey: key];</div><div class="line">  RELEASE(newObject);</div><div class="line">  _totalCost += num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么上面提到的自动清理内存的方法是如何实现的呢？<br>既然是自动清理必定需要有触发时机和进入清理的条件判断，触发时机一个是发生在添加 Cache 内容时，一个是发生在内存警告时。条件判断代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// cost 在添加新 cache 值时指定的 cost</span></div><div class="line"><span class="comment">// _costLimit 是 totalCostLimit 属性值</span></div><div class="line"><span class="keyword">if</span> (_costLimit &gt; <span class="number">0</span> &amp;&amp; _totalCost + cost &gt; _costLimit)&#123;</div><div class="line">	spaceNeeded = _totalCost + cost - _costLimit;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 只有当 cost 大于人工限制时才会清理</span></div><div class="line"><span class="comment">// 或者 cost 设置为0不进行人工干预</span></div><div class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; (spaceNeeded &gt; <span class="number">0</span> || count &gt;= _countLimit))</div></pre></td></tr></table></figure></p>
<p>所以 NSCache 的 totalCostLimit 的值会和每次 Cache 添加的 cost 之和对比，超出限制必然触发内存清理。</p>
<p>清理时会对经常访问的 objects 不清理，主要是通过 _totalAccesses 和总数获得平均访问频率，如果那个对象的访问次数是小于平均值的才需要清理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//_totalAccesses 所有的值的访问都会 +1</span></div><div class="line">NSUInteger averageAccesses = (_totalAccesses / count * <span class="number">0.2</span>) + <span class="number">1</span>;</div><div class="line"><span class="comment">//accessCount 每次 obj 取值时会 +1</span></div><div class="line"><span class="keyword">if</span> (obj-&gt;accessCount &lt; averageAccesses &amp;&amp; obj-&gt;isEvictable)</div></pre></td></tr></table></figure></p>
<p>在清理之前还需要一些准备工作，包括标记 Cached 对象的 isEvictable 防止后面有不安全的线程操作。将满足条件的清理 objects 放到清理数组里，如果空间释放足够就不用再把更多的 objects 加到清理数组里了，最后遍历清理数组进行逐个清理即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NSUInteger cost = obj-&gt;cost;</div><div class="line">obj-&gt;cost = <span class="number">0</span>;</div><div class="line"><span class="comment">// 不会被再次清除</span></div><div class="line">obj-&gt;isEvictable = NO;</div><div class="line"><span class="comment">// 添加到 remove list 里</span></div><div class="line"><span class="keyword">if</span> (_evictsObjectsWithDiscardedContent)</div><div class="line">&#123;</div><div class="line">    [evictedKeys addObject: obj-&gt;key];</div><div class="line">&#125;</div><div class="line">_totalCost -= cost;</div><div class="line"><span class="comment">// 如果已经释放了足够空间就不用后面操作了</span></div><div class="line"><span class="keyword">if</span> (cost &gt; spaceNeeded)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">spaceNeeded -= cost;</div></pre></td></tr></table></figure></p>
<p>在清理时会执行回调内容，这样如果有些缓存数据需要持续化存储可以在回调里进行处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) removeObjectForKey: (id)key</div><div class="line">&#123;</div><div class="line">    _GSCachedObject *obj = [_objects objectForKey: key];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (nil != obj)</div><div class="line">    &#123;</div><div class="line">        [_delegate cache: self willEvictObject: obj-&gt;object];</div><div class="line">        _totalAccesses -= obj-&gt;accessCount;</div><div class="line">        [_objects removeObjectForKey: key];</div><div class="line">        [_accesses removeObjectIdenticalTo: obj];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整的实现可以查看 GNUstep Base 的 NSCache.m 文件。</p>
<p>下面可以看看 NSCache 在 SDWebImage 的运用是怎么样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">// 检查 NSCache 里是否有</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 从磁盘里读</span></div><div class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">    <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">        [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> diskImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出利用 NSCache 自动释放内存的特点将图片都放到 NSCache 里这样在内存不够用时可以自动清理掉不常用的那些图片，在读取 Cache 里内容时如果没有被清理会直接返回图片数据，清理了的话才会执行 I/O 从磁盘读取图片，通过这种方式能够利用空间减少磁盘操作，空间也能够更加有效的控制释放。</p>
<h2 id="控制-App-的-Wake-次数"><a href="#控制-App-的-Wake-次数" class="headerlink" title="控制 App 的 Wake 次数"></a>控制 App 的 Wake 次数</h2><p>通知，VoIP，定位，蓝牙等都会使设备从 Standby 状态唤起。唤起这个过程会有比较大的消耗，应该避免频繁发生。通知方面主要要在产品层面多做考虑。定位方面，下面可以看看定位的一些 API 看看它们对性能的不同影响，便于考虑采用合适的接口。</p>
<p>连续的位置更新<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[locationManager startUpdatingLocation]</div></pre></td></tr></table></figure></p>
<p>这个方法会时设备一直处于活跃状态。</p>
<p>延时有效定位<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[locationManager allowDeferredLocationUpdatesUntilTraveled: timeout:]</div><div class="line">``` </div><div class="line">高效节能的定位方式，数据会缓存在位置硬件上。适合于跑步应用应该都采用这种方式。</div><div class="line"></div><div class="line">重大位置变化</div><div class="line">```objc</div><div class="line">[locationManager startMonitoringSignificantLocationChanges]</div></pre></td></tr></table></figure></p>
<p>会更节能，对于那些只有在位置有很大变化的才需要回调的应用可以采用这种，比如天气应用。</p>
<p>区域监测<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[locationManager startMonitoringForRegion:(<span class="built_in">CLRegion</span> *)]</div></pre></td></tr></table></figure></p>
<p>也是一种节能的定位方式，比如在博物馆里按照不同区域监测展示不同信息之类的应用比较适合这种定位。</p>
<p>经常访问的地方<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Start monitoring</span></div><div class="line">locationManager.startMonitoringVisits()</div><div class="line"><span class="comment">// Stop monitoring when no longer needed</span></div><div class="line">locationManager.stopMonitoringVisits()</div></pre></td></tr></table></figure></p>
<p>总的来说，不要轻易使用 startUpdatingLocation() 除非万不得已，尽快的使用 stopUpdatingLocation() 来结束定位还用户一个节能设备。</p>
<h2 id="内存对于性能的影响"><a href="#内存对于性能的影响" class="headerlink" title="内存对于性能的影响"></a>内存对于性能的影响</h2><p>首先 Reclaiming 内存是需要时间的，突然的大量内存需求是会影响响应的。</p>
<h1 id="如何预防这些性能问题，需要刻意预防么"><a href="#如何预防这些性能问题，需要刻意预防么" class="headerlink" title="如何预防这些性能问题，需要刻意预防么"></a>如何预防这些性能问题，需要刻意预防么</h1><p>坚持下面几个原则争取在编码阶段避免一些性能问题。</p>
<ul>
<li>优化计算的复杂度从而减少 CPU 的使用</li>
<li>在应用响应交互的时候停止没必要的任务处理</li>
<li>设置合适的 QoS</li>
<li>将定时器任务合并，让 CPU 更多时候处于 idle 状态</li>
</ul>
<p>那么如果写需求时来不及注意这些问题做不到预防的话，可以通过自动化代码检查的方式来避免这些问题吗？</p>
<h1 id="如何检查"><a href="#如何检查" class="headerlink" title="如何检查"></a>如何检查</h1><p>根据这些问题在代码里查，写工具或用工具自动化查？虽然可以，但是需要考虑的情况太多，现有工具支持不好，自己写需要考虑的点太多需要花费太长的时间，那么什么方式会比较好呢？</p>
<h1 id="通过监听主线程方式来监察"><a href="#通过监听主线程方式来监察" class="headerlink" title="通过监听主线程方式来监察"></a>通过监听主线程方式来监察</h1><p>首先用 CFRunLoopObserverCreate 创建一个观察者里面接受 CFRunLoopActivity 的回调，然后用 CFRunLoopAddObserver 将观察者添加到 CFRunLoopGetMain() 主线程 Runloop 的 kCFRunLoopCommonModes 模式下进行观察。</p>
<p>接下来创建一个子线程来进行监控，使用 dispatch_semaphore_wait 定义区间时间，标准是 16 或 20 微秒一次监控的话基本可以把影响响应的都找出来。监控结果的标准是根据两个 Runloop 的状态 BeforeSources 和 AfterWaiting 在区间时间是否能检测到来判断是否卡顿。</p>
<h1 id="如何打印堆栈信息，保存现场"><a href="#如何打印堆栈信息，保存现场" class="headerlink" title="如何打印堆栈信息，保存现场"></a>如何打印堆栈信息，保存现场</h1><p>打印堆栈整体思路是获取线程的信息得到线程的 state 从而得到线程里所有栈的指针，根据这些指针在 符号表里找到对应的描述即符号化解析，这样就能够展示出可读的堆栈信息。具体实现是怎样的呢？下面详细说说：</p>
<h2 id="获取线程的信息"><a href="#获取线程的信息" class="headerlink" title="获取线程的信息"></a>获取线程的信息</h2><p>这里首先是要通过 task_threads 取到所有的线程，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">thread_act_array_t</span> threads; <span class="comment">//int 组成的数组比如 thread[1] = 5635</span></div><div class="line"><span class="keyword">mach_msg_type_number_t</span> thread_count = <span class="number">0</span>; <span class="comment">//mach_msg_type_number_t 是 int 类型</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">task_t</span> this_task = mach_task_self(); <span class="comment">//int</span></div><div class="line"><span class="comment">//根据当前 task 获取所有线程</span></div><div class="line"><span class="keyword">kern_return_t</span> kr = task_threads(this_task, &amp;threads, &amp;thread_count);</div></pre></td></tr></table></figure></p>
<p>遍历时通过 thread_info 获取各个线程的详细信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">SMThreadInfoStruct threadInfoSt = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">thread_info_data_t</span> threadInfo;</div><div class="line"><span class="keyword">thread_basic_info_t</span> threadBasicInfo;</div><div class="line"><span class="keyword">mach_msg_type_number_t</span> threadInfoCount = THREAD_INFO_MAX;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (thread_info((<span class="keyword">thread_act_t</span>)thread, THREAD_BASIC_INFO, (<span class="keyword">thread_info_t</span>)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) &#123;</div><div class="line">    threadBasicInfo = (<span class="keyword">thread_basic_info_t</span>)threadInfo;</div><div class="line">    <span class="keyword">if</span> (!(threadBasicInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</div><div class="line">        threadInfoSt.cpuUsage = threadBasicInfo-&gt;cpu_usage / <span class="number">10</span>;</div><div class="line">        threadInfoSt.userTime = threadBasicInfo-&gt;system_time.microseconds;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">uintptr_t</span> buffer[<span class="number">100</span>];</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">NSMutableString *reStr = [NSMutableString stringWithFormat:@<span class="string">"Stack of thread: %u:\n CPU used: %.1f percent\n user time: %d second\n"</span>, thread, threadInfoSt.cpuUsage, threadInfoSt.userTime];</div></pre></td></tr></table></figure></p>
<h2 id="获取线程里所有栈的信息"><a href="#获取线程里所有栈的信息" class="headerlink" title="获取线程里所有栈的信息"></a>获取线程里所有栈的信息</h2><p>可以通过 thread_get_state 得到 machine context 里面包含了线程栈里所有的栈指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_STRUCT_MCONTEXT machineContext; <span class="comment">//线程栈里所有的栈指针</span></div><div class="line"><span class="comment">//通过 thread_get_state 获取完整的 machineContext 信息，包含 thread 状态信息</span></div><div class="line"><span class="keyword">mach_msg_type_number_t</span> state_count = smThreadStateCountByCPU();</div><div class="line"><span class="keyword">kern_return_t</span> kr = thread_get_state(thread, smThreadStateByCPU(), (<span class="keyword">thread_state_t</span>)&amp;machineContext.__ss, &amp;state_count);</div></pre></td></tr></table></figure></p>
<p>创建一个栈结构体用来保存栈的数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为通用回溯设计结构支持栈地址由小到大，地址里存储上个栈指针的地址</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SMStackFrame</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">SMStackFrame</span> *<span class="title">const</span> <span class="title">previous</span>;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uintptr_t</span> return_address;</div><div class="line">&#125; SMStackFrame;</div><div class="line"></div><div class="line">SMStackFrame stackFrame = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="comment">//通过栈基址指针获取当前栈帧地址</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uintptr_t</span> framePointer = smMachStackBasePointerByCPU(&amp;machineContext);</div><div class="line"><span class="keyword">if</span> (framePointer == <span class="number">0</span> || smMemCopySafely((<span class="keyword">void</span> *)framePointer, &amp;stackFrame, <span class="keyword">sizeof</span>(stackFrame)) != KERN_SUCCESS) &#123;</div><div class="line">    <span class="keyword">return</span> @<span class="string">"Fail frame pointer"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (; i &lt; <span class="number">32</span>; i++) &#123;</div><div class="line">    buffer[i] = stackFrame.return_address;</div><div class="line">    <span class="keyword">if</span> (buffer[i] == <span class="number">0</span> || stackFrame.previous == <span class="number">0</span> || smMemCopySafely(stackFrame.previous, &amp;stackFrame, <span class="keyword">sizeof</span>(stackFrame)) != KERN_SUCCESS) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h2><p>符号化主要思想就是通过栈指针地址减去 Slide 地址得到 ASLR 偏移量，通过这个偏移量可以在 __LINKEDIT segment 查找到字符串和符号表的位置。具体代码实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">info-&gt;dli_fname = <span class="literal">NULL</span>;</div><div class="line">info-&gt;dli_fbase = <span class="literal">NULL</span>;</div><div class="line">info-&gt;dli_sname = <span class="literal">NULL</span>;</div><div class="line">info-&gt;dli_saddr = <span class="literal">NULL</span>;</div><div class="line"><span class="comment">//根据地址获取是哪个 image</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> idx = smDyldImageIndexFromAddress(address);</div><div class="line"><span class="keyword">if</span> (idx == UINT_MAX) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> Header</div><div class="line"> ------------------</div><div class="line"> Load commands</div><div class="line"> Segment command 1 -------------|</div><div class="line"> Segment command 2              |</div><div class="line"> ------------------             |</div><div class="line"> Data                           |</div><div class="line"> Section 1 data |segment 1 &lt;----|</div><div class="line"> Section 2 data |          &lt;----|</div><div class="line"> Section 3 data |          &lt;----|</div><div class="line"> Section 4 data |segment 2</div><div class="line"> Section 5 data |</div><div class="line"> ...            |</div><div class="line"> Section n data |</div><div class="line"> */</div><div class="line"><span class="comment">/*----------Mach Header---------*/</span></div><div class="line"><span class="comment">//根据 image 的序号获取 mach_header</span></div><div class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>* <span class="title">machHeader</span> = _<span class="title">dyld_get_image_header</span>(<span class="title">idx</span>);</span></div><div class="line"><span class="comment">//返回 image_index 索引的 image 的虚拟内存地址 slide 的数量，如果 image_index 超出范围返回0</span></div><div class="line"><span class="comment">//动态链接器加载 image 时，image 必须映射到未占用地址的进程的虚拟地址空间。动态链接器通过添加一个值到 image 的基地址来实现，这个值是虚拟内存 slide 数量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uintptr_t</span> imageVMAddressSlide = (<span class="keyword">uintptr_t</span>)_dyld_get_image_vmaddr_slide(idx);</div><div class="line"><span class="comment">/*-----------ASLR 的偏移量---------*/</span></div><div class="line"><span class="comment">//https://en.wikipedia.org/wiki/Address_space_layout_randomization</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uintptr_t</span> addressWithSlide = address - imageVMAddressSlide;</div><div class="line"><span class="comment">//根据 Image 的 Index 来获取 segment 的基地址</span></div><div class="line"><span class="comment">//段定义Mach-O文件中的字节范围以及动态链接器加载应用程序时这些字节映射到虚拟内存中的地址和内存保护属性。 因此，段总是虚拟内存页对齐。 片段包含零个或多个节。</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">uintptr_t</span> segmentBase = smSegmentBaseOfImageIndex(idx) + imageVMAddressSlide;</div><div class="line"><span class="keyword">if</span> (segmentBase == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">info-&gt;dli_fname = _dyld_get_image_name(idx);</div><div class="line">info-&gt;dli_fbase = (<span class="keyword">void</span>*)machHeader;</div><div class="line"></div><div class="line"><span class="comment">/*--------------Mach Segment-------------*/</span></div><div class="line"><span class="comment">//地址最匹配的symbol</span></div><div class="line"><span class="keyword">const</span> nlistByCPU* bestMatch = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">uintptr_t</span> bestDistance = ULONG_MAX;</div><div class="line"><span class="keyword">uintptr_t</span> cmdPointer = smCmdFirstPointerFromMachHeader(machHeader);</div><div class="line"><span class="keyword">if</span> (cmdPointer == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//遍历每个 segment 判断目标地址是否落在该 segment 包含的范围里</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> iCmd = <span class="number">0</span>; iCmd &lt; machHeader-&gt;ncmds; iCmd++) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">loadCmd</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)<span class="title">cmdPointer</span>;</span></div><div class="line">    <span class="comment">/*----------目标 Image 的符号表----------*/</span></div><div class="line">    <span class="comment">//Segment 除了 __TEXT 和 __DATA 外还有 __LINKEDIT segment，它里面包含动态链接器的使用的原始数据，比如符号，字符串和重定位表项。</span></div><div class="line">    <span class="comment">//LC_SYMTAB 描述了 __LINKEDIT segment 内查找字符串和符号表的位置</span></div><div class="line">    <span class="keyword">if</span> (loadCmd-&gt;cmd == LC_SYMTAB) &#123;</div><div class="line">        <span class="comment">//获取字符串和符号表的虚拟内存偏移量。</span></div><div class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtabCmd</span> = (<span class="title">struct</span> <span class="title">symtab_command</span>*)<span class="title">cmdPointer</span>;</span></div><div class="line">        <span class="keyword">const</span> nlistByCPU* symbolTable = (nlistByCPU*)(segmentBase + symtabCmd-&gt;symoff);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">uintptr_t</span> stringTable = segmentBase + symtabCmd-&gt;stroff;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> iSym = <span class="number">0</span>; iSym &lt; symtabCmd-&gt;nsyms; iSym++) &#123;</div><div class="line">            <span class="comment">//如果 n_value 是0，symbol 指向外部对象</span></div><div class="line">            <span class="keyword">if</span> (symbolTable[iSym].n_value != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//给定的偏移量是文件偏移量，减去 __LINKEDIT segment 的文件偏移量获得字符串和符号表的虚拟内存偏移量</span></div><div class="line">                <span class="keyword">uintptr_t</span> symbolBase = symbolTable[iSym].n_value;</div><div class="line">                <span class="keyword">uintptr_t</span> currentDistance = addressWithSlide - symbolBase;</div><div class="line">                <span class="comment">//寻找最小的距离 bestDistance，因为 addressWithSlide 是某个方法的指令地址，要大于这个方法的入口。</span></div><div class="line">                <span class="comment">//离 addressWithSlide 越近的函数入口越匹配</span></div><div class="line">                <span class="keyword">if</span> ((addressWithSlide &gt;= symbolBase) &amp;&amp; (currentDistance &lt;= bestDistance)) &#123;</div><div class="line">                    bestMatch = symbolTable + iSym;</div><div class="line">                    bestDistance = currentDistance;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (bestMatch != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">//将虚拟内存偏移量添加到 __LINKEDIT segment 的虚拟内存地址可以提供字符串和符号表的内存 address。</span></div><div class="line">            info-&gt;dli_saddr = (<span class="keyword">void</span>*)(bestMatch-&gt;n_value + imageVMAddressSlide);</div><div class="line">            info-&gt;dli_sname = (<span class="keyword">char</span>*)((<span class="keyword">intptr_t</span>)stringTable + (<span class="keyword">intptr_t</span>)bestMatch-&gt;n_un.n_strx);</div><div class="line">            <span class="keyword">if</span> (*info-&gt;dli_sname == <span class="string">'_'</span>) &#123;</div><div class="line">                info-&gt;dli_sname++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//所有的 symbols 的已经被处理好了</span></div><div class="line">            <span class="keyword">if</span> (info-&gt;dli_saddr == info-&gt;dli_fbase &amp;&amp; bestMatch-&gt;n_type == <span class="number">3</span>) &#123;</div><div class="line">                info-&gt;dli_sname = <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cmdPointer += loadCmd-&gt;cmdsize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>需要注意的是这个程序有消耗性能的地方 thread get state。这个也会被监控检查出，所以可以过滤掉这样的堆栈信息。</p>
<h1 id="能够获取更多信息的方法"><a href="#能够获取更多信息的方法" class="headerlink" title="能够获取更多信息的方法"></a>能够获取更多信息的方法</h1><p>获取更多信息比如全层级方法调用和每个方法消耗的时间，那么这样做的好处在哪呢？</p>
<p>可以更细化的测量时间消耗，找到耗时方法，更快的交互操作能使用户体验更好，下面是一些可以去衡量的场景：</p>
<ul>
<li>响应能力</li>
<li>按钮点击</li>
<li>手势操作</li>
<li>Tab 切换</li>
<li>vc 的切换和转场</li>
</ul>
<p>可以给优化定个目标，比如滚动和动画达到 60fps，响应用户操作在 100ms 内完成。然后逐个检测出来 fix 掉。</p>
<p>如何获取到更多信息呢？</p>
<p>通过 hook objc_msgSend 方法能够获取所有被调用的方法，记录深度就能够得到方法调用的树状结构，通过执行前后时间的记录能够得到每个方法的耗时，这样就能获取一份完整的性能消耗信息了。</p>
<p>hook c 函数可以使用 facebook 的 <a href="https://github.com/facebook/fishhook" target="_blank" rel="external">fishhook</a>， 获取方法调用树状结构可以使用 <a href="https://github.com/DavidGoldman/InspectiveC" target="_blank" rel="external">InspectiveC</a>，下面对于他们的实现详细介绍一下：</p>
<h2 id="获取方法调用树结构"><a href="#获取方法调用树结构" class="headerlink" title="获取方法调用树结构"></a>获取方法调用树结构</h2><p>首先设计两个结构体，CallRecord 记录调用方法详细信息，包括 obj 和 SEL 等，ThreadCallStack 里面需要用 index 记录当前调用方法树的深度。有了 SEL 再通过 NSStringFromSelector 就能够取得方法名，有了 obj 通过 object_getClass 能够得到 Class 再用 NSStringFromClass 就能够获得类名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Shared structures.</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CallRecord_</span> &#123;</span></div><div class="line">  id obj;   <span class="comment">//通过 object_getClass 能够得到 Class 再通过 NSStringFromClass 能够得到类名</span></div><div class="line">  SEL _cmd; <span class="comment">//通过 NSStringFromSelector 方法能够得到方法名</span></div><div class="line">  <span class="keyword">uintptr_t</span> lr;</div><div class="line">  <span class="keyword">int</span> prevHitIndex;</div><div class="line">  <span class="keyword">char</span> isWatchHit;</div><div class="line">&#125; CallRecord;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadCallStack_</span> &#123;</span></div><div class="line">  FILE *file;</div><div class="line">  <span class="keyword">char</span> *spacesStr;</div><div class="line">  CallRecord *<span class="built_in">stack</span>;</div><div class="line">  <span class="keyword">int</span> allocatedLength;</div><div class="line">  <span class="keyword">int</span> index; <span class="comment">//index 记录当前调用方法树的深度</span></div><div class="line">  <span class="keyword">int</span> numWatchHits;</div><div class="line">  <span class="keyword">int</span> lastPrintedIndex;</div><div class="line">  <span class="keyword">int</span> lastHitIndex;</div><div class="line">  <span class="keyword">char</span> isLoggingEnabled;</div><div class="line">  <span class="keyword">char</span> isCompleteLoggingEnabled;</div><div class="line">&#125; ThreadCallStack;</div></pre></td></tr></table></figure></p>
<h2 id="存储读取-ThreadCallStack"><a href="#存储读取-ThreadCallStack" class="headerlink" title="存储读取 ThreadCallStack"></a>存储读取 ThreadCallStack</h2><p>pthread_setspecific() 可以将私有数据设置在指定线程上，pthread_getspecific() 用来读取这个私有数据，利用这个特性可以就可以将 ThreadCallStack 的数据和该线程绑定在一起，随时进行数据的存取。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> ThreadCallStack * <span class="title">getThreadCallStack</span><span class="params">()</span> </span>&#123;</div><div class="line">  ThreadCallStack *cs = (ThreadCallStack *)pthread_getspecific(threadKey); <span class="comment">//读取</span></div><div class="line">  <span class="keyword">if</span> (cs == <span class="literal">NULL</span>) &#123;</div><div class="line">    cs = (ThreadCallStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadCallStack));</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAIN_THREAD_ONLY</span></div><div class="line">    cs-&gt;file = (pthread_main_np()) ? newFileForThread() : <span class="literal">NULL</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    cs-&gt;file = newFileForThread();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    cs-&gt;isLoggingEnabled = (cs-&gt;file != <span class="literal">NULL</span>);</div><div class="line">    cs-&gt;isCompleteLoggingEnabled = <span class="number">0</span>;</div><div class="line">    cs-&gt;spacesStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(DEFAULT_CALLSTACK_DEPTH + <span class="number">1</span>);</div><div class="line">    <span class="built_in">memset</span>(cs-&gt;spacesStr, <span class="string">' '</span>, DEFAULT_CALLSTACK_DEPTH);</div><div class="line">    cs-&gt;spacesStr[DEFAULT_CALLSTACK_DEPTH] = <span class="string">'\0'</span>;</div><div class="line">    cs-&gt;<span class="built_in">stack</span> = (CallRecord *)<span class="built_in">calloc</span>(DEFAULT_CALLSTACK_DEPTH, <span class="keyword">sizeof</span>(CallRecord)); <span class="comment">//分配 CallRecord 默认空间</span></div><div class="line">    cs-&gt;allocatedLength = DEFAULT_CALLSTACK_DEPTH;</div><div class="line">    cs-&gt;index = cs-&gt;lastPrintedIndex = cs-&gt;lastHitIndex = <span class="number">-1</span>;</div><div class="line">    cs-&gt;numWatchHits = <span class="number">0</span>;</div><div class="line">    pthread_setspecific(threadKey, cs); <span class="comment">//保存数据</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="记录方法调用深度"><a href="#记录方法调用深度" class="headerlink" title="记录方法调用深度"></a>记录方法调用深度</h2><p>因为要记录深度，而一个方法的调用里会有更多的方法调用，所以方法的调用写两个方法分别记录开始 pushCallRecord 和记录结束的时刻 popCallRecord，这样才能够通过在开始时对深度加一在结束时减一。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开始时</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushCallRecord</span><span class="params">(id obj, <span class="keyword">uintptr_t</span> lr, SEL _cmd, ThreadCallStack *cs)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> nextIndex = (++cs-&gt;index); <span class="comment">//增加深度</span></div><div class="line">  <span class="keyword">if</span> (nextIndex &gt;= cs-&gt;allocatedLength) &#123;</div><div class="line">    cs-&gt;allocatedLength += CALLSTACK_DEPTH_INCREMENT;</div><div class="line">    cs-&gt;<span class="built_in">stack</span> = (CallRecord *)<span class="built_in">realloc</span>(cs-&gt;<span class="built_in">stack</span>, cs-&gt;allocatedLength * <span class="keyword">sizeof</span>(CallRecord));</div><div class="line">    cs-&gt;spacesStr = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(cs-&gt;spacesStr, cs-&gt;allocatedLength + <span class="number">1</span>);</div><div class="line">    <span class="built_in">memset</span>(cs-&gt;spacesStr, <span class="string">' '</span>, cs-&gt;allocatedLength);</div><div class="line">    cs-&gt;spacesStr[cs-&gt;allocatedLength] = <span class="string">'\0'</span>;</div><div class="line">  &#125;</div><div class="line">  CallRecord *newRecord = &amp;cs-&gt;<span class="built_in">stack</span>[nextIndex];</div><div class="line">  newRecord-&gt;obj = obj;</div><div class="line">  newRecord-&gt;_cmd = _cmd;</div><div class="line">  newRecord-&gt;lr = lr;</div><div class="line">  newRecord-&gt;isWatchHit = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结束时</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> CallRecord * <span class="title">popCallRecord</span><span class="params">(ThreadCallStack *cs)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> &amp;cs-&gt;<span class="built_in">stack</span>[cs-&gt;index--]; <span class="comment">//减少深度</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="在-objc-msgSend-前后插入执行方法"><a href="#在-objc-msgSend-前后插入执行方法" class="headerlink" title="在 objc_msgSend 前后插入执行方法"></a>在 objc_msgSend 前后插入执行方法</h2><p>最后是 hook objc_msgSend 需要在调用前和调用后分别加入 pushCallRecord 和 popCallRecord。因为需要在调用后这个时机插入一个方法，而且不可能编写一个保留未知参数并跳转到 c 中任意函数指针的函数，那么这就需要用到汇编来做到。</p>
<p>下面针对 arm64 进行分析，arm64 有31个64 bit 的整数型寄存器，用 x0 到 x30 表示，主要思路就是先入栈参数，参数寄存器是 x0 - x7，对于objc_msgSend方法来说 x0 第一个参数是传入对象，x1 第二个参数是选择器 _cmd。 syscall 的 number 会放到 x8 里。然后交换寄存器中，将用于返回的寄存器 lr 移到 x1 里。先让 pushCallRecord 能够执行，再执行原始的 objc_msgSend，保存返回值，最后让 popCallRecord 能执行。具体代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replacementObjc_msgSend</span><span class="params">()</span> </span>&#123;</div><div class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(</span></span></div><div class="line">    <span class="comment">// sp 是堆栈寄存器，存放栈的偏移地址，每次都指向栈顶。</span></div><div class="line">    <span class="comment">// 保存 &#123;q0-q7&#125; 偏移地址到 sp 寄存器</span></div><div class="line">      <span class="string">"stp q6, q7, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q4, q5, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q2, q3, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q0, q1, [sp, #-32]!\n"</span></div><div class="line">    <span class="comment">// 保存 &#123;x0-x8, lr&#125;</span></div><div class="line">      <span class="string">"stp x8, lr, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x6, x7, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x4, x5, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x2, x3, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x0, x1, [sp, #-16]!\n"</span></div><div class="line">    <span class="comment">// 交换参数.</span></div><div class="line">      <span class="string">"mov x2, x1\n"</span></div><div class="line">      <span class="string">"mov x1, lr\n"</span></div><div class="line">      <span class="string">"mov x3, sp\n"</span></div><div class="line">    <span class="comment">// 调用 preObjc_msgSend，使用 bl label 语法。bl 执行一个分支链接操作，label 是无条件分支的，是和本指令的地址偏移，范围是 -128MB 到 +128MB</span></div><div class="line">      <span class="string">"bl __Z15preObjc_msgSendP11objc_objectmP13objc_selectorP9RegState_\n"</span></div><div class="line">      <span class="string">"mov x9, x0\n"</span></div><div class="line">      <span class="string">"mov x10, x1\n"</span></div><div class="line">      <span class="string">"tst x10, x10\n"</span></div><div class="line">    <span class="comment">// 读取 &#123;x0-x8, lr&#125; 从保存到 sp 栈顶的偏移地址读起</span></div><div class="line">      <span class="string">"ldp x0, x1, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x2, x3, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x4, x5, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x6, x7, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x8, lr, [sp], #16\n"</span></div><div class="line">    <span class="comment">// 读取 &#123;q0-q7&#125;</span></div><div class="line">      <span class="string">"ldp q0, q1, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q2, q3, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q4, q5, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q6, q7, [sp], #32\n"</span></div><div class="line">      <span class="string">"b.eq Lpassthrough\n"</span></div><div class="line">    <span class="comment">// 调用原始 objc_msgSend。使用 blr xn 语法。blr 除了从指定寄存器读取新的 PC 值外效果和 bl 一样。xn 是通用寄存器的64位名称分支地址，范围0到31</span></div><div class="line">      <span class="string">"blr x9\n"</span></div><div class="line">    <span class="comment">// 保存 &#123;x0-x9&#125;</span></div><div class="line">      <span class="string">"stp x0, x1, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x2, x3, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x4, x5, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x6, x7, [sp, #-16]!\n"</span></div><div class="line">      <span class="string">"stp x8, x9, [sp, #-16]!\n"</span></div><div class="line">    <span class="comment">// 保存 &#123;q0-q7&#125;</span></div><div class="line">      <span class="string">"stp q0, q1, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q2, q3, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q4, q5, [sp, #-32]!\n"</span></div><div class="line">      <span class="string">"stp q6, q7, [sp, #-32]!\n"</span></div><div class="line">    <span class="comment">// 调用 postObjc_msgSend hook.</span></div><div class="line">      <span class="string">"bl __Z16postObjc_msgSendv\n"</span></div><div class="line">      <span class="string">"mov lr, x0\n"</span></div><div class="line">    <span class="comment">// 读取 &#123;q0-q7&#125;</span></div><div class="line">      <span class="string">"ldp q6, q7, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q4, q5, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q2, q3, [sp], #32\n"</span></div><div class="line">      <span class="string">"ldp q0, q1, [sp], #32\n"</span></div><div class="line">    <span class="comment">// 读取 &#123;x0-x9&#125;</span></div><div class="line">      <span class="string">"ldp x8, x9, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x6, x7, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x4, x5, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x2, x3, [sp], #16\n"</span></div><div class="line">      <span class="string">"ldp x0, x1, [sp], #16\n"</span></div><div class="line">      <span class="string">"ret\n"</span></div><div class="line">      <span class="string">"Lpassthrough:\n"</span></div><div class="line">    <span class="comment">// br 无条件分支到寄存器中的地址</span></div><div class="line">      <span class="string">"br x9"</span></div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="记录时间的方法"><a href="#记录时间的方法" class="headerlink" title="记录时间的方法"></a>记录时间的方法</h2><p>为了记录耗时，这样就需要在 pushCallRecord 和 popCallRecord 里记录下时间。下面列出一些计算一段代码开始到结束的时间的方法</p>
<p>第一种： NSDate 微秒<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDate</span>* tmpStartData = [<span class="built_in">NSDate</span> date];</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line"><span class="keyword">double</span> deltaTime = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:tmpStartData];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cost time: %f s"</span>, deltaTime);</div></pre></td></tr></table></figure></p>
<p>第二种：clock_t 微秒clock_t计时所表示的是占用CPU的时钟单元<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">clock_t start = clock();</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line">clock_t end = clock();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cost time: %f s"</span>, (<span class="keyword">double</span>)(end - start)/<span class="built_in">CLOCKS_PER_SEC</span>);</div></pre></td></tr></table></figure></p>
<p>第三种：CFAbsoluteTime 微秒<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFAbsoluteTime</span> start = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line"><span class="built_in">CFAbsoluteTime</span> end = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cost time = %f s"</span>, end - start); <span class="comment">//s</span></div></pre></td></tr></table></figure></p>
<p>第四种：CFTimeInterval 纳秒<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFTimeInterval</span> start = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line"><span class="built_in">CFTimeInterval</span> end = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"cost time: %f s"</span>, end - start);</div></pre></td></tr></table></figure></p>
<p>第五种：mach_absolute_time 纳秒<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">uint64_t start = mach_absolute_time ();</div><div class="line"><span class="comment">//some code need caculate</span></div><div class="line">uint64_t end = mach_absolute_time ();</div><div class="line">uint64_t elapsed = <span class="number">1e-9</span> *(end - start);</div></pre></td></tr></table></figure></p>
<p>最后两种可用，本质区别<br>NSDate 或 CFAbsoluteTimeGetCurrent() 返回的时钟时间将会会网络时间同步，从时钟 偏移量的角度。mach_absolute_time() 和 CACurrentMediaTime() 是基于内建时钟的。选择一种，加到 pushCallRecord 和 popCallRecord 里，相减就能够获得耗时。</p>
<h1 id="如何-hook-msgsend-方法"><a href="#如何-hook-msgsend-方法" class="headerlink" title="如何 hook msgsend 方法"></a>如何 hook msgsend 方法</h1><p>那么 objc_msgSend 这个 c 方法是如何 hook 到的呢。首先了解下 dyld 是通过更新 Mach-O 二进制的 __DATA segment 特定的部分中的指针来邦定 lazy 和 non-lazy 符号，通过确认传递给 rebind_symbol 里每个符号名称更新的位置就可以找出对应替换来重新绑定这些符号。下面针对关键代码进行分析：</p>
<h2 id="遍历-dyld"><a href="#遍历-dyld" class="headerlink" title="遍历 dyld"></a>遍历 dyld</h2><p>首先是遍历 dyld 里的所有的 image，取出 image header 和 slide。注意第一次调用时主要注册 callback。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</div><div class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</div><div class="line">        _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="找出符号表相关-Command"><a href="#找出符号表相关-Command" class="headerlink" title="找出符号表相关 Command"></a>找出符号表相关 Command</h2><p>接下来需要找到符号表相关的 command，包括 linkedit segment command，symtab command 和 dysymtab command。方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">segment_command_t</span> *cur_seg_cmd;</div><div class="line"><span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></div><div class="line"></div><div class="line"><span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</div><div class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</div><div class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</div><div class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</div><div class="line">            linkedit_segment = cur_seg_cmd;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</div><div class="line">        symtab_cmd = (struct symtab_command*)cur_seg_cmd;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</div><div class="line">        dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="获得-base-和-indirect-符号表"><a href="#获得-base-和-indirect-符号表" class="headerlink" title="获得 base 和 indirect 符号表"></a>获得 base 和 indirect 符号表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Find base symbol/string table addresses</span></div><div class="line"><span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</div><div class="line"><span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</div><div class="line"><span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</div><div class="line"></div><div class="line"><span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></div><div class="line"><span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</div></pre></td></tr></table></figure>
<h2 id="进行方法替换"><a href="#进行方法替换" class="headerlink" title="进行方法替换"></a>进行方法替换</h2><p>有了符号表和传入的方法替换数组就可以进行符号表访问指针地址的替换，具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</div><div class="line"><span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</div><div class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</div><div class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</div><div class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</div><div class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</div><div class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</div><div class="line">    <span class="keyword">if</span> (strnlen(symbol_name, <span class="number">2</span>) &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></div><div class="line">    <span class="keyword">while</span> (cur) &#123;</div><div class="line">        <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</div><div class="line">                    indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</div><div class="line">                    *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</div><div class="line">                &#125;</div><div class="line">                indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</div><div class="line">                <span class="keyword">goto</span> symbol_loop;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cur = cur-&gt;next;</div><div class="line">    &#125;</div><div class="line">symbol_loop:;</div></pre></td></tr></table></figure></p>
<h1 id="统计方法调用频次"><a href="#统计方法调用频次" class="headerlink" title="统计方法调用频次"></a>统计方法调用频次</h1><p>在一些应用场景会有一些频繁的方法调用，有些方法的调用实际上是没有必要的，但是首先是需要将那些频繁调用的方法找出来这样才能够更好的定位到潜在的会造成性能浪费的方法使用。这些频繁调用的方法要怎么找呢？</p>
<p>大致的思路是这样，基于上面章节提到的记录方法调用深度的方案，将每个调用方法的路径保存住，调用相同路径的相同方法调用一次加一记录在数据库中，最后做一个视图按照调用次数的排序即可找到调用频繁的那些方法。下图是完成后展示的效果：</p>
<p><img src="/uploads/deeply-ios-performance-optimization/07.PNG" alt=""></p>
<p>接下来看看具体实现方式</p>
<h2 id="设计方法调用频次记录的结构"><a href="#设计方法调用频次记录的结构" class="headerlink" title="设计方法调用频次记录的结构"></a>设计方法调用频次记录的结构</h2><p>在先前时间消耗的 model 基础上增加路径，频次等信息<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *className;       <span class="comment">//类名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *methodName;      <span class="comment">//方法名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isClassMethod;        <span class="comment">//是否是类方法</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeCost;   <span class="comment">//时间消耗</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> callDepth;      <span class="comment">//Call 层级</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *path;              <span class="comment">//路径</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> lastCall;             <span class="comment">//是否是最后一个 Call</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> frequency;      <span class="comment">//访问频次</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;SMCallTraceTimeCostModel *&gt; *subCosts;</div></pre></td></tr></table></figure></p>
<h2 id="拼装方法路径"><a href="#拼装方法路径" class="headerlink" title="拼装方法路径"></a>拼装方法路径</h2><p>在遍历 SMCallTrace 记录的方法 model 和 遍历方法子方法时将路径拼装好，记录到数据库中<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (SMCallTraceTimeCostModel *model <span class="keyword">in</span> arr) &#123;</div><div class="line">    <span class="comment">//记录方法路径</span></div><div class="line">    model.path = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"[%@ %@]"</span>,model.className,model.methodName];</div><div class="line">    [<span class="keyword">self</span> appendRecord:model to:mStr];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)appendRecord:(SMCallTraceTimeCostModel *)cost to:(<span class="built_in">NSMutableString</span> *)mStr &#123;</div><div class="line">    [mStr appendFormat:<span class="string">@"%@\n path%@\n"</span>,[cost des],cost.path];</div><div class="line">    <span class="keyword">if</span> (cost.subCosts.count &lt; <span class="number">1</span>) &#123;</div><div class="line">        cost.lastCall = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//记录到数据库中</span></div><div class="line">    [[[SMLagDB shareInstance] increaseWithClsCallModel:cost] subscribeNext:^(<span class="keyword">id</span> x) &#123;&#125;];</div><div class="line">    <span class="keyword">for</span> (SMCallTraceTimeCostModel *model <span class="keyword">in</span> cost.subCosts) &#123;</div><div class="line">        <span class="comment">//记录方法的子方法的路径</span></div><div class="line">        model.path = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ - [%@ %@]"</span>,cost.path,model.className,model.methodName];</div><div class="line">        [<span class="keyword">self</span> appendRecord:model to:mStr];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="记录方法调用频次数据库"><a href="#记录方法调用频次数据库" class="headerlink" title="记录方法调用频次数据库"></a>记录方法调用频次数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>这里的 lastcall 是记录是否是最后一个方法的调用，展示时只取最后一个方法即可，因为也会有完整路径可以知道父方法和来源方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">_clsCallDBPath = [PATH_OF_DOCUMENT stringByAppendingPathComponent:<span class="string">@"clsCall.sqlite"</span>];</div><div class="line"><span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:_clsCallDBPath] == <span class="literal">NO</span>) &#123;</div><div class="line">    FMDatabase *db = [FMDatabase databaseWithPath:_clsCallDBPath];</div><div class="line">    <span class="keyword">if</span> ([db open]) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         cid: 主id</div><div class="line">         fid: 父id 暂时不用</div><div class="line">         cls: 类名</div><div class="line">         mtd: 方法名</div><div class="line">         path: 完整路径标识</div><div class="line">         timecost: 方法消耗时长</div><div class="line">         calldepth: 层级</div><div class="line">         frequency: 调用次数</div><div class="line">         lastcall: 是否是最后一个 call</div><div class="line">         */</div><div class="line">        <span class="built_in">NSString</span> *createSql = <span class="string">@"create table clscall (cid INTEGER PRIMARY KEY AUTOINCREMENT  NOT NULL, fid integer, cls text, mtd text, path text, timecost integer, calldepth integer, frequency integer, lastcall integer)"</span>;</div><div class="line">        [db executeUpdate:createSql];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h3><p>添加记录时需要先检查数据库里是否有相同路径的同一个方法调用，这样可以给 frequency 字段加一已达到记录频次的目的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">FMResultSet *rsl = [db executeQuery:<span class="string">@"select cid,frequency from clscall where path = ?"</span>, model.path];</div><div class="line"><span class="keyword">if</span> ([rsl next]) &#123;</div><div class="line">    <span class="comment">//有相同路径就更新路径访问频率</span></div><div class="line">    <span class="keyword">int</span> fq = [rsl intForColumn:<span class="string">@"frequency"</span>] + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> cid = [rsl intForColumn:<span class="string">@"cid"</span>];</div><div class="line">    [db executeUpdate:<span class="string">@"update clscall set frequency = ? where cid = ?"</span>, @(fq), @(cid)];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//没有就添加一条记录</span></div><div class="line">    <span class="built_in">NSNumber</span> *lastCall = @<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (model.lastCall) &#123;</div><div class="line">        lastCall = @<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    [db executeUpdate:<span class="string">@"insert into clscall (cls, mtd, path, timecost, calldepth, frequency, lastcall) values (?, ?, ?, ?, ?, ?, ?)"</span>, model.className, model.methodName, model.path, @(model.timeCost), @(model.callDepth), @<span class="number">1</span>, lastCall];</div><div class="line">&#125;</div><div class="line">[db close];</div><div class="line">[subscriber sendCompleted];</div></pre></td></tr></table></figure></p>
<h3 id="检索记录"><a href="#检索记录" class="headerlink" title="检索记录"></a>检索记录</h3><p>检索时注意按照调用频次字段进行排序即可。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FMResultSet *rs = [db executeQuery:<span class="string">@"select * from clscall where lastcall=? order by frequency desc limit ?, 50"</span>,@<span class="number">1</span>, @(page * <span class="number">50</span>)];</div><div class="line"><span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line"><span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">    SMCallTraceTimeCostModel *model = [<span class="keyword">self</span> clsCallModelFromResultSet:rs];</div><div class="line">    [arr addObject:model];</div><div class="line">    count ++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">    [subscriber sendNext:arr];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    [subscriber sendError:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">[subscriber sendCompleted];</div><div class="line">[db close];</div></pre></td></tr></table></figure></p>
<h1 id="找出-CPU-使用大的线程堆栈"><a href="#找出-CPU-使用大的线程堆栈" class="headerlink" title="找出 CPU 使用大的线程堆栈"></a>找出 CPU 使用大的线程堆栈</h1><p>在前面检测卡顿打印的堆栈里提到使用 thread_info 能够获取到各个线程的 cpu 消耗，但是 cpu 不在主线程即使消耗很大也不一定会造成卡顿导致卡顿检测无法检测出更多 cpu 消耗的情况，所以只能通过轮询监控各线程里的 cpu 使用情况，对于超过标准值比如70%的进行记录来跟踪定位出耗电的那些方法。下图是列出 cpu 过载时的堆栈记录的展示效果：</p>
<p><img src="/uploads/deeply-ios-performance-optimization/08.PNG" alt=""></p>
<p>有了前面的基础，实现起来轻松多了<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//轮询检查多个线程 cpu 情况</span></div><div class="line">+ (<span class="keyword">void</span>)updateCPU &#123;</div><div class="line">    thread_act_array_t threads;</div><div class="line">    mach_msg_type_number_t threadCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">const</span> task_t thisTask = mach_task_self();</div><div class="line">    kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);</div><div class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</div><div class="line">        thread_info_data_t threadInfo;</div><div class="line">        thread_basic_info_t threadBaseInfo;</div><div class="line">        mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;</div><div class="line">        <span class="keyword">if</span> (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) &#123;</div><div class="line">            threadBaseInfo = (thread_basic_info_t)threadInfo;</div><div class="line">            <span class="keyword">if</span> (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</div><div class="line">                integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / <span class="number">10</span>;</div><div class="line">                <span class="keyword">if</span> (cpuUsage &gt; <span class="number">70</span>) &#123;</div><div class="line">                    <span class="comment">//cup 消耗大于 70 时打印和记录堆栈</span></div><div class="line">                    <span class="built_in">NSString</span> *reStr = smStackOfThread(threads[i]);</div><div class="line">                    <span class="comment">//记录数据库中</span></div><div class="line">                    [[[SMLagDB shareInstance] increaseWithStackString:reStr] subscribeNext:^(<span class="keyword">id</span> x) &#123;&#125;];</div><div class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"CPU useage overload thread stack：\n%@"</span>,reStr);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>工具已整合到先前做的 <a href="https://github.com/ming1016/GCDFetchFeed" target="_blank" rel="external">GCDFetchFeed</a> 里。</p>
<ul>
<li>子线程检测主线程卡顿使用的话在需要开始检测的地方添加 [[SMLagMonitor shareInstance] beginMonitor]; 即可。</li>
<li>需要检测所有方法调用的用法就是在需要检测的地方调用 [SMCallTrace start]; 就可以了，不检测打印出结果的话调用 stop 和 save 就好了。这里还可以设置最大深度和最小耗时检测来过滤不需要看到的信息。</li>
<li>方法调用频次使用可以在需要开始统计的地方加上 [SMCallTrace startWithMaxDepth:3]; 记录时使用 [SMCallTrace stopSaveAndClean]; 记录到到数据库中同时清理内存的占用。可以 hook VC 的 viewWillAppear 和 viewWillDisappear，在 appear 时开始记录，在 disappear 时记录到数据库同时清理一次。结果展示的 view controller 是 SMClsCallViewController，push 出来就能够看到列表结果。</li>
</ul>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><h2 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h2><ul>
<li>WWDC 2013 224 Designing Code for Performance</li>
<li>WWDC 2013 408 Optimizing Your Code Using LLVM</li>
<li>WWDC 2013 712 Energy Best Practices</li>
<li>WWDC 2014 710 writing energy efficient code part 1</li>
<li>WWDC 2014 710 writing energy efficient code part 2</li>
<li>WWDC 2015 230 performance on ios and watchos</li>
<li>WWDC 2015 707 achieving allday battery life</li>
<li>WWDC 2015 708 debugging energy issues</li>
<li>WWDC 2015 718 building responsive and efficient apps with gcd</li>
<li>WWDC 2016 406 optimizing app startup time</li>
<li>WWDC 2016 719 optimizing io for performance and battery life</li>
<li>WWDC 2017 238 writing energy efficient apps</li>
<li>WWDC 2017 706 modernizing grand central dispatch usage</li>
</ul>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h1><p>最近我这需要招一名实习生来滴滴和我一起攻克一个工程开发效率的项目，绝对会成就感满满的，有兴趣的可以将简历发我 daiming@didichuxing.com 或者在微博上联系我 @戴铭</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题种类&quot;&gt;&lt;a href=&quot;#问题种类&quot; class=&quot;headerlink&quot; title=&quot;问题种类&quot;&gt;&lt;/a&gt;问题种类&lt;/h1&gt;&lt;h2 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Performance optimization" scheme="http://ming1016.github.io/tags/Performance-optimization/"/>
    
  </entry>
  
  <entry>
    <title>GMTC 上分享滴滴出行 iOS 端瘦身实践的 Slides</title>
    <link href="http://ming1016.github.io/2017/06/12/gmtc-ios-slimming-practice/"/>
    <id>http://ming1016.github.io/2017/06/12/gmtc-ios-slimming-practice/</id>
    <published>2017-06-12T06:15:06.000Z</published>
    <updated>2017-10-11T03:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这次 GMTC 大会上分享了我们在包大小瘦身实践过程中使用的一些方法和遇到的一些问题，会前也有很多朋友咨询过这方面的问题，相信这些经验对大家会有一些帮助，完整的 Slides 我放到了这里 <a href="http://pan.baidu.com/s/1skPAIID" target="_blank" rel="external">http://pan.baidu.com/s/1skPAIID</a> 这次大会其他讲师的 pdf 在 GMTC 官网已经放出 <a href="http://gmtc.geekbang.org/" target="_blank" rel="external">http://gmtc.geekbang.org/</a></p>
<p>下面我提出 Slides 的内容</p>
<p><img src="/uploads/gmtc-ios-slimming-practice/01.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/02.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/03.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/04.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/05.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/06.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/07.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/08.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/09.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/10.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/11.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/12.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/13.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/14.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/15.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/16.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/17.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/18.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/19.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/20.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/21.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/22.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/23.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/24.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/25.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/26.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/27.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/28.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/29.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/30.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/31.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/32.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/33.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/34.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/35.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/36.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/37.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/38.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/39.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/40.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/41.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/42.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/43.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/44.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/45.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/46.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/47.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/48.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/49.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/50.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/51.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/52.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/53.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/54.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/55.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/56.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/57.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/58.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/59.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/60.jpeg" alt=""><br><img src="/uploads/gmtc-ios-slimming-practice/61.jpeg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这次 GMTC 大会上分享了我们在包大小瘦身实践过程中使用的一些方法和遇到的一些问题，会前也有很多朋友咨询过这方面的问题，相信这些经验对大家会有一些帮助，完整的 Slides 我放到了这里 &lt;a href=&quot;http://pan.baidu.com/s/1skPAIID&quot;
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
  </entry>
  
  <entry>
    <title>atSwift大会上分享《学习iOS编译原理能做哪些有意思的事情》的 Slides</title>
    <link href="http://ming1016.github.io/2017/05/27/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/"/>
    <id>http://ming1016.github.io/2017/05/27/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/</id>
    <published>2017-05-27T09:54:41.000Z</published>
    <updated>2017-10-11T03:35:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次 swift 大会上我分享了一个 h5 转 swift 的 demo 还有 llvm backend 相关的知识和应用，分享完后微信，淘宝和 perfect 团队成员都私下表示了对这个主题的兴趣，看来大家对用技术提高效率的决心是一致的。下面是我的 slides ，下载地址是 <a href="https://pan.baidu.com/s/1kVPvPiB" target="_blank" rel="external">https://pan.baidu.com/s/1kVPvPiB</a>。其他嘉宾的 pdf 和 源码在 <a href="https://github.com/atConf/atswift-2017-resources" target="_blank" rel="external">https://github.com/atConf/atswift-2017-resources</a></p>
<p><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/1.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/2.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/3.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/4.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/5.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/6.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/7.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/8.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/9.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/10.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/11.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/12.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/13.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/14.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/15.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/16.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/17.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/18.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/19.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/20.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/21.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/22.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/23.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/24.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/25.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/26.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/27.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/28.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/29.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/30.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/31.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/32.png" alt=""><br><img src="/uploads/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/33.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次 swift 大会上我分享了一个 h5 转 swift 的 demo 还有 llvm backend 相关的知识和应用，分享完后微信，淘宝和 perfect 团队成员都私下表示了对这个主题的兴趣，看来大家对用技术提高效率的决心是一致的。下面是我的 slides ，下载地
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
      <category term="LLVM" scheme="http://ming1016.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>用 Swift 编写的工程代码静态分析命令行工具 smck</title>
    <link href="http://ming1016.github.io/2017/04/01/build-static-analysis-program-smck-use-swift/"/>
    <id>http://ming1016.github.io/2017/04/01/build-static-analysis-program-smck-use-swift/</id>
    <published>2017-04-01T14:00:31.000Z</published>
    <updated>2017-10-11T03:15:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几周在用 swift 做一个命令行工具 smck 用来对现有 OC 工程的代码做些分析和处理。日后工程切换成 Swift 可以加上对 Swift 工程代码的支持。昨天看到喵神在微博上说他下周要直播 live coding 一个 swift 的命令行工具，传送门： <a href="http://m.quzhiboapp.com/?liveId=391&amp;fromUserId=12049#!/intro/391" target="_blank" rel="external">现场编程 - 用 Swift 创建命令行工具 fengniao-cli Part1</a> ，其实蛮期待。想想跟喵神挺有缘的，最近下了他开发的 iOS 应用 Mail Me，随时能够记录工作和准备讲座时一些灵感，smck 的一些实现还有模块的设计灵感也是通过这个应用随时记录了下来呢，所以也推荐大家使用，真心方便。还有先前 Segmentfault 邀请我这个月31号在他们的直播平台上做个讲座，传送门： <a href="https://segmentfault.com/l/1500000008514518" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM - 戴铭 - SegmentFault 讲堂</a> ，先前写过一篇文章，直播可能更利于演示和详细说明一些细节吧。看来这段时间我要跟喵神做好多类似的事情了。smck 的代码今天已经放到了 Github 上，地址：<a href="https://github.com/ming1016/smck" target="_blank" rel="external">https://github.com/ming1016/smck</a></p>
<h2 id="smck-可以做哪些事情呢？"><a href="#smck-可以做哪些事情呢？" class="headerlink" title="smck 可以做哪些事情呢？"></a>smck 可以做哪些事情呢？</h2><ul>
<li>简单的比如命名规则的检查，按照团队标准来，如所有继承 UIViewController 的命名末尾统一成 VC，继承 JSONModel 的命名末尾统一成 Model，还有特定功能基类的子类按照一定的命名规则来。</li>
<li>再比如查找所有中文字符串列出每个字符串分别使用在哪个控件上。</li>
<li>根据类是否被初始化或直接调用等规则检查来分析哪些类从来没有调用过来判断是否是没有用的类。</li>
<li>对工程质量的检查，比如 NSString，block，NSArray 的属性检查否是为 copy，还有 protocol 是否为 weak，Array 的操作是否使用具有安全操作的 Category 来做等等。<br>当然需要检查分析和处理的肯定不止这些，所以在 smck 这个程序设计成了一种非常利于添加各种检查功能模块的结构，通过简单的代码编写每个人或团队都可以方便编写添加各种 checker。</li>
</ul>
<h2 id="是怎么做到简单编写就能够添加功能呢？"><a href="#是怎么做到简单编写就能够添加功能呢？" class="headerlink" title="是怎么做到简单编写就能够添加功能呢？"></a>是怎么做到简单编写就能够添加功能呢？</h2><p>因为代码分析的过程会通过一系列已经编写好的 parser 来完成，parser 会完成 token 的分析和上下文还有工程全局分析输出所有节点的数据信息，根据这些完整的信息和已经定义好的一系列具有完整包含关系的结构体就能够进行各种各样功能的定制化了。下面是一些 parser 和功能介绍：</p>
<p><img src="https://github.com/ming1016/smck/blob/master/README/5.png?raw=true" alt="parser"></p>
<ul>
<li>ParsingMethod.swift ：会返回 Method 结构体，包含了方法名，各个参数，方法内使用过的方法，方法内定义的临时变量等信息。</li>
<li>ParsingMethodContent.swift ：会分析方法内的 token 根据语法形成数组结构进行处理。这里需要处理的东西很多，目前还在根据计划添加更多的数据输出。</li>
<li>ParsingMacro.swift ：处理宏定义，主要是输出 token 给其它 parser 来处理。</li>
<li>ParsingImport.swift ：返回 Import 结构体，包含引入的类名，包名</li>
<li>ParsingProperty.swift ：会分析定义的属性 Property 信息</li>
<li>ParsingInterface.swift ：会根据这个分析出一个文件中定义了多少各类，类的结构体 Object 里类名，父类名，类别名会在这里解析出。</li>
<li>ParsingProtocol.swift ：会将分析出的协议设置到 Object 结构体中。</li>
<li>ParsingObject.swift ： 目前主要是分析出使用过的类的信息。</li>
</ul>
<p>生成的 File 结构体里面套装各个子结构体，断点如图：<br><img src="https://github.com/ming1016/smck/blob/master/README/6.png?raw=true" alt="结构体"></p>
<h2 id="如何调试-smck？"><a href="#如何调试-smck？" class="headerlink" title="如何调试 smck？"></a>如何调试 smck？</h2><p>先填上对应的命令行参数和值，设置参数参考下图。然后运行即可。<br><img src="https://github.com/ming1016/smck/blob/master/README/2.png?raw=true" alt="命令行参数"></p>
<h2 id="导出成命令行工具"><a href="#导出成命令行工具" class="headerlink" title="导出成命令行工具"></a>导出成命令行工具</h2><p>在 Xcode 里选择 Product - Archive - Export 即可，如图：<br><img src="https://github.com/ming1016/smck/blob/master/README/3.png?raw=true" alt="导出"><br>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./smck -o /User/your_project_path</div></pre></td></tr></table></figure></p>
<p>输出如下<br><img src="https://github.com/ming1016/smck/blob/master/README/4.png?raw=true" alt="执行效果"></p>
<h2 id="如何编写自己的检查功能？"><a href="#如何编写自己的检查功能？" class="headerlink" title="如何编写自己的检查功能？"></a>如何编写自己的检查功能？</h2><p>由于工程检查规则非常多样化，所以需要编写一些 Plugin，后面我会逐渐抽出一些具有共性的放上来，目前在 Plugin 目录下我放了两个例子，在例子里可以看出来怎么通过订阅 Parser 输出的不同节点的不同数据来进行不同的检查。在控制台管理相关的 Checker 类里关联 Parser 和 Plugin 的代码由于使用了 RxSwift 也变得非常简洁明了，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doO</span><span class="params">(path:String)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> path.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="type">UnUseObjectPlugin</span>().plug(ob: <span class="type">ParsingEntire</span>.parsing(path: path))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近几周在用 swift 做一个命令行工具 smck 用来对现有 OC 工程的代码做些分析和处理。日后工程切换成 Swift 可以加上对 S
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="smck" scheme="http://ming1016.github.io/tags/smck/"/>
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 iOS 编译 Clang / LLVM 直播的 Slides</title>
    <link href="http://ming1016.github.io/2017/04/01/slides-of-deeply-analyse-llvm/"/>
    <id>http://ming1016.github.io/2017/04/01/slides-of-deeply-analyse-llvm/</id>
    <published>2017-04-01T10:27:46.000Z</published>
    <updated>2018-01-10T07:32:38.808Z</updated>
    
    <content type="html"><![CDATA[<p>这次直播主要是针对上篇文章：<a href="https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang---LLVM" target="_blank" rel="external">https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang—LLVM</a> 做了些补充，一些不容易用文字表达的知识点做了些详细的说明，同时现场做了些代码和操作的演示。</p>
<p>直播地址：<a href="https://segmentfault.com/l/1500000008514518" target="_blank" rel="external">https://segmentfault.com/l/1500000008514518</a></p>
<p>PPT 下载地址：<a href="https://pan.baidu.com/s/1dFkoaIl" target="_blank" rel="external">https://pan.baidu.com/s/1dFkoaIl</a></p>
<p>下面我贴出 PPT 内容</p>
<p><img src="/uploads/slides-of-deeply-analyse-llvm/1.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/2.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/3.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/4.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/5.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/6.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/7.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/8.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/9.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/10.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/11.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/12.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/13.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/14.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/15.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/16.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/17.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/18.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/19.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/20.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/21.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/22.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/23.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/24.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/25.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/26.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/27.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/28.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/29.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/30.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/31.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/32.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/33.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/34.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/35.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/36.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/37.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/38.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/39.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/40.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/41.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/42.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/43.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/44.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/45.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/46.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/47.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/48.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/49.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/50.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/51.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/52.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/53.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/54.png" alt=""><br><img src="/uploads/slides-of-deeply-analyse-llvm/55.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次直播主要是针对上篇文章：&lt;a href=&quot;https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang---LLVM&quot; t
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
      <category term="LLVM" scheme="http://ming1016.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 iOS 编译 Clang / LLVM</title>
    <link href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/"/>
    <id>http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/</id>
    <published>2017-03-01T13:58:09.000Z</published>
    <updated>2017-10-11T03:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter <a href="https://twitter.com/clattner_llvm" target="_blank" rel="external">@clattner_llvm</a> ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p>
<p>Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。</p>
<p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</p>
<p>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</p>
<p>LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是  Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。</p>
<p>LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。</p>
<p>LLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</p>
<p>这里是 Clang 官方详细文档： <a href="http://clang.llvm.org/docs/" target="_blank" rel="external">Welcome to Clang’s documentation! — Clang 4.0 documentation</a></p>
<p>这篇是对 LLVM 架构的一个概述： <a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">The Architecture of Open Source Applications</a></p>
<p>将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 <a href="https://book.douban.com/subject/1436811/" target="_blank" rel="external">《linkers and loaders》</a> 这本书就知道了。</p>
<h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><p>在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#define DEFINEEight 8</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int eight = DEFINEEight;</div><div class="line">        int six = 6;</div><div class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</div><div class="line">        int rank = eight + six;</div><div class="line">        NSLog(@“%@ rank %d”, site, rank);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -ccc-print-phases main.m</div></pre></td></tr></table></figure></p>
<p>可以看到编译源文件需要的几个不同的阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: input, “main.m”, objective-c</div><div class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</div><div class="line">2: compiler, &#123;1&#125;, ir</div><div class="line">3: backend, &#123;2&#125;, assembler</div><div class="line">4: assembler, &#123;3&#125;, object</div><div class="line">5: linker, &#123;4&#125;, image</div><div class="line">6: bind-arch, “x86_64”, &#123;5&#125;, image</div></pre></td></tr></table></figure></p>
<p>这样能够了解到过程和重要的信息。<br>查看oc的c实现可以使用如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m</div></pre></td></tr></table></figure></p>
<p>查看操作内部命令，可以使用 -### 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -### main.m -o main</div></pre></td></tr></table></figure></p>
<p>想看清clang的全部过程，可以先通过-E查看clang在预编译处理这步做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -E main.m</div></pre></td></tr></table></figure></p>
<p>执行完后可以看到文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 1 “/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h” 1 3</div><div class="line"># 185 “/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h” 2 3</div><div class="line"># 2 “main.m” 2</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int eight = 8;</div><div class="line">        int six = 6;</div><div class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</div><div class="line">        int rank = eight + six;</div><div class="line">        NSLog(@“%@ rank %d”, site, rank);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个过程的处理包括宏的替换，头文件的导入。下面这些代码也会在这步处理。</p>
<ul>
<li>“#define”</li>
<li>“#include”</li>
<li>“#indef”</li>
<li>注释</li>
<li>“#pragma”</li>
</ul>
<p>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p>
<p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p>
<p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="external">Writing an LLVM Pass — LLVM 5 documentation</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</p>
<p>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure></p>
<p>生成汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure></p>
<p>生成目标文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure></p>
<p>生成可执行文件，这样就能够执行看到输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">clang main.o -o main</div><div class="line">执行</div><div class="line">./main</div><div class="line">输出</div><div class="line">starming rank 14</div></pre></td></tr></table></figure></p>
<p>下面是完整步骤：</p>
<ul>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ul>
<h1 id="Clang-编译-m-文件"><a href="#Clang-编译-m-文件" class="headerlink" title="Clang 编译 .m 文件"></a>Clang 编译 .m 文件</h1><p>在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。</p>
<p>具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CompileC DerivedData path/AFSecurityPolicy.o AFNetworking/AFNetworking/AFSecurityPolicy.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</div></pre></td></tr></table></figure></p>
<p>接下来对会更新工作路径，同时设置 PATH<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods</div><div class="line">    export LANG=en_US.US-ASCII</div><div class="line">    export PATH=“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin”</div></pre></td></tr></table></figure></p>
<p>接下来就是实际的编译命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o</div></pre></td></tr></table></figure></p>
<p>clang 命令参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-x 编译语言比如objective-c</div><div class="line">-arch 编译的架构，比如arm7</div><div class="line">-f 以-f开头的。</div><div class="line">-W 以-W开头的，可以通过这些定制编译警告</div><div class="line">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</div><div class="line">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</div><div class="line">-I 把编译信息写入指定的辅助文件</div><div class="line">-F 需要的Framework</div><div class="line">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</div><div class="line">-o 编译结果</div></pre></td></tr></table></figure></p>
<h2 id="构建-Target"><a href="#构建-Target" class="headerlink" title="构建 Target"></a>构建 Target</h2><p>编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Create product structure</div><div class="line">Process product packaging</div><div class="line">Run custom shell script ‘Check Pods Manifest.lock’</div><div class="line">Compile … 各个项目中的.m文件</div><div class="line">Link /Users/… 路径</div><div class="line">Copy … 静态文件</div><div class="line">Compile asset catalogs</div><div class="line">Compile Storyboard file …</div><div class="line">Process info.plist</div><div class="line">Link Storyboards</div><div class="line">Run custom shell script ‘Embed Pods Frameworks’</div><div class="line">Run custom shell script ‘Copy Pods Resources’</div><div class="line">…</div><div class="line">Touch GCDFetchFeed.app</div><div class="line">Sign GCDFetchFeed.app</div></pre></td></tr></table></figure></p>
<p>从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。</p>
<h2 id="Target-在-Build-过程的控制"><a href="#Target-在-Build-过程的控制" class="headerlink" title="Target 在 Build 过程的控制"></a>Target 在 Build 过程的控制</h2><p>在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。</p>
<h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。</p>
<p>在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。</p>
<p>build phase 还会把静态资源拷贝到 bundle 里。</p>
<p>可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。</p>
<h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>在 build 的过程中各个阶段的选项的设置。</p>
<h3 id="pbxproj工程文件"><a href="#pbxproj工程文件" class="headerlink" title="pbxproj工程文件"></a>pbxproj工程文件</h3><p>build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rootObject = 3EE311301C4E1F0800103FA3 /* Project object */;</div></pre></td></tr></table></figure></p>
<p>然后根据这个 ID 找到 main 工程的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Begin PBXProject section */</div><div class="line">		3EE311301C4E1F0800103FA3 /* Project object */ = &#123;</div><div class="line">			isa = PBXProject;</div><div class="line">			…</div><div class="line">/* End PBXProject section */</div></pre></td></tr></table></figure></p>
<p>在 targets 里会指向各个 taget 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">targets = (</div><div class="line">	3EE311371C4E1F0800103FA3 /* GCDFetchFeed */,</div><div class="line">	3EE311501C4E1F0800103FA3 /* GCDFetchFeedTests */,</div><div class="line">	3EE3115B1C4E1F0800103FA3 /* GCDFetchFeedUITests */,</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">3EE311371C4E1F0800103FA3 /* GCDFetchFeed */ = &#123;</div><div class="line">	isa = PBXNativeTarget;</div><div class="line">	buildConfigurationList = 3EE311651C4E1F0800103FA3 /* configuration list for PBXNativeTarget “GCDFetchFeed” </div><div class="line">	buildPhases = (</div><div class="line">		9527AA01F4AAE11E18397E0C /* Check Pods st.lock */,</div><div class="line">		3EE311341C4E1F0800103FA3 /* Sources */,</div><div class="line">		3EE311351C4E1F0800103FA3 /* Frameworks */,</div><div class="line">		3EE311361C4E1F0800103FA3 /* Resources */,</div><div class="line">		C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks </div><div class="line">		DD33A716222617FAB49F1472 /* Copy Pods Resources </div><div class="line">	);</div><div class="line">	buildRules = (</div><div class="line">	);</div><div class="line">	dependencies = (</div><div class="line">	);</div><div class="line">	name = GCDFetchFeed;</div><div class="line">	productName = GCDFetchFeed;</div><div class="line">	productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */;</div><div class="line">	productType = “com.apple.product-type.application”;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。</p>
<p>接下来详细的看看 Clang 所做的事情吧。</p>
<h1 id="Clang-Static-Analyzer静态代码分析"><a href="#Clang-Static-Analyzer静态代码分析" class="headerlink" title="Clang Static Analyzer静态代码分析"></a>Clang Static Analyzer静态代码分析</h1><p>可以在 <a href="https://code.woboq.org/llvm/clang/" target="_blank" rel="external">llvm/clang/ Source Tree - Woboq Code Browser</a> 上查看 Clang 的代码。</p>
<p>Youtube上一个教程：<a href="https://www.youtube.com/watch?time_continue=280&amp;v=VqCkCDFLSsc" target="_blank" rel="external">The Clang AST - a Tutorial - YouTube</a><br>CMU关于llvm的教案 <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/" target="_blank" rel="external">http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/</a></p>
<p>静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 <a href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def" target="_blank" rel="external">TokensKind.def</a> 里有 Clang 定义的所有 Token。Token 可以分为以下几类</p>
<ul>
<li>关键字：语法中的关键字，if else while for 等。</li>
<li>标识符：变量名</li>
<li>字面量：值，数字，字符串</li>
<li>特殊符号：加减乘除等符号</li>
</ul>
<p>通过下面的命令可以输出所有 token 和所在文件具体位置，命令如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -E -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p>
<p>可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=<main.m:11:1> 这个样的具体位置。</main.m:11:1></p>
<p>接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。</p>
<p>打个比方，如果遇到 token 是 = 符号进行赋值的处理，遇到加减乘除就先处理乘除，然后处理加减，这些组合经过嵌套后会生成一个语法数的结构。这个过程完成后会进行赋值操作时类型是不是匹配的处理。</p>
<p>打印语法树的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p>
<p>TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。</p>
<p>clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。</p>
<p>可以通过 clang —analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib / StaticAnalyzer / Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">debug.ConfigDumper              Dump config table</div><div class="line">debug.DumpCFG                   Display Control-Flow Graphs</div><div class="line">debug.DumpCallGraph             Display Call Graph</div><div class="line">debug.DumpCalls                 Print calls as they are traversed by the engine</div><div class="line">debug.DumpDominators            Print the dominance tree for a given CFG</div><div class="line">debug.DumpLiveVars              Print results of live variable analysis</div><div class="line">debug.DumpTraversal             Print branch conditions as they are traversed by the engine</div><div class="line">debug.ExprInspection            Check the analyzer&apos;s understanding of expressions</div><div class="line">debug.Stats                     Emit warnings with analyzer statistics</div><div class="line">debug.TaintTest                 Mark tainted symbols as such.</div><div class="line">debug.ViewCFG                   View Control-Flow Graphs using GraphViz</div><div class="line">debug.ViewCallGraph             View Call Graph using GraphViz</div><div class="line">debug.ViewExplodedGraph         View Exploded Graphs using GraphViz</div></pre></td></tr></table></figure>
<p>这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。</p>
<p>clang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。</p>
<p>编译的概念（词法-&gt;语法-&gt;语义-&gt;IR-&gt;优化-&gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。</p>
<p>clang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。</p>
<p>整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：<a href="http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf" target="_blank" rel="external">http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf</a> 在clang里的具体实现代码可以查看这两个文件 <a href="https://code.woboq.org/llvm/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h.html" target="_blank" rel="external">MemRegion.h</a>和 <a href="https://code.woboq.org/llvm/clang/lib/StaticAnalyzer/Core/RegionStore.cpp.html" target="_blank" rel="external">RegionStore.cpp</a> 。</p>
<p>下面举个简单例子看看 clang static  analyzer 是如何对源码进行模拟的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</div><div class="line">	a = b;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的 AST 以及 CFG</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#————————AST—————————</div><div class="line"># clang -cc1 -ast-dump</div><div class="line">TranslationUnitDecl 0xc75b450 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</div><div class="line">|-TypedefDecl 0xc75b740 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list ‘char *’</div><div class="line">`-FunctionDecl 0xc75b7b0 &lt;test.cpp:1:1, line:7:1&gt; line:1:5 main ‘int (void)’</div><div class="line">  `-CompoundStmt 0xc75b978 &lt;line:2:1, line:7:1&gt;</div><div class="line">    |-DeclStmt 0xc75b870 &lt;line:3:2, col:7&gt;</div><div class="line">    | `-VarDecl 0xc75b840 &lt;col:2, col:6&gt; col:6 used a ‘int’</div><div class="line">    |-DeclStmt 0xc75b8d8 &lt;line:4:2, col:12&gt;</div><div class="line">    | `-VarDecl 0xc75b890 &lt;col:2, col:10&gt; col:6 used b ‘int’ cinit</div><div class="line">    |   `-IntegerLiteral 0xc75b8c0 &lt;col:10&gt; ‘int’ 10</div><div class="line"></div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; a = b &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">    |-BinaryOperator 0xc75b928 &lt;line:5:2, col:6&gt; ‘int’ lvalue ‘=‘</div><div class="line">    | |-DeclRefExpr 0xc75b8e8 &lt;col:2&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</div><div class="line">    | `-ImplicitCastExpr 0xc75b918 &lt;col:6&gt; ‘int’ &lt;LValueToRValue&gt;</div><div class="line">    |   `-DeclRefExpr 0xc75b900 &lt;col:6&gt; ‘int’ lvalue Var 0xc75b890 ‘b’ ‘int’</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line"></div><div class="line">    `-ReturnStmt 0xc75b968 &lt;line:6:2, col:9&gt;</div><div class="line">      `-ImplicitCastExpr 0xc75b958 &lt;col:9&gt; ‘int’ &lt;LValueToRValue&gt;</div><div class="line">        `-DeclRefExpr 0xc75b940 &lt;col:9&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</div><div class="line">#————————CFG—————————</div><div class="line"># clang -cc1 -analyze -analyzer-checker=debug.DumpCFG</div><div class="line">int main()</div><div class="line"> [B2 (ENTRY)]</div><div class="line">   Succs (1): B1</div><div class="line"></div><div class="line"> [B1]</div><div class="line">   1: int a;</div><div class="line">   2: 10</div><div class="line">   3: int b = 10;</div><div class="line">   4: b</div><div class="line">   5: [B1.4] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">   6: a</div><div class="line">   7: [B1.6] = [B1.5]</div><div class="line">   8: a</div><div class="line">   9: [B1.8] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">  10: return [B1.9];</div><div class="line">   Preds (1): B2</div><div class="line">   Succs (1): B0</div><div class="line"></div><div class="line"> [B0 (EXIT)]</div><div class="line">   Preds (1): B1</div></pre></td></tr></table></figure>
<p>CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。</p>
<p>在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。</p>
<p>官方 AST 相关文档</p>
<ul>
<li><a href="http://clang.llvm.org/docs/Tooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/Tooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="external">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></li>
<li><a href="http://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="external">http://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibTooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibTooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibASTMatchers.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibASTMatchers.html</a></li>
</ul>
<p>静态检查的一些库以及使用方法</p>
<ul>
<li><a href="https://github.com/DeveloperLx/FauxPas_document_translation/blob/master/README.md?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">FauxPas_document_translation/README.md at master · DeveloperLx/FauxPas_document_translation · GitHub</a></li>
</ul>
<h1 id="CodeGen-生成-IR-代码"><a href="#CodeGen-生成-IR-代码" class="headerlink" title="CodeGen 生成 IR 代码"></a>CodeGen 生成 IR 代码</h1><p>将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。</p>
<p>这个过程中还会跟 runtime 桥接。</p>
<ul>
<li>各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。</li>
<li>Non-Fragile ABI 合成 OBJC<em>IVAR</em>$_ 偏移值常量。</li>
<li>ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。</li>
<li>strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。</li>
<li>@synthesize 的处理。</li>
<li>生成 block_layout 数据结构</li>
<li><strong>block 和 </strong>weak</li>
<li>_block_invoke</li>
<li>ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。</li>
</ul>
<p>不管编译的语言时 Objective-C 还是 Swift 也不管对应机器是什么，亦或是即时编译，LLVM 里唯一不变的是中间语言 LLVM IR。那么我们就来看看如何玩 LLVM IR。</p>
<h2 id="IR-结构"><a href="#IR-结构" class="headerlink" title="IR 结构"></a>IR 结构</h2><p>下面是刚才生成的 main.ll 中间代码文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">; ModuleID = ‘main.c’</div><div class="line">source_filename = “main.c”</div><div class="line">target datalayout = “e-m:o-i64:64-f80:128-n8:16:32:64-S128”</div><div class="line">target triple = “x86_64-apple-macosx10.12.0”</div><div class="line"></div><div class="line">@.str = private unnamed_addr constant [16 x i8] c”Please input a:\00”, align 1</div><div class="line">@.str.1 = private unnamed_addr constant [3 x i8] c”%d\00”, align 1</div><div class="line">@.str.2 = private unnamed_addr constant [16 x i8] c”Please input b:\00”, align 1</div><div class="line">@.str.3 = private unnamed_addr constant [32 x i8] c”a is:%d,b is :%d,count equal:%d\00”, align 1</div><div class="line"></div><div class="line">; Function Attrs: nounwind ssp uwtable</div><div class="line">define i32 @main() #0 &#123;</div><div class="line">  %1 = alloca i32, align 4</div><div class="line">  %2 = alloca i32, align 4</div><div class="line">  %3 = bitcast i32* %1 to i8*</div><div class="line">  call void @llvm.lifetime.start(i64 4, i8* %3) #3</div><div class="line">  %4 = bitcast i32* %2 to i8*</div><div class="line">  call void @llvm.lifetime.start(i64 4, i8* %4) #3</div><div class="line">  %5 = tail call i32 (i8*, …) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i64 0, i64 0))</div><div class="line">  %6 = call i32 (i8*, …) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %1)</div><div class="line">  %7 = call i32 (i8*, …) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i64 0, i64 0))</div><div class="line">  %8 = call i32 (i8*, …) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %2)</div><div class="line">  %9 = load i32, i32* %1, align 4, !tbaa !2</div><div class="line">  %10 = load i32, i32* %2, align 4, !tbaa !2</div><div class="line">  %11 = add nsw i32 %10, %9</div><div class="line">  %12 = call i32 (i8*, …) @printf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3, i64 0, i64 0), i32 %9, i32 %10, i32 %11)</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* %4) #3</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* %3) #3</div><div class="line">  ret i32 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">; Function Attrs: argmemonly nounwind</div><div class="line">declare void @llvm.lifetime.start(i64, i8* nocapture) #1</div><div class="line"></div><div class="line">; Function Attrs: nounwind</div><div class="line">declare i32 @printf(i8* nocapture readonly, …) #2</div><div class="line"></div><div class="line">; Function Attrs: nounwind</div><div class="line">declare i32 @scanf(i8* nocapture readonly, …) #2</div><div class="line"></div><div class="line">; Function Attrs: argmemonly nounwind</div><div class="line">declare void @llvm.lifetime.end(i64, i8* nocapture) #1</div><div class="line"></div><div class="line">attributes #0 = &#123; nounwind ssp uwtable “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” &#125;</div><div class="line">attributes #1 = &#123; argmemonly nounwind &#125;</div><div class="line">attributes #2 = &#123; nounwind “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” &#125;</div><div class="line">attributes #3 = &#123; nounwind &#125;</div><div class="line"></div><div class="line">!llvm.module.flags = !&#123;!0&#125;</div><div class="line">!llvm.ident = !&#123;!1&#125;</div><div class="line"></div><div class="line">!0 = !&#123;i32 1, !”PIC Level”, i32 2&#125;</div><div class="line">!1 = !&#123;!”Apple LLVM version 8.0.0 (clang-800.0.42.1)”&#125;</div><div class="line">!2 = !&#123;!3, !3, i64 0&#125;</div><div class="line">!3 = !&#123;!”int”, !4, i64 0&#125;</div><div class="line">!4 = !&#123;!”omnipotent char”, !5, i64 0&#125;</div><div class="line">!5 = !&#123;!”Simple C/C++ TBAA”&#125;</div></pre></td></tr></table></figure></p>
<p>LLVM IR 有三种表示格式，第一种是 bitcode 这样的存储格式，以 .bc 做后缀，第二种是可读的以 .ll，第三种是用于开发时操作 LLVM IR 的内存格式。</p>
<p>一个编译的单元即一个文件在 IR 里就是一个 Module，Module 里有 Global Variable 和 Function，在 Function里有 Basic Block，Basic Block 里有 指令 Instructions。<br>‘</p>
<p>通过下面的 IR 结构图能够更好的理解 IR 的整体结构。</p>
<p><img src="/uploads/deeply-analyse-llvm/08.png" alt=""></p>
<p>图中可以看出最大的是 Module，里面包含多个 Function，每个 Function 包含多个 BasicBlock，BasicBlock 里含有 Instruction，代码非常清晰，这样如果想开发一个新语言只需要完成语法解析后通过 LLVM 提供的丰富接口在内存中生成 IR 就可以直接运行在各个不同的平台。</p>
<p>IR 语言满足静态单赋值，可以很好的降低数据流分析和控制流分析的复杂度。及只能在定义时赋值，后面不能更改。但是这样就没法写程序了，输入输出都没法弄，所以函数式编程才会有类似 Monad 这样机制的原因。</p>
<h2 id="LLVM-IR-优化"><a href="#LLVM-IR-优化" class="headerlink" title="LLVM IR 优化"></a>LLVM IR 优化</h2><p>使用 O2，O3 这样的优化会调用对应的 Pass 来进行处理，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。可以通过 llvm-opt 调用 LLVM 优化相关的库。</p>
<p>可能直接这么说不太直观，我们可以更改下原 c 代码举个小例子看看这些 Pass 会做哪些优化。当我们加上<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</div><div class="line">    i++;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的 IR 代码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">%call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 1)</div><div class="line">%call4.1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 2)</div><div class="line">%call4.2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 3)</div><div class="line">%call4.3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 4)</div><div class="line">%call4.4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 5)</div><div class="line">%call4.5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 6)</div><div class="line">%call4.6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 7)</div><div class="line">%call4.7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 8)</div><div class="line">%call4.8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 9)</div><div class="line">%call4.9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 10)</div></pre></td></tr></table></figure></p>
<p>可以看出来这个 while 在 IR 中就是重复的打印了10次，那要是我把10改成100是不是会变成打印100次呢？</p>
<p>我们改成100后，再次生成 IR 可以看到 IR 变成了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  br label %while.body</div><div class="line"></div><div class="line">while.body:                                       ; preds = %while.body, %entry</div><div class="line">  %i.010 = phi i32 [ 0, %entry ], [ %inc, %while.body ]</div><div class="line">  %inc = add nuw nsw i32 %i.010, 1</div><div class="line">  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 %inc)</div><div class="line">  %exitcond = icmp eq i32 %inc, 100</div><div class="line">  br i1 %exitcond, label %while.end, label %while.body</div><div class="line"></div><div class="line">while.end:                                        ; preds = %while.body</div><div class="line">  %2 = load i32, i32* %a, align 4, !tbaa !2</div><div class="line">  %3 = load i32, i32* %b, align 4, !tbaa !2</div><div class="line">  %add = add nsw i32 %3, %2</div><div class="line">  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3, i64 0, i64 0), i32 %add)</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* nonnull %1) #3</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* nonnull %0) #3</div><div class="line">  ret i32 0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里对不同条件生成的不同都是 Pass 优化器做的事情。解读上面这段 IR 需要先了解下 IR 语法关键字，如下：</p>
<ul>
<li>@ - 代表全局变量</li>
<li>% - 代表局部变量</li>
<li>alloca - 指令在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存。</li>
<li>i32：- i 是几这个整数就会占几位，i32就是32位4字节</li>
<li>align - 对齐，比如一个 int,一个 char 和一个 int。单个 int 占4个字节，为了对齐只占一个字节的 char需要向4对齐占用4字节空间。</li>
<li>Load - 读出，store 写入</li>
<li>icmp - 两个整数值比较，返回布尔值</li>
<li>br - 选择分支，根据 cond 来转向 label，不根据条件跳转的话类似 goto</li>
<li>indirectbr - 根据条件间接跳转到一个 label，而这个 label 一般是在一个数组里，所以跳转目标是可变的，由运行时决定的</li>
<li>label - 代码标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">br label %while.body</div></pre></td></tr></table></figure>
<p>如上面表述，br  会选择跳向 while.body 定义的这个标签。这个标签里可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%exitcond = icmp eq i32 %inc, 100</div><div class="line">  br i1 %exitcond, label %while.end, label %while.body</div></pre></td></tr></table></figure></p>
<p>这段，icmp 会比较当前的 %inc 和定义的临界值 100，根据返回的布尔值来决定 br 跳转到那个代码标签，真就跳转到 while.end 标签，否就在进入 while.body 标签。这就是 while 的逻辑。通过br 跳转和 label 这种标签的概念使得 IR 语言能够成为更低级兼容性更高更方便转向更低级语言的语言。</p>
<h2 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h2><p>LLVM IR 是 SSA 形式的，维护双向 def-use 信息，use-def 是通过普通指针实现信息维护，def-use 是通过内存跳表和链表来实现的，便于 forward dataflow analysis 和 backward dataflow analysis。可以通过 ADCE 这个 Pass 来了解下 backward dataflow，这个pass 的源文件在 lib/Transforms/Scalar/ADCE.cpp 中，ADCE 实现了 Aggressive Dead Code Elimination Pass。这个 Pass 乐观地假设所有 instructions 都是 Dead 直到证明是否定的，允许它消除其他 DCE Pass 的 Dead 计算 catch，特别是涉及循环计算。其它 DCE 相关的 Pass 可以查看同级目录下的 BDCE.cpp 和 DCE.cpp，目录下其它的 Pass 都是和数据流相关的分析包含了各种分析算法和思路。</p>
<p>那么看看加法这个操作的相关的 IR 代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%2 = load i32, i32* %a, align 4, !tbaa !2</div><div class="line">%3 = load i32, i32* %b, align 4, !tbaa !2</div><div class="line">%add = add nsw i32 %3, %2</div></pre></td></tr></table></figure></p>
<p>加法对应的指令是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BinaryOperator::CreateAdd(Value *V1, Value *V2, <span class="keyword">const</span> Twine &amp;Name)</div></pre></td></tr></table></figure></p>
<p>两个输入 V1 和 V2 的 def-use 是如何的呢，看看如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">class Value &#123;</div><div class="line">  void addUse(Use &amp;U) &#123; U.addToList(&amp;UseList); &#125;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Use &#123;</div><div class="line">  Value *Val;</div><div class="line">  Use *Next;</div><div class="line">  PointerIntPair&lt;Use **, 2, PrevPtrTag&gt; Prev;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void Use::set(Value *V) &#123;</div><div class="line">  if (Val) removeFromList();</div><div class="line">  Val = V;</div><div class="line">  if (V) V-&gt;addUse(*this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Value *Use::operator=(Value *RHS) &#123;</div><div class="line">  set(RHS);</div><div class="line">  return RHS;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class User : public Value &#123;</div><div class="line">  template &lt;int Idx, typename U&gt; static Use &amp;OpFrom(const U *that) &#123;</div><div class="line">    return Idx &lt; 0</div><div class="line">      ? OperandTraits&lt;U&gt;::op_end(const_cast&lt;U*&gt;(that))[Idx]</div><div class="line">      : OperandTraits&lt;U&gt;::op_begin(const_cast&lt;U*&gt;(that))[Idx];</div><div class="line">  &#125;</div><div class="line">  template &lt;int Idx&gt; Use &amp;Op() &#123;</div><div class="line">    return OpFrom&lt;Idx&gt;(this);</div><div class="line">  &#125;</div><div class="line">  template &lt;int Idx&gt; const Use &amp;Op() const &#123;</div><div class="line">    return OpFrom&lt;Idx&gt;(this);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Instruction : public User,</div><div class="line">                    public ilist_node_with_parent&lt;Instruction, BasicBlock&gt; &#123;</div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class BinaryOperator : public Instruction &#123;</div><div class="line">  /// Construct a binary instruction, given the opcode and the two</div><div class="line">  /// operands.  Optionally (if InstBefore is specified) insert the instruction</div><div class="line">  /// into a BasicBlock right before the specified instruction.  The specified</div><div class="line">  /// Instruction is allowed to be a dereferenced end iterator.</div><div class="line">  ///</div><div class="line">  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,</div><div class="line">                                const Twine &amp;Name = Twine(),</div><div class="line">                                Instruction *InsertBefore = nullptr);</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">BinaryOperator::BinaryOperator(BinaryOps iType, Value *S1, Value *S2,</div><div class="line">                               Type *Ty, const Twine &amp;Name,</div><div class="line">                               Instruction *InsertBefore)</div><div class="line">  : Instruction(Ty, iType,</div><div class="line">                OperandTraits&lt;BinaryOperator&gt;::op_begin(this),</div><div class="line">                OperandTraits&lt;BinaryOperator&gt;::operands(this),</div><div class="line">                InsertBefore) &#123;</div><div class="line">  Op&lt;0&gt;() = S1;</div><div class="line">  Op&lt;1&gt;() = S2;</div><div class="line">  init(iType);</div><div class="line">  setName(Name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">BinaryOperator *BinaryOperator::Create(BinaryOps Op, Value *S1, Value *S2,</div><div class="line">                                       const Twine &amp;Name,</div><div class="line">                                       Instruction *InsertBefore) &#123;</div><div class="line">  assert(S1-&gt;getType() == S2-&gt;getType() &amp;&amp;</div><div class="line">         "Cannot create binary operator with two operands of differing type!");</div><div class="line">  return new BinaryOperator(Op, S1, S2, S1-&gt;getType(), Name, InsertBefore);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码里可以看出是使用了 Use 对象来把 use 和 def 联系起来的。</p>
<p>LLVM IR 通过 mem2reg 这个 Pass 来把局部变量成 SSA 形式。这个 Pass 的代码在 lib/Transforms/Utils/Mem2Reg.cpp 里。LLVM通过 mem2reg Pass 能够识别 alloca 模式，将其设置 SSA value。这时就不在需要 alloca，load和store了。mem2reg 是对 PromoteMemToReg 函数调用的一个简单包装，真正的算法实现是在 PromoteMemToReg 函数里，这个函数在 lib/Transforms/Utils/PromoteMemoryToRegister.cpp 这个文件里。</p>
<p>这个算法会使 alloca 这个仅仅作为 load 和 stores 的用途的指令使用迭代 dominator 边界转换成 PHI 节点，然后通过使用深度优先函数排序重写 loads 和 stores。这种算法叫做 iterated dominance frontier算法，具体实现方法可以参看 PromoteMemToReg 函数的实现。</p>
<p>当然把多个字节码 .bc 合成一个文件，链接时还会优化，IR 结构在优化后会有变化，这样还能够在变化后的 IR 的结构上再进行更多的优化。</p>
<p>这里可以进行 lli 解释执行 LLVM IR。</p>
<p>llc 编译器是专门编译 LLVM IR 的编译器用来生成汇编文件。</p>
<p>调用系统汇编器比如 GNU 的 as 来编译生成 .o Object 文件，接下来就是用链接器链接相关库和 .o 文件一起生成可执行的 .out 或者 exe 文件了。</p>
<p>llvm-mc 还可以直接生成 object 文件。</p>
<h1 id="Clang-CFE"><a href="#Clang-CFE" class="headerlink" title="Clang CFE"></a>Clang CFE</h1><p>动手玩肯定不能少了 Clang 的前端组件及库，熟悉这些库以后就能够自己动手用这些库编写自己的程序了。下面我就对这些库做些介绍，然后再着重说说 libclang 库，以及如何用它来写工具。</p>
<ul>
<li>LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。</li>
<li>The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。</li>
<li>The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。</li>
<li>Precompiled Headers - Clang 支持预编译 headers 的两个实现。</li>
<li>The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。</li>
<li>The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。</li>
<li>The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。</li>
<li>The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。</li>
</ul>
<h2 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h2><p>libclang 会让你觉得 clang 不仅仅只是一个伟大的编译器。下面从解析源码来说下</p>
<p>先写个 libclang 的程序来解析源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">    CXIndex Index = clang_createIndex(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    CXTranslationUnit TU = clang_parseTranslationUnit(Index, <span class="number">0</span>,</div><div class="line">                                                      argv, argc, <span class="number">0</span>, <span class="number">0</span>, CXTranslationUnit_None); <span class="keyword">for</span> (<span class="keyword">unsigned</span> I = <span class="number">0</span>, N = clang_getNumDiagnostics(TU); I != N; ++I) &#123;</div><div class="line">        CXDiagnostic Diag = clang_getDiagnostic(TU, I);</div><div class="line">        CXString String = clang_formatDiagnostic(Diag,clang_defaultDiagnosticDisplayOptions());</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, clang_getCString(String));</div><div class="line">        clang_disposeString(String);</div><div class="line">    &#125;</div><div class="line">    clang_disposeTranslationUnit(TU);</div><div class="line">    clang_disposeIndex(Index);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再写个有问题的 c 程序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span> <span class="comment">/**/</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">union</span> List *L)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure></p>
<p>运行了语法检查后会出现提示信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">list.c:2:9: error: use of <span class="string">'List'</span> with tag <span class="built_in">type</span> that does not match</div><div class="line">      previous declaration</div><div class="line">int sum(union List *Node) &#123;</div><div class="line">^~~~~</div><div class="line">struct</div><div class="line">list.c:1:8: note: previous use is here</div><div class="line">struct List &#123;</div><div class="line">^</div></pre></td></tr></table></figure></p>
<p>下面我们看看诊断过程，显示几个核心诊断方法诊断出问题</p>
<ul>
<li>enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic Diag);</li>
<li>CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic Diag);</li>
<li>CXString clang_getDiagnosticSpelling(CXDiagnostic Diag);</li>
</ul>
<p>接着进行高亮显示，最后提供两个提示修复的方法</p>
<ul>
<li>unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diag);</li>
<li>CXString clang_getDiagnosticFixIt(CXDiagnostic Diag, unsigned FixIt,<br>CXSourceRange *ReplacementRange);</li>
</ul>
<p>我们先遍历语法树的节点。源 c 程序如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> Data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">Next</span>;</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(struct List *Node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (; Node; Node = Node-&gt;Next)</div><div class="line">        result = result + Node-&gt;Data;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先找出所有的声明，比如 List，Data，Next，sum，Node 以及 result 等。再找出引用，比如 struct List *Next 里的 List。还有声明和表达式，比如 int result = 0; 还有 for 语句等。还有宏定义和实例化等。</p>
<p>CXCursor 会统一 AST 的节点，规范包含的信息</p>
<ul>
<li>代码所在位置和长度</li>
<li>名字和符号解析</li>
<li>类型</li>
<li>子节点</li>
</ul>
<p>举个 CXCursor 分析例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> Data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">Next</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>CXCursor 的处理过程如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Top-level cursor C</span></div><div class="line">clang_getCursorKind(C) == CXCursor_StructDecl</div><div class="line">clang_getCursorSpelling(C) == <span class="string">"List"</span> <span class="comment">//获取名字字符串</span></div><div class="line">clang_getCursorLocation(C) <span class="comment">//位置</span></div><div class="line">clang_getCursorExtent(C) <span class="comment">//长度</span></div><div class="line">clang_visitChildren(C, ...); <span class="comment">//访问子节点</span></div><div class="line"></div><div class="line"><span class="comment">//Reference cursor R</span></div><div class="line">clang_getCursorKind(R) == CXCursor_TypeRef </div><div class="line">clang_getCursorSpelling(R) == <span class="string">"List"</span></div><div class="line">clang_getCursorLocation(R)</div><div class="line">clang_getCursorExtent(R)</div><div class="line">clang_getCursorReferenced(R) == C <span class="comment">//指向C</span></div></pre></td></tr></table></figure></p>
<h1 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h1><p>动手玩的话，特别是想要使用这些工具链之前最好先了解我们和 LLVM 交互的实现。那么这部分就介绍下 LLVM 里的 Driver。</p>
<p>Driver 是 Clang 面对用户的接口，用来解析 Option 设置，判断决定调用的工具链，最终完成整个编译过程。</p>
<p>相关源代码在这里：clang/tools/driver/driver.cpp</p>
<p>整个 Driver 源码的入口函数就是 driver.cpp 里的 main() 函数。从这里可以作为入口看看整个  driver 是如何工作的，这样更利于我们以后轻松动手驾驭 LLVM。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc_, <span class="keyword">const</span> <span class="keyword">char</span> **argv_)</span> </span>&#123;</div><div class="line">  llvm::sys::PrintStackTraceOnErrorSignal(argv_[<span class="number">0</span>]);</div><div class="line">  llvm::<span class="function">PrettyStackTraceProgram <span class="title">X</span><span class="params">(argc_, argv_)</span></span>;</div><div class="line">  llvm::llvm_shutdown_obj Y; <span class="comment">// Call llvm_shutdown() on exit.</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (llvm::sys::Process::FixupStandardFileDescriptors())</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">  SmallVector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="number">256</span>&gt; argv;</div><div class="line">  llvm::SpecificBumpPtrAllocator&lt;<span class="keyword">char</span>&gt; ArgAllocator;</div><div class="line">  <span class="built_in">std</span>::error_code EC = llvm::sys::Process::GetArgumentVector(</div><div class="line">      argv, llvm::makeArrayRef(argv_, argc_), ArgAllocator);</div><div class="line">  <span class="keyword">if</span> (EC) &#123;</div><div class="line">    llvm::errs() &lt;&lt; <span class="string">"error: couldn't get arguments: "</span> &lt;&lt; EC.message() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  llvm::InitializeAllTargets();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> ProgName = argv[<span class="number">0</span>];</div><div class="line">  <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; TargetAndMode =</div><div class="line">      ToolChain::getTargetAndModeFromProgramName(ProgName);</div><div class="line"></div><div class="line">  llvm::BumpPtrAllocator A;</div><div class="line">  llvm::<span class="function">StringSaver <span class="title">Saver</span><span class="params">(A)</span></span>;</div><div class="line">	</div><div class="line">	<span class="comment">//省略</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// If we have multiple failing commands, we return the result of the first</span></div><div class="line">  <span class="comment">// failing command.</span></div><div class="line">  <span class="keyword">return</span> Res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Driver-的工作流程图"><a href="#Driver-的工作流程图" class="headerlink" title="Driver 的工作流程图"></a>Driver 的工作流程图</h2><p>在 driver.cpp 的 main 函数里有 Driver 的初始化。我们来看看和 driver 相关的代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">  Driver TheDriver(Path, llvm::sys::getDefaultTargetTriple(), Diags);</div><div class="line">  SetInstallDir(argv, TheDriver, CanonicalPrefixes);</div><div class="line"></div><div class="line">  insertTargetAndModeArgs(TargetAndMode.first, TargetAndMode.second, argv,</div><div class="line">                          SavedStrings);</div><div class="line"></div><div class="line">  SetBackdoorDriverOutputsFromEnvVars(TheDriver);</div><div class="line"></div><div class="line">  std::unique_ptr&lt;Compilation&gt; C(TheDriver.BuildCompilation(argv));</div><div class="line">  int Res = 0;</div><div class="line">  SmallVector&lt;std::pair&lt;int, const Command *&gt;, 4&gt; FailingCommands;</div><div class="line">  if (C.get())</div><div class="line">    Res = TheDriver.ExecuteCompilation(*C, FailingCommands);</div><div class="line"></div><div class="line">  // Force a crash to test the diagnostics.</div><div class="line">  if (::getenv("FORCE_CLANG_DIAGNOSTICS_CRASH")) &#123;</div><div class="line">    Diags.Report(diag::err_drv_force_crash) &lt;&lt; "FORCE_CLANG_DIAGNOSTICS_CRASH";</div><div class="line"></div><div class="line">    // Pretend that every command failed.</div><div class="line">    FailingCommands.clear();</div><div class="line">    for (const auto &amp;J : C-&gt;getJobs())</div><div class="line">      if (const Command *C = dyn_cast&lt;Command&gt;(&amp;J))</div><div class="line">        FailingCommands.push_back(std::make_pair(-1, C));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  for (const auto &amp;P : FailingCommands) &#123;</div><div class="line">    int CommandRes = P.first;</div><div class="line">    const Command *FailingCommand = P.second;</div><div class="line">    if (!Res)</div><div class="line">      Res = CommandRes;</div><div class="line"></div><div class="line">    // If result status is &lt; 0, then the driver command signalled an error.</div><div class="line">    // If result status is 70, then the driver command reported a fatal error.</div><div class="line">    // On Windows, abort will return an exit code of 3.  In these cases,</div><div class="line">    // generate additional diagnostic information if possible.</div><div class="line">    bool DiagnoseCrash = CommandRes &lt; 0 || CommandRes == 70;</div><div class="line">#ifdef LLVM_ON_WIN32</div><div class="line">    DiagnoseCrash |= CommandRes == 3;</div><div class="line">#endif</div><div class="line">    if (DiagnoseCrash) &#123;</div><div class="line">      TheDriver.generateCompilationDiagnostics(*C, *FailingCommand);</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到初始化 Driver 后 driver 会调用 BuildCompilation 生成 Compilation。Compilation 字面意思是合集的意思，通过 driver.cpp 的 include 可以看到<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Driver/Compilation.h"</span></span></div></pre></td></tr></table></figure></p>
<p>根据此路径可以细看下 Compilation 这个为了 driver 设置的一组任务的类。通过这个类我们提取里面这个阶段比较关键的几个信息出来<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compilation</span> &#123;</span></div><div class="line">	<span class="comment">/// The original (untranslated) input argument list.</span></div><div class="line">  llvm::opt::InputArgList *Args;</div><div class="line"></div><div class="line">  <span class="comment">/// The driver translated arguments. Note that toolchains may perform their</span></div><div class="line">  <span class="comment">/// own argument translation.</span></div><div class="line">  llvm::opt::DerivedArgList *TranslatedArgs;</div><div class="line">  <span class="comment">/// The driver we were created by.</span></div><div class="line">  <span class="keyword">const</span> Driver &amp;TheDriver;</div><div class="line"></div><div class="line">  <span class="comment">/// The default tool chain.</span></div><div class="line">  <span class="keyword">const</span> ToolChain &amp;DefaultToolChain;</div><div class="line"> ...</div><div class="line">  <span class="comment">/// The list of actions.  This is maintained and modified by consumers, via</span></div><div class="line">  <span class="comment">/// getActions().</span></div><div class="line">  ActionList Actions;</div><div class="line"></div><div class="line">  <span class="comment">/// The root list of jobs.</span></div><div class="line">  JobList Jobs;</div><div class="line">	...</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	...</div><div class="line">  <span class="function"><span class="keyword">const</span> Driver &amp;<span class="title">getDriver</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> TheDriver; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">const</span> ToolChain &amp;<span class="title">getDefaultToolChain</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DefaultToolChain; &#125;</div><div class="line">	...</div><div class="line">  <span class="function">ActionList &amp;<span class="title">getActions</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Actions; &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> ActionList &amp;<span class="title">getActions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Actions; &#125;</div><div class="line">	...</div><div class="line">  <span class="function">JobList &amp;<span class="title">getJobs</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Jobs; &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> JobList &amp;<span class="title">getJobs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Jobs; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Command&gt; C)</span> </span>&#123; Jobs.addJob(<span class="built_in">std</span>::move(C)); &#125;</div><div class="line">	...</div><div class="line">  <span class="comment">/// ExecuteCommand - Execute an actual command.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param FailingCommand - For non-zero results, this will be set to the</span></div><div class="line">  <span class="comment">/// Command which failed, if any.</span></div><div class="line">  <span class="comment">/// \return The result code of the subprocess.</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command &amp;C, <span class="keyword">const</span> Command *&amp;FailingCommand)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/// ExecuteJob - Execute a single job.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param FailingCommands - For non-zero results, this will be a vector of</span></div><div class="line">  <span class="comment">/// failing commands and their associated result code.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ExecuteJobs</span><span class="params">(</span></span></div><div class="line">      <span class="keyword">const</span> JobList &amp;Jobs,</div><div class="line">      SmallVectorImpl&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">const</span> Command *&gt;&gt; &amp;FailingCommands) <span class="keyword">const</span>;</div><div class="line">	...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过这些关键定义再结合 BuildCompilation 函数的实现可以看出这个 Driver 的流程是按照 ArgList - Actions - Jobs 来的，完整的图如下：</p>
<p><img src="/uploads/deeply-analyse-llvm/04.png" alt=""></p>
<h2 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h2><p>看完完整的 Driver 流程后，我们就先从 Parse 开始说起。</p>
<p>Parse 是解析选项，对应的代码在 ParseArgStrings 这个函数里。</p>
<p>下面通过执行一个试试，比如 clang -### main.c -ITheOptionWeAdd</p>
<p><img src="/uploads/deeply-analyse-llvm/05.png" alt=""></p>
<p>这里的 -I 是 Clang 支持的，在 Clang 里是 Option 类，Clang 会对这些 Option 专门的进行解析，使用一种 DSL 语言将其转成 .tb 文件后使用 table-gen 转成 C++ 语言和其它代码一起进行编译。</p>
<p>Driver 层会解析我们传入的 -I Option 参数。</p>
<p>-x 后加个 c 表示是对 c 语言进行编译，Clang Driver 通过文件的后缀 .c 来自动加上这个 参数的。如果是 c++ 语言，仅仅通过在 -x 后添加 cpp 编译还是会出错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x c++ main.cpp</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/deeply-analyse-llvm/06.png" alt=""></p>
<p>通过报错信息可以看出一些链接错误</p>
<p>因为需要链接 C++ 标准库，所以加上参数 -lc++ 就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x c++ -lc++ main.cpp</div></pre></td></tr></table></figure></p>
<p>那么 clang++ 和 clang 命令的区别就在于会加载 C++ 库，其实 clang++ 最终还是会调用 Clang，那么手动指定加载库就好了何必还要多个 clang++ 命令呢，这主要是为了能够在这个命令里去加载更多的库，除了标准库以外，还有些非 C++ 标准库，辅助库等等。这样只要是 C++ 的程序用 clang++ 够了。</p>
<p>只有加上 -cc1 这个 option 才能进入到 Clang driver 比如 emit-obj 这个 option 就需要先加上 -cc1。</p>
<p>这点可以通过  driver.cpp 源码来看，在 main()  函数里可以看到在做了些多平台的兼容处理后就开始进行对入参判断第一个是不是 -cc1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (MarkEOLs &amp;&amp; argv.size() &gt; <span class="number">1</span> &amp;&amp; StringRef(argv[<span class="number">1</span>]).startswith(<span class="string">"-cc1"</span>))</div><div class="line">    MarkEOLs = <span class="literal">false</span>;</div><div class="line">  llvm::cl::ExpandResponseFiles(Saver, Tokenizer, argv, MarkEOLs);</div><div class="line"></div><div class="line">  <span class="comment">// 处理 -cc1 集成工具</span></div><div class="line">  <span class="keyword">auto</span> FirstArg = <span class="built_in">std</span>::find_if(argv.begin() + <span class="number">1</span>, argv.end(),</div><div class="line">                               [](<span class="keyword">const</span> <span class="keyword">char</span> *A) &#123; <span class="keyword">return</span> A != <span class="literal">nullptr</span>; &#125;);</div><div class="line">  <span class="keyword">if</span> (FirstArg != argv.end() &amp;&amp; StringRef(*FirstArg).startswith(<span class="string">"-cc1"</span>)) &#123;</div><div class="line">    <span class="comment">// 如果 -cc1 来自 response file, 移除 EOL sentinels</span></div><div class="line">    <span class="keyword">if</span> (MarkEOLs) &#123;</div><div class="line">      <span class="keyword">auto</span> newEnd = <span class="built_in">std</span>::remove(argv.begin(), argv.end(), <span class="literal">nullptr</span>);</div><div class="line">      argv.resize(newEnd - argv.begin());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ExecuteCC1Tool(argv, argv[<span class="number">1</span>] + <span class="number">4</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如果是 -cc1 的话会调用 ExecuteCC1Tool 这个函数，先看看这个函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ExecuteCC1Tool</span><span class="params">(ArrayRef&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; argv, StringRef Tool)</span> </span>&#123;</div><div class="line">  <span class="keyword">void</span> *GetExecutablePathVP = (<span class="keyword">void</span> *)(<span class="keyword">intptr_t</span>) GetExecutablePath;</div><div class="line">  <span class="keyword">if</span> (Tool == <span class="string">""</span>)</div><div class="line">    <span class="keyword">return</span> cc1_main(argv.slice(<span class="number">2</span>), argv[<span class="number">0</span>], GetExecutablePathVP);</div><div class="line">  <span class="keyword">if</span> (Tool == <span class="string">"as"</span>)</div><div class="line">    <span class="keyword">return</span> cc1as_main(argv.slice(<span class="number">2</span>), argv[<span class="number">0</span>], GetExecutablePathVP);</div><div class="line"></div><div class="line">  <span class="comment">// 拒绝未知工具</span></div><div class="line">  llvm::errs() &lt;&lt; <span class="string">"error: unknown integrated tool '"</span> &lt;&lt; Tool &lt;&lt; <span class="string">"'\n"</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的执行会执行 cc1-main 或者 cc1as_main 。这两个函数分别在 driver.cpp 同级目录里的 cc1_main.cpp 和 cc1as_main.cpp 中。</p>
<p>下面看看有哪些解析 Args 的方法</p>
<ul>
<li>ParseAnalyzerArgs - 解析出静态分析器 option</li>
<li>ParseMigratorArgs - 解析 Migrator option</li>
<li>ParseDependencyOutputArgs - 解析依赖输出 option</li>
<li>ParseCommentArgs - 解析注释 option</li>
<li>ParseFileSystemArgs - 解析文件系统 option</li>
<li>ParseFrontendArgs - 解析前端 option</li>
<li>ParseTargetArgs - 解析目标  option</li>
<li>ParseCodeGenArgs - 解析 CodeGen 相关的 option</li>
<li>ParseHeaderSearchArgs - 解析 HeaderSearch 对象相关初始化相关的 option</li>
<li>parseSanitizerKinds - 解析 Sanitizer Kinds</li>
<li>ParsePreprocessorArgs - 解析预处理的 option</li>
<li>ParsePreprocessorOutputArgs - 解析预处理输出的 option</li>
</ul>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>Pipeline 这里可以添加 -ccc-print-phases 看到进入 Pipeline 以后的事情。</p>
<p>这些如 -ccc-print-phases 这样的 option 在编译时会生成.inc 这样的 C++ TableGen 文件。在 Options.td 可以看到全部的 option 定义。</p>
<p>在 Clang 的 Pipeline 中很多实际行为都有对应的 Action，比如 preprocessor 时提供文件的 InputAction 和用于绑定机器架构的 BindArchAction。</p>
<p>使用 clang main.c -arch i386 -arch x86_64 -o main 然后 file main 能够看到这时 BindArchAction 这个 Action 起到了作用，编译链接了两次同时创建了一个库既能够支持32位也能够支持64位用 lipo 打包。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// BuildActions - Construct the list of actions to perform for the</span></div><div class="line">  <span class="comment">/// given arguments, which are only done for a single architecture.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param C - The compilation that is being built.</span></div><div class="line">  <span class="comment">/// \param Args - The input arguments.</span></div><div class="line">  <span class="comment">/// \param Actions - The list to store the resulting actions onto.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">BuildActions</span><span class="params">(Compilation &amp;C, llvm::opt::DerivedArgList &amp;Args,</span></span></div><div class="line">                    <span class="keyword">const</span> InputList &amp;Inputs, ActionList &amp;Actions) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="comment">/// BuildUniversalActions - Construct the list of actions to perform</span></div><div class="line">  <span class="comment">/// for the given arguments, which may require a universal build.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param C - The compilation that is being built.</span></div><div class="line">  <span class="comment">/// \param TC - The default host tool chain.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">BuildUniversalActions</span><span class="params">(Compilation &amp;C, <span class="keyword">const</span> ToolChain &amp;TC,</span></span></div><div class="line">                             <span class="keyword">const</span> InputList &amp;BAInputs) <span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<p>上面两个方法中 BuildUniversalActions 最后也会走 BuildActions。BuildActions 了，进入这个方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Driver::BuildActions(Compilation &amp;C, DerivedArgList &amp;Args,</div><div class="line">                          <span class="keyword">const</span> InputList &amp;Inputs, ActionList &amp;Actions) <span class="keyword">const</span> &#123;</div><div class="line">  llvm::<span class="function">PrettyStackTraceString <span class="title">CrashInfo</span><span class="params">(<span class="string">"Building compilation actions"</span>)</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!SuppressMissingInputWarning &amp;&amp; Inputs.empty()) &#123;</div><div class="line">    Diag(clang::diag::err_drv_no_input_files);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Arg *FinalPhaseArg;</div><div class="line">  phases::ID FinalPhase = getFinalPhase(Args, &amp;FinalPhaseArg);</div></pre></td></tr></table></figure></p>
<p>接着跟 getFinalPhase 这个方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// -&#123;E,EP,P,M,MM&#125; only run the preprocessor.</span></div><div class="line">  <span class="keyword">if</span> (CCCIsCPP() || (PhaseArg = DAL.getLastArg(options::OPT_E)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_EP)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT_M, options::OPT_MM)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_P))) &#123;</div><div class="line">    FinalPhase = phases::Preprocess;</div><div class="line"></div><div class="line">    <span class="comment">// -&#123;fsyntax-only,-analyze,emit-ast&#125; only run up to the compiler.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_fsyntax_only)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_module_file_info)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_verify_pch)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_objc)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_legacy_objc)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT__migrate)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT__analyze,</div><div class="line">                                        options::OPT__analyze_auto)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_emit_ast))) &#123;</div><div class="line">    FinalPhase = phases::Compile;</div><div class="line"></div><div class="line">    <span class="comment">// -S only runs up to the backend.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_S))) &#123;</div><div class="line">    FinalPhase = phases::Backend;</div><div class="line"></div><div class="line">    <span class="comment">// -c compilation only runs up to the assembler.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_c))) &#123;</div><div class="line">    FinalPhase = phases::Assemble;</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise do everything.</span></div><div class="line">  &#125; <span class="keyword">else</span></div><div class="line">    FinalPhase = phases::Link;</div></pre></td></tr></table></figure></p>
<p>看完这段代码就会发现其实每次的 option 都会完整的走一遍从预处理，静态分析，backend 再到汇编的过程。</p>
<p>下面列下一些编译器的前端 Action，大家可以一个个用着玩。</p>
<ul>
<li>InitOnlyAction - 只做前端初始化，编译器 option 是 -init-only</li>
<li>PreprocessOnlyAction - 只做预处理，不输出，编译器的 option 是 -Eonly</li>
<li>PrintPreprocessedAction - 做预处理，子选项还包括-P、-C、-dM、-dD 具体可以查看PreprocessorOutputOptions 这个类，编译器 option 是 -E</li>
<li>RewriteIncludesAction - 预处理</li>
<li>DumpTokensAction - 打印token，option 是 -dump-tokens</li>
<li>DumpRawTokensAction - 输出原始tokens，包括空格符，option 是 -dump-raw-tokens</li>
<li>RewriteMacrosAction - 处理并扩展宏定义，对应的 option 是 -rewrite-macros</li>
<li>HTMLPrintAction - 生成高亮的代码网页，对应的 option 是 -emit-html</li>
<li>DeclContextPrintAction - 打印声明，option 对应的是 -print-decl-contexts</li>
<li>ASTDeclListAction - 打印 AST 节点，option 是 -ast-list</li>
<li>ASTDumpAction - 打印 AST 详细信息，对应 option 是 -ast-dump</li>
<li>ASTViewAction - 生成 AST dot 文件，能够通过 Graphviz 来查看图形语法树。 option 是 -ast-view</li>
<li>AnalysisAction - 运行静态分析引擎，option 是 -analyze</li>
<li>EmitLLVMAction - 生成可读的 IR 中间语言文件，对应的 option 是 -emit-llvm</li>
<li>EmitBCAction - 生成 IR Bitcode 文件，option 是 -emit-llvm-bc</li>
<li>MigrateSourceAction - 代码迁移，option 是 -migrate</li>
</ul>
<h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>Bind 主要是与工具链 ToolChain 交互<br>根据创建的那些 Action，在 Action 执行时 Bind 来提供使用哪些工具，比如生成汇编时是使用内嵌的还是 GNU 的，还是其它的呢，这个就是由 Bind 来决定的，具体使用的工具有各个架构，平台，系统的 ToolChain 来决定。</p>
<p>通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果</p>
<p>可以看到编译选择的是 clang，链接选择的是 darwin::Linker，但是在链接时前没有汇编器的过程，这个就是 Bind 起了作用，它会根据不同的平台来决定选择什么工具，因为是在 Mac 系统里 Bind 就会决定使用 integrated-as 这个内置汇编器。那么如何在不用内置汇编器呢。可以使用 -fno-integrated-as 这个 option。</p>
<h2 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h2><p>Translate 就是把相关的参数对应到不同平台上不同的工具。</p>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>从创建 Jobs 的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// BuildJobsForAction - Construct the jobs to perform for the action \p A and</span></div><div class="line">  <span class="comment">/// return an InputInfo for the result of running \p A.  Will only construct</span></div><div class="line">  <span class="comment">/// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once.</span></div><div class="line">  <span class="function">InputInfo</span></div><div class="line">  <span class="title">BuildJobsForAction</span><span class="params">(Compilation &amp;C, <span class="keyword">const</span> Action *A, <span class="keyword">const</span> ToolChain *TC,</span></div><div class="line">                     StringRef BoundArch, <span class="keyword">bool</span> AtTopLevel, <span class="keyword">bool</span> MultipleArchs,</div><div class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *LinkingOutput,</div><div class="line">                     <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Action *, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;, InputInfo&gt;</div><div class="line">                         &amp;CachedResults,</div><div class="line">                     Action::OffloadKind TargetDeviceOffloadKind) <span class="keyword">const</span>;</div></pre></td></tr></table></figure></p>
<p>可以看出 Jobs 需要前面的 Compilation，Action，ToolChain 等，那么 Jobs 就是将前面获取的信息进行组合分组给后面的 Execute 做万全准备。</p>
<h2 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h2><p>在 driver.cpp 的 main 函数里的 ExecuteCompilation 方法里可以看到如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set up response file names for each command, if necessary</span></div><div class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Job : C.getJobs())</div><div class="line">   setUpResponseFiles(C, Job);</div><div class="line"></div><div class="line"> C.ExecuteJobs(C.getJobs(), FailingCommands);</div></pre></td></tr></table></figure></p>
<p>能够看到 Jobs 准备好了后就要开始 Excute 他们。</p>
<p>Execute 就是执行整个的编译过程的 Jobs。过程执行的内容和耗时可以通过添加 -ftime-report 这个 option 来看到。</p>
<p><img src="/uploads/deeply-analyse-llvm/07.png" alt=""></p>
<h1 id="Clang-Attributes"><a href="#Clang-Attributes" class="headerlink" title="Clang Attributes"></a>Clang Attributes</h1><p>以 <strong>attribute</strong>(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法：</p>
<h2 id="attribute-format-NSString-F-A-格式化字符串"><a href="#attribute-format-NSString-F-A-格式化字符串" class="headerlink" title="attribute((format(NSString, F, A))) 格式化字符串"></a><strong>attribute</strong>((format(<strong>NSString</strong>, F, A))) 格式化字符串</h2><p>可以查看 NSLog 的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_EXPORT void NSLog(NSString *format, …) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;</div><div class="line"></div><div class="line">// Marks APIs which format strings by taking a format string and optional varargs as arguments</div><div class="line">#if !defined(NS_FORMAT_FUNCTION)</div><div class="line">    #if (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED)</div><div class="line">	#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</div><div class="line">    #else</div><div class="line">	#define NS_FORMAT_FUNCTION(F,A)</div><div class="line">    #endif</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<h2 id="attribute-deprecated-s-版本弃用提示"><a href="#attribute-deprecated-s-版本弃用提示" class="headerlink" title="attribute((deprecated(s))) 版本弃用提示"></a><strong>attribute</strong>((deprecated(s))) 版本弃用提示</h2><p>在编译过程中能够提示开发者该方法或者属性已经被弃用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)preMethod:( NSString *)string __attribute__((deprecated(“preMethod已经被弃用，请使用newMethod”)));</div><div class="line">- (void)deprecatedMethod DEPRECATED_ATTRIBUTE; //也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏</div></pre></td></tr></table></figure></p>
<h2 id="attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围"><a href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围" class="headerlink" title="attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围"></a><strong>attribute</strong>((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” <strong>VA_ARGS</strong>))) 指明使用版本范围</h2><p>os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=“iOS3到iOS7版本可用，iOS7不能用”)));</div></pre></td></tr></table></figure></p>
<h2 id="attribute-unavailable-…-方法不可用提示"><a href="#attribute-unavailable-…-方法不可用提示" class="headerlink" title="attribute((unavailable(…))) 方法不可用提示"></a><strong>attribute</strong>((unavailable(…))) 方法不可用提示</h2><p>这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。</p>
<h2 id="attribute-unused"><a href="#attribute-unused" class="headerlink" title="attribute((unused))"></a><strong>attribute</strong>((unused))</h2><p>没有被使用也不报警告</p>
<h2 id="attribute-warn-unused-result"><a href="#attribute-warn-unused-result" class="headerlink" title="attribute((warn_unused_result))"></a><strong>attribute</strong>((<strong>warn_unused_result</strong>))</h2><p>不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。</p>
<h2 id="attribute-availability-swift-unavailable-message-msg"><a href="#attribute-availability-swift-unavailable-message-msg" class="headerlink" title="attribute((availability(swift, unavailable, message=_msg)))"></a><strong>attribute</strong>((<strong>availability</strong>(swift, unavailable, message=_msg)))</h2><p>OC 的方法不能在 Swift 中使用。</p>
<h2 id="attribute-cleanup-…-作用域结束时自动执行一个指定方法"><a href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法" class="headerlink" title="attribute((cleanup(…))) 作用域结束时自动执行一个指定方法"></a><strong>attribute</strong>((cleanup(…))) 作用域结束时自动执行一个指定方法</h2><p>作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。</p>
<p>Reactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define onExit \</div><div class="line">    rac_keywordify \</div><div class="line">    __strong rac_cleanupBlock_t metamacro_concat(rac_exitBlock_, __LINE__) __attribute__((cleanup(rac_executeCleanupBlock), unused)) = ^</div><div class="line"></div><div class="line">static inline void rac_executeCleanupBlock (__strong rac_cleanupBlock_t *block) &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (property != NULL) &#123;</div><div class="line">		rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property);</div><div class="line">		if (attributes != NULL) &#123;</div><div class="line">			@onExit &#123;</div><div class="line">				free(attributes);</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			BOOL isObject = attributes-&gt;objectClass != nil || strstr(attributes-&gt;type, @encode(id)) == attributes-&gt;type;</div><div class="line">			BOOL isProtocol = attributes-&gt;objectClass == NSClassFromString(@“Protocol”);</div><div class="line">			BOOL isBlock = strcmp(attributes-&gt;type, @encode(void(^)())) == 0;</div><div class="line">			BOOL isWeak = attributes-&gt;weak;</div><div class="line"></div><div class="line">			shouldAddDeallocObserver = isObject &amp;&amp; isWeak &amp;&amp; !isBlock &amp;&amp; !isProtocol;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。</p>
<h2 id="attribute-overloadable-方法重载"><a href="#attribute-overloadable-方法重载" class="headerlink" title="attribute((overloadable)) 方法重载"></a><strong>attribute</strong>((overloadable)) 方法重载</h2><p>能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">__attribute__((overloadable)) void printArgument(int number)&#123;</div><div class="line">    NSLog(@“Add Int %i”, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) void printArgument(NSString *number)&#123;</div><div class="line">    NSLog(@“Add NSString %@“, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) void printArgument(NSNumber *number)&#123;</div><div class="line">    NSLog(@“Add NSNumber %@“, number);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="attribute-objc-designated-initializer-指定内部实现的初始化方法"><a href="#attribute-objc-designated-initializer-指定内部实现的初始化方法" class="headerlink" title="attribute((objc_designated_initializer)) 指定内部实现的初始化方法"></a><strong>attribute</strong>((objc_designated_initializer)) 指定内部实现的初始化方法</h2><ul>
<li>如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。</li>
<li>如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。</li>
</ul>
<h2 id="attribute-objc-subclassing-restricted-指定不能有子类"><a href="#attribute-objc-subclassing-restricted-指定不能有子类" class="headerlink" title="attribute((objc_subclassing_restricted)) 指定不能有子类"></a><strong>attribute</strong>((objc_subclassing_restricted)) 指定不能有子类</h2><p>相当于 Java 里的 final 关键字，如果有子类继承就会出错。</p>
<h2 id="attribute-objc-requires-super-子类继承必须调用-super"><a href="#attribute-objc-requires-super-子类继承必须调用-super" class="headerlink" title="attribute((objc_requires_super)) 子类继承必须调用 super"></a><strong>attribute</strong>((objc_requires_super)) 子类继承必须调用 super</h2><p>声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。</p>
<h2 id="attribute-const-重复调用相同数值参数优化返回"><a href="#attribute-const-重复调用相同数值参数优化返回" class="headerlink" title="attribute((const)) 重复调用相同数值参数优化返回"></a><strong>attribute</strong>((const)) 重复调用相同数值参数优化返回</h2><p>用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。</p>
<h2 id="attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><a href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY" class="headerlink" title="attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))"></a><strong>attribute</strong>((constructor(PRIORITY))) 和 <strong>attribute</strong>((destructor(PRIORITY)))</h2><p>PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。</p>
<p>通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。</p>
<h1 id="Clang-警告处理"><a href="#Clang-警告处理" class="headerlink" title="Clang 警告处理"></a>Clang 警告处理</h1><p>先看看这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored “-Wdeprecated-declarations”</div><div class="line">        sizeLabel = [self sizeWithFont:font constrainedToSize:size lineBreakMode:NSLineBreakByWordWrapping];</div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure></p>
<p>如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p>
<h1 id="使用-libclang-来进行语法分析"><a href="#使用-libclang-来进行语法分析" class="headerlink" title="使用 libclang 来进行语法分析"></a>使用 libclang 来进行语法分析</h1><p>使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。</p>
<p>使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js / ruby binding，还有 Objective-C的开源库 <a href="https://github.com/macmade/ClangKit" target="_blank" rel="external">GitHub - macmade/ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented.</a> 。</p>
<p>写个 python 脚本来调用 clang<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pip install clang</div><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># vim: set fileencoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> clang.cindex</div><div class="line"><span class="keyword">import</span> asciitree</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node_children</span><span class="params">(node)</span>:</span></div><div class="line">    <span class="keyword">return</span> (c <span class="keyword">for</span> c <span class="keyword">in</span> node.get_children() <span class="keyword">if</span> c.location.file == sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_node</span><span class="params">(node)</span>:</span></div><div class="line">    text = node.spelling <span class="keyword">or</span> node.displayname</div><div class="line">    kind = str(node.kind)[str(node.kind).index(‘.’)+<span class="number">1</span>:]</div><div class="line">    <span class="keyword">return</span> ‘&#123;&#125; &#123;&#125;’.format(kind, text)</div><div class="line"></div><div class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</div><div class="line">    print(“Usage: dump_ast.py [header file name]”)</div><div class="line">    sys.exit()</div><div class="line"></div><div class="line">clang.cindex.Config.set_library_file(‘/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib’)</div><div class="line">index = clang.cindex.Index.create()</div><div class="line">translation_unit = index.parse(sys.argv[<span class="number">1</span>], [‘-x’, ‘objective-c’])</div><div class="line"></div><div class="line"><span class="keyword">print</span> asciitree.draw_tree(translation_unit.cursor,</div><div class="line">                          <span class="keyword">lambda</span> n: list(n.get_children()),</div><div class="line">                          <span class="keyword">lambda</span> n: “%s (%s)” % (n.spelling <span class="keyword">or</span> n.displayname, str(n.kind).split(“.”)[<span class="number">1</span>]))</div></pre></td></tr></table></figure></p>
<p>基于语法树的分析还可以针对字符串做加密。</p>
<h1 id="LibTooling-对语法树完全的控制"><a href="#LibTooling-对语法树完全的控制" class="headerlink" title="LibTooling 对语法树完全的控制"></a>LibTooling 对语法树完全的控制</h1><p>因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。</p>
<ul>
<li>可以改变 clang 生成代码的方式。</li>
<li>增加更强的类型检查。</li>
<li>按照自己的定义进行代码的检查分析。</li>
<li>对源码做任意类型分析，甚至重写程序。</li>
<li>给 clang 添加一些自定义的分析，创建自己的重构器。</li>
<li>基于现有代码做出大量的修改。</li>
<li>基于工程生成相关图形或文档。</li>
<li>检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者  Swift 。</li>
</ul>
<p>官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： <a href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="external">Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation</a></p>
<p>按照说明编译完成后进入 LLVM 的目录 ~/llvm/tools/clang/tools/ 在这了可以创建自己的 clang 工具。这里有个范例： <a href="https://github.com/objcio/issue-6-compiler-tool" target="_blank" rel="external">GitHub - objcio/issue-6-compiler-tool: Example code for a standalone clang/llvm tool.</a> 可以直接 make 成一个二进制文件。</p>
<p>下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface Observer</div><div class="line">+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">VisitObjCMessageExpr</span><span class="params">(ObjCMessageExpr *E)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) &#123;</div><div class="line">    QualType ReceiverType = E-&gt;getClassReceiver();</div><div class="line">    Selector Sel = E-&gt;getSelector();</div><div class="line">    <span class="built_in">string</span> TypeName = ReceiverType.getAsString();</div><div class="line">    <span class="built_in">string</span> SelName = Sel.getAsString();</div><div class="line">    <span class="keyword">if</span> (TypeName == “Observer” &amp;&amp; SelName == “observerWithTarget:action:”) &#123;</div><div class="line">      Expr *Receiver = E-&gt;getArg(<span class="number">0</span>)-&gt;IgnoreParenCasts();</div><div class="line">      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(<span class="number">1</span>)-&gt;IgnoreParenCasts());</div><div class="line">      Selector Sel = SelExpr-&gt;getSelector();</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">const</span> ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) &#123;</div><div class="line">        ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl();</div><div class="line">        <span class="keyword">if</span> (! decl-&gt;lookupInstanceMethod(Sel)) &#123;</div><div class="line">          errs() &lt;&lt; “Warning: <span class="class"><span class="keyword">class</span> “ &lt;&lt; TypeName &lt;&lt; “ does not implement selector “ &lt;&lt; Sel.getAsString() &lt;&lt; “\n”;</span></div><div class="line">          SourceLocation Loc = E-&gt;getExprLoc();</div><div class="line">          PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc);</div><div class="line">          errs() &lt;&lt; “in “ &lt;&lt; PLoc.getFilename() &lt;&lt; “ &lt;“ &lt;&lt; PLoc.getLine() &lt;&lt; “:” &lt;&lt; PLoc.getColumn() &lt;&lt; “&gt;\n”;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Clang-Plugin"><a href="#Clang-Plugin" class="headerlink" title="Clang Plugin"></a>Clang Plugin</h1><p>通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm/tools/clang/tools</p>
<p>动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库  <a href="https://lmsgsendnilself.github.io/blog/2017/02/28/clangtojszi-yuan/" target="_blank" rel="external">clangtojs资源 - Lmsgsendnilself</a> ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： <a href="http://slides.com/sunnyxx/calling-conventions-in-cocoa#/" target="_blank" rel="external">Calling Conventions in Cocoa by sunnyxx</a> bang 也有篇文章： <a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="external">如何动态调用 C 函数 «  bang’s blog</a>  。</p>
<p>这三个方案作者都分别写了文章详细说明其实现方案。</p>
<ul>
<li><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">JSPatch实现原理详解 «  bang’s blog</a></li>
<li><a href="http://mp.weixin.qq.com/s/qRW_akbU3TSd0SxpF3iQmQ" target="_blank" rel="external">DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航</a></li>
<li><a href="http://www.jianshu.com/p/6c756ce76758" target="_blank" rel="external">OCS——史上最疯狂的iOS动态化方案 - 简书</a></li>
</ul>
<p>滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 <a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651112856&amp;idx=1&amp;sn=b2c74c62a10b4c9a4e7538d1ad7eb739" target="_blank" rel="external">《基于clang插件的一种iOS包大小瘦身方案》</a></p>
<p>那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。</p>
<ul>
<li>官方 clang 的插件： <a href="http://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="external">External Clang Examples</a></li>
<li>收集一些如何使用 clang 库的例子：<a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li>在 Xcode 中添加 clang 静态分析自定义 checks： <a href="http://clang-analyzer.llvm.org/xcode.html" target="_blank" rel="external">Running the analyzer within Xcode</a></li>
<li>将 LLVM C 的 API 用 swift 来包装： <a href="https://github.com/harlanhaskins/LLVMSwift" target="_blank" rel="external">GitHub - harlanhaskins/LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1</a></li>
</ul>
<h1 id="LLVM-Backend"><a href="#LLVM-Backend" class="headerlink" title="LLVM Backend"></a>LLVM Backend</h1><p>首先通过下图看看 LLVM Backend 在整个 LLVM 里所处的位置：<br><img src="/uploads/deeply-analyse-llvm/09.png" alt=""></p>
<p>接下来是整个 LLVM Backend 的流程图，后面会对每个过程详细说明</p>
<p><img src="/uploads/deeply-analyse-llvm/10.png" alt=""></p>
<h2 id="CodeGen-阶段"><a href="#CodeGen-阶段" class="headerlink" title="CodeGen 阶段"></a>CodeGen 阶段</h2><ul>
<li>Instruction Selection 指令选择：将IR转化成目标平台指令组成的定向非循环图 DAG（Directed Acyclic Graph）。选择既能完成指定操作，又能执行时间最短的指令。</li>
<li>Scheduling and Formation 调度与排序：读取 DAG，将 DAG 的指令排成 MachineInstr 的队列。根据指令间的依赖进行指令重排使得能够更好的利用 CPU 的功能单元。</li>
<li>SSA 优化：多个基于 SSA（Static Single Assignment） 的 Pass 组成。比如 modulo-scheduling 和 peephole optimization 都是在这个阶段完成的</li>
<li>Register allocation 寄存器分配：将 Virtual Register 映射到 Physical Register 或内存上<br>Prolog / Epilog 生成</li>
<li>确定所需堆栈大小：Machine Code </li>
<li>晚期优化：最后一次优化机会</li>
<li>Code Emission：输出代码，可以选择汇编或者二进制机器码。</li>
</ul>
<h2 id="SelectionDAG"><a href="#SelectionDAG" class="headerlink" title="SelectionDAG"></a>SelectionDAG</h2><ul>
<li>构建最初的 DAG：把 IR 里的 add 指令转成 SelectionDAG 的 add 节点</li>
<li>优化构建好的 DAG：把一些平台支持的 meta instructions 比如 Rotates，div / rem 指令识别出</li>
<li>Legalization SelectionDAG 类型：比如某些平台只有64位浮点和32位整数运算指令，那么就需要把所有 f32 都提升到 f64，i1/i8/i16 都提升到 i32，同时还要把 i64 拆分成两个 i32 来存储，操作符的合法化，比如 SDIV 在 x86 上回转成 SDIVREM。这个过程结果可以通过 llc -view-dag-combine2-dags sum.ll 看到</li>
<li>指令选择 instruction selector（ISel）：将平台无关的 DAG 通过 TableGen 读入 .tb 文件并且生成对应的模式匹配代码从而转成平台相关的 DAG</li>
<li>SelectionDAG Scheduling and Formation：因为 CPU 是没法执行 DAG，所以需要将指令从 DAG 中提取依据一定规则比如 minimal register pressure 或隐藏指令延迟重排成指令队列。（DAG -&gt; linear list（SSA form） -&gt; MachineInstr -&gt; MC Layer API MCInst MCStreamr -&gt; MCCodeEmitter -&gt; Binary Instr）</li>
</ul>
<p>下图是 llc -view-isel-dags 状态下的 DAG 图：</p>
<p><img src="/uploads/deeply-analyse-llvm/11.png" alt=""></p>
<p>查看 DAG 不同状态的说明如下：</p>
<ul>
<li>-view-dag-combine1-dags：可以显示没有被优化的 DAG</li>
<li>-view-legalize-dags：合法化之前的 DAG</li>
<li>-view-dag-cmobine2-dags：第二次优化前</li>
<li>-view-isel-dags：显示指令选择前的 DAG</li>
<li>-view-sched-dags：在 Scheduler 之前 ISel 之后</li>
<li>-view-sunit-dags：可以显示 Scheduler 的依赖图</li>
</ul>
<h3 id="SDNode"><a href="#SDNode" class="headerlink" title="SDNode"></a>SDNode</h3><p>DAG 的节点都是有 SDNode 所构成，它的主要是作为 dag 值的操作符，描述这个 dag 所代表的操作，操作数。在 LLVM 里 SDNode 的定义出现在 SelectDAGNodes.h 还有就是 TargetSelectionDAG.td 里，每个 SelectionDAG 节点类型都有一个对应的 SDNode 定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDNode</span>&lt;string opcode, SDTypeProfile typeprof, list&lt;SDNodeProperty&gt; props = [], string sdclass ="SDNode"&gt; :</span>SDPatternOperator &#123;</div><div class="line">	stringOpcode  = opcode;</div><div class="line">	<span class="built_in">string</span> SDClass= sdclass;</div><div class="line">	<span class="built_in">list</span>&lt;SDNodeProperty&gt; Properties = props;</div><div class="line">	SDTypeProfileTypeProfile = typeprof; <span class="comment">//类型</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//类型要求</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDTypeProfile</span>&lt;intnumresults, int numoperands, list&lt;SDTypeConstraint&gt;constraints&gt; &#123;</span></div><div class="line">	<span class="keyword">int</span> NumResults= numresults;   <span class="comment">//多少个结果</span></div><div class="line">	<span class="keyword">int</span> NumOperands= numoperands; <span class="comment">//多少个操作数</span></div><div class="line">	<span class="built_in">list</span>&lt;SDTypeConstraint&gt; Constraints = constraints; <span class="comment">//类型的约束</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//描述对操作数类型的约束</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDTypeConstraint</span>&lt;intopnum&gt; &#123;</span></div><div class="line">	<span class="keyword">int</span> OperandNum= opnum; <span class="comment">//指明该约束适用第几个操作数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目标机器可以根据自己的需求定制约束来描述自己特有的指令。</p>
<p>SDNodeProperty 是 SDNode 的属性，用来描述 SDNode 操作的特征。</p>
<h3 id="PatFrag-可复用的结构"><a href="#PatFrag-可复用的结构" class="headerlink" title="PatFrag 可复用的结构"></a>PatFrag 可复用的结构</h3><p>为了支持高级语言的特性，TD 也通过 PatFrag 来支持，在SelectionTargetDAG.td 里定义的，这样就可以支持数据与结构的复用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PatFrag</span>&lt;dag ops, dag frag, code pred = [&#123;&#125;], SDNodeXForm xform =NOOP_SDNodeXForm&gt; :</span> SDPatternOperator &#123;</div><div class="line">	dag Operands= ops;  <span class="comment">//操作数</span></div><div class="line">	dag Fragment= frag; <span class="comment">//所指定的</span></div><div class="line">	code PredicateCode = pred; <span class="comment">//表示嵌入生成的指令选择器的代码，满足条件采用用这个 PatFrag</span></div><div class="line">	code ImmediateCode = [&#123;&#125;]; </div><div class="line">	SDNodeXForm OperandTransform = xform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Pattern-匹配指令"><a href="#Pattern-匹配指令" class="headerlink" title="Pattern 匹配指令"></a>Pattern 匹配指令</h3><p>Pattern 主要是解决复杂操作的 DAG 模式，LLVM 会使用贪婪匹配自动完成这个指令选择。定义在 Target.td 里。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pattern</span>&lt;dag patternToMatch, list&lt;dag&gt;resultInstrs&gt; &#123;</span></div><div class="line">	dagPatternToMatch = patternToMatch;</div><div class="line">	<span class="built_in">list</span>&lt;dag&gt;ResultInstrs  = resultInstrs;</div><div class="line">	<span class="built_in">list</span>&lt;Predicate&gt; Predicates = [];</div><div class="line">	<span class="keyword">int</span> AddedComplexity = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>在 Pattern 和 Instruction 的定义里都有 Predicates。满足 Predicates 的条件才能够继续，定义也在 Target.td 里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&lt;string cond&gt; &#123;</span></div><div class="line">	<span class="built_in">string</span> CondString = cond;</div><div class="line">	<span class="comment">//汇编匹配器的 predicate</span></div><div class="line">	bit AssemblerMatcherPredicate = <span class="number">0</span>;</div><div class="line">  	<span class="comment">//被测试的子 target 的名称用作汇编匹配器的替代条件字符串</span></div><div class="line">	<span class="built_in">string</span> AssemblerCondString = <span class="string">""</span>;</div><div class="line">	<span class="comment">//用户级别的 name 给 predicate 用，主要用在诊断时在汇编匹配器里缺少功能。</span></div><div class="line">	<span class="built_in">string</span> PredicateName = <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个 Predicate 实际上就是一个容器，转么装嵌入代码的，然后把这个代码插入到合适的地方来对某些局限的指令进行筛选过滤。</p>
<h3 id="Itinerary-和-SchedRW-调度信息"><a href="#Itinerary-和-SchedRW-调度信息" class="headerlink" title="Itinerary 和 SchedRW 调度信息"></a>Itinerary 和 SchedRW 调度信息</h3><p>Itinerary 和 SchedRW 在 Instruction 里定义，用来描述指令调度的信息。目标机器平台会从 InstrltinClass 来派生对应指令的定义，比如 X86，它的指令很多而且复杂所以定义的 InstrltinClass 派生定义数量也很多，都在 X86Schedule.td 里。每条指令都对应一个 InstrltinClass 定义。比如除法的 InstrltinClass 的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def IIC_DIV8_MEM   : InstrItinClass;</div><div class="line">def IIC_DIV8_REG   : InstrItinClass;</div><div class="line">def IIC_DIV16      : InstrItinClass;</div><div class="line">def IIC_DIV32      : InstrItinClass;</div><div class="line">defIIC_DIV64       : InstrItinClass;</div></pre></td></tr></table></figure></p>
<p>执行步骤是由 InstrStage 来描述：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstrStage</span>&lt;int cycles, list&lt;FuncUnit&gt; units, int timeinc = -1, ReservationKind kind =Required&gt; &#123;</span></div><div class="line">	<span class="keyword">int</span> Cycles          = cycles;       <span class="comment">//完成这个步骤需要的周期数</span></div><div class="line">	<span class="built_in">list</span>&lt;FuncUnit&gt; Units = units;       <span class="comment">//用于完成该步骤功能单元的选择</span></div><div class="line">	<span class="keyword">int</span> TimeInc         = timeinc;      <span class="comment">//从步骤开始到下个步骤需要多少周期</span></div><div class="line">	<span class="keyword">int</span> Kind            = kind.Value;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过 InstrltinData 将 InstrltinClass 和 stages 绑在一起使得指令能顺序执行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstrItinData</span>&lt;InstrItinClass Class,list&lt;InstrStage&gt; stages, list&lt;int&gt;operandcycles = [], list&lt;Bypass&gt; bypasses= [], int uops = 1&gt; &#123;</span></div><div class="line">	InstrItinClass TheClass = Class;</div><div class="line">	<span class="keyword">int</span> NumMicroOps = uops; <span class="comment">//指令解码后的 mirco operation 的数量，0表示数量不定</span></div><div class="line">	<span class="built_in">list</span>&lt;InstrStage&gt; Stages = stages;</div><div class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; OperandCycles =operandcycles; <span class="comment">//可选周期数</span></div><div class="line">	<span class="built_in">list</span>&lt;Bypass&gt; Bypasses = bypasses;       <span class="comment">//绕过寄存器，将写操作指令的结果直接交给后面读操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="TableGen"><a href="#TableGen" class="headerlink" title="TableGen"></a>TableGen</h3><p>在 llvm/lib/Target 目录下有各个 CPU 架构的目录。以 X86 举例</p>
<ul>
<li>X86.td：架构描述。</li>
<li>X86CallingConv.td：架构调用规范。</li>
<li>X86InstrInfo.td：基本指令集。</li>
<li>X86InstrMMX.td：MMX 指令集。</li>
<li>X86InstrMPX.td：MPX（MemoryProtection Extensions）指令集。</li>
<li>X86InstrSGX.td：SGX（Software GardExtensions）指令集。</li>
<li>X86InstrSSE.td：SSE指令集。</li>
<li>X86InstrSVM.td：AMD SVM（Secure VirutalMachine）指令集。</li>
<li>X86InstrTSX.td：TSX（TransactionalSynchronziation Extensions）指令集。</li>
<li>X86InstrVMX.td：VMX（Virtual MachineExtensions）指令集。</li>
<li>X86InstrSystem.td：特权指令集。</li>
<li>X86InstrXOP.td：对扩展操作的描述。</li>
<li>X86InstrFMA.td：对融合乘加指令的描述。</li>
<li>X86InstrFormat.td：格式定义的描述。</li>
<li>X86InstrFPStack.td：浮点单元指令集的描述。</li>
<li>X86InstrExtension.td：对零及符号扩展的描述。</li>
<li>X86InstrFragmentsSIMD.td：描述 SIMD 所使用的模式片段。</li>
<li>X86InstrShiftRotate.td：对 shift 和 rotate 指令的描述。</li>
<li>X86Instr3DNow.td：3DNow! 指令集的描述。</li>
<li>X86InstrArithmetic.td：算术指令的描述。</li>
<li>X86InstrAVX512.td：AVX512 指令集的描述。</li>
<li>X86InstrCMovSetCC.td：条件 move 及设置条件指令的描述。</li>
<li>X86InstrCompiler.td：各种伪指令和指令选择中的 Pat 模式。</li>
<li>X86InstrControl.td：jump，return，call 指令。</li>
<li>X86RegisterInfo.td：寄存器的描述。</li>
<li>X86SchedHaswell.td：对 Haswell 机器模型的描述。</li>
<li>X86SchedSandyBridge.td：对 Sandy Bridge 机器模型的描述。</li>
<li>X86Schedule.td：指令调度的一般描述。</li>
<li>X86ScheduleAtom.td：用于 Intel Atom 处理器指令调度。</li>
<li>X86SchedSandyBridge.td：用于 Sandy Bridge 机器模型的指令调度。</li>
<li>X86SchedHaswell.td：用于 Haswell 机器模型的指令调度。</li>
<li>X86ScheduleSLM.td：用于 Intel Silvermont 机器模型的指令调度。</li>
<li>X86ScheduleBtVer2.td：用于 AMD btver2 (Jaguar) 机器模型的指令调度。</li>
</ul>
<p>与平台无关的公用的描述在 llvm/include/llvm/target/ 下</p>
<ul>
<li>Target.td：每个机器都要实现的平台无关的接口。</li>
<li>TargetItinerary.td：平台无关的 instruction itineraries 调度接口。</li>
<li>TargetSchedule.td：平台无关的基于 Tablegen 调度接口。</li>
<li>TargetSelectionDAG.td：平台无关的 SelectionDAG 调度接口。</li>
<li>TargetCallingConv.td：平台无关 CallingConv 接口。</li>
</ul>
<p>llvm/include/llvm/CodeGen 目录包含 ValueTypes.td 是用来描述具有通用性的寄存器和操作数的类型。在 llvm/include/llvm/IR 包含描述平台无关的固有函数 Intrinsics.td 文件，还有平台相关的比如 IntrinsicsX86.td 这样的文件。</p>
<h4 id="TabelGen-类型"><a href="#TabelGen-类型" class="headerlink" title="TabelGen 类型"></a>TabelGen 类型</h4><ul>
<li>Dag：表示程序中间表达树中的 DAG 结构，是一个递归构造。有“(“DagArg DagArgList”)”，DagArgList ::= DagArg (“,” DagArg)*，DagArg ::= Value [“:” TokVarName] | TokVarName 这几种语法。比如 (set VR128:$dst, (v2i64 (scalar_to_vector (i64 (bitconvert (x86mmx VR64:$src)))))) 这个 dag 值有多层嵌套，表达的意思是将64位标量的源操作数保存在 MMX 寄存器中，先转成 64 位有符号整数，再转成 2Xi64向量，保存到 128 位寄存器。dag 操作都是比如 def 比如 out，in, set 等，再就是 SDNode 比如 scalar_to_vector 和 bitconvert，或者是 ValueType 的派生定义描述值类型比如 VR128，i64，x86mmx 等。</li>
<li>List：代表队列，有 “[“ ValueList ”]” [“&lt;” Type ”&gt;”]，ValueList ::= [ValueListNE]，ValueListNE ::= Value (“,” Value)* 这样的语法，比如 [llvm_ptr_ty, llvm_ptr_ty]</li>
<li>String：C++ 字符串常量</li>
<li>Bit，int：Bit 代表字节，int 是64位整数</li>
<li>Bits：代表若干字节，比如“bits<64>”</64></li>
</ul>
<h2 id="Register-Allocation-寄存器分配"><a href="#Register-Allocation-寄存器分配" class="headerlink" title="Register Allocation 寄存器分配"></a>Register Allocation 寄存器分配</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器定义在 TargetRegisterInfo.td 里，它们的基类是这样定义的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span>&lt;string n, list&lt;string&gt; altNames =[]&gt; &#123;</span></div><div class="line">	<span class="built_in">string</span> Namespace = <span class="string">""</span>;</div><div class="line">	<span class="built_in">string</span> AsmName = n;</div><div class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; AltNames = altNames;</div><div class="line">	<span class="comment">//别名寄存器</span></div><div class="line">	<span class="built_in">list</span>&lt;Register&gt; Aliases = [];</div><div class="line">	<span class="comment">//属于寄存器的子寄存器</span></div><div class="line">	<span class="built_in">list</span>&lt;Register&gt; SubRegs = [];</div><div class="line">	<span class="comment">//子寄存器的索引编号</span></div><div class="line">	<span class="built_in">list</span>&lt;SubRegIndex&gt; SubRegIndices = [];</div><div class="line">	<span class="comment">//可选名寄存器的索引</span></div><div class="line">	<span class="built_in">list</span>&lt;RegAltNameIndex&gt; RegAltNameIndices= [];</div><div class="line">    <span class="comment">//gcc/gdb 定义的号码</span></div><div class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; DwarfNumbers = [];</div><div class="line">	<span class="comment">//寄存器分配器会通过这个值尽量减少一个寄存器的指令数量</span></div><div class="line">	<span class="keyword">int</span> CostPerUse = <span class="number">0</span>;</div><div class="line">	<span class="comment">//决定寄存器的值是否由子寄存器的值来决定</span></div><div class="line">	bit CoveredBySubRegs = <span class="number">0</span>;</div><div class="line">	<span class="comment">//特定硬件的编码</span></div><div class="line">	bits&lt;<span class="number">16</span>&gt; HWEncoding = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据目标机器可以派生，比如 X86 可以派生出 X86RegisterInfo.td<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X86Reg</span>&lt;string n, bits&lt;16&gt; Enc, list&lt;Register&gt;subregs = []&gt; :</span> Register&lt;n&gt; &#123;</div><div class="line">  let Namespace= <span class="string">"X86"</span>;</div><div class="line">  letHWEncoding = Enc;</div><div class="line">  let SubRegs =subregs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="RegisterClass"><a href="#RegisterClass" class="headerlink" title="RegisterClass"></a>RegisterClass</h3><p>为了描述寄存器用途，将相同用途的寄存器归入同一个 RegisterClass。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterClass</span>&lt;string namespace, list&lt;ValueType&gt;regTypes, int alignment, dagregList, RegAltNameIndex idx = NoRegAltName&gt; :</span> DAGOperand &#123;</div><div class="line">	<span class="built_in">string</span> Namespace = <span class="keyword">namespace</span>;</div><div class="line"></div><div class="line">  	<span class="comment">//寄存器的值类型，寄存器里的寄存器们必须有相同的值类型</span></div><div class="line">	<span class="built_in">list</span>&lt;ValueType&gt; RegTypes = regTypes;</div><div class="line"></div><div class="line">	<span class="comment">//指定寄存器溢出大小</span></div><div class="line">	<span class="keyword">int</span> Size = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">//当寄存器进行存储或者读取时指定排序</span></div><div class="line">	<span class="keyword">int</span> Alignment = alignment;</div><div class="line"></div><div class="line">	<span class="comment">//指定在两个寄存器之间拷贝时的消耗，默认值是1，意味着使用一个指令执行拷贝，如果是负数意味着拷贝消耗昂贵或者不可能</span></div><div class="line">	<span class="keyword">int</span> CopyCost = <span class="number">1</span>;</div><div class="line"></div><div class="line">  	<span class="comment">//说明这个 class 里有哪些寄存器。如果 allocation_order_* 方法没有指定，这个同时定义在寄存器分配器的分配顺序</span></div><div class="line">	dagMemberList = regList;</div><div class="line"></div><div class="line">	<span class="comment">//寄存器备用名用在打印操作这个寄存器 class 时。每个寄存器都需要在一个给定的索引里有一个有效的备用名。</span></div><div class="line">	RegAltNameIndex altNameIndex = idx;</div><div class="line"></div><div class="line">	<span class="comment">//指定寄存器 class 是否能用在虚拟寄存器和寄存器分配里。有些寄存器 class 只限制在模型指令操作，这样就需要设置为0</span></div><div class="line">	bit isAllocatable = <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="comment">//列出可选的分配的命令。默认的命令是 memberlist 自己。当寄存器分配者自动移除保留的寄存器并且移动被调用保存的寄存器到最后是足够好的。</span></div><div class="line">	<span class="built_in">list</span>&lt;dag&gt;AltOrders = [];</div><div class="line"></div><div class="line">	<span class="comment">//这个函数里作用是选择分配给定机器函数顺序，</span></div><div class="line">	code AltOrderSelect = [&#123;&#125;];</div><div class="line"></div><div class="line">	<span class="comment">//寄存器分配器使用贪婪启发式指定分配优先级。如果值高表示优先。这个值的范围在[0,63]</span></div><div class="line">	<span class="keyword">int</span> AllocationPriority = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="寄存器在-LLVM-中的表达"><a href="#寄存器在-LLVM-中的表达" class="headerlink" title="寄存器在 LLVM 中的表达"></a>寄存器在 LLVM 中的表达</h3><p>物理寄存器在 LLVM 里均有 1 - 1023 范围内的编号。在 GenRegisterNames.inc 里找到，比如 lib/Target/X86/X86GenRegisterInfo.inc</p>
<h3 id="虚拟寄存器到物理寄存器的映射"><a href="#虚拟寄存器到物理寄存器的映射" class="headerlink" title="虚拟寄存器到物理寄存器的映射"></a>虚拟寄存器到物理寄存器的映射</h3><p>直接映射使用 TargetRegisterInfo 和 MachineOperand 中的 API。间接映射的API用 VirtRegMap 以正确插入读写指令实现内存调度</p>
<h3 id="LLVM-自带的寄存器分配算法"><a href="#LLVM-自带的寄存器分配算法" class="headerlink" title="LLVM 自带的寄存器分配算法"></a>LLVM 自带的寄存器分配算法</h3><p>llc -regalloc=Greedy add.bc -o ln.s</p>
<ul>
<li>Fast - debug 默认，尽可能保存寄存器。</li>
<li>Basic - 增量分配</li>
<li>Greedy - LLVM 默认寄存器分配算法，对 Basic 算法变量生存期进行分裂进行高度优化</li>
<li>PBQP - 将寄存器分配描述成分区布尔二次规划</li>
</ul>
<h2 id="Code-Emission"><a href="#Code-Emission" class="headerlink" title="Code Emission"></a>Code Emission</h2><p>下图详细表达了整个 Code Emission 的过程<br><img src="/uploads/deeply-analyse-llvm/12.png" alt=""></p>
<h1 id="Swift-编译流"><a href="#Swift-编译流" class="headerlink" title="Swift 编译流"></a>Swift 编译流</h1><p>Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C/OC 进行交互。</p>
<p>下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(“hi!”)</div></pre></td></tr></table></figure></p>
<p>生成程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc toy.swift</div><div class="line">./toy</div></pre></td></tr></table></figure></p>
<p>生成检查 AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -dump-ast toy.swift</div></pre></td></tr></table></figure></p>
<p>可以还原之前函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-silgen toy.swift | xcrun swift-demangle</div></pre></td></tr></table></figure></p>
<p>llvm ir 和汇编的生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-ir toy.swift</div><div class="line">swiftc -emit-assembly toy.swift</div></pre></td></tr></table></figure></p>
<p>生成可执行的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk macosx swiftc toy.swift -o toy</div></pre></td></tr></table></figure></p>
<h1 id="编译后生成的二进制内容-Link-Map-File"><a href="#编译后生成的二进制内容-Link-Map-File" class="headerlink" title="编译后生成的二进制内容 Link Map File"></a>编译后生成的二进制内容 Link Map File</h1><p>在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容</p>
<h2 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h2><p>这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。</p>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><p>这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 <strong>TEXT 代码段和 </strong>DATA 数据段两种。</p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>Symbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。</p>
<h1 id="每次编译后生成的-dSYM-文件"><a href="#每次编译后生成的-dSYM-文件" class="headerlink" title="每次编译后生成的 dSYM 文件"></a>每次编译后生成的 dSYM 文件</h1><p>在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。</p>
<p>可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。</p>
<p>还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</div><div class="line">symbolicatecrash appName.crash appName.app &gt; appName.log</div></pre></td></tr></table></figure></p>
<h1 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h1><p>记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。</p>
<p>Mach-O 文件包含三个区域</p>
<ul>
<li>Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等</li>
<li>Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。</li>
<li>Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。</li>
</ul>
<h2 id="Mach-O-文件的解析"><a href="#Mach-O-文件的解析" class="headerlink" title="Mach-O 文件的解析"></a>Mach-O 文件的解析</h2><p>再通过一个例子来分析下：<br>这次用 xcrun 来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -v</div></pre></td></tr></table></figure></p>
<p>先创建一个test.c的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch test.c</div></pre></td></tr></table></figure></p>
<p>编辑里面的内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vi test.c</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hi there!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行，没有起名默认为 a.out<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang test.c</div><div class="line">./a.out</div></pre></td></tr></table></figure></p>
<p>a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -S -o - test.c | open -f</div></pre></td></tr></table></figure></p>
<p>输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.section	__TEXT,__text,regular,pure_instructions</div><div class="line">.macosx_version_min 10, 12</div><div class="line">.globl	_main</div><div class="line">.align	4, 0x90</div></pre></td></tr></table></figure></p>
<p>.section 指令指定接下来执行哪一个段。</p>
<p>.globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。</p>
<p>.align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。</p>
<p>看看接下来的 main 函数头部部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_main:                                  ## @main</div><div class="line">	.cfi_startproc</div><div class="line">## BB#0:</div><div class="line">	pushq	%rbp</div><div class="line">Ltmp0:</div><div class="line">	.cfi_def_cfa_offset 16</div><div class="line">Ltmp1:</div><div class="line">	.cfi_offset %rbp, -16</div><div class="line">	movq	%rsp, %rbp</div><div class="line">Ltmp2:</div><div class="line">	.cfi_def_cfa_register %rbp</div><div class="line">	subq	$32, %rsp</div></pre></td></tr></table></figure></p>
<p>_main 是函数开始的地址，二进制文件会有这个位置的引用。</p>
<p>.cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in / out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。</p>
<p>pushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。</p>
<p>.cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。</p>
<p>movq %rsp, %rbp 把局部变量放到栈上。</p>
<p>subq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。</p>
<p>再看看 printf()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">leaq	L_.str(%rip), %rax</div><div class="line">movl	$0, -4(%rbp)</div><div class="line">movl	%edi, -8(%rbp)</div><div class="line">movq	%rsi, -16(%rbp)</div><div class="line">movq	%rax, %rdi</div><div class="line">movb	$0, %al</div><div class="line">callq	_printf</div></pre></td></tr></table></figure></p>
<p>leap 会将 L<em>.str 这个指针加载到 rax 寄存器里。可以看看 L</em>.str 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div></pre></td></tr></table></figure></p>
<p>这个就是我们代码文件里定义的那个字符串。</p>
<p>这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。</p>
<p>当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。</p>
<p>printf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。</p>
<p>接下来看看返回和函数的结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xorl	%ecx, %ecx</div><div class="line">movl	%eax, -20(%rbp)         ## 4-byte Spill</div><div class="line">movl	%ecx, %eax</div><div class="line">addq	$32, %rsp</div><div class="line">popq	%rbp</div><div class="line">retq</div><div class="line">.cfi_endproc</div></pre></td></tr></table></figure></p>
<p>xorl    %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。</p>
<p>函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。</p>
<p>接下来是字符串输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	.section	__TEXT,__cstring,cstring_literals</div><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div><div class="line"></div><div class="line">.subsections_via_symbols</div></pre></td></tr></table></figure></p>
<p>同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。</p>
<p>接下来通过 size 工具来看看 a.out 里的 section。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun size -x -l -m a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</div><div class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</div><div class="line">	Section __text: 0x34 (addr 0x100000f50 offset 3920)</div><div class="line">	Section __stubs: 0x6 (addr 0x100000f84 offset 3972)</div><div class="line">	Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980)</div><div class="line">	Section __cstring: 0xa (addr 0x100000fa6 offset 4006)</div><div class="line">	Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016)</div><div class="line">	total 0xa6</div><div class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</div><div class="line">	Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</div><div class="line">	Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</div><div class="line">	total 0x18</div><div class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</div><div class="line">total 0x100003000</div></pre></td></tr></table></figure>
<p>可以看出有四个 segment 和多个section。</p>
<p>在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。</p>
<p>__PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。</p>
<p>__TEXT segment 包含被执行的代码以只读和可执行的方式映射。</p>
<ul>
<li>__text section 包含编译后的机器码。</li>
<li><strong>stubs 和 </strong>stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。</li>
<li>__cstring 可执行文件中的字符串。</li>
<li>__const 不可变的常量。</li>
</ul>
<p>__DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。</p>
<ul>
<li>__nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 </li>
<li>__la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。</li>
<li>__const 需要重定向的常量，例如 char * const c = “foo”; c指针指向可变的数据。</li>
<li>__bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。</li>
<li>__common 包含外部全局变量。例如在函数外定义 int i;</li>
<li>__dyld 是section占位符，用于动态链接器。</li>
</ul>
<p>更多 section 类型介绍可以查看苹果文档： <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html" target="_blank" rel="external">OS X Assembler Reference</a></p>
<p>接下来用 otool 查看下 section 里的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -s __TEXT __text a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">Contents of (__TEXT,__text) section</div><div class="line">0000000100000f50	55 48 89 e5 48 83 ec 20 48 8d 05 47 00 00 00 c7 </div><div class="line">0000000100000f60	45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 </div><div class="line">0000000100000f70	b0 00 e8 0d 00 00 00 31 c9 89 45 ec 89 c8 48 83 </div><div class="line">0000000100000f80	c4 20 5d c3</div></pre></td></tr></table></figure>
<p>这个返回的内容很难读，加个 - v  就可以查看反汇编代码了， -s <strong>TEXT </strong>text 有个缩写 -t<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -v -t a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">(__TEXT,__text) section</div><div class="line">_main:</div><div class="line">0000000100000f50	pushq	%rbp</div><div class="line">0000000100000f51	movq	%rsp, %rbp</div><div class="line">0000000100000f54	subq	$0x20, %rsp</div><div class="line">0000000100000f58	leaq	0x47(%rip), %rax</div><div class="line">0000000100000f5f	movl	$0x0, -0x4(%rbp)</div><div class="line">0000000100000f66	movl	%edi, -0x8(%rbp)</div><div class="line">0000000100000f69	movq	%rsi, -0x10(%rbp)</div><div class="line">0000000100000f6d	movq	%rax, %rdi</div><div class="line">0000000100000f70	movb	$0x0, %al</div><div class="line">0000000100000f72	callq	0x100000f84</div><div class="line">0000000100000f77	xorl	%ecx, %ecx</div><div class="line">0000000100000f79	movl	%eax, -0x14(%rbp)</div><div class="line">0000000100000f7c	movl	%ecx, %eax</div><div class="line">0000000100000f7e	addq	$0x20, %rsp</div><div class="line">0000000100000f82	popq	%rbp</div><div class="line">0000000100000f83	retq</div></pre></td></tr></table></figure>
<p>看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。</p>
<p>现在来看看可执行文件。</p>
<p>通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -h a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Mach header</div><div class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</div><div class="line">MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    15       1200   NOUNDEFS DYLDLINK TWOLEVEL PIE</div></pre></td></tr></table></figure>
<p>mach_header 结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>      magic;</div><div class="line">  <span class="keyword">cpu_type_t</span>    cputype;</div><div class="line">  <span class="keyword">cpu_subtype_t</span> cpusubtype;</div><div class="line">  <span class="keyword">uint32_t</span>      filetype;</div><div class="line">  <span class="keyword">uint32_t</span>      ncmds;</div><div class="line">  <span class="keyword">uint32_t</span>      sizeofcmds;</div><div class="line">  <span class="keyword">uint32_t</span>      flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -l a.out | open -f</div></pre></td></tr></table></figure></p>
<p>加载命令结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>  cmd;</div><div class="line">  <span class="keyword">uint32_t</span>  cmdsize;</div><div class="line">  <span class="keyword">char</span>      segname[<span class="number">16</span>];</div><div class="line">  <span class="keyword">uint32_t</span>  vmaddr;</div><div class="line">  <span class="keyword">uint32_t</span>  vmsize;</div><div class="line">  <span class="keyword">uint32_t</span>  fileoff;</div><div class="line">  <span class="keyword">uint32_t</span>  filesize;</div><div class="line">  <span class="keyword">vm_prot_t</span> maxprot;</div><div class="line">  <span class="keyword">vm_prot_t</span> initprot;</div><div class="line">  <span class="keyword">uint32_t</span>  nsects;</div><div class="line">  <span class="keyword">uint32_t</span>  flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。</p>
<p>在加载命令里还是看看 <strong>TEXT </strong>text 的section的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Section</div><div class="line">  sectname __text</div><div class="line">   segname __TEXT</div><div class="line">      addr 0x0000000100000f50</div><div class="line">      size 0x0000000000000034</div><div class="line">    offset 3920</div><div class="line">     align 2^4 (16)</div><div class="line">    reloff 0</div><div class="line">    nreloc 0</div><div class="line">      type S_REGULAR</div><div class="line">attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS</div><div class="line"> reserved1 0</div><div class="line"> reserved2 0</div></pre></td></tr></table></figure></p>
<p>addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。</p>
<p>单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。<br>Foo.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Foo : NSObject</div><div class="line"></div><div class="line">- (void)say;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Foo.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import “Foo.h”</div><div class="line"></div><div class="line">@implementation Foo</div><div class="line"></div><div class="line">- (void)say</div><div class="line">&#123;</div><div class="line">    NSLog(@“hi there again!\n”);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>SayHi.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import “Foo.h”</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        Foo *foo = [[Foo alloc] init];</div><div class="line">        [foo say];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先编译多个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang -c Foo.m</div><div class="line">xcrun clang -c SayHi.m</div></pre></td></tr></table></figure></p>
<p>再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang SayHi.o Foo.o -Wl,`xcrun —show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</div></pre></td></tr></table></figure></p>
<h2 id="逆向-Mach-O-文件"><a href="#逆向-Mach-O-文件" class="headerlink" title="逆向 Mach-O 文件"></a>逆向 Mach-O 文件</h2><p>需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。</p>
<p>Mobilesubstrate 提供了三个模块来方便开发。</p>
<ul>
<li>MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。</li>
<li>MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook  放在这里就可以了。</li>
<li>Safe mode：类似安全模式，会禁用的改动。</li>
</ul>
<p>先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。</p>
<p>当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。</p>
<ul>
<li>这里有个实例，讲解如何通过逆向实现微信抢红包的插件： <a href="http://dev.qq.com/topic/5791da152168f2690e72daa4" target="_blank" rel="external">【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB</a></li>
<li>入门文章可以看看这篇： <a href="https://github.com/zhengmin1989/MyArticles/tree/master/iOS%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C" target="_blank" rel="external">MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub</a></li>
<li>玩出新花样： <a href="http://blog.imjun.net/2016/10/08/%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%9A%E6%8A%8A%E7%AC%AC%E4%B8%89%E6%96%B9-iOS-%E5%BA%94%E7%94%A8%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/" target="_blank" rel="external">黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog</a>，作者另一篇文章： <a href="http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog</a></li>
</ul>
<h1 id="dyld动态链接"><a href="#dyld动态链接" class="headerlink" title="dyld动态链接"></a>dyld动态链接</h1><p>生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。</p>
<p>用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。</p>
<p>符号表会规定它们的符号，使用 nm 工具看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm SayHi.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _OBJC_CLASS_$_Foo</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush</div><div class="line">                 (undefined) external _objc_msgSend</div><div class="line">0000000000000000 (__TEXT,__text) external _main</div></pre></td></tr></table></figure>
<ul>
<li>_OBJC<em>CLASS</em>$_Foo 表示 Foo 的 OC 符号。</li>
<li>(undefined) external 表示未实现非私有，如果是私有就是 non-external。</li>
<li>external _main 表示 main() 函数，处理 0 地址，将要到 <strong>TEXT,</strong>text section </li>
</ul>
<p>再看看 Foo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm Foo.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject</div><div class="line">                 (undefined) external ___CFConstantStringClassReference</div><div class="line">                 (undefined) external __objc_empty_cache</div><div class="line">0000000000000000 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo</div><div class="line">00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo</div><div class="line">00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo</div><div class="line">0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>因为 undefined 符号表示该文件类未实现的，所以在目标文件和  Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。</p>
<p>链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog (from Foundation)</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</div><div class="line">                 (undefined) external __objc_empty_cache (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</div><div class="line">                 (undefined) external _objc_msgSend (from libobjc)</div><div class="line">                 (undefined) external dyld_stub_binder (from libSystem)</div><div class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</div><div class="line">0000000100000e90 (__TEXT,__text) external _main</div><div class="line">0000000100000f10 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。</p>
<p>通过 otool 可以找到所需库在哪<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -L a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">	/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0)</div><div class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)</div><div class="line">	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0)</div><div class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</div></pre></td></tr></table></figure>
<p>libSystem 里有很多我们熟悉的lib</p>
<ul>
<li>libdispatch：GCD</li>
<li>libsystem_c：C语言库</li>
<li>libsystem_blocks：Block</li>
<li>libcommonCrypto：加密，比如md5</li>
</ul>
<p>dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。</p>
<p>打印什么库被加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(export DYLD_PRINT_LIBRARIES=; ./a.out )</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dyld: loaded: /Users/didi/Downloads/./a.out</div><div class="line">dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</div><div class="line">dyld: loaded: /usr/lib/libSystem.B.dylib</div><div class="line">dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation</div><div class="line">…</div></pre></td></tr></table></figure>
<p>数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。</p>
<p>动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external">Dynamic Linking On OS X</a></p>
<p>dyld 做了些什么事</p>
<ul>
<li>kernel 做启动程序初始准备，开始由dyld负责。</li>
<li>基于非常简单的原始栈为 kernel 设置进程来启动自身。</li>
<li>使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。</li>
<li>立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。</li>
<li>为可执行文件运行静态初始化。</li>
<li>设置参数到可执行文件的 main 函数并调用它。</li>
<li>在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 runtime 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime  会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 Class，按照继承层级依次调用  +load 方法。</li>
<li>在 mian 函数返回后运行 static terminator。</li>
<li>在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。</li>
</ul>
<p>查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="external">RetVal/objc-runtime: objc runtime 706</a> 来进行断点查看调用的 runtime 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  +[someclass load]</div><div class="line">1  call_class_loads()</div><div class="line">2  ::call_load_methods</div><div class="line">3  ::load_images(const char *path __unused, const struct mach_header *mh)</div><div class="line">4  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</div><div class="line">11 _dyld_start</div></pre></td></tr></table></figure>
<p>在  load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。</p>
<p>prepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。</p>
<p>最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。</p>
<p>如果想了解 Cocoa 的 Fundation 库可以通过 <a href="https://github.com/AaronYi/gnustep-base" target="_blank" rel="external">GNUStep</a> 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。</p>
<p>dyld 是开源的： <a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">GitHub - opensource-apple/dyld</a></p>
<p>还可以看看苹果的 WWDC 视频 <a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="external">WWDC 2016 Session 406</a> 里讲解对启动进行优化。</p>
<p>这篇文章也不错： <a href="https://www.codeproject.com/articles/187181/dynamic-linking-of-imported-functions-in-mach-o" target="_blank" rel="external">Dynamic Linking of Imported Functions in Mach-O - CodeProject</a></p>
<h1 id="LLVM-工具链"><a href="#LLVM-工具链" class="headerlink" title="LLVM 工具链"></a>LLVM 工具链</h1><h2 id="获取-LLVM"><a href="#获取-LLVM" class="headerlink" title="获取 LLVM"></a>获取 LLVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#先下载 LLVM</span></div><div class="line">svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</div><div class="line"></div><div class="line"><span class="comment">#在 LLVM 的 tools 目录下下载 Clang</span></div><div class="line"><span class="built_in">cd</span> llvm/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</div><div class="line"></div><div class="line"><span class="comment">#在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabi</span></div><div class="line"><span class="built_in">cd</span> ../projects</div><div class="line">svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi</div><div class="line"></div><div class="line"><span class="comment">#在 Clang 的 tools 下安装 extra 工具</span></div><div class="line"><span class="built_in">cd</span> ../tools/clang/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</div></pre></td></tr></table></figure>
<h2 id="编译-LLVM"><a href="#编译-LLVM" class="headerlink" title="编译 LLVM"></a>编译 LLVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">brew install gcc</div><div class="line">brew install cmake</div><div class="line">mkdir build</div><div class="line"><span class="built_in">cd</span> build</div><div class="line">cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLLVM_TARGETS_TO_BUILD=<span class="string">"AArch64;X86"</span> -G <span class="string">"Unix Makefiles"</span> ..</div><div class="line">make j8</div><div class="line"><span class="comment">#安装</span></div><div class="line">make install</div><div class="line"><span class="comment">#如果找不到标准库，Xcode 需要安装 xcode-select --install</span></div></pre></td></tr></table></figure>
<p><img src="/uploads/deeply-analyse-llvm/01.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#如果希望是 xcodeproject 方式 build 可以使用 -GXcode</span></div><div class="line">mkdir xcodeBuild</div><div class="line"><span class="built_in">cd</span> xcodeBuild</div><div class="line">cmake -GXcode /path/to/llvm/<span class="built_in">source</span></div></pre></td></tr></table></figure>
<p><img src="/uploads/deeply-analyse-llvm/02.png" alt=""></p>
<p>在 bin 下存放着工具链，有了这些工具链就能够完成源码编译了。</p>
<p><img src="/uploads/deeply-analyse-llvm/03.png" alt=""></p>
<h2 id="LLVM-源码工程目录介绍"><a href="#LLVM-源码工程目录介绍" class="headerlink" title="LLVM 源码工程目录介绍"></a>LLVM 源码工程目录介绍</h2><ul>
<li>llvm/examples/ - 使用 LLVM IR 和 JIT 的例子。</li>
<li>llvm/include/ - 导出的头文件。</li>
<li>llvm/lib/ - 主要源文件都在这里。</li>
<li>llvm/project/ - 创建自己基于 LLVM 的项目的目录。</li>
<li>llvm/test/ - 基于 LLVM 的回归测试，健全检察。</li>
<li>llvm/suite/ - 正确性，性能和基准测试套件。</li>
<li>llvm/tools/ - 基于 lib 构建的可以执行文件，用户通过这些程序进行交互，-help 可以查看各个工具详细使用。</li>
<li>llvm/utils/ - LLVM 源代码的实用工具，比如，查找 LLC 和 LLI 生成代码差异工具， Vim 或 Emacs 的语法高亮工具等。</li>
</ul>
<h2 id="lib-目录介绍"><a href="#lib-目录介绍" class="headerlink" title="lib 目录介绍"></a>lib 目录介绍</h2><ul>
<li>llvm/lib/IR/ - 核心类比如 Instruction 和 BasicBlock。</li>
<li>llvm/lib/AsmParser/ - 汇编语言解析器。</li>
<li>llvm/lib/Bitcode/ - 读取和写入字节码</li>
<li>llvm/lib/Analysis/ - 各种对程序的分析，比如 Call Graphs，Induction Variables，Natural Loop Identification 等等。</li>
<li>llvm/lib/Transforms/ - IR-to-IR 程序的变换。</li>
<li>llvm/lib/Target/ - 对像 X86 这样机器的描述。</li>
<li>llvm/lib/CodeGen/ - 主要是代码生成，指令选择器，指令调度和寄存器分配。</li>
<li>llvm/lib/ExecutionEngine/ - 在解释执行和JIT编译场景能够直接在运行时执行字节码的库。</li>
</ul>
<h2 id="工具链命令介绍"><a href="#工具链命令介绍" class="headerlink" title="工具链命令介绍"></a>工具链命令介绍</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>llvm-as - 汇编器，将 .ll 汇编成字节码。</li>
<li>llvm-dis - 反汇编器，将字节码编成可读的 .ll 文件。</li>
<li>opt - 字节码优化器。</li>
<li>llc - 静态编译器，将字节码编译成汇编代码。</li>
<li>lli - 直接执行 LLVM 字节码。</li>
<li>llvm-link - 字节码链接器，可以把多个字节码文件链接成一个。</li>
<li>llvm-ar - 字节码文件打包器。</li>
<li>llvm-lib - LLVM lib.exe 兼容库工具。</li>
<li>llvm-nm - 列出字节码和符号表。</li>
<li>llvm-config - 打印 LLVM 编译选项。</li>
<li>llvm-diff - 对两个进行比较。</li>
<li>llvm-cov - 输出 coverage infomation。</li>
<li>llvm-profdata - Profile 数据工具。</li>
<li>llvm-stress - 生成随机 .ll 文件。</li>
<li>llvm-symbolizer - 地址对应源码位置，定位错误。</li>
<li>llvm-dwarfdump - 打印 DWARF。</li>
</ul>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul>
<li>bugpoint - 自动测试案例工具</li>
<li>llvm-extract - 从一个 LLVM 的模块里提取一个函数。</li>
<li>llvm-bcanalyzer - LLVM 字节码分析器。</li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul>
<li>FileCheck - 灵活的模式匹配文件验证器。</li>
<li>tblgen - C++ 代码生成器。</li>
<li>lit - LLVM 集成测试器。</li>
<li>llvm-build - LLVM 构建工程时需要的工具。</li>
<li>llvm-readobj - LLVM Object 结构查看器。</li>
</ul>
<h1 id="Swift-编译"><a href="#Swift-编译" class="headerlink" title="Swift 编译"></a>Swift 编译</h1><p>官网： <a href="https://github.com/apple/swift" target="_blank" rel="external">GitHub - apple/swift: The Swift Programming Language</a><br>swift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： <a href="https://swift.org/contributing/#contributing-code" target="_blank" rel="external">Swift.org - Contributing</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录</div><div class="line">brew install cmake ninja</div><div class="line">mkdir swiftsource</div><div class="line">cd swiftsource</div><div class="line"></div><div class="line">#clone 下 swift 源码</div><div class="line">git clone https://github.com/apple/swift.git</div><div class="line"></div><div class="line">#checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个</div><div class="line">./swift/utils/update-checkout —clone</div><div class="line"></div><div class="line">#查看文件夹</div><div class="line">du -h -d 1</div><div class="line"></div><div class="line">#build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#更新</div><div class="line">./swift/utils/update-checkout</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#切到指定tag和分支</div><div class="line">#tag</div><div class="line">./swift/utils/update-checkout —tag swift-3.0-RELEASE</div><div class="line">#特定分支</div><div class="line">./swift/utils/update-checkout —scheme swift-3.0-branch</div></pre></td></tr></table></figure>
<p>swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： <a href="https://swift.org/source-code/" target="_blank" rel="external">Swift.org - Source Code</a></p>
<h1 id="其它编译工具"><a href="#其它编译工具" class="headerlink" title="其它编译工具"></a>其它编译工具</h1><h2 id="js写的C-解释器JSCPP"><a href="#js写的C-解释器JSCPP" class="headerlink" title="js写的C++解释器JSCPP"></a>js写的C++解释器JSCPP</h2><p>适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：<a href="https://github.com/felixhao28/JSCPP" target="_blank" rel="external">GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript</a></p>
<h2 id="C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language"><a href="#C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language" class="headerlink" title="C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language"></a>C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language</h2><p>在 web 中有个 WebAssembly 是个标准，可以使得 web 运行 C/C++ 成为可能。当然还有其它的比如：<a href="http://c-smile.sourceforge.net/" target="_blank" rel="external">http://c-smile.sourceforge.net/</a></p>
<h1 id="资料网址"><a href="#资料网址" class="headerlink" title="资料网址"></a>资料网址</h1><ul>
<li><a href="http://llvm.org" target="_blank" rel="external">http://llvm.org</a></li>
<li><a href="http://clang.llvm.org/" target="_blank" rel="external">http://clang.llvm.org/</a></li>
<li><a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">http://www.aosabook.org/en/llvm.html</a></li>
<li><a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li><a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks" target="_blank" rel="external">Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow</a></li>
<li><a href="http://llvm.org/devmtg/" target="_blank" rel="external">LLVM Developers’ Metting</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="LLVM" scheme="http://ming1016.github.io/tags/LLVM/"/>
    
      <category term="Clang" scheme="http://ming1016.github.io/tags/Clang/"/>
    
  </entry>
  
  <entry>
    <title>iOS预加载Web页面方案</title>
    <link href="http://ming1016.github.io/2016/11/22/how-to-preload-web-in-ios/"/>
    <id>http://ming1016.github.io/2016/11/22/how-to-preload-web-in-ios/</id>
    <published>2016-11-22T13:55:35.000Z</published>
    <updated>2017-10-11T03:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以先下载Demo看看效果，Github地址：&lt; <a href="https://github.com/ming1016/STMURLCache" target="_blank" rel="external">GitHub - ming1016/STMURLCache: iOS预加载Web页面方案</a> &gt;<br>可以预加载多个网址，然后在离线状态去显示那几个网址，看看是不是都完全缓存下来了。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在需要开启预加载的地方创建<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.sCache = [STMURLCache create:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.whiteListsHost(whiteLists).whiteUserAgent(<span class="string">@"starming"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>这里是所有可设置项目，默认设置可以查看 model 的 get 方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) memoryCapacity;   <span class="comment">//内存容量</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) diskCapacity;     <span class="comment">//本地存储容量</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSUInteger</span>)) cacheTime;        <span class="comment">//缓存时间</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) subDirectory;     <span class="comment">//子目录</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">BOOL</span>)) isDownloadMode;         <span class="comment">//是否启动下载模式</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSArray</span> *)) whiteListsHost;    <span class="comment">//域名白名单</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) whiteUserAgent;   <span class="comment">//WebView的user-agent白名单</span></div><div class="line"></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) addHostWhiteList;        <span class="comment">//添加一个域名白名单</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">NSString</span> *)) addRequestUrlWhiteList;  <span class="comment">//添加请求白名单</span></div><div class="line"></div><div class="line"><span class="comment">//NSURLProtocol相关设置</span></div><div class="line">- (STMURLCacheMk *(^)(<span class="built_in">BOOL</span>)) isUsingURLProtocol; <span class="comment">//是否使用NSURLProtocol，默认使用NSURLCache</span></div></pre></td></tr></table></figure></p>
<p>也可以随时更新这些设置项<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.sCache update:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.isDownloadMode(<span class="literal">YES</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>预加载名单可以按照整个 web 页面请求进行预加载<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.sCache preLoadByWebViewWithUrls:@[<span class="string">@"http://www.v2ex.com"</span>,<span class="string">@"http://www.github.com"</span>];</div></pre></td></tr></table></figure></p>
<p>如果需要按照单个资源列表进行预加载可以使用 <em>preLoadByRequestWithUrls</em> 这个方法。</p>
<h2 id="白名单设置"><a href="#白名单设置" class="headerlink" title="白名单设置"></a>白名单设置</h2><p>对于只希望缓存特定域名或者地址的可以通过白名单进行设置，可以在创建时进行设置或者更新时设置。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *whiteListStr = <span class="string">@"www.starming.com|www.github.com|www.v2ex.com|www.baidu.com"</span>;</div><div class="line"><span class="built_in">NSMutableArray</span> *whiteLists = [<span class="built_in">NSMutableArray</span> arrayWithArray:[whiteListStr componentsSeparatedByString:<span class="string">@"|"</span>]];</div><div class="line"><span class="keyword">self</span>.sCache = [STMURLCache create:^(STMURLCacheMk *mk) &#123;</div><div class="line">    mk.whiteListsHost(whiteLists).whiteUserAgent(<span class="string">@"starming"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>这里的 <em>whiteUserAgent</em> 的设置会设置 webview 的 UserAgent，这样能够让webview以外的网络请求被过滤掉。</p>
<h2 id="基本加载缓存实现原理"><a href="#基本加载缓存实现原理" class="headerlink" title="基本加载缓存实现原理"></a>基本加载缓存实现原理</h2><p>创建 <em>STMURLCache</em> 后设置 <em>NSURLCache</em> 的 <em>URLCache</em> ，在 <em>cachedResponseForRequest</em> 方法中获取 <em>NSURLRequest</em> 判断白名单，检验是否有与之对应的 Cache ，有就使用本地数据返回 <em>NSCachedURLResponse</em> ，没有就通过网络获取数据数据缓存。 <em>STMURLCache</em> 对象释放时将 <em>NSURLCache</em> 设置为不缓存，表示这次预加载完成不需要再缓存。当缓存空间超出设置大小会将其清空。</p>
<p>使用 <em>NSURLProtocol</em> 这种原理基本类似。</p>
<h2 id="白名单实现原理"><a href="#白名单实现原理" class="headerlink" title="白名单实现原理"></a>白名单实现原理</h2><p>创建域名列表设置项 <em>whiteListsHost</em> 和 <em>userAgent</em> 设置项，在创建和更新时对其进行设置。在网络请求开始通过设置项进行过滤。具体实现如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对于域名白名单的过滤</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.whiteListsHost.count &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">id</span> isExist = [<span class="keyword">self</span>.mk.cModel.whiteListsHost objectForKey:[<span class="keyword">self</span> hostFromRequest:request]];</div><div class="line">    <span class="keyword">if</span> (!isExist) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//User-Agent来过滤</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.whiteUserAgent.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">NSString</span> *uAgent = [request.allHTTPHeaderFields objectForKey:<span class="string">@"User-Agent"</span>];</div><div class="line">    <span class="keyword">if</span> (uAgent) &#123;</div><div class="line">        <span class="keyword">if</span> (![uAgent hasSuffix:<span class="keyword">self</span>.mk.cModel.whiteUserAgent]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="具体缓存实现"><a href="#具体缓存实现" class="headerlink" title="具体缓存实现"></a>具体缓存实现</h2><p>缓存的实现有两种，一种是 <em>NSURLCache</em> 另一种是 <em>NSURLProtocol</em> ， <em>STMURLCache</em> 同时支持了这两种，通过 <em>STMURLCacheModel</em> 里的 <em>isUsingURLProtocol</em> 设置项来选择使用哪个。</p>
<h3 id="NSURLCache的实现"><a href="#NSURLCache的实现" class="headerlink" title="NSURLCache的实现"></a>NSURLCache的实现</h3><p>没有缓存的 request 会对其进行请求将获取数据按照hash地址存两份于本地，一份是数据，一份记录时间和类型，时间记录可以用于判断失效时间。对于判断是否有缓存可以根据请求地址对应的文件进行判断。具体实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSCachedURLResponse</span> *)localCacheResponeWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    __block <span class="built_in">NSCachedURLResponse</span> *cachedResponse = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span> filePathFromRequest:request isInfo:<span class="literal">NO</span>];</div><div class="line">    <span class="built_in">NSString</span> *otherInfoPath = [<span class="keyword">self</span> filePathFromRequest:request isInfo:<span class="literal">YES</span>];</div><div class="line">    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</div><div class="line">    <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="keyword">if</span> ([fm fileExistsAtPath:filePath]) &#123;</div><div class="line">        <span class="comment">//有缓存文件的情况</span></div><div class="line">        <span class="built_in">BOOL</span> expire = <span class="literal">false</span>;</div><div class="line">        <span class="built_in">NSDictionary</span> *otherInfo = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:otherInfoPath];</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cacheTime &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSInteger</span> createTime = [[otherInfo objectForKey:<span class="string">@"time"</span>] integerValue];</div><div class="line">            <span class="keyword">if</span> (createTime + <span class="keyword">self</span>.cacheTime &lt; [date timeIntervalSince1970]) &#123;</div><div class="line">                expire = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (expire == <span class="literal">false</span>) &#123;</div><div class="line">            <span class="comment">//从缓存里读取数据</span></div><div class="line">            <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</div><div class="line">            <span class="built_in">NSURLResponse</span> *response = [[<span class="built_in">NSURLResponse</span> alloc] initWithURL:request.URL MIMEType:[otherInfo objectForKey:<span class="string">@"MIMEType"</span>] expectedContentLength:data.length textEncodingName:[otherInfo objectForKey:<span class="string">@"textEncodingName"</span>]];</div><div class="line">            <span class="built_in">NSCachedURLResponse</span> *cachedResponse = [[<span class="built_in">NSCachedURLResponse</span> alloc] initWithResponse:response data:data];</div><div class="line">            <span class="keyword">return</span> cachedResponse;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//cache失效了</span></div><div class="line">            [fm removeItemAtPath:filePath error:<span class="literal">nil</span>];      <span class="comment">//清除缓存data</span></div><div class="line">            [fm removeItemAtPath:otherInfoPath error:<span class="literal">nil</span>]; <span class="comment">//清除缓存其它信息</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//从网络读取</span></div><div class="line">        <span class="keyword">self</span>.isSavedOnDisk = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">id</span> isExist = [<span class="keyword">self</span>.responseDic objectForKey:request.URL.absoluteString];</div><div class="line">        <span class="keyword">if</span> (isExist == <span class="literal">nil</span>) &#123;</div><div class="line">            [<span class="keyword">self</span>.responseDic setValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">TRUE</span>] forKey:request.URL.absoluteString];</div><div class="line">            <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</div><div class="line">            <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">                <span class="keyword">if</span> (error) &#123;</div><div class="line">                    cachedResponse = <span class="literal">nil</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">NSDictionary</span> *dic = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%f"</span>,[date timeIntervalSince1970]],<span class="string">@"time"</span>,response.MIMEType,<span class="string">@"MIMEType"</span>,response.textEncodingName,<span class="string">@"textEncodingName"</span>, <span class="literal">nil</span>];</div><div class="line">                    <span class="built_in">BOOL</span> resultO = [dic writeToFile:otherInfoPath atomically:<span class="literal">YES</span>];</div><div class="line">                    <span class="built_in">BOOL</span> result = [data writeToFile:filePath atomically:<span class="literal">YES</span>];</div><div class="line">                    <span class="keyword">if</span> (resultO == <span class="literal">NO</span> || result == <span class="literal">NO</span>) &#123;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    &#125;</div><div class="line">                    cachedResponse = [[<span class="built_in">NSCachedURLResponse</span> alloc] initWithResponse:response data:data];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            [task resume];</div><div class="line">            <span class="keyword">return</span> cachedResponse;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="NSURLProtocol的实现"><a href="#NSURLProtocol的实现" class="headerlink" title="NSURLProtocol的实现"></a>NSURLProtocol的实现</h3><p>在设置配置项和更新配置项时需要创建一个 <em>STMURLCacheModel</em> 的单例来进行设置和更新配置项给 NSURLProtocol 的实现来使用。通过 isUsingURLProtocol 设置项区分， NSURLProtocol 是通过registerClass方式将protocol实现的进行注册。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (STMURLCache *)configWithMk &#123;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.mk.cModel.isSavedOnDisk = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.isUsingURLProtocol) &#123;</div><div class="line">        STMURLCacheModel *sModel = [STMURLCacheModel shareInstance];</div><div class="line">        sModel.cacheTime = <span class="keyword">self</span>.mk.cModel.cacheTime;</div><div class="line">        sModel.diskCapacity = <span class="keyword">self</span>.mk.cModel.diskCapacity;</div><div class="line">        sModel.diskPath = <span class="keyword">self</span>.mk.cModel.diskPath;</div><div class="line">        sModel.cacheFolder = <span class="keyword">self</span>.mk.cModel.cacheFolder;</div><div class="line">        sModel.subDirectory = <span class="keyword">self</span>.mk.cModel.subDirectory;</div><div class="line">        sModel.whiteUserAgent = <span class="keyword">self</span>.mk.cModel.whiteUserAgent;</div><div class="line">        sModel.whiteListsHost = <span class="keyword">self</span>.mk.cModel.whiteListsHost;</div><div class="line">        [<span class="built_in">NSURLProtocol</span> registerClass:[STMURLProtocol <span class="keyword">class</span>]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="built_in">NSURLCache</span> setSharedURLCache:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关闭时两者也是不同的，通过设置项进行区分<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mk.cModel.isUsingURLProtocol) &#123;</div><div class="line">        [<span class="built_in">NSURLProtocol</span> unregisterClass:[STMURLProtocol <span class="keyword">class</span>]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSURLCache</span> *c = [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">0</span> diskCapacity:<span class="number">0</span> diskPath:<span class="literal">nil</span>];</div><div class="line">        [<span class="built_in">NSURLCache</span> setSharedURLCache:c];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.mk.cModel checkCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>白名单处理还有读取缓存和前者都类似，但是在缓存Data时 <em>NSURLCached</em> 的方案里是通过发起一次新的请求来获取数据，而 <em>NSURLProtocol</em> 在 <em>NSURLConnection</em> 的 Delegate 里可以获取到，少了一次网络的请求，这里需要注意的是在 - (void) connection:(NSURLConnection <em>)connection didReceiveData:(NSData </em>)data 每次从这个回调里获取的数据不是完整的，要在 - (void) connectionDidFinishLoading:(NSURLConnection *)connection 这个会调里将分段数据拼接成完整的数据保存下来。具体完整的代码实现可以看 STMURLProtocol 里的代码实现。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过 <em>map</em> 网络请求可以缓存请求，也可以 <em>mock</em> 接口请求进行测试。</p>
<p>完整代码：&lt; <a href="https://github.com/ming1016/STMURLCache" target="_blank" rel="external">GitHub - ming1016/STMURLCache: iOS预加载Web页面方案</a> &gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以先下载Demo看看效果，Github地址：&amp;lt; &lt;a href=&quot;https://github.com/ming1016/STMURLCache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub - ming1016/STMURLCach
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="UIWebView" scheme="http://ming1016.github.io/tags/UIWebView/"/>
    
      <category term="NSURLProtocol" scheme="http://ming1016.github.io/tags/NSURLProtocol/"/>
    
  </entry>
  
  <entry>
    <title>使用Swift3开发了个macOS的程序可以检测出objc项目中无用方法，然后一键全部清理</title>
    <link href="http://ming1016.github.io/2016/11/17/use-swift3-build-macos-program-to-clear-unuse-method/"/>
    <id>http://ming1016.github.io/2016/11/17/use-swift3-build-macos-program-to-clear-unuse-method/</id>
    <published>2016-11-17T13:51:58.000Z</published>
    <updated>2017-10-11T03:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>当项目越来越大，引入第三方库越来越多，上架的APP体积也会越来越大，对于用户来说体验必定是不好的。在清理资源，编译选项优化，清理无用类等完成后，能够做而且效果会比较明显的就只有清理无用函数了。现有一种方案是根据Linkmap文件取到objc的所有类方法和实例方法。再用工具逆向可执行文件里引用到的方法名，求个差集列出无用方法。这个方案有些比较麻烦的地方，因为检索出的无用方法没法确定能够直接删除，还需要挨个检索人工判断是否可以删除，这样每次要清理时都需要这样人工排查一遍是非常耗时耗力的。</p>
<p>这样就只有模拟编译过程对代码进行深入分析才能够找出确定能够删除的方法。具体效果可以先试试看，程序代码在：<a href="https://github.com/ming1016/SMCheckProject" target="_blank" rel="external">https://github.com/ming1016/SMCheckProject</a> 选择工程目录后程序就开始检索无用方法然后将其注释掉。</p>
<h2 id="设置结构体-😚"><a href="#设置结构体-😚" class="headerlink" title="设置结构体 😚"></a>设置结构体 😚</h2><p>首先确定结构，类似先把 <em>OC</em> 文件根据语法画出整体结构。先看看 <em>OC Runtime</em> 里是如何设计的结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span>  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*类*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span>  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">long</span> version;</div><div class="line">    <span class="keyword">long</span> info;</div><div class="line">    <span class="keyword">long</span> instance_size;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*成员变量列表*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> ivar_count               </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                    </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> <span class="title">ivar_list</span>[1]</span></div><div class="line">&#125;      </div><div class="line"></div><div class="line">/*成员变量结构体*/</div><div class="line"><span class="title">struct</span> <span class="title">objc_ivar</span> &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name</div><div class="line">    <span class="keyword">char</span> *ivar_type</div><div class="line">    <span class="keyword">int</span> ivar_offset</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space      </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;    </div><div class="line"></div><div class="line"><span class="comment">/*方法列表*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> &#123;</span>  </div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">obsolete</span>;</span></div><div class="line">    <span class="keyword">int</span> method_count;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*方法结构体*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> &#123;</span>  </div><div class="line">    SEL method_name;</div><div class="line">    <span class="keyword">char</span> *method_types;    <span class="comment">/* a string representing argument/return types */</span></div><div class="line">    IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>一个 class 只有少量函数会被调用，为了减少较大的遍历所以创建一个 <em>objc_cache</em> ，在找到一个方法后将 <em>method_name</em> 作为 key，将 <em>method_imp</em> 做值，再次发起时就可以直接在 cache 里找。</p>
<p>使用 swift 创建类似的结构体，做些修改<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">//文件</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="type">FileType</span>.<span class="type">FileH</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> content = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> methods = [<span class="type">Method</span>]() <span class="comment">//所有方法</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> imports = [<span class="type">Import</span>]() <span class="comment">//引入类</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//引入</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Import</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> fileName = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对象</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> superObject = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> properties = [<span class="type">Property</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> methods = [<span class="type">Method</span>]()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//成员变量</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Property</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> classMethodTf = <span class="literal">false</span> <span class="comment">//+ or -</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnType = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnTypePointTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> returnTypeBlockTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> params = [<span class="type">MethodParam</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> usedMethod = [<span class="type">Method</span>]()</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> filePath = <span class="string">""</span> <span class="comment">//定义方法的文件路径，方便修改文件使用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> pnameId = <span class="string">""</span>  <span class="comment">//唯一标识，便于快速比较</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParam</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> typePointTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> iName = <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">//todo:更多类型</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type = <span class="number">0</span> <span class="comment">//0是值类型 1是指针</span></div><div class="line">&#125;</div><div class="line">```swift</div><div class="line"></div><div class="line">## 开始语法解析 😈</div><div class="line">首先遍历目录下所有的文件。</div><div class="line">```swift</div><div class="line"><span class="keyword">let</span> fileFolderPath = <span class="keyword">self</span>.selectFolder()</div><div class="line"><span class="keyword">let</span> fileFolderStringPath = fileFolderPath.replacingOccurrences(of: <span class="string">"file://"</span>, with: <span class="string">""</span>)</div><div class="line"><span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span>;</div><div class="line"><span class="comment">//深度遍历</span></div><div class="line"><span class="keyword">let</span> enumeratorAtPath = fileManager.enumerator(atPath: fileFolderStringPath)</div><div class="line"><span class="comment">//过滤文件后缀</span></div><div class="line"><span class="keyword">let</span> filterPath = <span class="type">NSArray</span>(array: (enumeratorAtPath?.allObjects)!).pathsMatchingExtensions([<span class="string">"h"</span>,<span class="string">"m"</span>])</div></pre></td></tr></table></figure></p>
<p>然后将注释排除在分析之外，这样做能够有效避免无用的解析。</p>
<p>分析是否需要按照行来切割，在 <em>@interface</em> ， <em>@end</em> 和 <em>@ implementation</em> ， <em>@end</em> 里面不需要换行，按照;符号，外部需要按行来。所以两种切割都需要。</p>
<p>先定义语法标识符<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sb</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> add = <span class="string">"+"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> minus = <span class="string">"-"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> rBktL = <span class="string">"("</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> rBktR = <span class="string">")"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> asterisk = <span class="string">"*"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> colon = <span class="string">":"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> semicolon = <span class="string">";"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> divide = <span class="string">"/"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> agBktL = <span class="string">"&lt;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> agBktR = <span class="string">"&gt;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> quotM = <span class="string">"\""</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> pSign = <span class="string">"#"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> braceL = <span class="string">"&#123;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> braceR = <span class="string">"&#125;"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> bktL = <span class="string">"["</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> bktR = <span class="string">"]"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> qM = <span class="string">"?"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> upArrow = <span class="string">"^"</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> inteface = <span class="string">"@interface"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> implementation = <span class="string">"@implementation"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> end = <span class="string">"@end"</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> selector = <span class="string">"@selector"</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> space = <span class="string">" "</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> newLine = <span class="string">"\n"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就要开始根据标记符号来进行切割分组了，使用 <em>Scanner</em> ，具体方式如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据代码文件解析出一个根据标记符切分的数组</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createOCTokens</span>(<span class="title">conent</span>:<span class="title">String</span>) -&gt; [<span class="title">String</span>] </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = conent</div><div class="line"></div><div class="line">    str = <span class="keyword">self</span>.dislodgeAnnotaion(content: str)</div><div class="line"></div><div class="line">    <span class="comment">//开始扫描切割</span></div><div class="line">    <span class="keyword">let</span> scanner = <span class="type">Scanner</span>(string: str)</div><div class="line">    <span class="keyword">var</span> tokens = [<span class="type">String</span>]()</div><div class="line">    <span class="comment">//Todo:待处理符号,.</span></div><div class="line">    <span class="keyword">let</span> operaters = [<span class="type">Sb</span>.add,<span class="type">Sb</span>.minus,<span class="type">Sb</span>.rBktL,<span class="type">Sb</span>.rBktR,<span class="type">Sb</span>.asterisk,<span class="type">Sb</span>.colon,<span class="type">Sb</span>.semicolon,<span class="type">Sb</span>.divide,<span class="type">Sb</span>.agBktL,<span class="type">Sb</span>.agBktR,<span class="type">Sb</span>.quotM,<span class="type">Sb</span>.pSign,<span class="type">Sb</span>.braceL,<span class="type">Sb</span>.braceR,<span class="type">Sb</span>.bktL,<span class="type">Sb</span>.bktR,<span class="type">Sb</span>.qM]</div><div class="line">    <span class="keyword">var</span> operatersString = <span class="string">""</span></div><div class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> operaters &#123;</div><div class="line">        operatersString = operatersString.appending(op)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> <span class="keyword">set</span> = <span class="type">CharacterSet</span>()</div><div class="line">    <span class="keyword">set</span>.insert(charactersIn: operatersString)</div><div class="line">    <span class="keyword">set</span>.formUnion(<span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> !scanner.isAtEnd &#123;</div><div class="line">        <span class="keyword">for</span> operater <span class="keyword">in</span> operaters &#123;</div><div class="line">            <span class="keyword">if</span> (scanner.scanString(operater, into: <span class="literal">nil</span>)) &#123;</div><div class="line">                tokens.append(operater)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> result:<span class="type">NSString</span>?</div><div class="line">        result = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span> scanner.scanUpToCharacters(from: <span class="keyword">set</span>, into: &amp;result) &#123;</div><div class="line">            tokens.append(result <span class="keyword">as</span>! <span class="type">String</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    tokens = tokens.<span class="built_in">filter</span> &#123;</div><div class="line">        $<span class="number">0</span> != <span class="type">Sb</span>.space</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tokens;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行解析的方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据代码文件解析出一个根据行切分的数组</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createOCLines</span>(<span class="title">content</span>:<span class="title">String</span>) -&gt; [<span class="title">String</span>] </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = content</div><div class="line">    str = <span class="keyword">self</span>.dislodgeAnnotaion(content: str)</div><div class="line">    <span class="keyword">let</span> strArr = str.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">    <span class="keyword">return</span> strArr</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="根据结构将定义的方法取出-🤖"><a href="#根据结构将定义的方法取出-🤖" class="headerlink" title="根据结构将定义的方法取出 🤖"></a>根据结构将定义的方法取出 🤖</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithMemoryCapacity:(<span class="built_in">NSUInteger</span>)memoryCapacity diskCapacity:(<span class="built_in">NSUInteger</span>)diskCapacity diskPath:(<span class="built_in">NSString</span> *)path cacheTime:(<span class="built_in">NSInteger</span>)cacheTime subDirectory:(<span class="built_in">NSString</span>*)subDirectory;</div></pre></td></tr></table></figure>
<p>这里按照语法规则顺序取出即可，将方法名，返回类型，参数名，参数类型记录。这里需要注意 <em>Block</em> 类型的参数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (STMPartMaker *(^)(STMPartColorType))colorTypeIs;</div></pre></td></tr></table></figure></p>
<p>这种类型中还带有括号的语法的解析，这里用到的方法是对括号进行计数，左括号加一右括号减一的方式取得完整方法。</p>
<p>获得这些数据后就可以开始检索定义的方法了。我写了一个类专门用来获得所有定义的方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">parsingWithArray</span>(<span class="title">arr</span>:<span class="title">Array</span>&lt;<span class="title">String</span>&gt;) -&gt; <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> mtd = <span class="type">Method</span>()</div><div class="line">    <span class="keyword">var</span> returnTypeTf = <span class="literal">false</span> <span class="comment">//是否取得返回类型</span></div><div class="line">    <span class="keyword">var</span> parsingTf = <span class="literal">false</span> <span class="comment">//解析中</span></div><div class="line">    <span class="keyword">var</span> bracketCount = <span class="number">0</span> <span class="comment">//括弧计数</span></div><div class="line">    <span class="keyword">var</span> step = <span class="number">0</span> <span class="comment">//1获取参数名，2获取参数类型，3获取iName</span></div><div class="line">    <span class="keyword">var</span> types = [<span class="type">String</span>]()</div><div class="line">    <span class="keyword">var</span> methodParam = <span class="type">MethodParam</span>()</div><div class="line">    <span class="comment">//print("\(arr)")</span></div><div class="line">    <span class="keyword">for</span> <span class="keyword">var</span> tk <span class="keyword">in</span> arr &#123;</div><div class="line">        tk = tk.replacingOccurrences(of: <span class="type">Sb</span>.newLine, with: <span class="string">""</span>)</div><div class="line">        <span class="keyword">if</span> (tk == <span class="type">Sb</span>.semicolon || tk == <span class="type">Sb</span>.braceL) &amp;&amp; step != <span class="number">1</span> &#123;</div><div class="line">            <span class="keyword">var</span> shouldAdd = <span class="literal">false</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> mtd.params.<span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</div><div class="line">                <span class="comment">//处理这种- (void)initWithC:(type)m m2:(type2)i, ... NS_REQUIRES_NIL_TERMINATION;入参为多参数情况</span></div><div class="line">                <span class="keyword">if</span> methodParam.type.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">                    shouldAdd = <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                shouldAdd = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> shouldAdd &#123;</div><div class="line">                mtd.params.append(methodParam)</div><div class="line">                mtd.pnameId = mtd.pnameId.appending(<span class="string">"<span class="subst">\(methodParam.name)</span>:"</span>)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktL &#123;</div><div class="line">            bracketCount += <span class="number">1</span></div><div class="line">            parsingTf = <span class="literal">true</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktR &#123;</div><div class="line">            bracketCount -= <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> bracketCount == <span class="number">0</span> &#123;</div><div class="line">                <span class="keyword">var</span> typeString = <span class="string">""</span></div><div class="line">                <span class="keyword">for</span> typeTk <span class="keyword">in</span> types &#123;</div><div class="line">                    typeString = typeString.appending(typeTk)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> !returnTypeTf &#123;</div><div class="line">                    <span class="comment">//完成获取返回</span></div><div class="line">                    mtd.returnType = typeString</div><div class="line">                    step = <span class="number">1</span></div><div class="line">                    returnTypeTf = <span class="literal">true</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> step == <span class="number">2</span> &#123;</div><div class="line">                        methodParam.type = typeString</div><div class="line">                        step = <span class="number">3</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//括弧结束后的重置工作</span></div><div class="line">                parsingTf = <span class="literal">false</span></div><div class="line">                types = []</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> parsingTf &#123;</div><div class="line">            types.append(tk)</div><div class="line">            <span class="comment">//todo:返回block类型会使用.设置值的方式，目前获取用过方法方式没有.这种的解析，暂时作为</span></div><div class="line">            <span class="keyword">if</span> tk == <span class="type">Sb</span>.upArrow &#123;</div><div class="line">                mtd.returnTypeBlockTf = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">            step = <span class="number">2</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> step == <span class="number">1</span> &#123;</div><div class="line">            <span class="keyword">if</span> tk == <span class="string">"initWithCoordinate"</span> &#123;</div><div class="line">                <span class="comment">//</span></div><div class="line">            &#125;</div><div class="line">            methodParam.name = tk</div><div class="line">            step = <span class="number">0</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> step == <span class="number">3</span> &#123;</div><div class="line">            methodParam.iName = tk</div><div class="line">            step = <span class="number">1</span></div><div class="line">            mtd.params.append(methodParam)</div><div class="line">            mtd.pnameId = mtd.pnameId.appending(<span class="string">"<span class="subst">\(methodParam.name)</span>:"</span>)</div><div class="line">            methodParam = <span class="type">MethodParam</span>()</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk != <span class="type">Sb</span>.minus &amp;&amp; tk != <span class="type">Sb</span>.add &#123;</div><div class="line">            methodParam.name = tk</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;<span class="comment">//遍历</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> mtd</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法大概的思路就是根据标记符设置不同的状态，然后将获取的信息放入定义的结构中。</p>
<h2 id="使用过的方法的解析-😱"><a href="#使用过的方法的解析-😱" class="headerlink" title="使用过的方法的解析 😱"></a>使用过的方法的解析 😱</h2><p>进行使用过的方法解析前需要处理的事情</p>
<ul>
<li>@“…” 里面的数据，因为这里面是允许我们定义的标识符出现的。</li>
<li>递归出文件中 import 所有的类，根据对类的使用可以清除无用的 import</li>
<li>继承链的获取。</li>
<li>解析获取实例化了的成员变量列表。在解析时需要依赖列表里的成员变量名和变量的类进行方法的完整获取。</li>
</ul>
<p>简单的方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[view update:status animation:<span class="literal">YES</span>];</div></pre></td></tr></table></figure></p>
<p>从左到右按照 : 符号获取</p>
<p>方法嵌套调用，下面这种情况如何解析出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[[[[[SMNetManager shareInstance] fetchAllFeedWithModelArray:<span class="keyword">self</span>.feeds] map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSUInteger</span> index = [value integerValue];</div><div class="line">    <span class="keyword">self</span>.feeds[index] = [SMNetManager shareInstance].feeds[index];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.feeds[index];</div><div class="line">&#125;] doCompleted:^&#123;</div><div class="line">    <span class="comment">//抓完所有的feeds</span></div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"fetch complete"</span>);</div><div class="line">    <span class="comment">//完成置为默认状态</span></div><div class="line">    <span class="keyword">self</span>.tbHeaderLabel.text = <span class="string">@""</span>;</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>;</div><div class="line">    [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">NO</span>;</div><div class="line">    <span class="comment">//下拉刷新关闭</span></div><div class="line">    [<span class="keyword">self</span>.tableView.mj_header endRefreshing];</div><div class="line">    <span class="comment">//更新列表</span></div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    <span class="comment">//检查是否需要增加源</span></div><div class="line">    <span class="keyword">if</span> ([SMFeedStore defaultFeeds].count &gt; <span class="keyword">self</span>.feeds.count) &#123;</div><div class="line">        <span class="keyword">self</span>.feeds = [SMFeedStore defaultFeeds];</div><div class="line">        [<span class="keyword">self</span> fetchAllFeeds];</div><div class="line">    &#125;</div><div class="line">&#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(SMFeedModel *feedModel) &#123;</div><div class="line">    <span class="comment">//抓完一个</span></div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.tbHeaderView;</div><div class="line">    <span class="comment">//显示抓取状态</span></div><div class="line">    <span class="keyword">self</span>.fetchingCount += <span class="number">1</span>;</div><div class="line">    <span class="keyword">self</span>.tbHeaderLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"正在获取%@...(%lu/%lu)"</span>,feedModel.title,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.fetchingCount,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.feeds.count];</div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>一开始会想到使用递归，以前我做 <em>STMAssembleView</em> 时就是使用的递归，这样时间复杂度就会是 O(nlogn) ，这次我换了个思路，将复杂度降低到了 n ，思路大概是 创建一个字典，键值就是深度，从左到右深度的增加根据 <em>[</em> 符号，减少根据 <em>]</em> 符号，值会在 <em>[</em> 时创建一个 <em>Method</em> 结构体，根据]来完成结构体，将其添加到 <em>methods</em> 数组中 。</p>
<p>具体实现如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">parsing</span>(<span class="title">contentArr</span>:<span class="title">Array</span>&lt;<span class="title">String</span>&gt;, <span class="title">inMethod</span>:<span class="title">Method</span>) -&gt; <span class="title">Method</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> mtdIn = inMethod</div><div class="line">    <span class="comment">//处理用过的方法</span></div><div class="line">    <span class="comment">//todo:还要过滤@""这种情况</span></div><div class="line">    <span class="keyword">var</span> psBrcStep = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> uMtdDic = [<span class="type">Int</span>:<span class="type">Method</span>]()</div><div class="line">    <span class="keyword">var</span> preTk = <span class="string">""</span></div><div class="line">    <span class="comment">//处理?:这种条件判断简写方式</span></div><div class="line">    <span class="keyword">var</span> psCdtTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> psCdtStep = <span class="number">0</span></div><div class="line">    <span class="comment">//判断selector</span></div><div class="line">    <span class="keyword">var</span> psSelectorTf = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> preSelectorTk = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> selectorMtd = <span class="type">Method</span>()</div><div class="line">    <span class="keyword">var</span> selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line"></div><div class="line">    uMtdDic[psBrcStep] = <span class="type">Method</span>() <span class="comment">//初始时就实例化一个method，避免在define里定义只定义]符号</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="keyword">var</span> tk <span class="keyword">in</span> contentArr &#123;</div><div class="line">        <span class="comment">//selector处理</span></div><div class="line">        <span class="keyword">if</span> psSelectorTf &#123;</div><div class="line">            <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">                selectorMtdPar.name = preSelectorTk</div><div class="line">                selectorMtd.params.append(selectorMtdPar)</div><div class="line">                selectorMtd.pnameId += <span class="string">"<span class="subst">\(selectorMtdPar.name)</span>:"</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.rBktR &#123;</div><div class="line">                mtdIn.usedMethod.append(selectorMtd)</div><div class="line">                psSelectorTf = <span class="literal">false</span></div><div class="line">                selectorMtd = <span class="type">Method</span>()</div><div class="line">                selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                preSelectorTk = tk</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> tk == <span class="type">Sb</span>.selector &#123;</div><div class="line">            psSelectorTf = <span class="literal">true</span></div><div class="line">            selectorMtd = <span class="type">Method</span>()</div><div class="line">            selectorMtdPar = <span class="type">MethodParam</span>()</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//通常处理</span></div><div class="line">        <span class="keyword">if</span> tk == <span class="type">Sb</span>.bktL &#123;</div><div class="line">            <span class="keyword">if</span> psCdtTf &#123;</div><div class="line">                psCdtStep += <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">            psBrcStep += <span class="number">1</span></div><div class="line">            uMtdDic[psBrcStep] = <span class="type">Method</span>()</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.bktR &#123;</div><div class="line">            <span class="keyword">if</span> psCdtTf &#123;</div><div class="line">                psCdtStep -= <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (uMtdDic[psBrcStep]?.params.<span class="built_in">count</span>)! &gt; <span class="number">0</span> &#123;</div><div class="line">                mtdIn.usedMethod.append(uMtdDic[psBrcStep]!)</div><div class="line">            &#125;</div><div class="line">            psBrcStep -= <span class="number">1</span></div><div class="line">            <span class="comment">//[]不配对的容错处理</span></div><div class="line">            <span class="keyword">if</span> psBrcStep &lt; <span class="number">0</span> &#123;</div><div class="line">                psBrcStep = <span class="number">0</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.colon &#123;</div><div class="line">            <span class="comment">//条件简写情况处理</span></div><div class="line">            <span class="keyword">if</span> psCdtTf &amp;&amp; psCdtStep == <span class="number">0</span> &#123;</div><div class="line">                psCdtTf = <span class="literal">false</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//dictionary情况处理@"key":@"value"</span></div><div class="line">            <span class="keyword">if</span> preTk == <span class="type">Sb</span>.quotM || preTk == <span class="string">"respondsToSelector"</span> &#123;</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> prm = <span class="type">MethodParam</span>()</div><div class="line">            prm.name = preTk</div><div class="line">            <span class="keyword">if</span> prm.name != <span class="string">""</span> &#123;</div><div class="line">                uMtdDic[psBrcStep]?.params.append(prm)</div><div class="line">                uMtdDic[psBrcStep]?.pnameId = (uMtdDic[psBrcStep]?.pnameId.appending(<span class="string">"<span class="subst">\(prm.name)</span>:"</span>))!</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tk == <span class="type">Sb</span>.qM &#123;</div><div class="line">            psCdtTf = <span class="literal">true</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tk = tk.replacingOccurrences(of: <span class="type">Sb</span>.newLine, with: <span class="string">""</span>)</div><div class="line">            preTk = tk</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> mtdIn</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在设置 <em>Method</em> 结构体时将参数名拼接起来成为 <em>Method</em> 的识别符用于后面处理时的快速比对。</p>
<p>解析使用过的方法时有几个问题需要注意下<br>1.在方法内使用的方法，会有 <em>respondsToSelector</em> ， <em>@selector</em> 还有条件简写语法的情况需要单独处理下。<br>2.在 <em>#define</em> 里定义使用了方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define CLASS_VALUE(x)    [NSValue valueWithNonretainedObject:(x)]</span></div></pre></td></tr></table></figure></p>
<h2 id="找出无用方法-😄"><a href="#找出无用方法-😄" class="headerlink" title="找出无用方法 😄"></a>找出无用方法 😄</h2><p>获取到所有使用方法后进行去重，和定义方法进行匹对求出差集，即全部未使用的方法。</p>
<h2 id="去除无用方法-😎"><a href="#去除无用方法-😎" class="headerlink" title="去除无用方法 😎"></a>去除无用方法 😎</h2><p>比对后获得无用方法后就要开始注释掉他们了。遍历未使用的方法，根据先前 <em>Method</em> 结构体中定义了方法所在文件路径，根据文件集结构和File的结构体，可以避免 IO ，直接获取方法对应的文件内容和路径。<br>对文件内容进行行切割，逐行检测方法名和参数，匹对时开始对行加上注释， h 文件已;符号为结束， m 文件会对大括号进行计数，逐行注释。实现的方法具体如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除指定的一组方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">delete</span>(<span class="title">methods</span>:[<span class="title">Method</span>]) </span>&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"无用方法"</span>)</div><div class="line">    <span class="keyword">for</span> aMethod <span class="keyword">in</span> methods &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(File.desDefineMethodParams(paramArr: aMethod.params)</span>)"</span>)</div><div class="line"></div><div class="line">        <span class="comment">//开始删除</span></div><div class="line">        <span class="comment">//continue</span></div><div class="line">        <span class="keyword">var</span> hContent = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mContent = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mFilePath = aMethod.filePath</div><div class="line">        <span class="keyword">if</span> aMethod.filePath.hasSuffix(<span class="string">".h"</span>) &#123;</div><div class="line">            hContent = <span class="keyword">try</span>! <span class="type">String</span>(contentsOf: <span class="type">URL</span>(string:aMethod.filePath)!, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">            <span class="comment">//todo:因为先处理了h文件的情况</span></div><div class="line">            mFilePath = aMethod.filePath.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>(charactersIn: <span class="string">"h"</span>)) <span class="comment">//去除头尾字符集</span></div><div class="line">            mFilePath = mFilePath.appending(<span class="string">"m"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> mFilePath.hasSuffix(<span class="string">".m"</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                mContent = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: <span class="type">URL</span>(string:mFilePath)!, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">            &#125; <span class="keyword">catch</span> &#123;</div><div class="line">                mContent = <span class="string">""</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> hContentArr = hContent.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">        <span class="keyword">let</span> mContentArr = mContent.components(separatedBy: <span class="type">CharacterSet</span>.newlines)</div><div class="line">        <span class="comment">//print(mContentArr)</span></div><div class="line">        <span class="comment">//----------------h文件------------------</span></div><div class="line">        <span class="keyword">var</span> psHMtdTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">var</span> hMtds = [<span class="type">String</span>]()</div><div class="line">        <span class="keyword">var</span> hMtdStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> hMtdAnnoStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> hContentCleaned = <span class="string">""</span></div><div class="line">        <span class="keyword">for</span> hOneLine <span class="keyword">in</span> hContentArr &#123;</div><div class="line">            <span class="keyword">var</span> line = hOneLine.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasPrefix(<span class="type">Sb</span>.minus) || line.hasPrefix(<span class="type">Sb</span>.add) &#123;</div><div class="line">                psHMtdTf = <span class="literal">true</span></div><div class="line">                hMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                hMtdStr = hMtdStr.appending(hOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                hMtdAnnoStr += <span class="string">"//-----由SMCheckProject工具删除-----\n//"</span></div><div class="line">                hMtdAnnoStr += hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                line = <span class="keyword">self</span>.dislodgeAnnotaionInOneLine(content: line)</div><div class="line">                line = line.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> psHMtdTf &#123;</div><div class="line">                hMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                hMtdStr = hMtdStr.appending(hOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                hMtdAnnoStr += <span class="string">"//"</span> + hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                line = <span class="keyword">self</span>.dislodgeAnnotaionInOneLine(content: line)</div><div class="line">                line = line.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                hContentCleaned += hOneLine + <span class="type">Sb</span>.newLine</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasSuffix(<span class="type">Sb</span>.semicolon) &amp;&amp; psHMtdTf&#123;</div><div class="line">                psHMtdTf = <span class="literal">false</span></div><div class="line"></div><div class="line">                <span class="keyword">let</span> methodPnameId = <span class="type">ParsingMethod</span>.parsingWithArray(arr: hMtds).pnameId</div><div class="line">                <span class="keyword">if</span> aMethod.pnameId == methodPnameId &#123;</div><div class="line">                    hContentCleaned += hMtdAnnoStr</div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    hContentCleaned += hMtdStr</div><div class="line">                &#125;</div><div class="line">                hMtdAnnoStr = <span class="string">""</span></div><div class="line">                hMtdStr = <span class="string">""</span></div><div class="line">                hMtds = []</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//删除无用函数</span></div><div class="line">        <span class="keyword">try</span>! hContentCleaned.write(to: <span class="type">URL</span>(string:aMethod.filePath)!, atomically: <span class="literal">false</span>, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line"></div><div class="line">        <span class="comment">//----------------m文件----------------</span></div><div class="line">        <span class="keyword">var</span> mDeletingTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">var</span> mBraceCount = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> mContentCleaned = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtdStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtdAnnoStr = <span class="string">""</span></div><div class="line">        <span class="keyword">var</span> mMtds = [<span class="type">String</span>]()</div><div class="line">        <span class="keyword">var</span> psMMtdTf = <span class="literal">false</span></div><div class="line">        <span class="keyword">for</span> mOneLine <span class="keyword">in</span> mContentArr &#123;</div><div class="line">            <span class="keyword">let</span> line = mOneLine.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> mDeletingTf &#123;</div><div class="line">                <span class="keyword">let</span> lTokens = <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                mMtdAnnoStr += <span class="string">"//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                <span class="keyword">for</span> tk <span class="keyword">in</span> lTokens &#123;</div><div class="line">                    <span class="keyword">if</span> tk == <span class="type">Sb</span>.braceL &#123;</div><div class="line">                        mBraceCount += <span class="number">1</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> tk == <span class="type">Sb</span>.braceR &#123;</div><div class="line">                        mBraceCount -= <span class="number">1</span></div><div class="line">                        <span class="keyword">if</span> mBraceCount == <span class="number">0</span> &#123;</div><div class="line">                            mContentCleaned = mContentCleaned.appending(mMtdAnnoStr)</div><div class="line">                            mMtdAnnoStr = <span class="string">""</span></div><div class="line">                            mDeletingTf = <span class="literal">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasPrefix(<span class="type">Sb</span>.minus) || line.hasPrefix(<span class="type">Sb</span>.add) &#123;</div><div class="line">                psMMtdTf = <span class="literal">true</span></div><div class="line">                mMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">                mMtdStr = mMtdStr.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                mMtdAnnoStr += <span class="string">"//-----由SMCheckProject工具删除-----\n//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> psMMtdTf &#123;</div><div class="line">                mMtdStr = mMtdStr.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">                mMtdAnnoStr += <span class="string">"//"</span> + mOneLine + <span class="type">Sb</span>.newLine</div><div class="line">                mMtds += <span class="keyword">self</span>.createOCTokens(conent: line)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mContentCleaned = mContentCleaned.appending(mOneLine + <span class="type">Sb</span>.newLine)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> line.hasSuffix(<span class="type">Sb</span>.braceL) &amp;&amp; psMMtdTf &#123;</div><div class="line">                psMMtdTf = <span class="literal">false</span></div><div class="line">                <span class="keyword">let</span> methodPnameId = <span class="type">ParsingMethod</span>.parsingWithArray(arr: mMtds).pnameId</div><div class="line">                <span class="keyword">if</span> aMethod.pnameId == methodPnameId &#123;</div><div class="line">                    mDeletingTf = <span class="literal">true</span></div><div class="line">                    mBraceCount += <span class="number">1</span></div><div class="line">                    mContentCleaned = mContentCleaned.appending(mMtdAnnoStr)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    mContentCleaned = mContentCleaned.appending(mMtdStr)</div><div class="line">                &#125;</div><div class="line">                mMtdStr = <span class="string">""</span></div><div class="line">                mMtdAnnoStr = <span class="string">""</span></div><div class="line">                mMtds = []</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="comment">//m文件</span></div><div class="line"></div><div class="line">        <span class="comment">//删除无用函数</span></div><div class="line">        <span class="keyword">if</span> mContent.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">try</span>! mContentCleaned.write(to: <span class="type">URL</span>(string:mFilePath)!, atomically: <span class="literal">false</span>, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整代码在：<a href="https://github.com/ming1016/SMCheckProject" target="_blank" rel="external">https://github.com/ming1016/SMCheckProject</a> 这里。</p>
<h2 id="后记-🦁"><a href="#后记-🦁" class="headerlink" title="后记 🦁"></a>后记 🦁</h2><p>有了这样的结构数据就可以模拟更多人工检测的方式来检测项目。</p>
<p>通过获取的方法结合获取类里面定义的局部变量和全局变量，在解析过程中模拟引用的计数来分析循环引用等等类似这样的检测。<br>通过获取的类的完整结构还能够将其转成JavaScriptCore能解析的js语法文件等等。</p>
<h2 id="对于APP瘦身的一些想法-👽"><a href="#对于APP瘦身的一些想法-👽" class="headerlink" title="对于APP瘦身的一些想法 👽"></a>对于APP瘦身的一些想法 👽</h2><p>瘦身应该从平时开发时就需要注意。除了功能和组件上的复用外还需要对堆栈逻辑进行封装以达到代码压缩的效果。</p>
<p>比如使用ReactiveCocoa和RxSwift这样的函数响应式编程库提供的方法和编程模式进行</p>
<p>对于UI的视图逻辑可以使用一套统一逻辑压缩代码使用DSL来简化写法等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当项目越来越大，引入第三方库越来越多，上架的APP体积也会越来越大，对于用户来说体验必定是不好的。在清理资源，编译选项优化，清理无用类等完成后，能够做而且效果会比较明显的就只有清理无用函数了。现有一种方案是根据Linkmap文件取到objc的所有类方法和实例方法。再用工具逆
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="macOS" scheme="http://ming1016.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>15，16年iPad上使用Procreate画的</title>
    <link href="http://ming1016.github.io/2016/09/20/draw-with-procreate-in-ipad-during-15-to-16/"/>
    <id>http://ming1016.github.io/2016/09/20/draw-with-procreate-in-ipad-during-15-to-16/</id>
    <published>2016-09-20T13:34:41.000Z</published>
    <updated>2017-10-11T03:20:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/1.png" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/2.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/3.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/4.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/5.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/6.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/7.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/8.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/9.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/10.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/11.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/12.jpeg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-15-to-16/13.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/draw-with-procreate-in-ipad-during-15-to-16/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-with-procreate-in-ipad-during-15
    
    </summary>
    
      <category term="My painting" scheme="http://ming1016.github.io/categories/My-painting/"/>
    
    
      <category term="Painting" scheme="http://ming1016.github.io/tags/Painting/"/>
    
      <category term="GOT" scheme="http://ming1016.github.io/tags/GOT/"/>
    
      <category term="iPad" scheme="http://ming1016.github.io/tags/iPad/"/>
    
      <category term="Procreate" scheme="http://ming1016.github.io/tags/Procreate/"/>
    
  </entry>
  
  <entry>
    <title>使用ReactiveCocoa开发RSS阅读器</title>
    <link href="http://ming1016.github.io/2016/09/02/develop-rss-reader/"/>
    <id>http://ming1016.github.io/2016/09/02/develop-rss-reader/</id>
    <published>2016-09-02T13:47:59.000Z</published>
    <updated>2017-10-11T03:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前已经完成的功能有对RSS的解析和Atom解析，RSS内容本地数据库存储和读取，抓取中状态进度展示，标记阅读状态，标记全部已读等。这些功能里我对一些异步操作产生的数据采用了ReactiveCocoa来对数据流向进行了控制，下面我来说下如何运用RAC来进行的开发。</p>
<h1 id="初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新"><a href="#初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新" class="headerlink" title="初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新"></a>初始时读取本地存储首页列表数据，过滤无效数据，监听列表数据变化进行列表更新</h1><p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot1.png?raw=true" alt="截图"></p>
<p>这里会用到RAC这个宏可以方便的来进行键值和信号的绑定，RACObserve这个宏方便的进行键值变化的监听处理。具体实现代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line"><span class="comment">//首页列表数据赋值，过滤无效数据</span></div><div class="line">RAC(<span class="keyword">self</span>, feeds) = [[[SMDB shareInstance] selectAllFeeds] filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSMutableArray</span> *feedsArray) &#123;</div><div class="line">    <span class="keyword">if</span> (feedsArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">//监听列表数据变化进行列表更新</span></div><div class="line">[RACObserve(<span class="keyword">self</span>, feeds) subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">//本地读取首页订阅源数据</span></div><div class="line">- (RACSignal *)selectAllFeeds &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        FMDatabase *db = [FMDatabase databaseWithPath:<span class="keyword">self</span>.feedDBPath];</div><div class="line">        <span class="keyword">if</span> ([db open]) &#123;</div><div class="line">            FMResultSet *rs = [db executeQuery:<span class="string">@"select * from feeds"</span>];</div><div class="line">            <span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line">            <span class="built_in">NSMutableArray</span> *feedsArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">                SMFeedModel *feedModel = [[SMFeedModel alloc] init];</div><div class="line">                feedModel.fid = [rs intForColumn:<span class="string">@"fid"</span>];</div><div class="line">                feedModel.title = [rs stringForColumn:<span class="string">@"title"</span>];</div><div class="line">                feedModel.link = [rs stringForColumn:<span class="string">@"link"</span>];</div><div class="line">                feedModel.des = [rs stringForColumn:<span class="string">@"des"</span>];</div><div class="line">                feedModel.copyright = [rs stringForColumn:<span class="string">@"copyright"</span>];</div><div class="line">                feedModel.generator = [rs stringForColumn:<span class="string">@"generator"</span>];</div><div class="line">                feedModel.imageUrl = [rs stringForColumn:<span class="string">@"imageurl"</span>];</div><div class="line">                feedModel.feedUrl = [rs stringForColumn:<span class="string">@"feedurl"</span>];</div><div class="line">                feedModel.unReadCount = [rs intForColumn:<span class="string">@"unread"</span>];</div><div class="line">                [feedsArray addObject:feedModel];</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            [subscriber sendNext:feedsArray];</div><div class="line">            [subscriber sendCompleted];</div><div class="line">            [db close];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示"><a href="#通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示" class="headerlink" title="通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示"></a>通过网络获取订阅源最新内容，获取后进行本地存储，转成显示用的model进行列表的显示</h1><p>这里的异步操作比较多，而且为了尽快取得数据采用的是并行队列，需要准确的获取到每个源完成的状态，包括解析的完成，本地存储完成，全部获取完成等数据完成情况。具体使用RAC方式的代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取所有feeds以及完成处理</span></div><div class="line">- (<span class="keyword">void</span>)fetchAllFeeds &#123;</div><div class="line">    [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.tbHeaderView;</div><div class="line">    <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>; <span class="comment">//统计抓取数量</span></div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    [[[[[[SMNetManager shareInstance] fetchAllFeedWithModelArray:<span class="keyword">self</span>.feeds] map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="built_in">NSUInteger</span> index = [value integerValue];</div><div class="line">        <span class="keyword">self</span>.feeds[index] = [SMNetManager shareInstance].feeds[index];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.feeds[index];</div><div class="line">    &#125;] doCompleted:^&#123;</div><div class="line">        <span class="comment">//抓完所有的feeds</span></div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fetch complete"</span>);</div><div class="line">        <span class="comment">//完成置为默认状态</span></div><div class="line">        <span class="keyword">self</span>.tbHeaderLabel.text = <span class="string">@""</span>;</div><div class="line">        <span class="keyword">self</span>.tableView.tableHeaderView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">        <span class="keyword">self</span>.fetchingCount = <span class="number">0</span>;</div><div class="line">        [<span class="built_in">UIApplication</span> sharedApplication].networkActivityIndicatorVisible = <span class="literal">NO</span>;</div><div class="line">    &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(SMFeedModel *feedModel) &#123;</div><div class="line">        <span class="comment">//抓完一个</span></div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="comment">//显示抓取状态</span></div><div class="line">        <span class="keyword">self</span>.fetchingCount += <span class="number">1</span>;</div><div class="line">        <span class="keyword">self</span>.tbHeaderLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"正在获取%@...(%lu/%lu)"</span>,feedModel.title,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.fetchingCount,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="keyword">self</span>.feeds.count];</div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"><span class="comment">//网络获取以及解析本地存储</span></div><div class="line">- (RACSignal *)fetchAllFeedWithModelArray:(<span class="built_in">NSMutableArray</span> *)modelArray &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="comment">//创建并行队列</span></div><div class="line">        <span class="built_in">dispatch_queue_t</span> fetchFeedQueue = dispatch_queue_create(<span class="string">"com.starming.fetchfeed.fetchfeed"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">        dispatch_group_t group = dispatch_group_create();</div><div class="line">        <span class="keyword">self</span>.feeds = modelArray;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; modelArray.count; i++) &#123;</div><div class="line">            dispatch_group_enter(group);</div><div class="line">            SMFeedModel *feedModel = modelArray[i];</div><div class="line">            <span class="built_in">dispatch_async</span>(fetchFeedQueue, ^&#123;</div><div class="line">                [<span class="keyword">self</span> GET:feedModel.feedUrl parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">                    <span class="comment">//解析feed</span></div><div class="line">                    <span class="keyword">self</span>.feeds[i] = [<span class="keyword">self</span>.feedStore updateFeedModelWithData:responseObject preModel:feedModel];</div><div class="line">                    <span class="comment">//入库存储</span></div><div class="line">                    SMDB *db = [[SMDB alloc] init];</div><div class="line">                    [[db insertWithFeedModel:<span class="keyword">self</span>.feeds[i]] subscribeNext:^(<span class="built_in">NSNumber</span> *x) &#123;</div><div class="line">                        SMFeedModel *model = (SMFeedModel *)<span class="keyword">self</span>.feeds[i];</div><div class="line">                        model.fid = [x integerValue];</div><div class="line">                        <span class="comment">//插入本地数据库成功后开始sendNext</span></div><div class="line">                        [subscriber sendNext:@(i)];</div><div class="line">                        <span class="comment">//通知单个完成</span></div><div class="line">                        dispatch_group_leave(group);</div><div class="line">                    &#125;];</div><div class="line"></div><div class="line">                &#125; failure:^(<span class="built_in">NSURLSessionTask</span> *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                    dispatch_group_leave(group);</div><div class="line">                &#125;];</div><div class="line"></div><div class="line">            &#125;);<span class="comment">//end dispatch async</span></div><div class="line"></div><div class="line">        &#125;<span class="comment">//end for</span></div><div class="line">        <span class="comment">//全完成后执行事件</span></div><div class="line">        dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">            [subscriber sendCompleted];</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="读取RSS列表，异步读取，主线程更新"><a href="#读取RSS列表，异步读取，主线程更新" class="headerlink" title="读取RSS列表，异步读取，主线程更新"></a>读取RSS列表，异步读取，主线程更新</h1><p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot2.png?raw=true" alt="截图"></p>
<p>这里通过RAC能够很方便的进行主线程操作UI，非主线程操作数据这样的操作，具体实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取列表数据以及对应的操作</span></div><div class="line">- (<span class="keyword">void</span>)selectFeedItems &#123;</div><div class="line">    RACScheduler *scheduler = [RACScheduler schedulerWithPriority:RACSchedulerPriorityHigh];</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    [[[[[SMDB shareInstance] selectFeedItemsWithPage:<span class="keyword">self</span>.page fid:<span class="keyword">self</span>.feedModel.fid]</div><div class="line">       subscribeOn:scheduler]</div><div class="line">      deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">     subscribeNext:^(<span class="built_in">NSMutableArray</span> *x) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.listData.count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//进入时加载</span></div><div class="line">            [<span class="keyword">self</span>.listData addObjectsFromArray:x];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//加载更多</span></div><div class="line">            <span class="keyword">self</span>.listData = x;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//刷新</span></div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">        <span class="comment">//处理无数据的显示</span></div><div class="line">        [<span class="keyword">self</span>.tableView.mj_footer endRefreshingWithNoMoreData];</div><div class="line">    &#125; completed:^&#123;</div><div class="line">        <span class="comment">//加载完成后的处理</span></div><div class="line">        [<span class="keyword">self</span>.tableView.mj_footer endRefreshing];</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.page += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//数据库获取信号</span></div><div class="line">- (RACSignal *)selectFeedItemsWithPage:(<span class="built_in">NSUInteger</span>)page fid:(<span class="built_in">NSUInteger</span>)fid &#123;</div><div class="line">    @weakify(<span class="keyword">self</span>);</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        FMDatabase *db = [FMDatabase databaseWithPath:<span class="keyword">self</span>.feedDBPath];</div><div class="line">        <span class="keyword">if</span> ([db open]) &#123;</div><div class="line">            <span class="comment">//分页获取</span></div><div class="line">            FMResultSet *rs = [db executeQuery:<span class="string">@"select * from feeditem where fid = ? and isread = ? order by iid desc limit ?, 20"</span>,@(fid), @(<span class="number">0</span>), @(page * <span class="number">20</span>)];</div><div class="line">            <span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line">            <span class="built_in">NSMutableArray</span> *feedItemsArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="comment">//设置返回Array里的Model</span></div><div class="line">            <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">                SMFeedItemModel *itemModel = [[SMFeedItemModel alloc] init];</div><div class="line">                itemModel.iid = [rs intForColumn:<span class="string">@"iid"</span>];</div><div class="line">                itemModel.fid = [rs intForColumn:<span class="string">@"fid"</span>];</div><div class="line">                itemModel.link = [rs stringForColumn:<span class="string">@"link"</span>];</div><div class="line">                itemModel.title = [rs stringForColumn:<span class="string">@"title"</span>];</div><div class="line">                itemModel.author = [rs stringForColumn:<span class="string">@"author"</span>];</div><div class="line">                itemModel.category = [rs stringForColumn:<span class="string">@"category"</span>];</div><div class="line">                itemModel.pubDate = [rs stringForColumn:<span class="string">@"pubDate"</span>];</div><div class="line">                itemModel.des = [rs stringForColumn:<span class="string">@"des"</span>];</div><div class="line">                itemModel.isRead = [rs intForColumn:<span class="string">@"isread"</span>];</div><div class="line">                [feedItemsArray addObject:itemModel];</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                [subscriber sendNext:feedItemsArray];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//获取出错处理</span></div><div class="line">                [subscriber sendError:<span class="literal">nil</span>];</div><div class="line">            &#125;</div><div class="line">            [subscriber sendCompleted];</div><div class="line">            [db close];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/resource/ScreenShot3.png?raw=true" alt="截图"></p>
<p>完整代码可以在这里看:<a href="https://github.com/ming1016/GCDFetchFeed" target="_blank" rel="external">https://github.com/ming1016/GCDFetchFeed</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前已经完成的功能有对RSS的解析和Atom解析，RSS内容本地数据库存储和读取，抓取中状态进度展示，标记阅读状态，标记全部已读等。这些功能里我对一些异步操作产生的数据采用了ReactiveCocoa来对数据流向进行了控制，下面我来说下如何运用RAC来进行的开发。&lt;/p&gt;

    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="RSSReader" scheme="http://ming1016.github.io/tags/RSSReader/"/>
    
  </entry>
  
  <entry>
    <title>iOS函数响应式编程以及ReactiveCocoa的使用</title>
    <link href="http://ming1016.github.io/2016/08/09/how-to-use-reactivecocoa/"/>
    <id>http://ming1016.github.io/2016/08/09/how-to-use-reactivecocoa/</id>
    <published>2016-08-09T13:44:10.000Z</published>
    <updated>2017-10-11T03:34:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅</p>
<h1 id="声明式编程泛型Declarative-programming"><a href="#声明式编程泛型Declarative-programming" class="headerlink" title="声明式编程泛型Declarative programming"></a>声明式编程泛型Declarative programming</h1><p>函数反应式编程是声明式编程的子编程范式之一</p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>需要满足两个条件</p>
<ul>
<li>一个或者多个函数作为输入。</li>
<li>有且仅有一个函数输出。</li>
</ul>
<p>objectivec里使用block作为函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">NSNumber</span> *number, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,number);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h2 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> * mappedArray = [array rx_mapWithBlock:^<span class="keyword">id</span>(<span class="keyword">id</span> each)&#123;</div><div class="line">    <span class="keyword">return</span> @(pow([each integerValue],<span class="number">2</span>));</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="过滤filter"><a href="#过滤filter" class="headerlink" title="过滤filter"></a>过滤filter</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *filteredArray = [array rx_filterWithBlock:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> each)&#123;</div><div class="line">    <span class="keyword">return</span> ([each integerValue] % <span class="number">2</span> == <span class="number">0</span>);</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<h2 id="折叠fold"><a href="#折叠fold" class="headerlink" title="折叠fold"></a>折叠fold</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[array rx_mapWithBlock:^<span class="keyword">id</span> (<span class="keyword">id</span> each)&#123;</div><div class="line">        <span class="keyword">return</span> [each stringValue];</div><div class="line">    &#125;] rx_foldInitialValue:<span class="string">@""</span> block:^<span class="keyword">id</span> (<span class="keyword">id</span> memo , <span class="keyword">id</span> each)&#123;</div><div class="line">        <span class="keyword">return</span> [memo stringByAppendingString:each];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>用函数生成另一个函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterGenerator</span><span class="params">(lastnameCondition: String)</span></span> -&gt; (<span class="type">Staff</span>) -&gt; (<span class="type">Bool</span>) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;staff <span class="keyword">in</span></div><div class="line">        <span class="keyword">return</span> staff.lastname == lastnameCondition</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> filterWang = filterGenerator(<span class="string">"Wang"</span>)</div><div class="line"><span class="keyword">let</span> filterHu = filterGenerator(<span class="string">"Hu"</span>)</div><div class="line"></div><div class="line">staffs.<span class="built_in">filter</span>(filterHu)</div></pre></td></tr></table></figure></p>
<h1 id="RAC中使用高阶函数"><a href="#RAC中使用高阶函数" class="headerlink" title="RAC中使用高阶函数"></a>RAC中使用高阶函数</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[ @<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span> ];</div><div class="line">RACSequence * stream = [array rac_sequence];</div><div class="line"><span class="comment">//RACSequence是一个RACStream的子类。</span></div><div class="line">[stream map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">    <span class="keyword">return</span> @(pow([value integerValue], <span class="number">2</span>));</div><div class="line">&#125;];</div><div class="line"><span class="comment">//RACSequence有一个方法返回数组:array</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[stream array]);</div><div class="line"></div><div class="line"><span class="comment">//避免污染变量的作用域</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[[array rac_sequence] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> @(pow([value integerValue], <span class="number">2</span>));</div><div class="line">                &#125;] array]);</div></pre></td></tr></table></figure>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[[array rac_sequence] filter:^<span class="built_in">BOOL</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                        <span class="keyword">return</span> [value integerValue] % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">                    &#125;] array]);</div></pre></td></tr></table></figure>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[[array rac_sequence] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> [value stringValue];</div><div class="line">                &#125;] foldLeftWithStart:<span class="string">@""</span> reduce:^<span class="keyword">id</span> (<span class="keyword">id</span> accumulator, <span class="keyword">id</span> value)&#123;</div><div class="line">                    <span class="keyword">return</span> [accumulator stringByAppendingString:value];</div><div class="line">            &#125;]);</div></pre></td></tr></table></figure>
<h2 id="绑定键值"><a href="#绑定键值" class="headerlink" title="绑定键值"></a>绑定键值</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RACSignal * validEmailSignal = [<span class="keyword">self</span>.textField.rac_textSignal map:^<span class="keyword">id</span> (<span class="built_in">NSString</span> *value)&#123;</div><div class="line">    <span class="keyword">return</span> @([value rangeOfString:<span class="string">@"@"</span>].location != <span class="built_in">NSNotFound</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RAC(<span class="keyword">self</span>.button, enabled) = validEmailSignal;</div><div class="line"></div><div class="line">RAC(<span class="keyword">self</span>.textField, textColor) = [validEmailSignal map: ^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">    <span class="keyword">if</span>([value boolValue])&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> greenColor];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> redColor];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><img src="https://github.com/ming1016/study/blob/master/pic/CombinePipeline.png?raw=true" alt="绑定键值图示"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>比较好的一个完整的RAC实践的例子：<a href="https://github.com/ashfurrow/FunctionalReactivePixels" target="_blank" rel="external">https://github.com/ashfurrow/FunctionalReactivePixels</a></p>
<h3 id="网络请求生成对应model"><a href="#网络请求生成对应model" class="headerlink" title="网络请求生成对应model"></a>网络请求生成对应model</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">+ (RACSignal *)importPhotos&#123;</div><div class="line">    RACReplaySubject * subject = [RACReplaySubject subject];</div><div class="line">    <span class="built_in">NSURLRequest</span> * request = [<span class="keyword">self</span> popularURLRequest];</div><div class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request</div><div class="line">                                    queue:[<span class="built_in">NSOperationQueue</span> mainQueue]</div><div class="line">                        completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError)&#123;</div><div class="line">                            <span class="keyword">if</span> (data) &#123;</div><div class="line">                                <span class="keyword">id</span> results = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">                                [subject sendNext:[[[results[<span class="string">@"photos"</span>] rac_sequence] map:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span> *photoDictionary)&#123;</div><div class="line">                                    FRPPhotoModel * model = [FRPPhotoModel new];</div><div class="line"></div><div class="line">                                    [<span class="keyword">self</span> configurePhotoModel:model withDictionary:photoDictionary];</div><div class="line">                                    [<span class="keyword">self</span> downloadThumbnailForPhotoModel:model];</div><div class="line"></div><div class="line">                                    <span class="keyword">return</span> model;</div><div class="line">                                &#125;] array]];</div><div class="line"></div><div class="line">                                [subject sendCompleted];</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span>&#123;</div><div class="line">                                [subject sendError:connectionError];</div><div class="line">                            &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> subject;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="过滤相同大小的图片，取出他们的url，返回第一个"><a href="#过滤相同大小的图片，取出他们的url，返回第一个" class="headerlink" title="过滤相同大小的图片，取出他们的url，返回第一个"></a>过滤相同大小的图片，取出他们的url，返回第一个</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSString</span> *)urlForImageSize:(<span class="built_in">NSInteger</span>)size inDictionary:(<span class="built_in">NSArray</span> *)array&#123;</div><div class="line">    <span class="keyword">return</span> [[[[[array rac_sequence] filter:^ <span class="built_in">BOOL</span> (<span class="built_in">NSDictionary</span> * value)&#123;</div><div class="line">        <span class="keyword">return</span> [value[<span class="string">@"size"</span>] integerValue] == size;</div><div class="line">    &#125;] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">        <span class="keyword">return</span> value[<span class="string">@"url"</span>];</div><div class="line">    &#125;] array] firstObject];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径"><a href="#观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径" class="headerlink" title="观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径"></a>观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setPhotoModel:(FRPPhotoModel *)photoModel&#123;</div><div class="line">    <span class="keyword">self</span>.subscription = [[[RACObserver(photoModel, thumbnailData)</div><div class="line">        filter:^ <span class="built_in">BOOL</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">            <span class="keyword">return</span> value != <span class="literal">nil</span>;</div><div class="line">        &#125;] map:^<span class="keyword">id</span> (<span class="keyword">id</span> value)&#123;</div><div class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithData:value];</div><div class="line">        &#125;] setKeyPath:@keypath(<span class="keyword">self</span>.imageView, image) onObject:<span class="keyword">self</span>.imageView];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="UITableViewCell复用时需要取消cell上各个组件的订阅"><a href="#UITableViewCell复用时需要取消cell上各个组件的订阅" class="headerlink" title="UITableViewCell复用时需要取消cell上各个组件的订阅"></a>UITableViewCell复用时需要取消cell上各个组件的订阅</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForReuse &#123;</div><div class="line">    [<span class="keyword">super</span> prepareForReuse];</div><div class="line">    [<span class="keyword">self</span>.subscription dispose], <span class="keyword">self</span>.subscription = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Delegate的使用"><a href="#Delegate的使用" class="headerlink" title="Delegate的使用"></a>Delegate的使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意：你必须retain这个delegate对象，否则他们将会被释放，你将会得到一个EXC_BAD_ACCESS异常。添加下列私有属性到画廊视图控制器：</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> collectionViewDelegate;</div><div class="line"></div><div class="line"><span class="comment">//同时你也需要导入RACDelegateProxy.h，因为他不是ReactiveCocoa的核心部分，不包含在ReactiveCocoa.h中。</span></div><div class="line">RACDelegateProxy *viewControllerDelegate = [[RACDelegateProxy alloc]</div><div class="line">                                    initWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">FRPFullSizePhotoViewControllerDelegate</span>)];</span></div><div class="line"></div><div class="line">[[viewControllerDelegate rac_signalForSelector:<span class="keyword">@selector</span>(userDidScroll:toPhotoAtIndex:)     fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">FRPFullSizePhotoViewControllerDelegate</span>)]</span></div><div class="line">        subscribeNext:^(RACTuple *value)&#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            [<span class="keyword">self</span>.collectionView</div><div class="line">                scrollToItemAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForItem:[value.second integerValue] inSection:<span class="number">0</span>]</div><div class="line">                atScrollPosition:<span class="built_in">UICollectionViewScrollPositionCenteredVertically</span></div><div class="line">                animated:<span class="literal">NO</span>];</div><div class="line">        &#125;];</div><div class="line"></div><div class="line"><span class="keyword">self</span>.collectionViewDelegate = [[RACDelegateProxy alloc] initWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UICollectionViewDelegate</span>)];</span></div><div class="line"></div><div class="line">[[<span class="keyword">self</span>.collectionViewDelegate rac_signalForSelector:<span class="keyword">@selector</span>(collectionView:didSelectItemAtIndexPath:)]</div><div class="line">        subscribeNext:^(RACTuple *arguments) &#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            FRPFullSizePhotoViewController *viewController = [[FRPFullSizePhotoViewController alloc] initWithPhotoModels:<span class="keyword">self</span>.photosArray currentPhotoIndex:[(<span class="built_in">NSIndexPath</span> *)arguments.second item]];</div><div class="line">            viewController.delegate = (<span class="keyword">id</span>&lt;FRPFullSizePhotoViewControllerDelegate&gt;)viewControllerDelegate;</div><div class="line"></div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:viewController animated:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">        &#125;];</div></pre></td></tr></table></figure>
<h3 id="处理异常，完成执行刷新操作，异常打印日志，执行对应方法"><a href="#处理异常，完成执行刷新操作，异常打印日志，执行对应方法" class="headerlink" title="处理异常，完成执行刷新操作，异常打印日志，执行对应方法"></a>处理异常，完成执行刷新操作，异常打印日志，执行对应方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RAC(<span class="keyword">self</span>, photosArray) = [[[[FRPPhotoImporter importPhotos]</div><div class="line">        doCompleted:^&#123;</div><div class="line">            @strongify(<span class="keyword">self</span>);</div><div class="line">            [<span class="keyword">self</span>.collectionView reloadData];</div><div class="line">        &#125;] logError] catchTo:[RACSignal empty]];</div></pre></td></tr></table></figure>
<h3 id="网络请求处理数据，获取数据返回主线程"><a href="#网络请求处理数据，获取数据返回主线程" class="headerlink" title="网络请求处理数据，获取数据返回主线程"></a>网络请求处理数据，获取数据返回主线程</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+ (RACSignal *)importPhotos &#123;</div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="keyword">self</span> popularURLRequest];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[[[[[<span class="built_in">NSURLConnection</span> rac_sendAsynchronousRequest:request]</div><div class="line">                reduceEach:^<span class="keyword">id</span>(<span class="built_in">NSURLResponse</span> *response , <span class="built_in">NSData</span> *data)&#123;</div><div class="line">                    <span class="comment">//注意：我们可以用下面的reduceEach:替代使用RACTuple的第一个map:，以便提供编译时检查。</span></div><div class="line">                    <span class="keyword">return</span> data;</div><div class="line">                &#125;]</div><div class="line">                deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">                map:^<span class="keyword">id</span> (<span class="built_in">NSData</span> *data) &#123;</div><div class="line">                    <span class="keyword">id</span> results = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</div><div class="line">                    <span class="keyword">return</span> [[[results[<span class="string">@"photo"</span>] rac_sequence]</div><div class="line">                        map:^<span class="keyword">id</span> (<span class="built_in">NSDictionary</span> *photoDictionary) &#123;</div><div class="line">                            FRPPhotoModel *model = [FRPPhotoModel new];</div><div class="line">                            [<span class="keyword">self</span> configurePhotoModel:model withDictionary:photoDictionary];</div><div class="line">                            [<span class="keyword">self</span> downloadThumbnailForPhotoModel:model];</div><div class="line">                            <span class="keyword">return</span> model;</div><div class="line">                        &#125;] array];</div><div class="line">                &#125;] publish] autoconnect];</div><div class="line">    <span class="comment">//信号链条最末端的信号操作publish. publish返回一个RACMulitcastConnection,当信号连接上时，他将订阅该接收信号。autoconnect为我们做的是：当它返回的信号被订阅，连接到 该(订阅背后的)信号（underly signal）。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="信号的信号Signal-of-signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext-块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。"><a href="#信号的信号Signal-of-signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext-块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。" class="headerlink" title="信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。"></a>信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[[<span class="keyword">self</span>.signInButton rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] flattenMap:^RACStream *(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> signInSignal];</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">//x</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sign in result: %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）"><a href="#不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）" class="headerlink" title="不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）"></a>不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)requestAccessToTwitterSignal</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 定义一个错误，如果用户拒绝访问则发送</span></div><div class="line">    <span class="built_in">NSError</span> *accessError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 创建并返回信号</span></div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 请求访问twitter</span></div><div class="line">        @strongify(<span class="keyword">self</span>)</div><div class="line">        [<span class="keyword">self</span>.accountStore requestAccessToAccountsWithType:<span class="keyword">self</span>.twitterAccountType</div><div class="line">                                                   options:<span class="literal">nil</span></div><div class="line">                                                completion:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                                                    <span class="comment">// 处理响应</span></div><div class="line">                                                    <span class="keyword">if</span> (!granted)</div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendError:accessError];</div><div class="line">                                                    &#125;</div><div class="line">                                                    <span class="keyword">else</span></div><div class="line">                                                    &#123;</div><div class="line">                                                        [subscriber sendNext:<span class="literal">nil</span>];</div><div class="line">                                                        [subscriber sendCompleted];</div><div class="line">                                                    &#125;</div><div class="line">                                                &#125;];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//throttle可以避免连续输入造成的不必要的请求，then会忽略前一个信号的值，底层的实现是先过滤之前信号发的值，再使用concat连接then返回的信号。</span></div><div class="line">[[[[[[[<span class="keyword">self</span> requestAccessToTwitterSignal]</div><div class="line">      then:^RACSignal *&#123;</div><div class="line">          @strongify(<span class="keyword">self</span>)</div><div class="line">          <span class="keyword">return</span> <span class="keyword">self</span>.searchText.rac_textSignal;</div><div class="line">      &#125;]</div><div class="line">     filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">         @strongify(<span class="keyword">self</span>)</div><div class="line">         <span class="keyword">return</span> [<span class="keyword">self</span> isValidSearchText:text];</div><div class="line">     &#125;]</div><div class="line">    throttle:<span class="number">0.5</span>]</div><div class="line">   flattenMap:^RACStream *(<span class="built_in">NSString</span> *text) &#123;</div><div class="line">       @strongify(<span class="keyword">self</span>)</div><div class="line">       <span class="comment">//flattenMap来将每个next事件映射到一个新的被订阅的信号</span></div><div class="line">       <span class="keyword">return</span> [<span class="keyword">self</span> signalForSearchWithText:text];</div><div class="line">   &#125;]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line"> subscribeNext:^(<span class="built_in">NSDictionary</span> *jsonSearchResult) &#123;</div><div class="line">     <span class="built_in">NSArray</span> *statuses = jsonSearchResult[<span class="string">@"statuses"</span>];</div><div class="line">     <span class="built_in">NSArray</span> *tweets = [statuses linq_select:^<span class="keyword">id</span>(<span class="keyword">id</span> tweet) &#123;</div><div class="line">         <span class="keyword">return</span> [RWTweet tweetWithStatus:tweet];</div><div class="line">     &#125;];</div><div class="line">     [<span class="keyword">self</span>.resultsViewController displayTweets:tweets];</div><div class="line"> &#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"An error occurred: %@"</span>, error);</div><div class="line"> &#125;];</div><div class="line"> - (RACSignal *)signalForSearchWithText:(<span class="built_in">NSString</span> *)text &#123;</div><div class="line">    <span class="comment">// 1 - define the errors</span></div><div class="line">    <span class="built_in">NSError</span> *noAccountsError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain</div><div class="line">                                                   code:RWTwitterInstantErrorNoTwitterAccounts</div><div class="line">                                               userInfo:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSError</span> *invalidResponseError = [<span class="built_in">NSError</span> errorWithDomain:RWTwitterInstantDomain</div><div class="line">                                                        code:RWTwitterInstantErrorInvalidResponse</div><div class="line">                                                        userInfo:<span class="literal">nil</span>];</div><div class="line">    @weakify(<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span> subscriber) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        SLRequest *request = [<span class="keyword">self</span> requestforTwitterSearchWithText:text];</div><div class="line">        <span class="built_in">NSArray</span> *twitterAccounts = [<span class="keyword">self</span>.accountStore accountsWithAccountType:<span class="keyword">self</span>.twitterAccountType];         <span class="keyword">if</span> (twitterAccounts.count == <span class="number">0</span>) &#123;</div><div class="line">            [subscriber sendError:noAccountsError];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [request setAccount:[twitterAccounts lastObject]];</div><div class="line">        [request performRequestWithHandler: ^(<span class="built_in">NSData</span> *responseData,</div><div class="line">                <span class="built_in">NSHTTPURLResponse</span> *urlResponse, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">            <span class="keyword">if</span> (urlResponse.statusCode == <span class="number">200</span>) &#123;</div><div class="line">                <span class="built_in">NSDictionary</span> *timelineData = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:responseData</div><div class="line">                                                options:<span class="built_in">NSJSONReadingAllowFragments</span></div><div class="line">                                                  error:<span class="literal">nil</span>];</div><div class="line">                [subscriber sendNext:timelineData];</div><div class="line">                [subscriber sendCompleted];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [subscriber sendError:invalidResponseError];</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/ming1016/study/blob/master/pic/CompletePipeline.png?raw=true" alt="不同信号顺序链接"></p>
<h3 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-(RACSignal *)signalForLoadingImage:(<span class="built_in">NSString</span> *)imageUrl &#123;</div><div class="line"></div><div class="line">    RACScheduler *scheduler = [RACScheduler</div><div class="line">                               schedulerWithPriority:RACSchedulerPriorityBackground];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:imageUrl]];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        [subscriber sendNext:image];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;] subscribeOn:scheduler];</div><div class="line">&#125;</div><div class="line"></div><div class="line">cell.twitterAvatarView.image = <span class="literal">nil</span>;</div><div class="line">[[[<span class="keyword">self</span> signalForLoadingImage:tweet.profileImageUrl]</div><div class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</div><div class="line">  subscribeNext:^(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">   cell.twitterAvatarView.image = image;</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<h3 id="观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用"><a href="#观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用" class="headerlink" title="观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用"></a>观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[[RACSignal merge: @[RACObserve(<span class="keyword">self</span>.viewModel,  tweets),</div><div class="line">                     RACObserve(<span class="keyword">self</span>.viewModel,  allTweetsLoaded)]]</div><div class="line">    bufferWithTime: <span class="number">0</span> onScheduler: [RACScheduler mainThreadScheduler]]</div><div class="line">    subscribeNext: ^(<span class="keyword">id</span> value) &#123;</div><div class="line">        @strongify(<span class="keyword">self</span>);</div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125;];</div><div class="line"><span class="comment">//bufferWithTime设置为0是为了避免同一时刻两个值被同时设置新值产生了table进行了两次reloadData</span></div></pre></td></tr></table></figure>
<h3 id="封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。"><a href="#封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。" class="headerlink" title="封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。"></a>封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[tableView rac_signalForSelector:<span class="keyword">@selector</span>(layoutSubviews)]subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line">    [<span class="keyword">self</span> doSomethingBeforeTableViewLayoutSubviews];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等"><a href="#使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等" class="headerlink" title="使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等"></a>使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等</h3><p>Demo的github地址：<a href="https://github.com/olegam/RACCommandExample" target="_blank" rel="external">https://github.com/olegam/RACCommandExample</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bindWithViewModel &#123;</div><div class="line">  RAC(<span class="keyword">self</span>.viewModel, email) =<span class="keyword">self</span>.emailTextField.rac_textSignal;</div><div class="line">  <span class="keyword">self</span>.subscribeButton.rac_command = <span class="keyword">self</span>.viewModel.subscribeCommand;</div><div class="line">  RAC(<span class="keyword">self</span>.statusLabel, text) =RACObserve(<span class="keyword">self</span>.viewModel, statusMessage);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubscribeViewModel</span> :<span class="title">NSObject</span></span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)RACCommand *subscribeCommand;  <span class="comment">// writeto this property</span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *email;  <span class="comment">// read from this property</span></div><div class="line">  <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *statusMessage;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"SubscribeViewModel.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"AFHTTPRequestOperationManager+RACSupport.h"</span></span></div><div class="line"><span class="meta">#import<span class="meta-string">"NSString+EmailAdditions.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kSubscribeURL =<span class="string">@"http://reactivetest.apiary.io/subscribers"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubscribeViewModel</span> ()</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSignal*emailValidSignal;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubscribeViewModel</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">       <span class="keyword">self</span>= [<span class="keyword">super</span> init];</div><div class="line">       <span class="keyword">if</span>(<span class="keyword">self</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> mapSubscribeCommandStateToStatusMessage];</div><div class="line">       &#125;</div><div class="line">       returnself;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)mapSubscribeCommandStateToStatusMessage &#123;</div><div class="line">       RACSignal *startedMessageSource = [<span class="keyword">self</span>.subscribeCommand.executionSignals map:^<span class="keyword">id</span>(RACSignal *subscribeSignal) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Sending request..."</span>, <span class="literal">nil</span>);</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RACSignal *completedMessageSource = [<span class="keyword">self</span>.subscribeCommand.executionSignals flattenMap:^RACStream *(RACSignal *subscribeSignal) &#123;</div><div class="line">              <span class="keyword">return</span>[[[subscribeSignal materialize] filter:^<span class="built_in">BOOL</span>(RACEvent *event) &#123;</div><div class="line">                     <span class="keyword">return</span> event.eventType == RACEventTypeCompleted;</div><div class="line">              &#125;] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">                     <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Thanks"</span>, <span class="literal">nil</span>);</div><div class="line">              &#125;];</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RACSignal*failedMessageSource = [[<span class="keyword">self</span>.subscribeCommand.errors subscribeOn:[RACSchedulermainThreadScheduler]] map:^<span class="keyword">id</span>(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="built_in">NSLocalizedString</span>(<span class="string">@"Error :("</span>, <span class="literal">nil</span>);</div><div class="line">       &#125;];</div><div class="line"></div><div class="line">       RAC(<span class="keyword">self</span>,statusMessage) = [RACSignal merge:@[startedMessageSource, completedMessageSource, failedMessageSource]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (RACCommand *)subscribeCommand &#123;</div><div class="line">       <span class="keyword">if</span>(!_subscribeCommand) &#123;</div><div class="line">              @weakify(<span class="keyword">self</span>);</div><div class="line">              _subscribeCommand = [[RACCommand alloc] initWithEnabled:<span class="keyword">self</span>.emailValidSignal signalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line">                     @strongify(<span class="keyword">self</span>);</div><div class="line">                     <span class="keyword">return</span> [SubscribeViewModel postEmail:<span class="keyword">self</span>.email];</div><div class="line">              &#125;];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> _subscribeCommand;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (RACSignal *)postEmail:(<span class="built_in">NSString</span> *)email&#123;</div><div class="line">       AFHTTPRequestOperationManager*manager = [AFHTTPRequestOperationManager manager];</div><div class="line">       manager.requestSerializer= [AFJSONRequestSerializer new];</div><div class="line">       <span class="built_in">NSDictionary</span>*body = @&#123;<span class="string">@"email"</span>: email ?: <span class="string">@""</span>&#125;;</div><div class="line">       <span class="keyword">return</span> [[[manager rac_POST:kSubscribeURL parameters:body] logError] replayLazily];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (RACSignal *)emailValidSignal &#123;</div><div class="line">       <span class="keyword">if</span>(!_emailValidSignal) &#123;</div><div class="line">              _emailValidSignal= [RACObserve(<span class="keyword">self</span>, email) map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *email) &#123;</div><div class="line">                     <span class="keyword">return</span>@([email isValidEmail]);</div><div class="line">              &#125;];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> _emailValidSignal;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="替换Delegate，直接使用RACSubject"><a href="#替换Delegate，直接使用RACSubject" class="headerlink" title="替换Delegate，直接使用RACSubject"></a>替换Delegate，直接使用RACSubject</h3><h1 id="RAC内存管理"><a href="#RAC内存管理" class="headerlink" title="RAC内存管理"></a>RAC内存管理</h1><p>RAC会维护一个全局的信号集合，一个或多于一个订阅者就可用，所有订阅者都被移除了，信号就被释放了。</p>
<h1 id="RAC需要注意的内存问题"><a href="#RAC需要注意的内存问题" class="headerlink" title="RAC需要注意的内存问题"></a>RAC需要注意的内存问题</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123; <span class="comment">//1</span></div><div class="line">        MTModel *model = [[MTModel alloc] init]; <span class="comment">// MTModel有一个名为的title的属性</span></div><div class="line">        [subscriber sendNext:model];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.flattenMapSignal = [signal flattenMap:^RACStream *(MTModel *model) &#123; <span class="comment">//2</span></div><div class="line">        <span class="keyword">return</span> RACObserve(model, title);</div><div class="line">    &#125;];</div><div class="line">    [<span class="keyword">self</span>.flattenMapSignal subscribeNext:^(<span class="keyword">id</span> x) &#123; <span class="comment">//3</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"subscribeNext - %@"</span>, x);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的RACObserve会引起引用不释放的问题，通过RACObserve的定义来看看，里面会对self进行持有。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define RACObserve(TARGET, KEYPATH) \</span></div><div class="line">    (&#123; \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic push"</span>) \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic ignored \"-Wreceiver-is-weak\""</span>) \</div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">id</span> target_ = (TARGET); \</div><div class="line">        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:<span class="keyword">self</span>]; \</div><div class="line">        _Pragma(<span class="string">"clang diagnostic pop"</span>) \</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p>对subject进行map这样的操作，这时就需要sendCompleted<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    RACSubject *subject = [RACSubject subject];</div><div class="line">    [subject.rac_willDeallocSignal subscribeCompleted:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"subject dealloc"</span>);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [[subject map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">        <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</div><div class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"next = %@"</span>, x);</div><div class="line">    &#125;];</div><div class="line">    [subject sendNext:@<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是为什么signal进行map操作，不sendCompleted而不会内存泄漏呢。因为调到bind的比如map、filter、merge、combineLatest、flattenMap等操作如果是RACSubject这样会持有订阅者的信号会产生内存泄漏需要sendCompleted。可以先看看bind的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)bind:(RACStreamBindBlock (^)(<span class="keyword">void</span>))block &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * -bind: should:</div><div class="line">     *</div><div class="line">     * 1. Subscribe to the original signal of values.</div><div class="line">     * 2. Any time the original signal sends a value, transform it using the binding block.</div><div class="line">     * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they're received.</div><div class="line">     * 4. If the binding block asks the bind to terminate, complete the _original_ signal.</div><div class="line">     * 5. When _all_ signals complete, send completed to the subscriber.</div><div class="line">     *</div><div class="line">     * If any signal sends an error at any point, send that to the subscriber.</div><div class="line">     */</div><div class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        RACStreamBindBlock bindingBlock = block();</div><div class="line">        <span class="built_in">NSMutableArray</span> *signals = [<span class="built_in">NSMutableArray</span> arrayWithObject:<span class="keyword">self</span>];</div><div class="line">        <span class="comment">// 此处省略了80行代码</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>didSubscribe的开头，就创建了一个数组signals，并且持有了self，也就是源信号，也就是订阅者持有了信号，如果是Subject那么这种信号又会持有订阅者，这样就形成了循环引用。</p>
<p>下面看看sendCompleted如何修复的内存泄漏<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^completeSignal)(RACSignal *, RACDisposable *) = ^(RACSignal *signal, RACDisposable *finishedDisposable) &#123;</div><div class="line">    <span class="built_in">BOOL</span> removeDisposable = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">@synchronized</span> (signals) &#123;</div><div class="line">        [signals removeObject:signal]; <span class="comment">//1</span></div><div class="line">        <span class="keyword">if</span> (signals.count == <span class="number">0</span>) &#123;</div><div class="line">            [subscriber sendCompleted]; <span class="comment">//2</span></div><div class="line">            [compoundDisposable dispose]; <span class="comment">//3</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            removeDisposable = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (removeDisposable) [compoundDisposable removeDisposable:finishedDisposable]; <span class="comment">//4</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从signals这个数组中移除传入的signal，也就是让订阅的signal不会持有subject这种信号。</p>
<p>还有replay这样的操作，因为这个方法返回的是一个RACReplaySubject<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    [subscriber sendNext:@<span class="number">1</span>];</div><div class="line">    [subscriber sendCompleted]; <span class="comment">// 保证源信号发送完成</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *replaySignal = [signal replay]; <span class="comment">// 这里返回的其实是一个RACReplaySubject</span></div><div class="line"></div><div class="line">[[replaySignal map:^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</div><div class="line">    <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscribeNext - %@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h1 id="热信号冷信号"><a href="#热信号冷信号" class="headerlink" title="热信号冷信号"></a>热信号冷信号</h1><ul>
<li>热信号是主动的，不订阅也能够按时发送。冷信号是被动的，只有订阅才会发送。</li>
<li>热信号可以有多个订阅者。冷信号只能够一对一，有不同订阅者，消息会从新完整发送。</li>
</ul>
<h1 id="RAC的API手册"><a href="#RAC的API手册" class="headerlink" title="RAC的API手册"></a>RAC的API手册</h1><h2 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h2><h3 id="RACSiganl-信号类。"><a href="#RACSiganl-信号类。" class="headerlink" title="RACSiganl 信号类。"></a>RACSiganl 信号类。</h3><ul>
<li>RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法；</li>
<li>RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法；</li>
<li>RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；</li>
<li>RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法；</li>
<li>RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。</li>
</ul>
<h3 id="RACSubscriber-订阅者"><a href="#RACSubscriber-订阅者" class="headerlink" title="RACSubscriber 订阅者"></a>RACSubscriber 订阅者</h3><h3 id="RACDisposable-用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。"><a href="#RACDisposable-用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。" class="headerlink" title="RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。"></a>RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</h3><ul>
<li>RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来；</li>
<li>RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察；</li>
<li>RACCompoundDisposable ：它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象</li>
<li>RACScopedDisposable ：当它被 dealloc 的时候调用本身的 -dispose 方法。</li>
</ul>
<h3 id="RACSubject-信号提供者，自己可以充当信号，又能发送信号。订阅后发送"><a href="#RACSubject-信号提供者，自己可以充当信号，又能发送信号。订阅后发送" class="headerlink" title="RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送"></a>RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送</h3><ul>
<li>RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能；</li>
<li>RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值；</li>
<li>RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。可以先发送后订阅</li>
</ul>
<h3 id="RACTuple-元组类-类似NSArray-用来包装值"><a href="#RACTuple-元组类-类似NSArray-用来包装值" class="headerlink" title="RACTuple 元组类,类似NSArray,用来包装值."></a>RACTuple 元组类,类似NSArray,用来包装值.</h3><h3 id="RACSequence-RAC中的集合类"><a href="#RACSequence-RAC中的集合类" class="headerlink" title="RACSequence RAC中的集合类"></a>RACSequence RAC中的集合类</h3><h3 id="RACCommand-RAC中用于处理事件的类，可以把事件如何处理-事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。"><a href="#RACCommand-RAC中用于处理事件的类，可以把事件如何处理-事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。" class="headerlink" title="RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。"></a>RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</h3><h3 id="RACMulticastConnection-用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。"><a href="#RACMulticastConnection-用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。" class="headerlink" title="RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。"></a>RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</h3><h3 id="RACScheduler-RAC中的队列，用GCD封装的。"><a href="#RACScheduler-RAC中的队列，用GCD封装的。" class="headerlink" title="RACScheduler RAC中的队列，用GCD封装的。"></a>RACScheduler RAC中的队列，用GCD封装的。</h3><ul>
<li>RACImmediateScheduler ：立即执行调度的任务，这是唯一一个支持同步执行的调度器；</li>
<li>RACQueueScheduler ：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务；</li>
<li>RACTargetQueueScheduler ：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务；</li>
<li>RACSubscriptionScheduler ：一个只用来调度订阅的调度器。</li>
</ul>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><ul>
<li>rac_signalForSelector : 代替代理</li>
<li>rac_valuesAndChangesForKeyPath: KVO</li>
<li>rac_signalForControlEvents:监听事件</li>
<li>rac_addObserverForName 代替通知</li>
<li>rac_textSignal：监听文本框文字改变</li>
<li>rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
</ul>
<h2 id="常见宏"><a href="#常见宏" class="headerlink" title="常见宏"></a>常见宏</h2><ul>
<li>RAC(TARGET, [KEYPATH, [NIL_VALUE]])：用于给某个对象的某个属性绑定</li>
<li>RACObserve(self, name) ：监听某个对象的某个属性,返回的是信号。</li>
<li>@weakify(Obj)和@strongify(Obj)</li>
<li>RACTuplePack ：把数据包装成RACTuple（元组类）</li>
<li>RACTupleUnpack：把RACTuple（元组类）解包成对应的数据</li>
<li>RACChannelTo 用于双向绑定的一个终端</li>
</ul>
<h2 id="常用操作方法"><a href="#常用操作方法" class="headerlink" title="常用操作方法"></a>常用操作方法</h2><ul>
<li>flattenMap map 用于把源信号内容映射成新的内容。</li>
<li>concat 组合 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号</li>
<li>then 用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</li>
<li>merge 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用</li>
<li>zipWith 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。</li>
<li>combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</li>
<li>reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值</li>
<li>filter:过滤信号，使用它可以获取满足条件的信号.</li>
<li>ignore:忽略完某些值的信号.</li>
<li>distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</li>
<li>take:从开始一共取N次的信号</li>
<li>takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.</li>
<li>takeUntil:(RACSignal *):获取信号直到某个信号执行完成</li>
<li>skip:(NSUInteger):跳过几个信号,不接受。</li>
<li>switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</li>
<li>doNext: 执行Next之前，会先执行这个Block</li>
<li>doCompleted: 执行sendCompleted之前，会先执行这个Block</li>
<li>timeout：超时，可以让一个信号在一定的时间后，自动报错。</li>
<li>interval 定时：每隔一段时间发出信号</li>
<li>delay 延迟发送next。</li>
<li>retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</li>
<li>replay重放：当一个信号被多次订阅,反复播放内容</li>
<li>throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</li>
</ul>
<h2 id="UI-Category（常用汇总）"><a href="#UI-Category（常用汇总）" class="headerlink" title="UI - Category（常用汇总）"></a>UI - Category（常用汇总）</h2><h3 id="rac-prepareForReuseSignal：-需要复用时用"><a href="#rac-prepareForReuseSignal：-需要复用时用" class="headerlink" title="rac_prepareForReuseSignal： 需要复用时用"></a>rac_prepareForReuseSignal： 需要复用时用</h3><ul>
<li>相关UI: MKAnnotationView、UICollectionReusableView、UITableViewCell、UITableViewHeaderFooterView</li>
</ul>
<h3 id="rac-buttonClickedSignal：点击事件触发信号"><a href="#rac-buttonClickedSignal：点击事件触发信号" class="headerlink" title="rac_buttonClickedSignal：点击事件触发信号"></a>rac_buttonClickedSignal：点击事件触发信号</h3><ul>
<li>相关UI：UIActionSheet、UIAlertView</li>
</ul>
<h3 id="rac-command：button类、刷新类相关命令替换"><a href="#rac-command：button类、刷新类相关命令替换" class="headerlink" title="rac_command：button类、刷新类相关命令替换"></a>rac_command：button类、刷新类相关命令替换</h3><ul>
<li>相关UI：UIBarButtonItem、UIButton、UIRefreshControl</li>
</ul>
<h3 id="rac-signalForControlEvents-control-event-触发"><a href="#rac-signalForControlEvents-control-event-触发" class="headerlink" title="rac_signalForControlEvents: control event 触发"></a>rac_signalForControlEvents: control event 触发</h3><ul>
<li>相关UI：UIControl</li>
</ul>
<h3 id="rac-gestureSignal-UIGestureRecognizer-事件处理信号"><a href="#rac-gestureSignal-UIGestureRecognizer-事件处理信号" class="headerlink" title="rac_gestureSignal UIGestureRecognizer 事件处理信号"></a>rac_gestureSignal UIGestureRecognizer 事件处理信号</h3><ul>
<li>相关UI：UIGestureRecognizer</li>
</ul>
<h3 id="rac-imageSelectedSignal-选择图片的信号"><a href="#rac-imageSelectedSignal-选择图片的信号" class="headerlink" title="rac_imageSelectedSignal 选择图片的信号"></a>rac_imageSelectedSignal 选择图片的信号</h3><ul>
<li>相关UI：UIImagePickerController</li>
</ul>
<h3 id="rac-textSignal"><a href="#rac-textSignal" class="headerlink" title="rac_textSignal"></a>rac_textSignal</h3><ul>
<li>相关UI：UITextField、UITextView</li>
</ul>
<h3 id="可实现双向绑定的相关API"><a href="#可实现双向绑定的相关API" class="headerlink" title="可实现双向绑定的相关API"></a>可实现双向绑定的相关API</h3><ul>
<li>rac_channelForControlEvents: key: nilValue:</li>
<li>相关UI：UIControl类</li>
<li>rac_newDateChannelWithNilValue:</li>
<li>相关UI：UIDatePicker</li>
<li>rac_newSelectedSegmentIndexChannelWithNilValue:</li>
<li>相关UI：UISegmentedControl</li>
<li>rac_newValueChannelWithNilValue:</li>
<li>相关UI：UISlider、UIStepper</li>
<li>rac_newOnChannel</li>
<li>相关UI：UISwitch</li>
<li>rac_newTextChannel</li>
<li>相关UI：UITextField</li>
</ul>
<h2 id="Foundation-Category-（常用汇总）"><a href="#Foundation-Category-（常用汇总）" class="headerlink" title="Foundation - Category （常用汇总）"></a>Foundation - Category （常用汇总）</h2><h3 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h3><ul>
<li>rac_readContentsOfURL: options: scheduler: 比oc多出线程设置</li>
</ul>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><ul>
<li>rac_sequence</li>
<li>rac_keySequence key 集合</li>
<li>rac_valueSequence value 集合</li>
</ul>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><ul>
<li>rac_sequence 信号集合</li>
</ul>
<h3 id="NSFileHandle"><a href="#NSFileHandle" class="headerlink" title="NSFileHandle"></a>NSFileHandle</h3><ul>
<li>rac_readInBackground 后台线程读取</li>
</ul>
<h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><ul>
<li>rac_setArgument: atIndex: 设置参数</li>
<li>rac_argumentAtIndex 取某个参数</li>
<li>rac_returnValue 所关联方法的返回值</li>
</ul>
<h3 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h3><ul>
<li>rac_addObserverForName: object:注册通知</li>
</ul>
<h3 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h3><ul>
<li>rac_willDeallocSignal 对象销毁时发动的信号</li>
<li>rac_description debug用</li>
<li>rac_observeKeyPath: options: observer: block:监听某个事件</li>
<li>rac_liftSelector: withSignals: 全部信号都next在执行</li>
<li>rac_signalForSelector: 代替某个方法</li>
<li>rac_signalForSelector:(SEL)selector fromProtocol:代替代理</li>
</ul>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><ul>
<li>rac_keyPathComponents 获取一个路径所有的部分</li>
<li>rac_keyPathByDeletingLastKeyPathComponent 删除路径最后一部分</li>
<li>rac_keyPathByDeletingFirstKeyPathComponent 删除路径第一部分</li>
<li>rac_readContentsOfURL: usedEncoding: scheduler: 比之OC多线程调用</li>
<li>rac_sequence</li>
</ul>
<h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><ul>
<li>rac_sendAsynchronousRequest 发起异步请求</li>
</ul>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><ul>
<li>rac_channelTerminalForKey 用于双向绑定，此乃一</li>
</ul>
<h3 id="NSEnumerator"><a href="#NSEnumerator" class="headerlink" title="NSEnumerator"></a>NSEnumerator</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSIndexSet"><a href="#NSIndexSet" class="headerlink" title="NSIndexSet"></a>NSIndexSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSOrderedSet"><a href="#NSOrderedSet" class="headerlink" title="NSOrderedSet"></a>NSOrderedSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h1 id="RAC图片版的API手册"><a href="#RAC图片版的API手册" class="headerlink" title="RAC图片版的API手册"></a>RAC图片版的API手册</h1><h2 id="ReactiveCocoa-objectivec"><a href="#ReactiveCocoa-objectivec" class="headerlink" title="ReactiveCocoa objectivec"></a>ReactiveCocoa objectivec</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/ReactiveCocoaOC.png?raw=true" alt="ReactiveCocoaobjectivec"></p>
<h2 id="ReactiveCocoa-Swift"><a href="#ReactiveCocoa-Swift" class="headerlink" title="ReactiveCocoa Swift"></a>ReactiveCocoa Swift</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/ReactiveCocoaSwift.png?raw=true" alt="ReactiveCocoaSwift"></p>
<h2 id="RXSwift"><a href="#RXSwift" class="headerlink" title="RXSwift"></a>RXSwift</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/RXSwift.png?raw=true" alt="RXSwift"></p>
<h1 id="本文参考整理自"><a href="#本文参考整理自" class="headerlink" title="本文参考整理自"></a>本文参考整理自</h1><ul>
<li>ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2 <a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1</a></li>
<li>ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2 <a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2</a></li>
<li>iOS的函数响应型编程 <a href="https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details" target="_blank" rel="external">https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details</a></li>
<li>ReactiveCocoa Essentials: Understanding and Using RACCommand <a href="http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/" target="_blank" rel="external">http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/</a></li>
<li>iOS ReactiveCocoa 最全常用API整理（可做为手册查询）<a href="http://www.cocoachina.com/ios/20160729/17236.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20160729/17236.html</a></li>
<li>ReactiveCocoa和RXSwift速查表 <a href="http://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/" target="_blank" rel="external">http://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/</a></li>
<li>ReactiveCocoa中潜在的内存泄漏及解决方案<a href="http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅&lt;/p&gt;
&lt;h1 id=&quot;声明式编程泛型Declarative-programming&quot;&gt;&lt;a href=&quot;#声明式编程泛型Declarative-programming&quot;
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://ming1016.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>制作一个类似苹果VFL(Visual Format Language)的格式化语言来描述类似UIStackView那种布局思路，并解析生成页面</title>
    <link href="http://ming1016.github.io/2016/07/21/assembleview/"/>
    <id>http://ming1016.github.io/2016/07/21/assembleview/</id>
    <published>2016-07-21T13:38:01.000Z</published>
    <updated>2017-10-11T03:15:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中总是希望页面上各处的文字，颜色，字体大小甚至各个视图控件布局都能够在发版之后能够修改以弥补一些前期考虑不周，或者根据统计数据能够随时进行调整，当然是各个版本都能够统一变化。看到这样的要求后，第一反应是这样的页面只能改成H5，或者尝试使用React Native来应对这种要求。</p>
<p>既然UIStackView已经提供了一种既先进又简洁的布局思路，为何不通过制作一个类似VFL这样的DSL语言来处理布局。这样不就能够通过下发一串DSL字符串的方式来进行内容样式甚至布局的更换，不用跟版，还能使多版本统一。同时在端内直接用这样的DSL语言来写界面不光能够减少代码量易于维护，还能够很直观方便的看出整个界面布局结构。</p>
<h1 id="AssembleView（组装视图）和PartView（零件视图）"><a href="#AssembleView（组装视图）和PartView（零件视图）" class="headerlink" title="AssembleView（组装视图）和PartView（零件视图）"></a>AssembleView（组装视图）和PartView（零件视图）</h1><p>在设计格式化语言之前需要对布局做个统一思想进行管理，在看了WWDC里关于UIStackView的介绍后感觉任何复杂的布局都能够通过这样一种组合排布再组合排布的思路特别适合用格式化语言来描述。于是我想出两个视图概念。</p>
<p>一个是AssembleView组合视图，专门用于对其PartView子视图进行排列，比如说是水平排列还是垂直排列，PartView是按照居中对齐还是居左等对齐方式，各个PartView之间间隔是多少。</p>
<p>PartView决定自己视图类型，内容，无固定大小的可以设置大小，同时AssembleView可以作为PartView被加入另一个AssembleView里进行排列，这样各种设计图都可以在初期通过拆解分成不同的AssembleView和PartView进行组合套组合布局出来。</p>
<h1 id="格式化语言"><a href="#格式化语言" class="headerlink" title="格式化语言"></a>格式化语言</h1><p>接下来是如何通过格式化语言来描述AssembleView和PartView。“{}”符号里包含的是AssembleView的设置，“[]”符号里是PartView的设置，“()”里是他们的属性设置，“&lt;&gt;”可以将对象带入到设置里。下面举几个例子说明下。完整Demo放到了Github上：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">https://github.com/ming1016/STMAssembleView</a></p>
<h2 id="三个星星水平对齐居中排列"><a href="#三个星星水平对齐居中排列" class="headerlink" title="三个星星水平对齐居中排列"></a>三个星星水平对齐居中排列</h2><p>h表示水平排列horizontal，c表示居中center，“[]”PartView会根据顺序依次添加排列，imageName属性能够指定本地图片<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/center.png?raw=true" alt="三个星星水平对齐居中排列"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    hc(padding:30)</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">    [(imageName:starmingicon)]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView里套作为PartView的AssembleView的复杂情况"><a href="#AssembleView里套作为PartView的AssembleView的复杂情况" class="headerlink" title="AssembleView里套作为PartView的AssembleView的复杂情况"></a>AssembleView里套作为PartView的AssembleView的复杂情况</h2><p>color可以指定文字颜色，font指定文字大小<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/mid.png?raw=true" alt="AssembleView里套作为PartView的AssembleView的复杂情况"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    ht(padding:10)</div><div class="line">    [avatarImageView(imageName:avatar)]</div><div class="line">    [</div><div class="line">        &#123;</div><div class="line">            vl(padding:10)</div><div class="line">            [(text:戴铭,color:AAA0A3)]</div><div class="line">            [(text:Starming站长,color:E3DEE0,font:13)]</div><div class="line">            [(text:喜欢画画编程和写小说,color:E3DEE0,font:13)]</div><div class="line">        &#125;</div><div class="line">        (width:210,backColor:FAF8F9,backPaddingHorizontal:10,backPaddingVertical:10,radius:8)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="给PartView设置背景色和按钮"><a href="#给PartView设置背景色和按钮" class="headerlink" title="给PartView设置背景色和按钮"></a>给PartView设置背景色和按钮</h2><p>设置背景色使用backColor，背景距离设置的PartView的内容间距通过backPaddingHorizontal属性设置水平间距，backPaddingVertical设置垂直间距，“&lt;&gt;”符号带入的button通过button属性设置。<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/followBt.png?raw=true" alt="给PartView设置背景色和按钮"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        hc(padding:4)</div><div class="line">        [(imageName:starmingicon,width:14,height:10)]</div><div class="line">        [(text:关注,font:16,color:FFFFFF)]</div><div class="line">    &#125;</div><div class="line">    (height:36,backColor:AAA0A3,radius:8,backBorderWidth:1,backBorderColor:E3DEE0,backPaddingHorizontal:80,backPaddingVertical:10,button:&lt;clickBt&gt;)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView设置忽略约束的方法"><a href="#AssembleView设置忽略约束的方法" class="headerlink" title="AssembleView设置忽略约束的方法"></a>AssembleView设置忽略约束的方法</h2><p>水平排列时，通过ignoreAlignment属性设置忽略left约束，如果是垂直排列设置top忽略。<br><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/des.png?raw=true" alt="AssembleView设置忽略约束的方法"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    hc(padding:5)</div><div class="line">    [(text:STMAssembleView演示,color:E3DEE0,font:13)]</div><div class="line">    [(imageName:starmingicon,width:14,height:10,ignoreAlignment:left)]</div><div class="line">    [(text:Starming星光社,color:E3DEE0,font:13)]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="将前面的视图组合成一个AssembleView"><a href="#将前面的视图组合成一个AssembleView" class="headerlink" title="将前面的视图组合成一个AssembleView"></a>将前面的视图组合成一个AssembleView</h2><p><img src="https://github.com/ming1016/STMAssembleView/blob/master/STMAssembleView/as.png?raw=true" alt="将前面的视图组合成一个AssembleView"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ASS(@&quot;&#123;</div><div class="line">    vc(padding:20)</div><div class="line">    [%@(height:90)]</div><div class="line">    [%@(height:36,backColor:AAA0A3,radius:8,backBorderWidth:1,backBorderColor:E3DEE0,backPaddingHorizontal:80,backPaddingVertical:10,button:&lt;clickBt&gt;)]</div><div class="line">    [%@(height:25)]</div><div class="line">    [%@(ignoreAlignment:top,isFill:1,height:16)]</div><div class="line">&#125;&quot;,midStr,followBtStr,centerStr,desStr)</div></pre></td></tr></table></figure></p>
<h2 id="AssembleView的属性"><a href="#AssembleView的属性" class="headerlink" title="AssembleView的属性"></a>AssembleView的属性</h2><ul>
<li>当在“{}”里面第一个字母是v表示垂直排列vertical，是h表示水平排列horizontal</li>
<li>第二个字母是c表示所有PartView居中对齐center，l表示居左对齐left，r表示居右对齐right，t表示居上对齐top，b表示居下对齐bottom。</li>
<li>padding：默认各个PartView的间距。</li>
</ul>
<h2 id="PartView的属性"><a href="#PartView的属性" class="headerlink" title="PartView的属性"></a>PartView的属性</h2><p>如果不希望通过属性生成视图，可以通过在[后直接填入带入对象对应的key，然后再在()里设置属性。</p>
<h3 id="PartView布局相关属性"><a href="#PartView布局相关属性" class="headerlink" title="PartView布局相关属性"></a>PartView布局相关属性</h3><ul>
<li>width：UILabel和UIImage这样有固定大小的可以不用设置，会按照固定大小的来。</li>
<li>height：有固定大小的可以不用设置。</li>
<li>isFill：垂直排列时会将宽设置为父AssembleView的宽，水平排列时会将高设置为父AssembleView的高。</li>
<li>padding：设置后会忽略父AssembleView里设置的padding，达到自定义间距的效果。</li>
<li>partAlignment：可以自定义对齐方向，设置后会忽略父AssembleView里设置的对齐。值可填center，left，right，top，bottom。</li>
<li>ignoreAlignment：设置忽略的约束方向，在父AssembleView不需要由子PartView决定大小的情况下，可以通过打断某个方向约束来实现拆开排列的效果。值可填center，left，right，top，bottom。</li>
</ul>
<h3 id="PartView权重相关属性"><a href="#PartView权重相关属性" class="headerlink" title="PartView权重相关属性"></a>PartView权重相关属性</h3><ul>
<li>crp：Compression Resistance Priority的设置，根据权重由低到高值可以设置为fit，low，high，required。对应的UILayoutPriority的分别是UILayoutPriorityFittingSizeLevel，UILayoutPriorityDefaultLow，UILayoutPriorityDefaultHigh，UILayoutPriorityRequired。</li>
<li>minWidth：对应NSLayoutRelationGreaterThanOrEqual，设置一个最小的宽</li>
<li>maxWidth：对应NSLayoutRelationLessThanOrEqual，设置一个最大的宽</li>
</ul>
<h3 id="PartView视图控件相关设置"><a href="#PartView视图控件相关设置" class="headerlink" title="PartView视图控件相关设置"></a>PartView视图控件相关设置</h3><p>通过以下属性即可生成对应的UILabel，UIImageView或者UIButton等控件视图，而不用特别指出需要生成哪种控件视图</p>
<ul>
<li>text：设置文字内容</li>
<li>font：设置字体，可以带入一个UIFont，也可以直接设置一个字体大小，解析时会判断类型。</li>
<li>color：设置颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>imageName：设置本地图片，值是本地图片名称。</li>
<li>image：带入一个UIImage。</li>
<li>imageUrl：设置一个网络图片的url地址，ps:目前需要通过&lt;&gt;来带入一个字符串。</li>
</ul>
<h3 id="PartView的通用设置"><a href="#PartView的通用设置" class="headerlink" title="PartView的通用设置"></a>PartView的通用设置</h3><p>可以为PartView创建一个底部视图，并设置其样式。也可以添加一个UIButton设置UIControlStateHighlighted时的样式。</p>
<ul>
<li>backColor：设置底部视图的颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>backPaddingHorizontal：设置当前PartView视图距离底部视图top和bottom的间距。</li>
<li>backPaddingVertical：设置当前PartView视图距离底部视图left和right的间距。</li>
<li>backBorderColor：设置底部视图边框的颜色，可以带入一个UIColor，也可以直接设置一个十六进制颜色，解析时会判断类型。</li>
<li>backBorderWidth：设置底部视图边框宽。</li>
<li>radius：设置底部视图的圆角半径。</li>
<li>button：带入一个button。</li>
<li>buttonHighlightColor：设置button在UIControlStateHighlighted时的颜色，默认是透明度0.05的黑色。</li>
</ul>
<h1 id="解析格式化语言"><a href="#解析格式化语言" class="headerlink" title="解析格式化语言"></a>解析格式化语言</h1><p>解析过程的第一步采用扫描scanner程序将字符串按照分析符号表将字符流序列收集到有意义的单元中。</p>
<p>第二步将这些单元逐个归类到对应的类别中。比如解析到“()”里内容时就将其归类到对应的AssembleView的属性或者PartView的属性类别中。在归类过程中会出现PartView是AssembleView，这个Assemble里面又有这样作为PartView的AssembleView这样层层套的情况，所以需要采用类似引用计数方式保证在最后一个“}”符号结束时能将整个Assemble递归进行解析。</p>
<p>第三步将各个类别集合转换成对应原生代码从而生成对应的视图布局。</p>
<p>具体实现可以查看STMAssembleView.m文件。Github地址：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">https://github.com/ming1016/STMAssembleView</a></p>
<h1 id="如何生成页面"><a href="#如何生成页面" class="headerlink" title="如何生成页面"></a>如何生成页面</h1><p>生成页面需要实现格式化语言对应的原生代码，所有PartView的属性都会存放在STMPartMaker里，包括带入的自定义视图还有用于生成视图控件的属性等。PartView属性设置完成后会在STMPartView这个类中先决定对应的视图控件，并将STMPartMaker里的属性都设置上。实现代码可以查看STMPartView.m里的- (STMPartView *)buildPartView方法。</p>
<p>接下来STMAssembleView会在buildAssembleView时进行布局，具体实现代码可以查看STMAssembleView.m里的- (STMAssembleView *)buildAssembleView方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中总是希望页面上各处的文字，颜色，字体大小甚至各个视图控件布局都能够在发版之后能够修改以弥补一些前期考虑不周，或者根据统计数据能够随时进行调整，当然是各个版本都能够统一变化。看到这样的要求后，第一反应是这样的页面只能改成H5，或者尝试使用React Native来应对
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="AssembleView" scheme="http://ming1016.github.io/tags/AssembleView/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
