<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS,LLVM,Clang," />





  <link rel="alternate" href="/atom.xml" title="星光社 - 戴铭的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/uploads/logo.png?v=5.1.1" />






<meta name="description" content="前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器">
<meta name="keywords" content="iOS,LLVM,Clang">
<meta property="og:type" content="article">
<meta property="og:title" content="深入剖析 iOS 编译 Clang &#x2F; LLVM">
<meta property="og:url" content="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/index.html">
<meta property="og:site_name" content="星光社 - 戴铭的博客">
<meta property="og:description" content="前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器">
<meta property="og:updated_time" content="2017-05-27T13:16:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入剖析 iOS 编译 Clang &#x2F; LLVM">
<meta name="twitter:description" content="前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/"/>





  <title>深入剖析 iOS 编译 Clang / LLVM | 星光社 - 戴铭的博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">星光社 - 戴铭的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="戴铭">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/251980?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星光社 - 戴铭的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入剖析 iOS 编译 Clang / LLVM</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T21:58:09+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              

              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter <a href="https://twitter.com/clattner_llvm" target="_blank" rel="external">@clattner_llvm</a> ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p>
<p>Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。</p>
<p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</p>
<p>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</p>
<p>LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是  Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。</p>
<p>LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。</p>
<p>LLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</p>
<p>这里是 Clang 官方详细文档： <a href="http://clang.llvm.org/docs/" target="_blank" rel="external">Welcome to Clang’s documentation! — Clang 4.0 documentation</a></p>
<p>这篇是对 LLVM 架构的一个概述： <a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">The Architecture of Open Source Applications</a></p>
<p>将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 <a href="https://book.douban.com/subject/1436811/" target="_blank" rel="external">《linkers and loaders》</a> 这本书就知道了。</p>
<h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><p>在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#define DEFINEEight 8</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int eight = DEFINEEight;</div><div class="line">        int six = 6;</div><div class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</div><div class="line">        int rank = eight + six;</div><div class="line">        NSLog(@“%@ rank %d”, site, rank);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -ccc-print-phases main.m</div></pre></td></tr></table></figure></p>
<p>可以看到编译源文件需要的几个不同的阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: input, “main.m”, objective-c</div><div class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</div><div class="line">2: compiler, &#123;1&#125;, ir</div><div class="line">3: backend, &#123;2&#125;, assembler</div><div class="line">4: assembler, &#123;3&#125;, object</div><div class="line">5: linker, &#123;4&#125;, image</div><div class="line">6: bind-arch, “x86_64”, &#123;5&#125;, image</div></pre></td></tr></table></figure></p>
<p>这样能够了解到过程和重要的信息。<br>查看oc的c实现可以使用如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m</div></pre></td></tr></table></figure></p>
<p>查看操作内部命令，可以使用 -### 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -### main.m -o main</div></pre></td></tr></table></figure></p>
<p>想看清clang的全部过程，可以先通过-E查看clang在预编译处理这步做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -E main.m</div></pre></td></tr></table></figure></p>
<p>执行完后可以看到文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 1 “/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h” 1 3</div><div class="line"># 185 “/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h” 2 3</div><div class="line"># 2 “main.m” 2</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int eight = 8;</div><div class="line">        int six = 6;</div><div class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</div><div class="line">        int rank = eight + six;</div><div class="line">        NSLog(@“%@ rank %d”, site, rank);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个过程的处理包括宏的替换，头文件的导入。下面这些代码也会在这步处理。</p>
<ul>
<li>“#define”</li>
<li>“#include”</li>
<li>“#indef”</li>
<li>注释</li>
<li>“#pragma”</li>
</ul>
<p>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p>
<p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p>
<p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="external">Writing an LLVM Pass — LLVM 5 documentation</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</p>
<p>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure></p>
<p>生成汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure></p>
<p>生成目标文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure></p>
<p>生成可执行文件，这样就能够执行看到输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">clang main.o -o main</div><div class="line">执行</div><div class="line">./main</div><div class="line">输出</div><div class="line">starming rank 14</div></pre></td></tr></table></figure></p>
<p>下面是完整步骤：</p>
<ul>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ul>
<h1 id="Clang-编译-m-文件"><a href="#Clang-编译-m-文件" class="headerlink" title="Clang 编译 .m 文件"></a>Clang 编译 .m 文件</h1><p>在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。</p>
<p>具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CompileC DerivedData path/AFSecurityPolicy.o AFNetworking/AFNetworking/AFSecurityPolicy.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</div></pre></td></tr></table></figure></p>
<p>接下来对会更新工作路径，同时设置 PATH<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods</div><div class="line">    export LANG=en_US.US-ASCII</div><div class="line">    export PATH=“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin”</div></pre></td></tr></table></figure></p>
<p>接下来就是实际的编译命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o</div></pre></td></tr></table></figure></p>
<p>clang 命令参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-x 编译语言比如objective-c</div><div class="line">-arch 编译的架构，比如arm7</div><div class="line">-f 以-f开头的。</div><div class="line">-W 以-W开头的，可以通过这些定制编译警告</div><div class="line">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</div><div class="line">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</div><div class="line">-I 把编译信息写入指定的辅助文件</div><div class="line">-F 需要的Framework</div><div class="line">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</div><div class="line">-o 编译结果</div></pre></td></tr></table></figure></p>
<h2 id="构建-Target"><a href="#构建-Target" class="headerlink" title="构建 Target"></a>构建 Target</h2><p>编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Create product structure</div><div class="line">Process product packaging</div><div class="line">Run custom shell script ‘Check Pods Manifest.lock’</div><div class="line">Compile … 各个项目中的.m文件</div><div class="line">Link /Users/… 路径</div><div class="line">Copy … 静态文件</div><div class="line">Compile asset catalogs</div><div class="line">Compile Storyboard file …</div><div class="line">Process info.plist</div><div class="line">Link Storyboards</div><div class="line">Run custom shell script ‘Embed Pods Frameworks’</div><div class="line">Run custom shell script ‘Copy Pods Resources’</div><div class="line">…</div><div class="line">Touch GCDFetchFeed.app</div><div class="line">Sign GCDFetchFeed.app</div></pre></td></tr></table></figure></p>
<p>从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。</p>
<h2 id="Target-在-Build-过程的控制"><a href="#Target-在-Build-过程的控制" class="headerlink" title="Target 在 Build 过程的控制"></a>Target 在 Build 过程的控制</h2><p>在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。</p>
<h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。</p>
<p>在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。</p>
<p>build phase 还会把静态资源拷贝到 bundle 里。</p>
<p>可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。</p>
<h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>在 build 的过程中各个阶段的选项的设置。</p>
<h3 id="pbxproj工程文件"><a href="#pbxproj工程文件" class="headerlink" title="pbxproj工程文件"></a>pbxproj工程文件</h3><p>build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rootObject = 3EE311301C4E1F0800103FA3 /* Project object */;</div></pre></td></tr></table></figure></p>
<p>然后根据这个 ID 找到 main 工程的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Begin PBXProject section */</div><div class="line">		3EE311301C4E1F0800103FA3 /* Project object */ = &#123;</div><div class="line">			isa = PBXProject;</div><div class="line">			…</div><div class="line">/* End PBXProject section */</div></pre></td></tr></table></figure></p>
<p>在 targets 里会指向各个 taget 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">targets = (</div><div class="line">	3EE311371C4E1F0800103FA3 /* GCDFetchFeed */,</div><div class="line">	3EE311501C4E1F0800103FA3 /* GCDFetchFeedTests */,</div><div class="line">	3EE3115B1C4E1F0800103FA3 /* GCDFetchFeedUITests */,</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">3EE311371C4E1F0800103FA3 /* GCDFetchFeed */ = &#123;</div><div class="line">	isa = PBXNativeTarget;</div><div class="line">	buildConfigurationList = 3EE311651C4E1F0800103FA3 /* configuration list for PBXNativeTarget “GCDFetchFeed” </div><div class="line">	buildPhases = (</div><div class="line">		9527AA01F4AAE11E18397E0C /* Check Pods st.lock */,</div><div class="line">		3EE311341C4E1F0800103FA3 /* Sources */,</div><div class="line">		3EE311351C4E1F0800103FA3 /* Frameworks */,</div><div class="line">		3EE311361C4E1F0800103FA3 /* Resources */,</div><div class="line">		C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks </div><div class="line">		DD33A716222617FAB49F1472 /* Copy Pods Resources </div><div class="line">	);</div><div class="line">	buildRules = (</div><div class="line">	);</div><div class="line">	dependencies = (</div><div class="line">	);</div><div class="line">	name = GCDFetchFeed;</div><div class="line">	productName = GCDFetchFeed;</div><div class="line">	productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */;</div><div class="line">	productType = “com.apple.product-type.application”;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。</p>
<p>接下来详细的看看 Clang 所做的事情吧。</p>
<h1 id="Clang-Static-Analyzer静态代码分析"><a href="#Clang-Static-Analyzer静态代码分析" class="headerlink" title="Clang Static Analyzer静态代码分析"></a>Clang Static Analyzer静态代码分析</h1><p>可以在 <a href="https://code.woboq.org/llvm/clang/" target="_blank" rel="external">llvm/clang/ Source Tree - Woboq Code Browser</a> 上查看 Clang 的代码。</p>
<p>Youtube上一个教程：<a href="https://www.youtube.com/watch?time_continue=280&amp;v=VqCkCDFLSsc" target="_blank" rel="external">The Clang AST - a Tutorial - YouTube</a><br>CMU关于llvm的教案 <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/" target="_blank" rel="external">http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/</a></p>
<p>静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 <a href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def" target="_blank" rel="external">TokensKind.def</a> 里有 Clang 定义的所有 Token。Token 可以分为以下几类</p>
<ul>
<li>关键字：语法中的关键字，if else while for 等。</li>
<li>标识符：变量名</li>
<li>字面量：值，数字，字符串</li>
<li>特殊符号：加减乘除等符号</li>
</ul>
<p>通过下面的命令可以输出所有 token 和所在文件具体位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -E -Xclang -dump-tokens main.m</div><div class="line">``` </div><div class="line">结果如下</div></pre></td></tr></table></figure></p>
<p>annot_module_include ‘#import <fo’ loc="<main.m:2:1"><br>int ‘int’     [StartOfLine]    Loc=<main.m:5:1><br>identifier ‘main’     [LeadingSpace]    Loc=<main.m:5:5><br>l_paren ‘(‘        Loc=<main.m:5:9><br>r_paren ‘)’        Loc=<main.m:5:10><br>l_brace ‘{‘     [LeadingSpace]    Loc=<main.m:5:12><br>at ‘@‘     [StartOfLine] [LeadingSpace]    Loc=<main.m:6:5><br>identifier ‘autoreleasepool’        Loc=<main.m:6:6><br>l_brace ‘{‘     [LeadingSpace]    Loc=<main.m:6:22><br>identifier ‘NSString’     [StartOfLine] [LeadingSpace]    Loc=<main.m:7:9><br>star ‘*’     [LeadingSpace]    Loc=<main.m:7:18><br>identifier ‘a’        Loc=<main.m:7:19><br>equal ‘=‘     [LeadingSpace]    Loc=<main.m:7:21><br>at ‘@‘     [LeadingSpace]    Loc=<main.m:7:23><br>string_literal ‘”aaa”’        Loc=<main.m:7:24><br>semi ‘;’        Loc=<main.m:7:29><br>identifier ‘NSLog’     [StartOfLine] [LeadingSpace]    Loc=<main.m:8:9><br>l_paren ‘(‘        Loc=<main.m:8:14><br>at ‘@‘        Loc=<main.m:8:15><br>string_literal ‘”hi %@“’        Loc=<main.m:8:16><br>comma ‘,’        Loc=<main.m:8:23><br>identifier ‘a’        Loc=<main.m:8:24><br>r_paren ‘)’        Loc=<main.m:8:25><br>semi ‘;’        Loc=<main.m:8:26><br>r_brace ‘}’     [StartOfLine] [LeadingSpace]    Loc=<main.m:9:5><br>return ‘return’     [StartOfLine] [LeadingSpace]    Loc=<main.m:10:5><br>numeric_constant ‘0’     [LeadingSpace]    Loc=<main.m:10:12><br>semi ‘;’        Loc=<main.m:10:13><br>r_brace ‘}’     [StartOfLine]    Loc=<main.m:11:1><br>eof ‘’        Loc=<main.m:11:2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=&lt;main.m:11:1&gt; 这个样的具体位置。</div><div class="line"></div><div class="line">接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。</div><div class="line"></div><div class="line">打个比方，如果遇到 token 是 = 符号进行赋值的处理，遇到加减乘除就先处理乘除，然后处理加减，这些组合经过嵌套后会生成一个语法数的结构。这个过程完成后会进行赋值操作时类型是不是匹配的处理。</div><div class="line"></div><div class="line">打印语法树的命令</div></pre></td></tr></table></figure></main.m:11:2></main.m:11:1></main.m:10:13></main.m:10:12></main.m:10:5></main.m:9:5></main.m:8:26></main.m:8:25></main.m:8:24></main.m:8:23></main.m:8:16></main.m:8:15></main.m:8:14></main.m:8:9></main.m:7:29></main.m:7:24></main.m:7:23></main.m:7:21></main.m:7:19></main.m:7:18></main.m:7:9></main.m:6:22></main.m:6:6></main.m:6:5></main.m:5:12></main.m:5:10></main.m:5:9></main.m:5:5></main.m:5:1></fo’></p>
<p>clang -fmodules -fsyntax-only -Xclang -ast-dump main.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出结果</div></pre></td></tr></table></figure></p>
<p>TranslationUnitDecl 0x7fa80f018ad0 &lt;<invalid sloc="">&gt; <invalid sloc=""><br>|-TypedefDecl 0x7fa80f018fc8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit <strong>int128_t ‘</strong>int128’<br>| <code>-BuiltinType 0x7fa80f018d20 ‘__int128’
|-TypedefDecl 0x7fa80f019028 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t ‘unsigned __int128’
|</code>-BuiltinType 0x7fa80f018d40 ‘unsigned <strong>int128’<br>|-TypedefDecl 0x7fa80f0190b8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit SEL ‘SEL <em>’<br>| `-PointerType 0x7fa80f019080 ‘SEL </em>’<br>|   <code>-BuiltinType 0x7fa80f018f30 ‘SEL’
|-TypedefDecl 0x7fa80f019198 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit id ‘id’
|</code>-ObjCObjectPointerType 0x7fa80f019140 ‘id’ imported<br>|   <code>-ObjCObjectType 0x7fa80f019110 ‘id’ imported
|-TypedefDecl 0x7fa80f019278 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit Class ‘Class’
|</code>-ObjCObjectPointerType 0x7fa80f019220 ‘Class’<br>|   `-ObjCObjectType 0x7fa80f0191f0 ‘Class’<br>|-ObjCInterfaceDecl 0x7fa80f0192c8 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit Protocol<br>|-TypedefDecl 0x7fa80f019618 &lt;<invalid sloc="">&gt; <invalid sloc=""> implicit </invalid></invalid></invalid></invalid></invalid></invalid></strong>NSConstantString ‘struct <strong>NSConstantString_tag’<br>| `-RecordType 0x7fa80f019430 ‘struct </strong>NSConstantString_tag’<br>|   <code>-Record 0x7fa80f019390 ‘__NSConstantString_tag’
|-TypedefDecl 0x7fa80f0196a8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list ‘char *’
|</code>-PointerType 0x7fa80f019670 ‘char <em>’<br>|   <code>-BuiltinType 0x7fa80f018b60 ‘char’
|-TypedefDecl 0x7fa80f047978 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list ‘struct __va_list_tag [1]’
|</code>-ConstantArrayType 0x7fa80f047920 ‘struct <strong>va_list_tag [1]’ 1<br>|   `-RecordType 0x7fa80f0197a0 ‘struct </strong>va_list_tag’<br>|     <code>-Record 0x7fa80f0196f8 ‘__va_list_tag’
|-ImportDecl 0x7fa80f0486b0 &lt;main.m:2:1&gt; col:1 implicit Foundation
|-FunctionDecl 0x7fa80f048738 &lt;line:5:1, line:11:1&gt; line:5:5 main ‘int ()’
|</code>-CompoundStmt 0x7fa80f393998 <col:12, line:11:1=""><br>|   |-ObjCAutoreleasePoolStmt 0x7fa80f393950 <line:6:5, line:9:5=""><br>|   | <code>-CompoundStmt 0x7fa80f393928 &lt;line:6:22, line:9:5&gt;
|   |   |-DeclStmt 0x7fa80f3a3b38 &lt;line:7:9, col:29&gt;
|   |   |</code>-VarDecl 0x7fa80f3a3580 <col:9, col:24=""> col:19 used a ‘NSString </col:9,></line:6:5,></col:12,></em>’ cinit<br>|   |   |   <code>-ObjCStringLiteral 0x7fa80f3a3648 &lt;col:23, col:24&gt; ‘NSString *’
|   |   |</code>-StringLiteral 0x7fa80f3a3618 <col:24> ‘char [4]’ lvalue “aaa”<br>|   |   <code>-CallExpr 0x7fa80f3938c0 &lt;line:8:9, col:25&gt; ‘void’
|   |     |-ImplicitCastExpr 0x7fa80f3938a8 &lt;col:9&gt; ‘void (*)(id, …)’ &lt;FunctionToPointerDecay&gt;
|   |     |</code>-DeclRefExpr 0x7fa80f3a3b50 <col:9> ‘void (id, …)’ Function 0x7fa80f3a3670 ‘NSLog’ ‘void (id, …)’<br>|   |     |-ImplicitCastExpr 0x7fa80f3938f8 <col:15, col:16=""> ‘id’:’id’ <bitcast><br>|   |     | <code>-ObjCStringLiteral 0x7fa80f393800 &lt;col:15, col:16&gt; ‘NSString *’
|   |     |</code>-StringLiteral 0x7fa80f3a3bb8 <col:16> ‘char [6]’ lvalue “hi %@“<br>|   |     <code>-ImplicitCastExpr 0x7fa80f393910 &lt;col:24&gt; ‘NSString *’ &lt;LValueToRValue&gt;
|   |</code>-DeclRefExpr 0x7fa80f393820 <col:24> ‘NSString <em>’ lvalue Var 0x7fa80f3a3580 ‘a’ ‘NSString </em>’<br>|   <code>-ReturnStmt 0x7fa80f393980 &lt;line:10:5, col:12&gt;
|</code>-IntegerLiteral 0x7fa80f393960 <col:12> ‘int’ 0<br>`-<undeserialized declarations=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。</div><div class="line"></div><div class="line">clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。</div><div class="line"></div><div class="line">可以通过 clang —analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib / StaticAnalyzer / Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker</div></pre></td></tr></table></figure></undeserialized></col:12></col:24></col:16></bitcast></col:15,></col:9></col:24></invalid></invalid></invalid></invalid></p>
<p>debug.ConfigDumper              Dump config table<br>debug.DumpCFG                   Display Control-Flow Graphs<br>debug.DumpCallGraph             Display Call Graph<br>debug.DumpCalls                 Print calls as they are traversed by the engine<br>debug.DumpDominators            Print the dominance tree for a given CFG<br>debug.DumpLiveVars              Print results of live variable analysis<br>debug.DumpTraversal             Print branch conditions as they are traversed by the engine<br>debug.ExprInspection            Check the analyzer’s understanding of expressions<br>debug.Stats                     Emit warnings with analyzer statistics<br>debug.TaintTest                 Mark tainted symbols as such.<br>debug.ViewCFG                   View Control-Flow Graphs using GraphViz<br>debug.ViewCallGraph             View Call Graph using GraphViz<br>debug.ViewExplodedGraph         View Exploded Graphs using GraphViz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。</div><div class="line"></div><div class="line">clang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。</div><div class="line"></div><div class="line">编译的概念（词法-&gt;语法-&gt;语义-&gt;IR-&gt;优化-&gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。</div><div class="line"></div><div class="line">clang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。</div><div class="line"></div><div class="line">整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf 在clang里的具体实现代码可以查看这两个文件 [MemRegion.h](https://code.woboq.org/llvm/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h.html)和 [RegionStore.cpp](https://code.woboq.org/llvm/clang/lib/StaticAnalyzer/Core/RegionStore.cpp.html) 。</div><div class="line"></div><div class="line">下面举个简单例子看看 clang static  analyzer 是如何对源码进行模拟的。</div><div class="line">```c</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	int a;</div><div class="line">	int b = 10;</div><div class="line">	a = b;</div><div class="line">	return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的 AST 以及 CFG<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#————————AST—————————</div><div class="line"># clang -cc1 -ast-dump</div><div class="line">TranslationUnitDecl 0xc75b450 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</div><div class="line">|-TypedefDecl 0xc75b740 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list ‘char *’</div><div class="line">`-FunctionDecl 0xc75b7b0 &lt;test.cpp:1:1, line:7:1&gt; line:1:5 main ‘int (void)’</div><div class="line">  `-CompoundStmt 0xc75b978 &lt;line:2:1, line:7:1&gt;</div><div class="line">    |-DeclStmt 0xc75b870 &lt;line:3:2, col:7&gt;</div><div class="line">    | `-VarDecl 0xc75b840 &lt;col:2, col:6&gt; col:6 used a ‘int’</div><div class="line">    |-DeclStmt 0xc75b8d8 &lt;line:4:2, col:12&gt;</div><div class="line">    | `-VarDecl 0xc75b890 &lt;col:2, col:10&gt; col:6 used b ‘int’ cinit</div><div class="line">    |   `-IntegerLiteral 0xc75b8c0 &lt;col:10&gt; ‘int’ 10</div><div class="line"></div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; a = b &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">    |-BinaryOperator 0xc75b928 &lt;line:5:2, col:6&gt; ‘int’ lvalue ‘=‘</div><div class="line">    | |-DeclRefExpr 0xc75b8e8 &lt;col:2&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</div><div class="line">    | `-ImplicitCastExpr 0xc75b918 &lt;col:6&gt; ‘int’ &lt;LValueToRValue&gt;</div><div class="line">    |   `-DeclRefExpr 0xc75b900 &lt;col:6&gt; ‘int’ lvalue Var 0xc75b890 ‘b’ ‘int’</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line"></div><div class="line">    `-ReturnStmt 0xc75b968 &lt;line:6:2, col:9&gt;</div><div class="line">      `-ImplicitCastExpr 0xc75b958 &lt;col:9&gt; ‘int’ &lt;LValueToRValue&gt;</div><div class="line">        `-DeclRefExpr 0xc75b940 &lt;col:9&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</div><div class="line">#————————CFG—————————</div><div class="line"># clang -cc1 -analyze -analyzer-checker=debug.DumpCFG</div><div class="line">int main()</div><div class="line"> [B2 (ENTRY)]</div><div class="line">   Succs (1): B1</div><div class="line"></div><div class="line"> [B1]</div><div class="line">   1: int a;</div><div class="line">   2: 10</div><div class="line">   3: int b = 10;</div><div class="line">   4: b</div><div class="line">   5: [B1.4] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">   6: a</div><div class="line">   7: [B1.6] = [B1.5]</div><div class="line">   8: a</div><div class="line">   9: [B1.8] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">  10: return [B1.9];</div><div class="line">   Preds (1): B2</div><div class="line">   Succs (1): B0</div><div class="line"></div><div class="line"> [B0 (EXIT)]</div><div class="line">   Preds (1): B1</div></pre></td></tr></table></figure></p>
<p>CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。</p>
<p>在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。</p>
<p>官方 AST 相关文档</p>
<ul>
<li><a href="http://clang.llvm.org/docs/Tooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/Tooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="external">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></li>
<li><a href="http://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="external">http://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibTooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibTooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibASTMatchers.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibASTMatchers.html</a></li>
</ul>
<p>静态检查的一些库以及使用方法</p>
<ul>
<li><a href="https://github.com/DeveloperLx/FauxPas_document_translation/blob/master/README.md?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">FauxPas_document_translation/README.md at master · DeveloperLx/FauxPas_document_translation · GitHub</a></li>
</ul>
<h1 id="CodeGen-生成-IR-代码"><a href="#CodeGen-生成-IR-代码" class="headerlink" title="CodeGen 生成 IR 代码"></a>CodeGen 生成 IR 代码</h1><p>将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。</p>
<p>这个过程中还会跟 runtime 桥接。</p>
<ul>
<li>各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。</li>
<li>Non-Fragile ABI 合成 OBJC<em>IVAR</em>$_ 偏移值常量。</li>
<li>ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。</li>
<li>strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。</li>
<li>@synthesize 的处理。</li>
<li>生成 block_layout 数据结构</li>
<li><strong>block 和 </strong>weak</li>
<li>_block_invoke</li>
<li>ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。</li>
</ul>
<h1 id="Clang-Attributes"><a href="#Clang-Attributes" class="headerlink" title="Clang Attributes"></a>Clang Attributes</h1><p>以 <strong>attribute</strong>(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法：</p>
<h2 id="attribute-format-NSString-F-A-格式化字符串"><a href="#attribute-format-NSString-F-A-格式化字符串" class="headerlink" title="attribute((format(NSString, F, A))) 格式化字符串"></a><strong>attribute</strong>((format(<strong>NSString</strong>, F, A))) 格式化字符串</h2><p>可以查看 NSLog 的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_EXPORT void NSLog(NSString *format, …) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;</div><div class="line"></div><div class="line">// Marks APIs which format strings by taking a format string and optional varargs as arguments</div><div class="line">#if !defined(NS_FORMAT_FUNCTION)</div><div class="line">    #if (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED)</div><div class="line">	#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</div><div class="line">    #else</div><div class="line">	#define NS_FORMAT_FUNCTION(F,A)</div><div class="line">    #endif</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<h2 id="attribute-deprecated-s-版本弃用提示"><a href="#attribute-deprecated-s-版本弃用提示" class="headerlink" title="attribute((deprecated(s))) 版本弃用提示"></a><strong>attribute</strong>((deprecated(s))) 版本弃用提示</h2><p>在编译过程中能够提示开发者该方法或者属性已经被弃用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)preMethod:( NSString *)string __attribute__((deprecated(“preMethod已经被弃用，请使用newMethod”)));</div><div class="line">- (void)deprecatedMethod DEPRECATED_ATTRIBUTE; //也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏</div></pre></td></tr></table></figure></p>
<h2 id="attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围"><a href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围" class="headerlink" title="attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围"></a><strong>attribute</strong>((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” <strong>VA_ARGS</strong>))) 指明使用版本范围</h2><p>os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=“iOS3到iOS7版本可用，iOS7不能用”)));</div></pre></td></tr></table></figure></p>
<h2 id="attribute-unavailable-…-方法不可用提示"><a href="#attribute-unavailable-…-方法不可用提示" class="headerlink" title="attribute((unavailable(…))) 方法不可用提示"></a><strong>attribute</strong>((unavailable(…))) 方法不可用提示</h2><p>这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。</p>
<h2 id="attribute-unused"><a href="#attribute-unused" class="headerlink" title="attribute((unused))"></a><strong>attribute</strong>((unused))</h2><p>没有被使用也不报警告</p>
<h2 id="attribute-warn-unused-result"><a href="#attribute-warn-unused-result" class="headerlink" title="attribute((warn_unused_result))"></a><strong>attribute</strong>((<strong>warn_unused_result</strong>))</h2><p>不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。</p>
<h2 id="attribute-availability-swift-unavailable-message-msg"><a href="#attribute-availability-swift-unavailable-message-msg" class="headerlink" title="attribute((availability(swift, unavailable, message=_msg)))"></a><strong>attribute</strong>((<strong>availability</strong>(swift, unavailable, message=_msg)))</h2><p>OC 的方法不能在 Swift 中使用。</p>
<h2 id="attribute-cleanup-…-作用域结束时自动执行一个指定方法"><a href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法" class="headerlink" title="attribute((cleanup(…))) 作用域结束时自动执行一个指定方法"></a><strong>attribute</strong>((cleanup(…))) 作用域结束时自动执行一个指定方法</h2><p>作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。</p>
<p>Reactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define onExit \</div><div class="line">    rac_keywordify \</div><div class="line">    __strong rac_cleanupBlock_t metamacro_concat(rac_exitBlock_, __LINE__) __attribute__((cleanup(rac_executeCleanupBlock), unused)) = ^</div><div class="line"></div><div class="line">static inline void rac_executeCleanupBlock (__strong rac_cleanupBlock_t *block) &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (property != NULL) &#123;</div><div class="line">		rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property);</div><div class="line">		if (attributes != NULL) &#123;</div><div class="line">			@onExit &#123;</div><div class="line">				free(attributes);</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			BOOL isObject = attributes-&gt;objectClass != nil || strstr(attributes-&gt;type, @encode(id)) == attributes-&gt;type;</div><div class="line">			BOOL isProtocol = attributes-&gt;objectClass == NSClassFromString(@“Protocol”);</div><div class="line">			BOOL isBlock = strcmp(attributes-&gt;type, @encode(void(^)())) == 0;</div><div class="line">			BOOL isWeak = attributes-&gt;weak;</div><div class="line"></div><div class="line">			shouldAddDeallocObserver = isObject &amp;&amp; isWeak &amp;&amp; !isBlock &amp;&amp; !isProtocol;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。</p>
<h2 id="attribute-overloadable-方法重载"><a href="#attribute-overloadable-方法重载" class="headerlink" title="attribute((overloadable)) 方法重载"></a><strong>attribute</strong>((overloadable)) 方法重载</h2><p>能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">__attribute__((overloadable)) void printArgument(int number)&#123;</div><div class="line">    NSLog(@“Add Int %i”, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) void printArgument(NSString *number)&#123;</div><div class="line">    NSLog(@“Add NSString %@“, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) void printArgument(NSNumber *number)&#123;</div><div class="line">    NSLog(@“Add NSNumber %@“, number);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="attribute-objc-designated-initializer-指定内部实现的初始化方法"><a href="#attribute-objc-designated-initializer-指定内部实现的初始化方法" class="headerlink" title="attribute((objc_designated_initializer)) 指定内部实现的初始化方法"></a><strong>attribute</strong>((objc_designated_initializer)) 指定内部实现的初始化方法</h2><ul>
<li>如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。</li>
<li>如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。</li>
</ul>
<h2 id="attribute-objc-subclassing-restricted-指定不能有子类"><a href="#attribute-objc-subclassing-restricted-指定不能有子类" class="headerlink" title="attribute((objc_subclassing_restricted)) 指定不能有子类"></a><strong>attribute</strong>((objc_subclassing_restricted)) 指定不能有子类</h2><p>相当于 Java 里的 final 关键字，如果有子类继承就会出错。</p>
<h2 id="attribute-objc-requires-super-子类继承必须调用-super"><a href="#attribute-objc-requires-super-子类继承必须调用-super" class="headerlink" title="attribute((objc_requires_super)) 子类继承必须调用 super"></a><strong>attribute</strong>((objc_requires_super)) 子类继承必须调用 super</h2><p>声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。</p>
<h2 id="attribute-const-重复调用相同数值参数优化返回"><a href="#attribute-const-重复调用相同数值参数优化返回" class="headerlink" title="attribute((const)) 重复调用相同数值参数优化返回"></a><strong>attribute</strong>((const)) 重复调用相同数值参数优化返回</h2><p>用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。</p>
<h2 id="attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><a href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY" class="headerlink" title="attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))"></a><strong>attribute</strong>((constructor(PRIORITY))) 和 <strong>attribute</strong>((destructor(PRIORITY)))</h2><p>PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。</p>
<p>通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。</p>
<h1 id="Clang-警告处理"><a href="#Clang-警告处理" class="headerlink" title="Clang 警告处理"></a>Clang 警告处理</h1><p>先看看这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored “-Wdeprecated-declarations”</div><div class="line">        sizeLabel = [self sizeWithFont:font constrainedToSize:size lineBreakMode:NSLineBreakByWordWrapping];</div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure></p>
<p>如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p>
<h1 id="使用-libclang-来进行语法分析"><a href="#使用-libclang-来进行语法分析" class="headerlink" title="使用 libclang 来进行语法分析"></a>使用 libclang 来进行语法分析</h1><p>使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。</p>
<p>使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js / ruby binding，还有 Objective-C的开源库 <a href="https://github.com/macmade/ClangKit" target="_blank" rel="external">GitHub - macmade/ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented.</a> 。</p>
<p>写个 python 脚本来调用 clang<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pip install clang</div><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># vim: set fileencoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> clang.cindex</div><div class="line"><span class="keyword">import</span> asciitree</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node_children</span><span class="params">(node)</span>:</span></div><div class="line">    <span class="keyword">return</span> (c <span class="keyword">for</span> c <span class="keyword">in</span> node.get_children() <span class="keyword">if</span> c.location.file == sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_node</span><span class="params">(node)</span>:</span></div><div class="line">    text = node.spelling <span class="keyword">or</span> node.displayname</div><div class="line">    kind = str(node.kind)[str(node.kind).index(‘.’)+<span class="number">1</span>:]</div><div class="line">    <span class="keyword">return</span> ‘&#123;&#125; &#123;&#125;’.format(kind, text)</div><div class="line"></div><div class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</div><div class="line">    print(“Usage: dump_ast.py [header file name]”)</div><div class="line">    sys.exit()</div><div class="line"></div><div class="line">clang.cindex.Config.set_library_file(‘/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib’)</div><div class="line">index = clang.cindex.Index.create()</div><div class="line">translation_unit = index.parse(sys.argv[<span class="number">1</span>], [‘-x’, ‘objective-c’])</div><div class="line"></div><div class="line"><span class="keyword">print</span> asciitree.draw_tree(translation_unit.cursor,</div><div class="line">                          <span class="keyword">lambda</span> n: list(n.get_children()),</div><div class="line">                          <span class="keyword">lambda</span> n: “%s (%s)” % (n.spelling <span class="keyword">or</span> n.displayname, str(n.kind).split(“.”)[<span class="number">1</span>]))</div></pre></td></tr></table></figure></p>
<p>基于语法树的分析还可以针对字符串做加密。</p>
<h1 id="LibTooling-对语法树完全的控制"><a href="#LibTooling-对语法树完全的控制" class="headerlink" title="LibTooling 对语法树完全的控制"></a>LibTooling 对语法树完全的控制</h1><p>因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。</p>
<ul>
<li>可以改变 clang 生成代码的方式。</li>
<li>增加更强的类型检查。</li>
<li>按照自己的定义进行代码的检查分析。</li>
<li>对源码做任意类型分析，甚至重写程序。</li>
<li>给 clang 添加一些自定义的分析，创建自己的重构器。</li>
<li>基于现有代码做出大量的修改。</li>
<li>基于工程生成相关图形或文档。</li>
<li>检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者  Swift 。</li>
</ul>
<p>官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： <a href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="external">Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation</a></p>
<p>按照说明编译完成后进入 LLVM 的目录 ~/llvm/tools/clang/tools/ 在这了可以创建自己的 clang 工具。这里有个范例： <a href="https://github.com/objcio/issue-6-compiler-tool" target="_blank" rel="external">GitHub - objcio/issue-6-compiler-tool: Example code for a standalone clang/llvm tool.</a> 可以直接 make 成一个二进制文件。</p>
<p>下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface Observer</div><div class="line">+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">VisitObjCMessageExpr</span><span class="params">(ObjCMessageExpr *E)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) &#123;</div><div class="line">    QualType ReceiverType = E-&gt;getClassReceiver();</div><div class="line">    Selector Sel = E-&gt;getSelector();</div><div class="line">    <span class="built_in">string</span> TypeName = ReceiverType.getAsString();</div><div class="line">    <span class="built_in">string</span> SelName = Sel.getAsString();</div><div class="line">    <span class="keyword">if</span> (TypeName == “Observer” &amp;&amp; SelName == “observerWithTarget:action:”) &#123;</div><div class="line">      Expr *Receiver = E-&gt;getArg(<span class="number">0</span>)-&gt;IgnoreParenCasts();</div><div class="line">      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(<span class="number">1</span>)-&gt;IgnoreParenCasts());</div><div class="line">      Selector Sel = SelExpr-&gt;getSelector();</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">const</span> ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) &#123;</div><div class="line">        ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl();</div><div class="line">        <span class="keyword">if</span> (! decl-&gt;lookupInstanceMethod(Sel)) &#123;</div><div class="line">          errs() &lt;&lt; “Warning: <span class="class"><span class="keyword">class</span> “ &lt;&lt; TypeName &lt;&lt; “ does not implement selector “ &lt;&lt; Sel.getAsString() &lt;&lt; “\n”;</span></div><div class="line">          SourceLocation Loc = E-&gt;getExprLoc();</div><div class="line">          PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc);</div><div class="line">          errs() &lt;&lt; “in “ &lt;&lt; PLoc.getFilename() &lt;&lt; “ &lt;“ &lt;&lt; PLoc.getLine() &lt;&lt; “:” &lt;&lt; PLoc.getColumn() &lt;&lt; “&gt;\n”;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Clang-Plugin"><a href="#Clang-Plugin" class="headerlink" title="Clang Plugin"></a>Clang Plugin</h1><p>通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm/tools/clang/tools</p>
<p>动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库  <a href="https://lmsgsendnilself.github.io/blog/2017/02/28/clangtojszi-yuan/" target="_blank" rel="external">clangtojs资源 - Lmsgsendnilself</a> ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： <a href="http://slides.com/sunnyxx/calling-conventions-in-cocoa#/" target="_blank" rel="external">Calling Conventions in Cocoa by sunnyxx</a> bang 也有篇文章： <a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="external">如何动态调用 C 函数 «  bang’s blog</a>  。</p>
<p>这三个方案作者都分别写了文章详细说明其实现方案。</p>
<ul>
<li><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">JSPatch实现原理详解 «  bang’s blog</a></li>
<li><a href="http://mp.weixin.qq.com/s/qRW_akbU3TSd0SxpF3iQmQ" target="_blank" rel="external">DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航</a></li>
<li><a href="http://www.jianshu.com/p/6c756ce76758" target="_blank" rel="external">OCS——史上最疯狂的iOS动态化方案 - 简书</a></li>
</ul>
<p>滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 <a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651112856&amp;idx=1&amp;sn=b2c74c62a10b4c9a4e7538d1ad7eb739" target="_blank" rel="external">《基于clang插件的一种iOS包大小瘦身方案》</a></p>
<p>那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。</p>
<ul>
<li>官方 clang 的插件： <a href="http://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="external">External Clang Examples</a></li>
<li>收集一些如何使用 clang 库的例子：<a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li>在 Xcode 中添加 clang 静态分析自定义 checks： <a href="http://clang-analyzer.llvm.org/xcode.html" target="_blank" rel="external">Running the analyzer within Xcode</a></li>
<li>将 LLVM C 的 API 用 swift 来包装： <a href="https://github.com/harlanhaskins/LLVMSwift" target="_blank" rel="external">GitHub - harlanhaskins/LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1</a></li>
</ul>
<h1 id="Swift-编译流"><a href="#Swift-编译流" class="headerlink" title="Swift 编译流"></a>Swift 编译流</h1><p>Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C/OC 进行交互。</p>
<p>下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(“hi!”)</div></pre></td></tr></table></figure></p>
<p>生成程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc toy.swift</div><div class="line">./toy</div></pre></td></tr></table></figure></p>
<p>生成检查 AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -dump-ast toy.swift</div></pre></td></tr></table></figure></p>
<p>可以还原之前函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-silgen toy.swift | xcrun swift-demangle</div></pre></td></tr></table></figure></p>
<p>llvm ir 和汇编的生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-ir toy.swift</div><div class="line">swiftc -emit-assembly toy.swift</div></pre></td></tr></table></figure></p>
<p>生成可执行的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk macosx swiftc toy.swift -o toy</div></pre></td></tr></table></figure></p>
<h1 id="编译后生成的二进制内容-Link-Map-File"><a href="#编译后生成的二进制内容-Link-Map-File" class="headerlink" title="编译后生成的二进制内容 Link Map File"></a>编译后生成的二进制内容 Link Map File</h1><p>在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容</p>
<h2 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h2><p>这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。</p>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><p>这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 <strong>TEXT 代码段和 </strong>DATA 数据段两种。</p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>Symbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。</p>
<h1 id="每次编译后生成的-dSYM-文件"><a href="#每次编译后生成的-dSYM-文件" class="headerlink" title="每次编译后生成的 dSYM 文件"></a>每次编译后生成的 dSYM 文件</h1><p>在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。</p>
<p>可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。</p>
<p>还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</div><div class="line">symbolicatecrash appName.crash appName.app &gt; appName.log</div></pre></td></tr></table></figure></p>
<h1 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h1><p>记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。</p>
<p>Mach-O 文件包含三个区域</p>
<ul>
<li>Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等</li>
<li>Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。</li>
<li>Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。</li>
</ul>
<h2 id="Mach-O-文件的解析"><a href="#Mach-O-文件的解析" class="headerlink" title="Mach-O 文件的解析"></a>Mach-O 文件的解析</h2><p>再通过一个例子来分析下：<br>这次用 xcrun 来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -v</div></pre></td></tr></table></figure></p>
<p>先创建一个test.c的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch test.c</div></pre></td></tr></table></figure></p>
<p>编辑里面的内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vi test.c</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hi there!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行，没有起名默认为 a.out<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang test.c</div><div class="line">./a.out</div></pre></td></tr></table></figure></p>
<p>a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -S -o - test.c | open -f</div></pre></td></tr></table></figure></p>
<p>输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.section	__TEXT,__text,regular,pure_instructions</div><div class="line">.macosx_version_min 10, 12</div><div class="line">.globl	_main</div><div class="line">.align	4, 0x90</div></pre></td></tr></table></figure></p>
<p>.section 指令指定接下来执行哪一个段。</p>
<p>.globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。</p>
<p>.align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。</p>
<p>看看接下来的 main 函数头部部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_main:                                  ## @main</div><div class="line">	.cfi_startproc</div><div class="line">## BB#0:</div><div class="line">	pushq	%rbp</div><div class="line">Ltmp0:</div><div class="line">	.cfi_def_cfa_offset 16</div><div class="line">Ltmp1:</div><div class="line">	.cfi_offset %rbp, -16</div><div class="line">	movq	%rsp, %rbp</div><div class="line">Ltmp2:</div><div class="line">	.cfi_def_cfa_register %rbp</div><div class="line">	subq	$32, %rsp</div></pre></td></tr></table></figure></p>
<p>_main 是函数开始的地址，二进制文件会有这个位置的引用。</p>
<p>.cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in / out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。</p>
<p>pushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。</p>
<p>.cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。</p>
<p>movq %rsp, %rbp 把局部变量放到栈上。</p>
<p>subq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。</p>
<p>再看看 printf()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">leaq	L_.str(%rip), %rax</div><div class="line">movl	$0, -4(%rbp)</div><div class="line">movl	%edi, -8(%rbp)</div><div class="line">movq	%rsi, -16(%rbp)</div><div class="line">movq	%rax, %rdi</div><div class="line">movb	$0, %al</div><div class="line">callq	_printf</div></pre></td></tr></table></figure></p>
<p>leap 会将 L<em>.str 这个指针加载到 rax 寄存器里。可以看看 L</em>.str 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div></pre></td></tr></table></figure></p>
<p>这个就是我们代码文件里定义的那个字符串。</p>
<p>这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。</p>
<p>当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。</p>
<p>printf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。</p>
<p>接下来看看返回和函数的结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xorl	%ecx, %ecx</div><div class="line">movl	%eax, -20(%rbp)         ## 4-byte Spill</div><div class="line">movl	%ecx, %eax</div><div class="line">addq	$32, %rsp</div><div class="line">popq	%rbp</div><div class="line">retq</div><div class="line">.cfi_endproc</div></pre></td></tr></table></figure></p>
<p>xorl    %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。</p>
<p>函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。</p>
<p>接下来是字符串输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	.section	__TEXT,__cstring,cstring_literals</div><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div><div class="line"></div><div class="line">.subsections_via_symbols</div></pre></td></tr></table></figure></p>
<p>同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。</p>
<p>接下来通过 size 工具来看看 a.out 里的 section。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun size -x -l -m a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</div><div class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</div><div class="line">	Section __text: 0x34 (addr 0x100000f50 offset 3920)</div><div class="line">	Section __stubs: 0x6 (addr 0x100000f84 offset 3972)</div><div class="line">	Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980)</div><div class="line">	Section __cstring: 0xa (addr 0x100000fa6 offset 4006)</div><div class="line">	Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016)</div><div class="line">	total 0xa6</div><div class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</div><div class="line">	Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</div><div class="line">	Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</div><div class="line">	total 0x18</div><div class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</div><div class="line">total 0x100003000</div></pre></td></tr></table></figure>
<p>可以看出有四个 segment 和多个section。</p>
<p>在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。</p>
<p>__PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。</p>
<p>__TEXT segment 包含被执行的代码以只读和可执行的方式映射。</p>
<ul>
<li>__text section 包含编译后的机器码。</li>
<li><strong>stubs 和 </strong>stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。</li>
<li>__cstring 可执行文件中的字符串。</li>
<li>__const 不可变的常量。</li>
</ul>
<p>__DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。</p>
<ul>
<li>__nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 </li>
<li>__la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。</li>
<li>__const 需要重定向的常量，例如 char * const c = “foo”; c指针指向可变的数据。</li>
<li>__bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。</li>
<li>__common 包含外部全局变量。例如在函数外定义 int i;</li>
<li>__dyld 是section占位符，用于动态链接器。</li>
</ul>
<p>更多 section 类型介绍可以查看苹果文档： <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html" target="_blank" rel="external">OS X Assembler Reference</a></p>
<p>接下来用 otool 查看下 section 里的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -s __TEXT __text a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">Contents of (__TEXT,__text) section</div><div class="line">0000000100000f50	55 48 89 e5 48 83 ec 20 48 8d 05 47 00 00 00 c7 </div><div class="line">0000000100000f60	45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 </div><div class="line">0000000100000f70	b0 00 e8 0d 00 00 00 31 c9 89 45 ec 89 c8 48 83 </div><div class="line">0000000100000f80	c4 20 5d c3</div></pre></td></tr></table></figure>
<p>这个返回的内容很难读，加个 - v  就可以查看反汇编代码了， -s <strong>TEXT </strong>text 有个缩写 -t<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -v -t a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">(__TEXT,__text) section</div><div class="line">_main:</div><div class="line">0000000100000f50	pushq	%rbp</div><div class="line">0000000100000f51	movq	%rsp, %rbp</div><div class="line">0000000100000f54	subq	$0x20, %rsp</div><div class="line">0000000100000f58	leaq	0x47(%rip), %rax</div><div class="line">0000000100000f5f	movl	$0x0, -0x4(%rbp)</div><div class="line">0000000100000f66	movl	%edi, -0x8(%rbp)</div><div class="line">0000000100000f69	movq	%rsi, -0x10(%rbp)</div><div class="line">0000000100000f6d	movq	%rax, %rdi</div><div class="line">0000000100000f70	movb	$0x0, %al</div><div class="line">0000000100000f72	callq	0x100000f84</div><div class="line">0000000100000f77	xorl	%ecx, %ecx</div><div class="line">0000000100000f79	movl	%eax, -0x14(%rbp)</div><div class="line">0000000100000f7c	movl	%ecx, %eax</div><div class="line">0000000100000f7e	addq	$0x20, %rsp</div><div class="line">0000000100000f82	popq	%rbp</div><div class="line">0000000100000f83	retq</div></pre></td></tr></table></figure>
<p>看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。</p>
<p>现在来看看可执行文件。</p>
<p>通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -h a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Mach header</div><div class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</div><div class="line">MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    15       1200   NOUNDEFS DYLDLINK TWOLEVEL PIE</div></pre></td></tr></table></figure>
<p>mach_header 结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>      magic;</div><div class="line">  <span class="keyword">cpu_type_t</span>    cputype;</div><div class="line">  <span class="keyword">cpu_subtype_t</span> cpusubtype;</div><div class="line">  <span class="keyword">uint32_t</span>      filetype;</div><div class="line">  <span class="keyword">uint32_t</span>      ncmds;</div><div class="line">  <span class="keyword">uint32_t</span>      sizeofcmds;</div><div class="line">  <span class="keyword">uint32_t</span>      flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -l a.out | open -f</div></pre></td></tr></table></figure></p>
<p>加载命令结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>  cmd;</div><div class="line">  <span class="keyword">uint32_t</span>  cmdsize;</div><div class="line">  <span class="keyword">char</span>      segname[<span class="number">16</span>];</div><div class="line">  <span class="keyword">uint32_t</span>  vmaddr;</div><div class="line">  <span class="keyword">uint32_t</span>  vmsize;</div><div class="line">  <span class="keyword">uint32_t</span>  fileoff;</div><div class="line">  <span class="keyword">uint32_t</span>  filesize;</div><div class="line">  <span class="keyword">vm_prot_t</span> maxprot;</div><div class="line">  <span class="keyword">vm_prot_t</span> initprot;</div><div class="line">  <span class="keyword">uint32_t</span>  nsects;</div><div class="line">  <span class="keyword">uint32_t</span>  flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。</p>
<p>在加载命令里还是看看 <strong>TEXT </strong>text 的section的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Section</div><div class="line">  sectname __text</div><div class="line">   segname __TEXT</div><div class="line">      addr 0x0000000100000f50</div><div class="line">      size 0x0000000000000034</div><div class="line">    offset 3920</div><div class="line">     align 2^4 (16)</div><div class="line">    reloff 0</div><div class="line">    nreloc 0</div><div class="line">      type S_REGULAR</div><div class="line">attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS</div><div class="line"> reserved1 0</div><div class="line"> reserved2 0</div></pre></td></tr></table></figure></p>
<p>addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。</p>
<p>单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。<br>Foo.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Foo : NSObject</div><div class="line"></div><div class="line">- (void)say;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Foo.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import “Foo.h”</div><div class="line"></div><div class="line">@implementation Foo</div><div class="line"></div><div class="line">- (void)say</div><div class="line">&#123;</div><div class="line">    NSLog(@“hi there again!\n”);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>SayHi.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import “Foo.h”</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        Foo *foo = [[Foo alloc] init];</div><div class="line">        [foo say];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先编译多个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang -c Foo.m</div><div class="line">xcrun clang -c SayHi.m</div></pre></td></tr></table></figure></p>
<p>再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang SayHi.o Foo.o -Wl,`xcrun —show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</div></pre></td></tr></table></figure></p>
<h2 id="逆向-Mach-O-文件"><a href="#逆向-Mach-O-文件" class="headerlink" title="逆向 Mach-O 文件"></a>逆向 Mach-O 文件</h2><p>需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。</p>
<p>Mobilesubstrate 提供了三个模块来方便开发。</p>
<ul>
<li>MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。</li>
<li>MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook  放在这里就可以了。</li>
<li>Safe mode：类似安全模式，会禁用的改动。</li>
</ul>
<p>先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。</p>
<p>当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。</p>
<ul>
<li>这里有个实例，讲解如何通过逆向实现微信抢红包的插件： <a href="http://dev.qq.com/topic/5791da152168f2690e72daa4" target="_blank" rel="external">【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB</a></li>
<li>入门文章可以看看这篇： <a href="https://github.com/zhengmin1989/MyArticles/tree/master/iOS%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C" target="_blank" rel="external">MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub</a></li>
<li>玩出新花样： <a href="http://blog.imjun.net/2016/10/08/%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%9A%E6%8A%8A%E7%AC%AC%E4%B8%89%E6%96%B9-iOS-%E5%BA%94%E7%94%A8%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/" target="_blank" rel="external">黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog</a>，作者另一篇文章： <a href="http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog</a></li>
</ul>
<h1 id="dyld动态链接"><a href="#dyld动态链接" class="headerlink" title="dyld动态链接"></a>dyld动态链接</h1><p>生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。</p>
<p>用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。</p>
<p>符号表会规定它们的符号，使用 nm 工具看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm SayHi.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _OBJC_CLASS_$_Foo</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush</div><div class="line">                 (undefined) external _objc_msgSend</div><div class="line">0000000000000000 (__TEXT,__text) external _main</div></pre></td></tr></table></figure>
<ul>
<li>_OBJC<em>CLASS</em>$_Foo 表示 Foo 的 OC 符号。</li>
<li>(undefined) external 表示未实现非私有，如果是私有就是 non-external。</li>
<li>external _main 表示 main() 函数，处理 0 地址，将要到 <strong>TEXT,</strong>text section </li>
</ul>
<p>再看看 Foo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm Foo.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject</div><div class="line">                 (undefined) external ___CFConstantStringClassReference</div><div class="line">                 (undefined) external __objc_empty_cache</div><div class="line">0000000000000000 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo</div><div class="line">00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo</div><div class="line">00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo</div><div class="line">0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>因为 undefined 符号表示该文件类未实现的，所以在目标文件和  Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。</p>
<p>链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog (from Foundation)</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</div><div class="line">                 (undefined) external __objc_empty_cache (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</div><div class="line">                 (undefined) external _objc_msgSend (from libobjc)</div><div class="line">                 (undefined) external dyld_stub_binder (from libSystem)</div><div class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</div><div class="line">0000000100000e90 (__TEXT,__text) external _main</div><div class="line">0000000100000f10 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。</p>
<p>通过 otool 可以找到所需库在哪<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -L a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">	/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0)</div><div class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)</div><div class="line">	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0)</div><div class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</div></pre></td></tr></table></figure>
<p>libSystem 里有很多我们熟悉的lib</p>
<ul>
<li>libdispatch：GCD</li>
<li>libsystem_c：C语言库</li>
<li>libsystem_blocks：Block</li>
<li>libcommonCrypto：加密，比如md5</li>
</ul>
<p>dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。</p>
<p>打印什么库被加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(export DYLD_PRINT_LIBRARIES=; ./a.out )</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dyld: loaded: /Users/didi/Downloads/./a.out</div><div class="line">dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</div><div class="line">dyld: loaded: /usr/lib/libSystem.B.dylib</div><div class="line">dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation</div><div class="line">…</div></pre></td></tr></table></figure>
<p>数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。</p>
<p>动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external">Dynamic Linking On OS X</a></p>
<p>dyld 做了些什么事</p>
<ul>
<li>kernel 做启动程序初始准备，开始由dyld负责。</li>
<li>基于非常简单的原始栈为 kernel 设置进程来启动自身。</li>
<li>使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。</li>
<li>立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。</li>
<li>为可执行文件运行静态初始化。</li>
<li>设置参数到可执行文件的 main 函数并调用它。</li>
<li>在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 runtime 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime  会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 Class，按照继承层级依次调用  +load 方法。</li>
<li>在 mian 函数返回后运行 static terminator。</li>
<li>在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。</li>
</ul>
<p>查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="external">RetVal/objc-runtime: objc runtime 706</a> 来进行断点查看调用的 runtime 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  +[someclass load]</div><div class="line">1  call_class_loads()</div><div class="line">2  ::call_load_methods</div><div class="line">3  ::load_images(const char *path __unused, const struct mach_header *mh)</div><div class="line">4  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</div><div class="line">11 _dyld_start</div></pre></td></tr></table></figure>
<p>在  load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。</p>
<p>prepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。</p>
<p>最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。</p>
<p>如果想了解 Cocoa 的 Fundation 库可以通过 <a href="https://github.com/AaronYi/gnustep-base" target="_blank" rel="external">GNUStep</a> 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。</p>
<p>dyld 是开源的： <a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">GitHub - opensource-apple/dyld</a></p>
<p>还可以看看苹果的 WWDC 视频 <a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="external">WWDC 2016 Session 406</a> 里讲解对启动进行优化。</p>
<p>这篇文章也不错： <a href="https://www.codeproject.com/articles/187181/dynamic-linking-of-imported-functions-in-mach-o" target="_blank" rel="external">Dynamic Linking of Imported Functions in Mach-O - CodeProject</a></p>
<h1 id="安装编译-LLVM"><a href="#安装编译-LLVM" class="headerlink" title="安装编译 LLVM"></a>安装编译 LLVM</h1><h2 id="多种获取方式"><a href="#多种获取方式" class="headerlink" title="多种获取方式"></a>多种获取方式</h2><p>官网：<a href="http://releases.llvm.org/download.html" target="_blank" rel="external">http://releases.llvm.org/download.html</a><br>svn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#先下载 LLVM</div><div class="line">svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</div><div class="line"></div><div class="line">#在 LLVM 的 tools 目录下下载 Clang</div><div class="line">cd llvm/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</div><div class="line"></div><div class="line">#在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabi</div><div class="line">cd ../projects</div><div class="line">svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi</div><div class="line"></div><div class="line">#在 Clang 的 tools 下安装 extra 工具</div><div class="line">cd ../tools/clang/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</div></pre></td></tr></table></figure></p>
<p>git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git clone http://llvm.org/git/llvm.git</div><div class="line">cd llvm/tools</div><div class="line">git clone http://llvm.org/git/clang.git</div><div class="line">cd ../projects</div><div class="line">git clone http://llvm.org/git/compiler-rt.git</div><div class="line">cd ../tools/clang/tools</div><div class="line">git clone http://llvm.org/git/clang-tools-extra.git</div></pre></td></tr></table></figure></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">brew install gcc</div><div class="line">brew install cmake</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake /path/to/llvm/source</div><div class="line">cmake —build .</div><div class="line"></div><div class="line">#如果希望是 xcodeproject 方式 build 可以使用 -GXcode</div><div class="line">mkdir xcodeBuild</div><div class="line">cd xcodeBuild</div><div class="line">cmake cmake -GXcode /path/to/llvm/source</div></pre></td></tr></table></figure>
<p>接下来可以看看 LLVM 的官方教程如何实现一个自己的编程语Kaleidoscope。 <a href="http://llvm.org/docs/tutorial/index.html" target="_blank" rel="external">LLVM Tutorial: Table of Contents — LLVM 5 documentation</a></p>
<p>这里有个使用swift的实现的系列教程<br><a href="https://harlanhaskins.com/2017/01/08/building-a-compiler-with-swift-in-llvm-part-1-introduction-and-the-lexer.html" target="_blank" rel="external">Building a Compiler in Swift with LLVM</a></p>
<h1 id="Swift-编译"><a href="#Swift-编译" class="headerlink" title="Swift 编译"></a>Swift 编译</h1><p>官网： <a href="https://github.com/apple/swift" target="_blank" rel="external">GitHub - apple/swift: The Swift Programming Language</a><br>swift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： <a href="https://swift.org/contributing/#contributing-code" target="_blank" rel="external">Swift.org - Contributing</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录</div><div class="line">brew install cmake ninja</div><div class="line">mkdir swiftsource</div><div class="line">cd swiftsource</div><div class="line"></div><div class="line">#clone 下 swift 源码</div><div class="line">git clone https://github.com/apple/swift.git</div><div class="line"></div><div class="line">#checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个</div><div class="line">./swift/utils/update-checkout —clone</div><div class="line"></div><div class="line">#查看文件夹</div><div class="line">du -h -d 1</div><div class="line"></div><div class="line">#build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#更新</div><div class="line">./swift/utils/update-checkout</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#切到指定tag和分支</div><div class="line">#tag</div><div class="line">./swift/utils/update-checkout —tag swift-3.0-RELEASE</div><div class="line">#特定分支</div><div class="line">./swift/utils/update-checkout —scheme swift-3.0-branch</div></pre></td></tr></table></figure>
<p>swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： <a href="https://swift.org/source-code/" target="_blank" rel="external">Swift.org - Source Code</a></p>
<h1 id="其它编译工具"><a href="#其它编译工具" class="headerlink" title="其它编译工具"></a>其它编译工具</h1><h2 id="js写的C-解释器JSCPP"><a href="#js写的C-解释器JSCPP" class="headerlink" title="js写的C++解释器JSCPP"></a>js写的C++解释器JSCPP</h2><p>适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：<a href="https://github.com/felixhao28/JSCPP" target="_blank" rel="external">GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript</a></p>
<h2 id="C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language"><a href="#C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language" class="headerlink" title="C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language"></a>C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language</h2><p>在 web 中有个 WebAssembly 是个标准，可以使得 web 运行 C/C++ 成为可能。当然还有其它的比如：<a href="http://c-smile.sourceforge.net/" target="_blank" rel="external">http://c-smile.sourceforge.net/</a></p>
<h1 id="资料网址"><a href="#资料网址" class="headerlink" title="资料网址"></a>资料网址</h1><ul>
<li><a href="http://llvm.org" target="_blank" rel="external">http://llvm.org</a></li>
<li><a href="http://clang.llvm.org/" target="_blank" rel="external">http://clang.llvm.org/</a></li>
<li><a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">http://www.aosabook.org/en/llvm.html</a></li>
<li><a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li><a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks" target="_blank" rel="external">Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow</a></li>
<li><a href="http://llvm.org/devmtg/" target="_blank" rel="external">LLVM Developers’ Metting</a></li>
</ul>

      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="戴铭 wechat" style="width: 200px; max-width: 100%;"/>
    <div>扫一扫Starming星光社微信公众号starming-weixin，关注最新文章</div>
</div>


      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      戴铭
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/" title="深入剖析 iOS 编译 Clang / LLVM">http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/LLVM/" rel="tag"># LLVM</a>
          
            <a href="/tags/Clang/" rel="tag"># Clang</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/22/how-to-preload-web-in-ios/" rel="next" title="iOS预加载Web页面方案">
                <i class="fa fa-chevron-left"></i> iOS预加载Web页面方案
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/01/slides-of-deeply-analyse-llvm/" rel="prev" title="深入剖析 iOS 编译 Clang / LLVM 直播的 Slides">
                深入剖析 iOS 编译 Clang / LLVM 直播的 Slides <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/251980?v=3&s=460"
               alt="戴铭" />
          <p class="site-author-name" itemprop="name">戴铭</p>
           
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里；不积小流，无以成江海</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ming1016" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/allstarming" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/ming1016" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编译流程"><span class="nav-number">2.</span> <span class="nav-text">编译流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Clang-编译-m-文件"><span class="nav-number">3.</span> <span class="nav-text">Clang 编译 .m 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构建-Target"><span class="nav-number">3.1.</span> <span class="nav-text">构建 Target</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Target-在-Build-过程的控制"><span class="nav-number">3.2.</span> <span class="nav-text">Target 在 Build 过程的控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-Phases"><span class="nav-number">3.2.1.</span> <span class="nav-text">Build Phases</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-Rules"><span class="nav-number">3.2.2.</span> <span class="nav-text">Build Rules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-Settings"><span class="nav-number">3.2.3.</span> <span class="nav-text">Build Settings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pbxproj工程文件"><span class="nav-number">3.2.4.</span> <span class="nav-text">pbxproj工程文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Clang-Static-Analyzer静态代码分析"><span class="nav-number">4.</span> <span class="nav-text">Clang Static Analyzer静态代码分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CodeGen-生成-IR-代码"><span class="nav-number">5.</span> <span class="nav-text">CodeGen 生成 IR 代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Clang-Attributes"><span class="nav-number">6.</span> <span class="nav-text">Clang Attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-format-NSString-F-A-格式化字符串"><span class="nav-number">6.1.</span> <span class="nav-text">attribute((format(NSString, F, A))) 格式化字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-deprecated-s-版本弃用提示"><span class="nav-number">6.2.</span> <span class="nav-text">attribute((deprecated(s))) 版本弃用提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围"><span class="nav-number">6.3.</span> <span class="nav-text">attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-unavailable-…-方法不可用提示"><span class="nav-number">6.4.</span> <span class="nav-text">attribute((unavailable(…))) 方法不可用提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-unused"><span class="nav-number">6.5.</span> <span class="nav-text">attribute((unused))</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-warn-unused-result"><span class="nav-number">6.6.</span> <span class="nav-text">attribute((warn_unused_result))</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-availability-swift-unavailable-message-msg"><span class="nav-number">6.7.</span> <span class="nav-text">attribute((availability(swift, unavailable, message=_msg)))</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法"><span class="nav-number">6.8.</span> <span class="nav-text">attribute((cleanup(…))) 作用域结束时自动执行一个指定方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-overloadable-方法重载"><span class="nav-number">6.9.</span> <span class="nav-text">attribute((overloadable)) 方法重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-objc-designated-initializer-指定内部实现的初始化方法"><span class="nav-number">6.10.</span> <span class="nav-text">attribute((objc_designated_initializer)) 指定内部实现的初始化方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-objc-subclassing-restricted-指定不能有子类"><span class="nav-number">6.11.</span> <span class="nav-text">attribute((objc_subclassing_restricted)) 指定不能有子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-objc-requires-super-子类继承必须调用-super"><span class="nav-number">6.12.</span> <span class="nav-text">attribute((objc_requires_super)) 子类继承必须调用 super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-const-重复调用相同数值参数优化返回"><span class="nav-number">6.13.</span> <span class="nav-text">attribute((const)) 重复调用相同数值参数优化返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><span class="nav-number">6.14.</span> <span class="nav-text">attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Clang-警告处理"><span class="nav-number">7.</span> <span class="nav-text">Clang 警告处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用-libclang-来进行语法分析"><span class="nav-number">8.</span> <span class="nav-text">使用 libclang 来进行语法分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LibTooling-对语法树完全的控制"><span class="nav-number">9.</span> <span class="nav-text">LibTooling 对语法树完全的控制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Clang-Plugin"><span class="nav-number">10.</span> <span class="nav-text">Clang Plugin</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Swift-编译流"><span class="nav-number">11.</span> <span class="nav-text">Swift 编译流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编译后生成的二进制内容-Link-Map-File"><span class="nav-number">12.</span> <span class="nav-text">编译后生成的二进制内容 Link Map File</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-files"><span class="nav-number">12.1.</span> <span class="nav-text">Object files</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sections"><span class="nav-number">12.2.</span> <span class="nav-text">Sections</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbols"><span class="nav-number">12.3.</span> <span class="nav-text">Symbols</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#每次编译后生成的-dSYM-文件"><span class="nav-number">13.</span> <span class="nav-text">每次编译后生成的 dSYM 文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mach-O-文件"><span class="nav-number">14.</span> <span class="nav-text">Mach-O 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mach-O-文件的解析"><span class="nav-number">14.1.</span> <span class="nav-text">Mach-O 文件的解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逆向-Mach-O-文件"><span class="nav-number">14.2.</span> <span class="nav-text">逆向 Mach-O 文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dyld动态链接"><span class="nav-number">15.</span> <span class="nav-text">dyld动态链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装编译-LLVM"><span class="nav-number">16.</span> <span class="nav-text">安装编译 LLVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多种获取方式"><span class="nav-number">16.1.</span> <span class="nav-text">多种获取方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装"><span class="nav-number">16.2.</span> <span class="nav-text">安装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Swift-编译"><span class="nav-number">17.</span> <span class="nav-text">Swift 编译</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其它编译工具"><span class="nav-number">18.</span> <span class="nav-text">其它编译工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#js写的C-解释器JSCPP"><span class="nav-number">18.1.</span> <span class="nav-text">js写的C++解释器JSCPP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language"><span class="nav-number">18.2.</span> <span class="nav-text">C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#资料网址"><span class="nav-number">19.</span> <span class="nav-text">资料网址</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">戴铭</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
